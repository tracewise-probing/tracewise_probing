"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.7, \"n\": 64, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_vanilla_bug_trace_TPL_NEXT_qwen_7b_hard_n_64.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"difficulty": "hard", "num_threads": 32, "temperature": 0.7, "n": 64, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_vanilla_bug_trace_TPL_NEXT_qwen_7b_hard_n_64.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "arc183_b", "codes": ["def can_transform_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        \n        index += 2 * N\n        \n        freq_A = {}\n        freq_B = {}\n        \n        for a in A:\n            freq_A[a] = freq_A.get(a, 0) + 1\n        \n        for b in B:\n            freq_B[b] = freq_B.get(b, 0) + 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_to_B()", "d", "d", "d", "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef solve(case):\n    N = int(case[0])\n    K = int(case[1])\n    A = list(map(int, case[2:N+2]))\n    B = list(map(int, case[N+2:2*N+2]))\n    \n    sorted_A = sorted(A)\n    sorted_B = sorted(B)\n    \n    if sorted_A == sorted_B:\n        return \"Yes\"\n    else:\n        return \"No\"\n\ndef main():\n    T = int(data[0])\n    cases = [data[1+4*i:5+4*i] for i in range(T)]\n    results = [solve(case) for case in cases]\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def can_make_identical(T, cases):\n    results = []\n    for N, K, A, B in cases:\n        A = list(A)\n        B = list(B)\n        for i in range(N):\n            subarray_A = A[i:i+K+1]\n            subarray_B = B[i:i+K+1]\n            if sorted(subarray_A) != sorted(subarray_B):\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get results\nresults = can_make_identical(T, cases)\n\n# Print results\nfor result in results:\n    print(result)", "d", "def can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Check if all elements of B can be transformed into A within the window of size K\n        can_transform = True\n        for i in range(N):\n            if B[i] not in A:\n                can_transform = False\n                break\n            if not can_transform_within_window(A, B[i], i, K):\n                can_transform = False\n                break\n        \n        results.append(\"Yes\" if can_transform else \"No\")\n    \n    return results\n\ndef can_transform_within_window(A, target, idx, K):\n    left = max(0, idx - K)\n    right = min(len(A) - 1, idx + K)\n    \n    for i in range(left, right + 1):\n        if A[i] == target:\n            return True\n    return False\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Process test cases\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)", "d", "def can_transform_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        \n        index += 2 * N\n        \n        freq_A = {}\n        freq_B = {}\n        \n        for num in A:\n            if num not in freq_A:\n                freq_A[num] = 0\n            freq_A[num] += 1\n        \n        for num in B:\n            if num not in freq_B:\n                freq_B[num] = 0\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_to_B()", "d", "d", "def can_make_identical(T, test_cases):\n    results = []\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Count the frequency of each element in A and B\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        for a in A:\n            freq_A[a] += 1\n        for b in B:\n            freq_B[b] += 1\n        \n        # Check if the frequencies are equal\n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        test_cases.append((N, K, A, B))\n        index += 2 * N\n    \n    results = can_make_identical(T, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    results = []\n    for _ in range(int(data[index])):\n        index += 1\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        for num in A:\n            count_A[num] += 1\n        for num in B:\n            count_B[num] += 1\n        if count_A != count_B:\n            results.append('No')\n            continue\n        for i in range(1, N + 1):\n            if count_A[i] == 0 and count_B[i] > 0:\n                results.append('No')\n                break\n        else:\n            window_size = 2 * K + 1\n            for i in range(1, N + 1):\n                if count_A[i] > 0 and i not in B[:min(i + K, N)]:\n                    results.append('No')\n                    break\n            else:\n                results.append('Yes')\n    return '\\n'.join(results)\n\nif __name__ == '__main__':\n    print(can_make_identical(int(input())))", "d", "def can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a list to store the groups\n        groups = [[] for _ in range(N)]\n        \n        # Group elements that can be made equal\n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                groups[i].append(j)\n        \n        # Create a dictionary to count frequencies of elements in each group for A and B\n        freq_A = [{} for _ in range(N)]\n        freq_B = [{} for _ in range(N)]\n        \n        for i in range(N):\n            for j in groups[i]:\n                freq_A[i][A[j]] = freq_A[i].get(A[j], 0) + 1\n                freq_B[i][B[j]] = freq_B[i].get(B[j], 0) + 1\n        \n        # Check if frequencies match for each group\n        for i in range(N):\n            if freq_A[i] != freq_B[i]:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        test_cases.append((N, K, A, B))\n        index += 2 * N\n    \n    results = can_make_identical(T, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "i", "def can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Count occurrences of each element in A and B\n        count_A = {}\n        count_B = {}\n        for a in A:\n            if a in count_A:\n                count_A[a] += 1\n            else:\n                count_A[a] = 1\n        for b in B:\n            if b in count_B:\n                count_B[b] += 1\n            else:\n                count_B[b] = 1\n        \n        # If counts are not the same, it's not possible\n        if count_A != count_B:\n            results.append(\"No\")\n            continue\n        \n        # Try to match elements in B with A within the allowed range K\n        used_A = [False] * N\n        for b in B:\n            found = False\n            for i in range(N):\n                if not used_A[i] and abs(i + 1 - B.index(b) + 1) <= K and A[i] == b:\n                    used_A[i] = True\n                    found = True\n                    break\n            if not found:\n                results.append(\"No\")\n                break\n        if found:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Example usage:\n# T = int(input())\n# cases = []\n# for _ in range(T):\n#     N, K = map(int, input().split())\n#     A = list(map(int, input().split()))\n#     B = list(map(int, input().split()))\n#     cases.append((N, K, A, B))\n# can_make_identical(T, cases)", "import sys\nfrom collections import Counter\n\ndef can_make_identical(N, K, A, B):\n    # Count the frequency of each element in A and B\n    freq_A = Counter(A)\n    freq_B = Counter(B)\n    \n    # Check if the frequency of each element in A matches that in B\n    if freq_A != freq_B:\n        return \"No\"\n    \n    # Check if the elements can be rearranged within the allowed windows\n    # to match B\n    for i in range(N):\n        if A[i] != B[i]:\n            found = False\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[j] == B[i]:\n                    A[j], A[i] = A[i], A[j]\n                    found = True\n                    break\n            if not found:\n                return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_make_identical(N, K, A, B)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "d", "d", "d", "d", "d", "def can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create frequency maps for A and B\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for i in range(N):\n            freq_A[A[i]] += 1\n            freq_B[B[i]] += 1\n        \n        # Check if frequency maps are the same\n        if freq_A != freq_B:\n            results.append(\"No\")\n            continue\n        \n        # Check if we can match elements within the allowed window size K\n        for i in range(N):\n            if A[i] != B[i]:\n                found = False\n                for j in range(max(0, i - K), min(N, i + K + 1)):\n                    if A[j] == B[i]:\n                        A[j] = A[i]\n                        found = True\n                        break\n                if not found:\n                    results.append(\"No\")\n                    break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Process test cases\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)", "def can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 * N + 2]))\n        \n        index += 2 * N + 2\n        \n        # Check if sorted versions are equal\n        if sorted(A) != sorted(B):\n            results.append(\"No\")\n            continue\n        \n        # Check if elements can be rearranged within the allowed windows\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        \n        for i in range(N):\n            count_A[A[i]] += 1\n            count_B[B[i]] += 1\n        \n        if count_A == count_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\n# Call the function with the number of test cases\ncan_make_identical(125000)", "d", "def can_make_identical(T, test_cases):\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a sorted list of A with their indices\n        A_sorted = sorted((x, i) for i, x in enumerate(A))\n        \n        # Create a list to keep track of used indices in A\n        used = [False] * N\n        \n        for x in B:\n            # Find the first value in A_sorted that is within the range of B\n            while A_sorted and abs(A_sorted[0][0] - x) > K:\n                A_sorted.pop(0)\n            \n            if not A_sorted:\n                print(\"No\")\n                break\n            \n            # Find the first unused index that is within the range\n            while A_sorted and used[A_sorted[0][1]]:\n                A_sorted.pop(0)\n            \n            if not A_sorted:\n                print(\"No\")\n                break\n            \n            # Mark the index as used and remove it from the list\n            index = A_sorted.pop(0)[1]\n            used[index] = True\n        else:\n            print(\"Yes\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + N + 2]))\n    B = list(map(int, data[index + N + 2:index + 2 * N + 2]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N + 2\n\n# Process test cases\ncan_make_identical(T, test_cases)", "d", "def can_make_identical(A, B, K):\n    N = len(A)\n    segments = K + 1\n    \n    for i in range(0, N, segments):\n        segment_A = A[i:i+segments]\n        segment_B = B[i:i+segments]\n        \n        if sorted(segment_A) != sorted(segment_B):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 + 2 * N\n        \n        result = can_make_identical(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "d", "def can_make_identical(A, B, K):\n    N = len(A)\n    sorted_B = sorted(B)\n    target = [0] * N\n    \n    # Create a frequency array for A and B\n    freq_A = [0] * (N + 1)\n    freq_B = [0] * (N + 1)\n    \n    for i in range(N):\n        freq_A[A[i]] += 1\n        freq_B[B[i]] += 1\n    \n    # Check if the frequency arrays are the same\n    if freq_A != freq_B:\n        return False\n    \n    # Use a sliding window to check if we can rearrange A to match B\n    for i in range(N):\n        target[(i + 1) % (N + 1)] = sorted_B[i]\n    \n    left = 0\n    right = 0\n    count = 0\n    \n    while left < N:\n        if target[right] == A[left]:\n            count += 1\n            right += 1\n            left += 1\n        else:\n            left += 1\n    \n    return count == N\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        \n        if can_make_identical(A, B, K):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = map(int, case[0].split())\n        A = list(map(int, case[1].split()))\n        B = list(map(int, case[2].split()))\n        \n        # Dictionary to store the count of elements within the sliding window\n        count_window_A = {}\n        count_window_B = {}\n        \n        # Initialize the first window\n        for i in range(K):\n            count_window_A[A[i]] = count_window_A.get(A[i], 0) + 1\n            count_window_B[B[i]] = count_window_B.get(B[i], 0) + 1\n        \n        # Check if the first window is the same\n        if count_window_A != count_window_B:\n            results.append('No')\n            continue\n        \n        # Slide the window across the sequence\n        for i in range(K, N):\n            # Remove the element that is sliding out of the window\n            count_window_A[A[i-K]] -= 1\n            if count_window_A[A[i-K]] == 0:\n                del count_window_A[A[i-K]]\n            \n            # Add the new element that is sliding into the window\n            count_window_A[A[i]] = count_window_A.get(A[i], 0) + 1\n            \n            # Update the count for B\n            count_window_B[B[i-K]] -= 1\n            if count_window_B[B[i-K]] == 0:\n                del count_window_B[B[i-K]]\n            \n            count_window_B[B[i]] = count_window_B.get(B[i], 0) + 1\n            \n            # Check if the current window is the same\n            if count_window_A != count_window_B:\n                results.append('No')\n                break\n        else:\n            results.append('Yes')\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = data[index + 2:index + 2 + N]\n    B = data[index + 2 + N:index + 2 + 2 * N]\n    cases.append((f\"{N} {K}\", \" \".join(A), \" \".join(B)))\n    index += 2 * N\n\n# Process cases\nresults = can_make_identical(T, cases)\n\n# Print results\nfor result in results:\n    print(result)", "def can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    results = []\n\n    for _ in range(int(data[index])):\n        index += 1\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n\n        # Check if both sequences have the same multiset of elements\n        if sorted(A) != sorted(B):\n            results.append('No')\n            continue\n\n        # Check if counts of elements within any window of size 2K+1 match\n        valid = True\n        for i in range(N - 2 * K - 1):\n            if sorted(A[i:i + 2 * K + 1]) != sorted(B[i:i + 2 * K + 1]):\n                valid = False\n                break\n\n        results.append('Yes' if valid else 'No')\n\n    return '\\n'.join(results)\n\n# Example usage\nprint(can_make_identical(4))\n", "d", "d", "d", "d", "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    index += 2 * N\n    \n    # Check if the frequency of elements in A matches B\n    if sorted(A) == sorted(B):\n        results.append(\"Yes\")\n    else:\n        results.append(\"No\")\n\n# Print results for all test cases\nfor result in results:\n    print(result)", "def can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 + 2 * N\n        \n        # Check if frequencies of elements in A and B are the same\n        if sorted(A) == sorted(B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\n# Call the function with the number of test cases\ncan_make_identical(125000)", "i", "d", "d", "d", "def can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a list of tuples (value, index) for B\n        B_with_index = [(B[i], i) for i in range(N)]\n        # Sort B based on the value\n        B_with_index.sort()\n        \n        # Create a list of tuples (value, index) for A\n        A_with_index = [(A[i], i) for i in range(N)]\n        # Sort A based on the value\n        A_with_index.sort()\n        \n        # Create a dictionary to map values in B to their indices\n        B_index_map = {value: index for index, (value, _) in enumerate(B_with_index)}\n        \n        # Create a list to keep track of visited indices in A\n        visited = [False] * N\n        \n        for i in range(N):\n            if visited[i]:\n                continue\n            \n            # Get the value and index of the current element in A\n            value, index = A_with_index[i]\n            target_index = B_index_map[value]\n            \n            # Check if the element can be moved to its target index within the allowed swap distance\n            if abs(index - target_index) > K:\n                results.append(\"No\")\n                break\n            \n            # Mark the current index as visited and recursively visit the target index\n            visited[i] = True\n            visited[target_index] = True\n            i = target_index\n        \n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get results\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)", "def can_make_identical(A, B, K):\n    from collections import defaultdict\n    \n    n = len(A)\n    b_count = defaultdict(list)\n    \n    # Collect indices of each element in B\n    for i, x in enumerate(B):\n        b_count[x].append(i)\n    \n    # Check each value in B\n    for indices in b_count.values():\n        if len(indices) == 0:\n            continue\n        start = indices[0]\n        for i in range(1, len(indices)):\n            if indices[i] - start > K:\n                return False\n            start = indices[i]\n    \n    return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        \n        if can_make_identical(A, B, K):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\n# Call the function to solve the problem\nsolve()", "d", "def can_transform(A, B, K):\n    from collections import Counter\n    \n    # Count frequencies of elements in both sequences\n    freq_A = Counter(A)\n    freq_B = Counter(B)\n    \n    # If frequencies don't match, return \"No\"\n    if freq_A != freq_B:\n        return \"No\"\n    \n    # Sliding window approach\n    n = len(A)\n    window_size = 2 * K + 1\n    \n    for i in range(n - window_size + 1):\n        sub_A = A[i:i + window_size]\n        sub_B = B[i:i + window_size]\n        \n        if Counter(sub_A) != Counter(sub_B):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "d", "d", "d", "def can_make_identical(T, cases):\n    results = []\n    for N, K, A, B in cases:\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        for num in A:\n            count_A[num] += 1\n        for num in B:\n            count_B[num] += 1\n        \n        for num in set(B):\n            if count_A[num] < count_B[num]:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Call the function\ncan_make_identical(T, cases)", "def can_make_identical(T, cases):\n    results = []\n    for N, K, A, B in cases:\n        from collections import Counter\n        \n        count_B = Counter(B)\n        count_A = Counter(A)\n        \n        for j, v in enumerate(B):\n            if count_B[v] == 0:\n                results.append(\"No\")\n                break\n            if count_A[v] < count_B[v]:\n                for i in range(max(0, j - K), min(N, j + K + 1)):\n                    if A[i] == v:\n                        A[i], A[j] = A[j], A[i]\n                        count_A[A[j]] += 1\n                        count_A[A[i]] -= 1\n                        break\n                else:\n                    results.append(\"No\")\n                    break\n            else:\n                count_A[v] -= 1\n                count_B[v] -= 1\n        else:\n            results.append(\"Yes\")\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    cases = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2: index + 2 + N]))\n        B = list(map(int, data[index + 2 + N: index + 2 + 2 * N]))\n        cases.append((N, K, A, B))\n        index += 2 * N\n    \n    results = can_make_identical(T, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def can_make_identical(A, B, K):\n    from collections import Counter\n    \n    count_A = Counter(A)\n    count_B = Counter(B)\n    \n    if count_A != count_B:\n        return \"No\"\n    \n    A_positions = {val: [] for val in set(A)}\n    for i, val in enumerate(A):\n        A_positions[val].append(i)\n    \n    B_positions = {val: [] for val in set(B)}\n    for i, val in enumerate(B):\n        B_positions[val].append(i)\n    \n    for val in set(B):\n        if len(A_positions[val]) != len(B_positions[val]):\n            return \"No\"\n        \n        for pos_B in B_positions[val]:\n            found = False\n            for pos_A in A_positions[val]:\n                if abs(pos_A - pos_B) <= K:\n                    found = True\n                    break\n            if not found:\n                return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_make_identical(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef can_transform_to_B(T, cases):\n    results = []\n    \n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        parent = list(range(N))\n        rank = [0] * N\n        \n        # Perform union operations for adjacent elements within range K\n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[i] == A[j]:\n                    union(parent, rank, i, j)\n        \n        # Group elements in A based on their roots\n        A_groups = {}\n        for i in range(N):\n            root = find(parent, i)\n            if root not in A_groups:\n                A_groups[root] = set()\n            A_groups[root].add(A[i])\n        \n        # Group elements in B based on their values\n        B_groups = {}\n        for i in range(N):\n            if B[i] not in B_groups:\n                B_groups[B[i]] = set()\n            B_groups[B[i]].add(B[i])\n        \n        # Check if the groups in A match the groups in B\n        if len(A_groups) != len(B_groups):\n            results.append(\"No\")\n            continue\n        \n        for value in A_groups:\n            if A_groups[value] != B_groups[value]:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nT = int(data[index])\nindex += 1\ncases = []\n\nfor _ in range(T):\n    N = int(data[index])\n    index += 1\n    K = int(data[index])\n    index += 1\n    A = list(map(int, data[index:index+N]))\n    index += N\n    B = list(map(int, data[index:index+N]))\n    index += N\n    cases.append((N, K, A, B))\n\ncan_transform_to_B(T, cases)", "def can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        used = [False] * N\n        for b in B:\n            found = False\n            for i in range(N):\n                if not used[i] and A[i] == b:\n                    if abs(i - B.index(b)) <= K:\n                        used[i] = True\n                        found = True\n                        break\n            if not found:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Example usage\nT = 4\ncases = [\n    ([3, 1, [1, 1, 2], [1, 2, 2]]),\n    ([5, 4, [2, 4, 5, 1, 3], [2, 1, 3, 2, 2]]),\n    ([13, 1, [3, 1, 3, 3, 5, 3, 3, 4, 2, 2, 2, 5, 1], [5, 3, 3, 3, 4, 2, 2, 2, 2, 5, 5, 1, 3]]),\n    ([20, 14, [10, 6, 6, 19, 13, 16, 15, 15, 2, 10, 2, 16, 9, 12, 2, 6, 13, 5, 5, 9], [5, 9, 6, 2, 10, 19, 16, 15, 13, 12, 10, 2, 9, 6, 5, 16, 19, 12, 15, 13]])\n]\n\nresults = can_make_identical(T, cases)\nfor result in results:\n    print(result)", "d", "d", "d", "d", "d", "def can_transform(A, B, K):\n    from collections import defaultdict\n    \n    # Dictionary to store positions of each value in B\n    pos = defaultdict(list)\n    for i, x in enumerate(B):\n        pos[x].append(i)\n    \n    # Function to check if two positions can be transformed within K swaps\n    def can_transform_group(pos1, pos2):\n        pos1.sort()\n        pos2.sort()\n        j = 0\n        for i in range(len(pos1)):\n            while j < len(pos2) and pos2[j] - pos1[i] > K:\n                j += 1\n            if j == len(pos2):\n                return False\n            j += 1\n        return True\n    \n    # Check each group\n    for positions in pos.values():\n        if not can_transform_group(positions, positions):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        results.append(can_transform(A, B, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def can_make_identical(A, B, K):\n    N = len(A)\n    for i in range(N):\n        group_A = sorted(A[i:i+K+1])\n        group_B = sorted(B[i:i+K+1])\n        if group_A != group_B:\n            return \"No\"\n    return \"Yes\"\n\ndef solve(input_data):\n    lines = input_data.strip().split('\\n')\n    T = int(lines[0])\n    results = []\n    for i in range(1, T+1):\n        N, K = map(int, lines[2*i].split())\n        A = list(map(int, lines[2*i+1].split()))\n        B = list(map(int, lines[2*i+2].split()))\n        result = can_make_identical(A, B, K)\n        results.append(result)\n    return '\\n'.join(results)\n\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read()\n    print(solve(input_data))", "d"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef can_transform_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        \n        index += 2 * N\n        \n        freq_A = {}\n        freq_B = {}\n        \n        for a in A:\n            freq_A[a] = freq_A.get(a, 0) + 1\n        \n        for b in B:\n            freq_B[b] = freq_B.get(b, 0) + 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_to_B()\n```", "```python\ndef can_make_identical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    T = int(data[index])\n    index += 1\n\n    results = []\n\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n\n        can_make = True\n        for i in range(N):\n            found = False\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[i] == B[j]:\n                    found = True\n                    break\n            if not found:\n                can_make = False\n                break\n\n        results.append(\"Yes\" if can_make else \"No\")\n\n    for result in results:\n        print(result)\n\ncan_make_identical()", "```python\ndef can_make_identical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        if 2 * K + 1 >= N:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_make_identical()", "```python\ndef can_match_sequences(T, cases):\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        # Create a list of tuples (value, index) for A and B\n        A = [(A[i], i) for i in range(N)]\n        B = [(B[i], i) for i in range(N)]\n        \n        # Sort the tuples by value\n        A.sort()\n        B.sort()\n        \n        # Check if we can match A to B within the allowed window size K\n        for i in range(N):\n            if abs(A[i][1] - B[i][1]) > K:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n\n# Read input\nT = int(input())\ncases = []\nfor _ in range(T):\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    cases.append((N, K, A, B))\n\n# Call the function with the input cases\ncan_match_sequences(T, cases)", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef solve(case):\n    N = int(case[0])\n    K = int(case[1])\n    A = list(map(int, case[2:N+2]))\n    B = list(map(int, case[N+2:2*N+2]))\n    \n    sorted_A = sorted(A)\n    sorted_B = sorted(B)\n    \n    if sorted_A == sorted_B:\n        return \"Yes\"\n    else:\n        return \"No\"\n\ndef main():\n    T = int(data[0])\n    cases = [data[1+4*i:5+4*i] for i in range(T)]\n    results = [solve(case) for case in cases]\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for N, K, A, B in cases:\n        A = list(A)\n        B = list(B)\n        for i in range(N):\n            subarray_A = A[i:i+K+1]\n            subarray_B = B[i:i+K+1]\n            if sorted(subarray_A) != sorted(subarray_B):\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get results\nresults = can_make_identical(T, cases)\n\n# Print results\nfor result in results:\n    print(result)\n```", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    for N, K, A, B in test_cases:\n        from collections import defaultdict\n        \n        # Count occurrences of each value in A within the sliding window\n        window = defaultdict(int)\n        for i in range(min(N, 2 * K + 1)):\n            window[A[i]] += 1\n        \n        valid = True\n        for i in range(N):\n            # Check if the current value in B exists in the window\n            if B[i] not in window:\n                valid = False\n                break\n            # Move the window to the right\n            window[B[i]] -= 1\n            if i + 2 * K + 1 < N:\n                window[A[i + 2 * K + 1]] += 1\n            else:\n                window[A[i]] -= 1\n        \n        results.append(\"Yes\" if valid else \"No\")\n    \n    for result in results:\n        print(result)\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\ncan_make_identical(T, test_cases)", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Check if all elements of B can be transformed into A within the window of size K\n        can_transform = True\n        for i in range(N):\n            if B[i] not in A:\n                can_transform = False\n                break\n            if not can_transform_within_window(A, B[i], i, K):\n                can_transform = False\n                break\n        \n        results.append(\"Yes\" if can_transform else \"No\")\n    \n    return results\n\ndef can_transform_within_window(A, target, idx, K):\n    left = max(0, idx - K)\n    right = min(len(A) - 1, idx + K)\n    \n    for i in range(left, right + 1):\n        if A[i] == target:\n            return True\n    return False\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ntest_cases = []\n\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Process test cases\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```", "```python\ndef can_make_identical(A, B, K):\n    from collections import defaultdict\n    \n    # Create a dictionary to count the frequency of each element in A\n    freq = defaultdict(int)\n    for a in A:\n        freq[a] += 1\n    \n    # Iterate through each element in B\n    for b in B:\n        if freq[b] > 0:\n            freq[b] -= 1\n        else:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nT = int(data[0])\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    index += 2 * N\n    results.append(can_make_identical(A, B, K))\n\n# Print results\nfor result in results:\n    print(result)", "```python\ndef can_transform_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        \n        index += 2 * N\n        \n        freq_A = {}\n        freq_B = {}\n        \n        for num in A:\n            if num not in freq_A:\n                freq_A[num] = 0\n            freq_A[num] += 1\n        \n        for num in B:\n            if num not in freq_B:\n                freq_B[num] = 0\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_to_B()\n```", "```python\ndef can_transform(A, B, K):\n    N = len(A)\n    for i in range(N):\n        target = B[i]\n        found = False\n        for j in range(max(0, i - K), min(N, i + K + 1)):\n            if A[j] == target:\n                A[j] = A[i]\n                A[i] = target\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        if can_transform(A.copy(), B, K):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nmain()", "```python\ndef can_make_equal(T, cases):\n    results = []\n    \n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Sort both sequences\n        sorted_A = sorted(A)\n        sorted_B = sorted(B)\n        \n        # Check if the sorted sequences are equal\n        if sorted_A == sorted_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ncases = []\n\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get the results\nresults = can_make_equal(T, cases)\n\n# Print results\nfor result in results:\n    print(result)", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Count the frequency of each element in A and B\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        for a in A:\n            freq_A[a] += 1\n        for b in B:\n            freq_B[b] += 1\n        \n        # Check if the frequencies are equal\n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    test_cases = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        test_cases.append((N, K, A, B))\n        index += 2 * N\n    \n    results = can_make_identical(T, test_cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "def can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    results = []\n    for _ in range(int(data[index])):\n        index += 1\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        for num in A:\n            count_A[num] += 1\n        for num in B:\n            count_B[num] += 1\n        if count_A != count_B:\n            results.append('No')\n            continue\n        for i in range(1, N + 1):\n            if count_A[i] == 0 and count_B[i] > 0:\n                results.append('No')\n                break\n        else:\n            window_size = 2 * K + 1\n            for i in range(1, N + 1):\n                if count_A[i] > 0 and i not in B[:min(i + K, N)]:\n                    results.append('No')\n                    break\n            else:\n                results.append('Yes')\n    return '\\n'.join(results)\n\nif __name__ == '__main__':\n    print(can_make_identical(int(input())))", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a dictionary to count occurrences of elements in B\n        B_count = {i: B.count(i) for i in range(1, N + 1)}\n        \n        # Iterate through each element in B\n        for i in range(N):\n            found = False\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[j] == B[i]:\n                    B_count[B[i]] -= 1\n                    if B_count[B[i]] == 0:\n                        del B_count[B[i]]\n                    found = True\n                    break\n            if not found:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get results\nresults = can_make_identical(T, cases)\n\n# Print results\nfor result in results:\n    print(result)", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a list to store the groups\n        groups = [[] for _ in range(N)]\n        \n        # Group elements that can be made equal\n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                groups[i].append(j)\n        \n        # Create a dictionary to count frequencies of elements in each group for A and B\n        freq_A = [{} for _ in range(N)]\n        freq_B = [{} for _ in range(N)]\n        \n        for i in range(N):\n            for j in groups[i]:\n                freq_A[i][A[j]] = freq_A[i].get(A[j], 0) + 1\n                freq_B[i][B[j]] = freq_B[i].get(B[j], 0) + 1\n        \n        # Check if frequencies match for each group\n        for i in range(N):\n            if freq_A[i] != freq_B[i]:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    test_cases = []\n    index = 1\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        test_cases.append((N, K, A, B))\n        index += 2 * N\n    \n    results = can_make_identical(T, test_cases)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef can_make_identical(A, B, K):\n    i = 0\n    while i < len(A):\n        subseq_A = A[i:i+K+1]\n        subseq_B = B[i:i+K+1]\n        if len(subseq_A) != len(subseq_B):\n            return False\n        if set(subseq_A) != set(subseq_B):\n            return False\n        i += K + 1\n    return True\n\ndef solve():\n    T = int(data[0])\n    index = 1\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        if can_make_identical(A, B, K):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nsolve()", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Count occurrences of each element in A and B\n        count_A = {}\n        count_B = {}\n        for a in A:\n            if a in count_A:\n                count_A[a] += 1\n            else:\n                count_A[a] = 1\n        for b in B:\n            if b in count_B:\n                count_B[b] += 1\n            else:\n                count_B[b] = 1\n        \n        # If counts are not the same, it's not possible\n        if count_A != count_B:\n            results.append(\"No\")\n            continue\n        \n        # Try to match elements in B with A within the allowed range K\n        used_A = [False] * N\n        for b in B:\n            found = False\n            for i in range(N):\n                if not used_A[i] and abs(i + 1 - B.index(b) + 1) <= K and A[i] == b:\n                    used_A[i] = True\n                    found = True\n                    break\n            if not found:\n                results.append(\"No\")\n                break\n        if found:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Example usage:\n# T = int(input())\n# cases = []\n# for _ in range(T):\n#     N, K = map(int, input().split())\n#     A = list(map(int, input().split()))\n#     B = list(map(int, input().split()))\n#     cases.append((N, K, A, B))\n# can_make_identical(T, cases)\n```", "```python\nimport sys\nfrom collections import Counter\n\ndef can_make_identical(N, K, A, B):\n    # Count the frequency of each element in A and B\n    freq_A = Counter(A)\n    freq_B = Counter(B)\n    \n    # Check if the frequency of each element in A matches that in B\n    if freq_A != freq_B:\n        return \"No\"\n    \n    # Check if the elements can be rearranged within the allowed windows\n    # to match B\n    for i in range(N):\n        if A[i] != B[i]:\n            found = False\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[j] == B[i]:\n                    A[j], A[i] = A[i], A[j]\n                    found = True\n                    break\n            if not found:\n                return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_make_identical(N, K, A, B)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef can_transform(T, test_cases):\n    results = []\n    for N, K, A, B in test_cases:\n        from collections import defaultdict\n        \n        # Count occurrences of each value in A\n        count_A = defaultdict(list)\n        for i, a in enumerate(A):\n            count_A[a].append(i)\n        \n        # Check for each unique value in B\n        for b in set(B):\n            indices = count_A[b]\n            if not indices:\n                results.append(\"No\")\n                break\n            if max(indices) - min(indices) > K:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Call the function\ncan_transform(T, test_cases)", "```python\ndef can_make_identical(T):\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        # Dictionary to store the positions of elements in B\n        pos_B = {}\n        for i, b in enumerate(B):\n            if b not in pos_B:\n                pos_B[b] = []\n            pos_B[b].append(i)\n        \n        # Iterate over each element in A\n        i = 0\n        while i < N:\n            a = A[i]\n            if a not in pos_B:\n                print(\"No\")\n                break\n            # Find the closest position of a in B within the sliding window\n            closest_pos = None\n            min_dist = float('inf')\n            for j in pos_B[a]:\n                if abs(i - j) <= K:\n                    if j < min_dist:\n                        min_dist = j\n                        closest_pos = j\n            if closest_pos is None:\n                print(\"No\")\n                break\n            # Move the element to the closest position\n            A[closest_pos], A[i] = A[i], A[closest_pos]\n            pos_B[a].remove(closest_pos)\n            pos_B[a].append(i)\n            i += 1\n        else:\n            print(\"Yes\")\n\n# Read input and call the function\nT = int(input())\ncan_make_identical(T)", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Check if the frequency of each element in A matches the frequency in B\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        for a, b in zip(A, B):\n            freq_A[a] += 1\n            freq_B[b] += 1\n        \n        if freq_A != freq_B:\n            results.append(\"No\")\n            continue\n        \n        # Check if elements within the same connected component can be made identical\n        visited = [False] * (N + 1)\n        for i in range(1, N + 1):\n            if not visited[i]:\n                stack = [i]\n                connected = set()\n                while stack:\n                    node = stack.pop()\n                    if not visited[node]:\n                        visited[node] = True\n                        connected.add(node)\n                        for j in range(max(1, node - K), min(N + 1, node + K + 1)):\n                            if A[j-1] == node:\n                                stack.append(j)\n                \n                # Check if all elements in the connected component can be made identical\n                if len(connected) != 1:\n                    results.append(\"No\")\n                    break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Process cases\nresults = can_make_identical(T, cases)\n\n# Print results\nfor result in results:\n    print(result)", "```python\ndef can_make_identical(A, B, K):\n    from collections import Counter\n    \n    N = len(A)\n    freq_A = Counter(A)\n    freq_B = Counter(B)\n    \n    for i in range(N):\n        freq_A[A[i]] -= 1\n        freq_B[B[i]] -= 1\n        if i >= K:\n            freq_A[A[i - K]] += 1\n            freq_B[B[i - K]] += 1\n        if freq_A == freq_B:\n            return True\n    return False\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        if can_make_identical(A, B, K):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "```python\ndef can_make_identical(T, test_cases):\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        from collections import defaultdict\n        \n        # Count occurrences of each value in B\n        B_count = defaultdict(int)\n        for b in B:\n            B_count[b] += 1\n        \n        # Check if we can make A identical to B\n        possible = True\n        for b, count in B_count.items():\n            # Find occurrences of b in A within the window of size K\n            A_count = 0\n            for i in range(N):\n                if A[i] == b:\n                    A_count += 1\n                if i >= K and A[i - K] == b:\n                    A_count -= 1\n                if A_count < count:\n                    possible = False\n                    break\n            if not possible:\n                break\n        \n        if possible:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Process each test case\ncan_make_identical(T, test_cases)", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create frequency maps for A and B\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for i in range(N):\n            freq_A[A[i]] += 1\n            freq_B[B[i]] += 1\n        \n        # Check if frequency maps are the same\n        if freq_A != freq_B:\n            results.append(\"No\")\n            continue\n        \n        # Check if we can match elements within the allowed window size K\n        for i in range(N):\n            if A[i] != B[i]:\n                found = False\n                for j in range(max(0, i - K), min(N, i + K + 1)):\n                    if A[j] == B[i]:\n                        A[j] = A[i]\n                        found = True\n                        break\n                if not found:\n                    results.append(\"No\")\n                    break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Process test cases\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```", "```python\ndef can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 * N + 2]))\n        \n        index += 2 * N + 2\n        \n        # Check if sorted versions are equal\n        if sorted(A) != sorted(B):\n            results.append(\"No\")\n            continue\n        \n        # Check if elements can be rearranged within the allowed windows\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        \n        for i in range(N):\n            count_A[A[i]] += 1\n            count_B[B[i]] += 1\n        \n        if count_A == count_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\n# Call the function with the number of test cases\ncan_make_identical(125000)\n```", "```python\ndef can_transform_A_to_B(N, K, A, B):\n    from collections import defaultdict, deque\n    \n    # Create a graph where each node is connected to nodes within K distance\n    graph = defaultdict(list)\n    for i in range(N):\n        for j in range(i - K, i + K + 1):\n            if 0 <= j < N and j != i:\n                graph[i].append(j)\n    \n    # Function to perform BFS and find connected components\n    def bfs(start):\n        visited = set()\n        queue = deque([start])\n        component = []\n        while queue:\n            node = queue.popleft()\n            if node not in visited:\n                visited.add(node)\n                component.append(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n        return component\n    \n    # Find all connected components\n    visited = set()\n    components = []\n    for i in range(N):\n        if i not in visited:\n            component = bfs(i)\n            components.append(component)\n            visited.update(component)\n    \n    # Check each component\n    for component in components:\n        sorted_A = sorted(A[i] for i in component)\n        sorted_B = sorted(B[i] for i in component)\n        if sorted_A != sorted_B:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        result = can_transform_A_to_B(N, K, A, B)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "```python\ndef can_make_identical(T, test_cases):\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a sorted list of A with their indices\n        A_sorted = sorted((x, i) for i, x in enumerate(A))\n        \n        # Create a list to keep track of used indices in A\n        used = [False] * N\n        \n        for x in B:\n            # Find the first value in A_sorted that is within the range of B\n            while A_sorted and abs(A_sorted[0][0] - x) > K:\n                A_sorted.pop(0)\n            \n            if not A_sorted:\n                print(\"No\")\n                break\n            \n            # Find the first unused index that is within the range\n            while A_sorted and used[A_sorted[0][1]]:\n                A_sorted.pop(0)\n            \n            if not A_sorted:\n                print(\"No\")\n                break\n            \n            # Mark the index as used and remove it from the list\n            index = A_sorted.pop(0)[1]\n            used[index] = True\n        else:\n            print(\"Yes\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + N + 2]))\n    B = list(map(int, data[index + N + 2:index + 2 * N + 2]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N + 2\n\n# Process test cases\ncan_make_identical(T, test_cases)\n```", "```python\ndef can_make_identical(T):\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        from collections import defaultdict\n        \n        # Dictionary to store the indices of each value in B\n        B_indices = defaultdict(list)\n        for i, x in enumerate(B):\n            B_indices[x].append(i)\n        \n        # Check each value in A\n        for i, x in enumerate(A):\n            found = False\n            for j in range(max(0, i-K), min(N, i+K+1)):\n                if x in B_indices and B_indices[x][0] == j:\n                    B_indices[x].pop(0)\n                    found = True\n                    break\n            if not found:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n\n# Read the number of test cases\nT = int(input())\ncan_make_identical(T)", "```python\ndef can_make_identical(A, B, K):\n    N = len(A)\n    segments = K + 1\n    \n    for i in range(0, N, segments):\n        segment_A = A[i:i+segments]\n        segment_B = B[i:i+segments]\n        \n        if sorted(segment_A) != sorted(segment_B):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 + 2 * N\n        \n        result = can_make_identical(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef can_make_equal(N, K, A, B):\n    from collections import defaultdict\n    \n    # Initialize a dictionary to count occurrences of values in A within the window\n    window_count = defaultdict(int)\n    for i in range(K):\n        window_count[A[i]] += 1\n    \n    # Initialize pointers for the sliding window\n    left, right = 0, K\n    \n    # Check the first window\n    for i in range(K):\n        if A[i] != B[i]:\n            return False\n    \n    # Slide the window to the right\n    while right < N:\n        window_count[A[right]] += 1\n        window_count[A[left]] -= 1\n        if window_count[A[left]] == 0:\n            del window_count[A[left]]\n        if A[right] != B[right]:\n            return False\n        left += 1\n        right += 1\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        \n        result = \"Yes\" if can_make_equal(N, K, A, B) else \"No\"\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nmain()", "```python\ndef can_make_identical(A, B, K):\n    N = len(A)\n    sorted_B = sorted(B)\n    target = [0] * N\n    \n    # Create a frequency array for A and B\n    freq_A = [0] * (N + 1)\n    freq_B = [0] * (N + 1)\n    \n    for i in range(N):\n        freq_A[A[i]] += 1\n        freq_B[B[i]] += 1\n    \n    # Check if the frequency arrays are the same\n    if freq_A != freq_B:\n        return False\n    \n    # Use a sliding window to check if we can rearrange A to match B\n    for i in range(N):\n        target[(i + 1) % (N + 1)] = sorted_B[i]\n    \n    left = 0\n    right = 0\n    count = 0\n    \n    while left < N:\n        if target[right] == A[left]:\n            count += 1\n            right += 1\n            left += 1\n        else:\n            left += 1\n    \n    return count == N\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        \n        if can_make_identical(A, B, K):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = map(int, case[0].split())\n        A = list(map(int, case[1].split()))\n        B = list(map(int, case[2].split()))\n        \n        # Dictionary to store the count of elements within the sliding window\n        count_window_A = {}\n        count_window_B = {}\n        \n        # Initialize the first window\n        for i in range(K):\n            count_window_A[A[i]] = count_window_A.get(A[i], 0) + 1\n            count_window_B[B[i]] = count_window_B.get(B[i], 0) + 1\n        \n        # Check if the first window is the same\n        if count_window_A != count_window_B:\n            results.append('No')\n            continue\n        \n        # Slide the window across the sequence\n        for i in range(K, N):\n            # Remove the element that is sliding out of the window\n            count_window_A[A[i-K]] -= 1\n            if count_window_A[A[i-K]] == 0:\n                del count_window_A[A[i-K]]\n            \n            # Add the new element that is sliding into the window\n            count_window_A[A[i]] = count_window_A.get(A[i], 0) + 1\n            \n            # Update the count for B\n            count_window_B[B[i-K]] -= 1\n            if count_window_B[B[i-K]] == 0:\n                del count_window_B[B[i-K]]\n            \n            count_window_B[B[i]] = count_window_B.get(B[i], 0) + 1\n            \n            # Check if the current window is the same\n            if count_window_A != count_window_B:\n                results.append('No')\n                break\n        else:\n            results.append('Yes')\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = data[index + 2:index + 2 + N]\n    B = data[index + 2 + N:index + 2 + 2 * N]\n    cases.append((f\"{N} {K}\", \" \".join(A), \" \".join(B)))\n    index += 2 * N\n\n# Process cases\nresults = can_make_identical(T, cases)\n\n# Print results\nfor result in results:\n    print(result)\n```", "def can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    results = []\n\n    for _ in range(int(data[index])):\n        index += 1\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n\n        # Check if both sequences have the same multiset of elements\n        if sorted(A) != sorted(B):\n            results.append('No')\n            continue\n\n        # Check if counts of elements within any window of size 2K+1 match\n        valid = True\n        for i in range(N - 2 * K - 1):\n            if sorted(A[i:i + 2 * K + 1]) != sorted(B[i:i + 2 * K + 1]):\n                valid = False\n                break\n\n        results.append('Yes' if valid else 'No')\n\n    return '\\n'.join(results)\n\n# Example usage\nprint(can_make_identical(4))\n", "```python\ndef can_transform(A, B, K):\n    from collections import Counter\n    \n    N = len(A)\n    freq_A = Counter(A)\n    freq_B = Counter(B)\n    \n    if freq_A != freq_B:\n        return \"No\"\n    \n    for i in range(N):\n        window = A[i:i+K+1]\n        if sorted(window) != sorted(B[i:i+K+1]):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 + 2 * N\n        results.append(can_transform(A, B, K))\n    \n    for result in results:\n        print(result)\n\nsolve()", "```python\ndef can_make_equal(A, B, K):\n    pairs = sorted((A[i], B[i]) for i in range(len(A)))\n    visited = [False] * len(A)\n    for _, b in pairs:\n        found = False\n        for i in range(len(A)):\n            if not visited[i] and abs(A[i] - b) <= K:\n                visited[i] = True\n                found = True\n                break\n        if not found:\n            return \"No\"\n    return \"Yes\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        result = can_make_equal(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\n# Call the function to solve the problem\nsolve()", "```python\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef can_transform_to_B(N, K, A, B):\n    parent = list(range(N))\n    rank = [0] * N\n    \n    # Union elements within distance K\n    for i in range(N):\n        for j in range(max(0, i-K), min(N, i+K+1)):\n            if A[i] == A[j]:\n                union(parent, rank, i, j)\n    \n    # Check frequency of each element in A and B\n    freq_A = {}\n    freq_B = {}\n    \n    for i in range(N):\n        freq_A[A[find(parent, i)]] = freq_A.get(A[find(parent, i)], 0) + 1\n        freq_B[B[i]] = freq_B.get(B[i], 0) + 1\n    \n    if freq_A != freq_B:\n        return False\n    \n    # Check if elements within the same component can be rearranged\n    visited = set()\n    \n    for i in range(N):\n        if find(parent, i) not in visited:\n            component = []\n            queue = [i]\n            while queue:\n                node = queue.pop(0)\n                if node not in visited:\n                    visited.add(node)\n                    component.append(node)\n                    for j in range(max(0, node-K), min(N, node+K+1)):\n                        if A[j] == A[node]:\n                            queue.append(j)\n            \n            # Check if elements in this component can be rearranged to match B\n            comp_freq_A = {}\n            comp_freq_B = {}\n            for node in component:\n                comp_freq_A[A[node]] = comp_freq_A.get(A[node], 0) + 1\n                comp_freq_B[B[node]] = comp_freq_B.get(B[node], 0) + 1\n            \n            if comp_freq_A != comp_freq_B:\n                return False\n    \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = \"Yes", "```python\ndef can_make_identical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    T = int(data[index])\n    index += 1\n\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n\n        A_sorted = sorted(A)\n        B_sorted = sorted(B)\n\n        if A_sorted == B_sorted:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n\n    for result in results:\n        print(result)\n\ncan_make_identical()", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    index += 2 * N\n    \n    # Check if the frequency of elements in A matches B\n    if sorted(A) == sorted(B):\n        results.append(\"Yes\")\n    else:\n        results.append(\"No\")\n\n# Print results for all test cases\nfor result in results:\n    print(result)\n```", "```python\ndef can_make_identical(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 + 2 * N\n        \n        # Check if frequencies of elements in A and B are the same\n        if sorted(A) == sorted(B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\n# Call the function with the number of test cases\ncan_make_identical(125000)\n```", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef main():\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        parent = list(range(N))\n        rank = [1] * N\n        \n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[i] == A[j]:\n                    union(parent, rank, i, j)\n        \n        A_group = [find(parent, i) for i in range(N)]\n        B_group = [find(parent, B[i] - 1) for i in range(N)]\n        \n        if sorted(A_group) == sorted(B_group):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nmain()", "```python\ndef can_make_identical(T):\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        from collections import defaultdict\n        \n        # Create a dictionary to map each value in A to the indices where it appears\n        index_map = defaultdict(list)\n        for i, a in enumerate(A):\n            index_map[a].append(i)\n        \n        # Check each unique value in A\n        for indices in index_map.values():\n            # For each index in B that corresponds to this value in A\n            for b_index in [i for i, b in enumerate(B) if b in index_map]:\n                # Check if b_index is within the same group as the indices in A\n                if not any(abs(b_index - a_index) <= K for a_index in indices):\n                    print(\"No\")\n                    break\n            else:\n                continue\n            break\n        else:\n            print(\"Yes\")\n\n# Call the function with the number of test cases\nT = int(input())\ncan_make_identical(T)", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a dictionary to keep track of the count of each value in A within the K-length window\n        window_count = {}\n        for i in range(K):\n            window_count[A[i]] = window_count.get(A[i], 0) + 1\n        \n        # Check if the first K-length window contains all values from B\n        for value in B[:K]:\n            if value not in window_count or window_count[value] == 0:\n                results.append(\"No\")\n                break\n            window_count[value] -= 1\n        \n        # Slide the window across A and check for each value in B\n        for i in range(K, N):\n            if i - K >= 0:\n                window_count[A[i - K]] += 1\n            for value in B[i - K:i + 1]:\n                if value not in window_count or window_count[value] == 0:\n                    results.append(\"No\")\n                    break\n                window_count[value] -= 1\n            else:\n                results.append(\"Yes\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Solve and print results\nresults = can_make_identical(T, cases)\nfor result in results:\n    print(result)", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for N, K, A, B in cases:\n        target = {}\n        for b in B:\n            if b in target:\n                target[b] += 1\n            else:\n                target[b] = 1\n        \n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[j] in target:\n                    target[A[j]] -= 1\n                    if target[A[j]] == 0:\n                        del target[A[j]]\n                    break\n            if not target:\n                results.append(\"Yes\")\n                break\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Call the function with the input cases\ncan_make_identical(T, cases)", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    \n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a list of tuples (value, index) for B\n        B_with_index = [(B[i], i) for i in range(N)]\n        # Sort B based on the value\n        B_with_index.sort()\n        \n        # Create a list of tuples (value, index) for A\n        A_with_index = [(A[i], i) for i in range(N)]\n        # Sort A based on the value\n        A_with_index.sort()\n        \n        # Create a dictionary to map values in B to their indices\n        B_index_map = {value: index for index, (value, _) in enumerate(B_with_index)}\n        \n        # Create a list to keep track of visited indices in A\n        visited = [False] * N\n        \n        for i in range(N):\n            if visited[i]:\n                continue\n            \n            # Get the value and index of the current element in A\n            value, index = A_with_index[i]\n            target_index = B_index_map[value]\n            \n            # Check if the element can be moved to its target index within the allowed swap distance\n            if abs(index - target_index) > K:\n                results.append(\"No\")\n                break\n            \n            # Mark the current index as visited and recursively visit the target index\n            visited[i] = True\n            visited[target_index] = True\n            i = target_index\n        \n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get results\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```", "```python\ndef can_make_identical(A, B, K):\n    from collections import defaultdict\n    \n    n = len(A)\n    b_count = defaultdict(list)\n    \n    # Collect indices of each element in B\n    for i, x in enumerate(B):\n        b_count[x].append(i)\n    \n    # Check each value in B\n    for indices in b_count.values():\n        if len(indices) == 0:\n            continue\n        start = indices[0]\n        for i in range(1, len(indices)):\n            if indices[i] - start > K:\n                return False\n            start = indices[i]\n    \n    return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        \n        if can_make_identical(A, B, K):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\n# Call the function to solve the problem\nsolve()\n```", "```python\ndef can_make_identical(A, B, K):\n    from collections import defaultdict, deque\n    \n    n = len(A)\n    graph = defaultdict(list)\n    \n    # Build the graph\n    for i in range(n):\n        for j in range(max(0, i - K), min(n, i + K + 1)):\n            if i != j:\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    def bfs(start):\n        visited = set()\n        queue = deque([start])\n        component = set()\n        while queue:\n            node = queue.popleft()\n            if node not in visited:\n                visited.add(node)\n                component.add(A[node])\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n        return component\n    \n    components = []\n    seen = set()\n    for i in range(n):\n        if i not in seen:\n            component = bfs(i)\n            seen.update(component)\n            components.append((component, B[i: i + len(component)]))\n    \n    result = []\n    for comp, target in components:\n        if sorted(comp) == sorted(target):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n    \n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2: index + 2 + N]))\n        B = list(map(int, data[index + 2 + N: index + 2 + 2 * N]))\n        index += 2 * N\n        results.append(\"\".join(can_make_identical(A, B, K)))\n    \n    for result in results:\n        print(result)\n\nsolve()", "```python\ndef can_transform(A, B, K):\n    from collections import Counter\n    \n    # Count frequencies of elements in both sequences\n    freq_A = Counter(A)\n    freq_B = Counter(B)\n    \n    # If frequencies don't match, return \"No\"\n    if freq_A != freq_B:\n        return \"No\"\n    \n    # Sliding window approach\n    n = len(A)\n    window_size = 2 * K + 1\n    \n    for i in range(n - window_size + 1):\n        sub_A = A[i:i + window_size]\n        sub_B = B[i:i + window_size]\n        \n        if Counter(sub_A) != Counter(sub_B):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    for N, K, A, B in test_cases:\n        A_count = [0] * (N + 1)\n        B_count = [0] * (N + 1)\n        for i in range(N):\n            A_count[A[i]] += 1\n            B_count[B[i]] += 1\n        \n        for i in range(1, N + 1):\n            if A_count[i] != B_count[i]:\n                results.append(\"No\")\n                continue\n            \n            A_count[i] = 0\n            B_count[i] = 0\n        \n        A_index = [0] * (N + 1)\n        for i in range(N):\n            A_index[A[i]] = i\n        \n        for i in range(1, N + 1):\n            if B_count[i] == 0:\n                continue\n            \n            j = A_index[i]\n            while abs(j - i) > K:\n                A_index[A[j]] = A_index[A[j + 1]]\n                A[j] = A[j + 1]\n                j += 1\n            \n            if abs(j - i) > K:\n                results.append(\"No\")\n                break\n            \n            A_index[A[j]] = i\n            A[j] = i\n            B_count[i] -= 1\n        \n        else:\n            results.append(\"Yes\")\n    \n    return results\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\nresults = can_make_identical(T, test_cases)\n\nfor result in results:\n    print(result)", "```python\ndef can_transform(A, B, K):\n    N = len(A)\n    B_counter = [0] * (N + 1)\n    for b in B:\n        B_counter[b] += 1\n    \n    A_counter = [0] * (N + 1)\n    for i in range(K):\n        A_counter[A[i]] += 1\n    \n    for b in B:\n        if B_counter[b] == 0:\n            return \"No\"\n        B_counter[b] -= 1\n        A_counter[A[i]] -= 1\n        i += 1\n        if i < N:\n            A_counter[A[i]] += 1\n    \n    return \"Yes\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nsolve()", "```python\ndef can_make_equal(T, cases):\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Frequency array to count occurrences of each element\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for a in A:\n            freq_A[a] += 1\n        for b in B:\n            freq_B[b] += 1\n        \n        # If frequency arrays are not identical, return No\n        if freq_A != freq_B:\n            print(\"No\")\n            continue\n        \n        # Sliding window approach\n        used = [False] * (N + 1)\n        for i in range(N):\n            target = B[i]\n            found = False\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[j] == target and not used[j]:\n                    used[j] = True\n                    found = True\n                    break\n            if not found:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Call the function\ncan_make_equal(T, cases)", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for N, K, A, B in cases:\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        for num in A:\n            count_A[num] += 1\n        for num in B:\n            count_B[num] += 1\n        \n        for num in set(B):\n            if count_A[num] < count_B[num]:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ncases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    cases.append((N, K, A, B))\n    index += 2 * N\n\n# Call the function\ncan_make_identical(T, cases)\n```", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for N, K, A, B in cases:\n        from collections import Counter\n        \n        count_B = Counter(B)\n        count_A = Counter(A)\n        \n        for j, v in enumerate(B):\n            if count_B[v] == 0:\n                results.append(\"No\")\n                break\n            if count_A[v] < count_B[v]:\n                for i in range(max(0, j - K), min(N, j + K + 1)):\n                    if A[i] == v:\n                        A[i], A[j] = A[j], A[i]\n                        count_A[A[j]] += 1\n                        count_A[A[i]] -= 1\n                        break\n                else:\n                    results.append(\"No\")\n                    break\n            else:\n                count_A[v] -= 1\n                count_B[v] -= 1\n        else:\n            results.append(\"Yes\")\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    cases = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2: index + 2 + N]))\n        B = list(map(int, data[index + 2 + N: index + 2 + 2 * N]))\n        cases.append((N, K, A, B))\n        index += 2 * N\n    \n    results = can_make_identical(T, cases)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef can_make_identical(A, B, K):\n    from collections import Counter\n    \n    count_A = Counter(A)\n    count_B = Counter(B)\n    \n    if count_A != count_B:\n        return \"No\"\n    \n    A_positions = {val: [] for val in set(A)}\n    for i, val in enumerate(A):\n        A_positions[val].append(i)\n    \n    B_positions = {val: [] for val in set(B)}\n    for i, val in enumerate(B):\n        B_positions[val].append(i)\n    \n    for val in set(B):\n        if len(A_positions[val]) != len(B_positions[val]):\n            return \"No\"\n        \n        for pos_B in B_positions[val]:\n            found = False\n            for pos_A in A_positions[val]:\n                if abs(pos_A - pos_B) <= K:\n                    found = True\n                    break\n            if not found:\n                return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_make_identical(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef can_transform_to_B(T, cases):\n    results = []\n    \n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        parent = list(range(N))\n        rank = [0] * N\n        \n        # Perform union operations for adjacent elements within range K\n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[i] == A[j]:\n                    union(parent, rank, i, j)\n        \n        # Group elements in A based on their roots\n        A_groups = {}\n        for i in range(N):\n            root = find(parent, i)\n            if root not in A_groups:\n                A_groups[root] = set()\n            A_groups[root].add(A[i])\n        \n        # Group elements in B based on their values\n        B_groups = {}\n        for i in range(N):\n            if B[i] not in B_groups:\n                B_groups[B[i]] = set()\n            B_groups[B[i]].add(B[i])\n        \n        # Check if the groups in A match the groups in B\n        if len(A_groups) != len(B_groups):\n            results.append(\"No\")\n            continue\n        \n        for value in A_groups:\n            if A_groups[value] != B_groups[value]:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nT = int(data[index])\nindex += 1\ncases = []\n\nfor _ in range(T):\n    N = int(data[index])\n    index += 1\n    K = int(data[index])\n    index += 1\n    A = list(map(int, data[index:index+N]))\n    index += N\n    B = list(map(int, data[index:index+N]))\n    index += N\n    cases.append((N, K, A, B))\n\ncan_transform_to_B(T, cases)\n```", "```python\ndef can_make_identical(T, cases):\n    results = []\n    for case in cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        used = [False] * N\n        for b in B:\n            found = False\n            for i in range(N):\n                if not used[i] and A[i] == b:\n                    if abs(i - B.index(b)) <= K:\n                        used[i] = True\n                        found = True\n                        break\n            if not found:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Example usage\nT = 4\ncases = [\n    ([3, 1, [1, 1, 2], [1, 2, 2]]),\n    ([5, 4, [2, 4, 5, 1, 3], [2, 1, 3, 2, 2]]),\n    ([13, 1, [3, 1, 3, 3, 5, 3, 3, 4, 2, 2, 2, 5, 1], [5, 3, 3, 3, 4, 2, 2, 2, 2, 5, 5, 1, 3]]),\n    ([20, 14, [10, 6, 6, 19, 13, 16, 15, 15, 2, 10, 2, 16, 9, 12, 2, 6, 13, 5, 5, 9], [5, 9, 6, 2, 10, 19, 16, 15, 13, 12, 10, 2, 9, 6, 5, 16, 19, 12, 15, 13]])\n]\n\nresults = can_make_identical(T, cases)\nfor result in results:\n    print(result)\n```", "```python\ndef can_make_identical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        A_count = [0] * (N + 1)\n        B_count = [0] * (N + 1)\n        \n        for num in A:\n            A_count[num] += 1\n        for num in B:\n            B_count[num] += 1\n        \n        if A_count != B_count:\n            results.append(\"No\")\n            continue\n        \n        B_copy = B[:]\n        A_copy = A[:]\n        \n        for num in B:\n            found = False\n            for i in range(max(0, B.index(num) - K), min(N, B.index(num) + K + 1)):\n                if A_copy[i] == num:\n                    A_copy[i] = 0\n                    found = True\n                    break\n            if not found:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\ncan_make_identical()", "```python\ndef can_transform_A_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        count_A = {}\n        count_B = {}\n        \n        for i in range(N):\n            if A[i] not in count_A:\n                count_A[A[i]] = 0\n            count_A[A[i]] += 1\n            \n            if B[i] not in count_B:\n                count_B[B[i]] = 0\n            count_B[B[i]] += 1\n        \n        if count_A != count_B:\n            results.append(\"No\")\n            continue\n        \n        for i in range(N):\n            if B[i] not in A[i - K:i + K + 1]:\n                results.append(\"No\")\n                break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_A_to_B()", "```python\ndef can_make_identical(A, B, K):\n    N = len(A)\n    for i in range(N):\n        window = A[max(0, i-K):min(N, i+K+1)]\n        if sorted(window) != sorted(B[max(0, i-K):min(N, i+K+1)]):\n            return \"No\"\n    return \"Yes\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2*N]))\n        index += 2*N\n        \n        results.append(can_make_identical(A, B, K))\n    \n    for result in results:\n        print(result)\n\nsolve()", "```python\ndef can_make_identical(T):\n    for _ in range(T):\n        N, K = map(int, input().split())\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        \n        A_dict = [{} for _ in range(N)]\n        B_dict = [{} for _ in range(N)]\n        \n        for i in range(N):\n            A_dict[i % (K + 1)][A[i]] = A_dict[i % (K + 1)].get(A[i], 0) + 1\n            B_dict[i % (K + 1)][B[i]] = B_dict[i % (K + 1)].get(B[i], 0) + 1\n        \n        for i in range(N):\n            if A_dict[i % (K + 1)] != B_dict[i % (K + 1)]:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")\n\n# Call the function after defining it\ncan_make_identical(int(input()))", "```python\ndef can_transform_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        def is_transformable(A, B, K):\n            from collections import defaultdict\n            \n            # Dictionary to store the positions of each element in B\n            pos = defaultdict(list)\n            for i, val in enumerate(B):\n                pos[val].append(i)\n            \n            for i, val in enumerate(A):\n                if val not in pos:\n                    return False\n                b_indices = pos[val]\n                if not any(abs(i - b_i) <= K for b_i in b_indices):\n                    return False\n                # Remove the used position to avoid reusing it\n                b_indices.pop(0)\n            return True\n        \n        results.append(\"Yes\" if is_transformable(A, B, K) else \"No\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_to_B()", "```python\ndef can_transform(A, B, K):\n    from collections import defaultdict\n    \n    # Dictionary to store positions of each value in B\n    pos = defaultdict(list)\n    for i, x in enumerate(B):\n        pos[x].append(i)\n    \n    # Function to check if two positions can be transformed within K swaps\n    def can_transform_group(pos1, pos2):\n        pos1.sort()\n        pos2.sort()\n        j = 0\n        for i in range(len(pos1)):\n            while j < len(pos2) and pos2[j] - pos1[i] > K:\n                j += 1\n            if j == len(pos2):\n                return False\n            j += 1\n        return True\n    \n    # Check each group\n    for positions in pos.values():\n        if not can_transform_group(positions, positions):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        results.append(can_transform(A, B, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef can_make_identical(A, B, K):\n    N = len(A)\n    for i in range(N):\n        group_A = sorted(A[i:i+K+1])\n        group_B = sorted(B[i:i+K+1])\n        if group_A != group_B:\n            return \"No\"\n    return \"Yes\"\n\ndef solve(input_data):\n    lines = input_data.strip().split('\\n')\n    T = int(lines[0])\n    results = []\n    for i in range(1, T+1):\n        N, K = map(int, lines[2*i].split())\n        A = list(map(int, lines[2*i+1].split()))\n        B = list(map(int, lines[2*i+2].split()))\n        result = can_make_identical(A, B, K)\n        results.append(result)\n    return '\\n'.join(results)\n\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read()\n    print(solve(input_data))\n```", "```python\ndef can_make_identical(T, test_cases):\n    results = []\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Sort A and B within each window of size K + 1\n        for i in range(N):\n            if i + K < N:\n                if sorted(A[i:i + K + 1]) != sorted(B[i:i + K + 1]):\n                    results.append(\"No\")\n                    break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Process test cases\ncan_make_identical(T, test_cases)"]}
