"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.7, \"n\": 2, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_vanilla_bug_trace_TPL_CODEEXECUTOR_qwen_7b_hard_n_2.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42, \"resume\": true}"
{"task_id": "abc366_f", "codes": ["```python\ndef max_composition_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for i in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order, and by B in descending order if A is the same\n    functions.sort(key=lambda x: (-x[0], -x[1]))\n    \n    value = 1\n    for i in range(K):\n        A, B = functions[i]\n        value = A * value + B\n    \n    print(value)\n\nmax_composition_value()", ""], "passed": [false, false], "raw_code": ["```python\ndef max_composition_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for i in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order, and by B in descending order if A is the same\n    functions.sort(key=lambda x: (-x[0], -x[1]))\n    \n    value = 1\n    for i in range(K):\n        A, B = functions[i]\n        value = A * value + B\n    \n    print(value)\n\nmax_composition_value()", ""]}
{"task_id": "arc182_e", "codes": ["", ""], "passed": [false, false], "raw_code": ["", ""]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base case initialization\n    dp_non_decr[0][nums[0]] = 1\n    dp_non_incr[0][nums[0]] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(1, 51):\n            if j >= nums[i]:\n                dp_non_decr[i][j] = (dp_non_decr[i-1][j] + dp_non_decr[i-1][j-nums[i]]) % MOD\n            dp_non_incr[i][j] = (dp_non_incr[i-1][j] + dp_non_incr[i-1][j+nums[i]]) % MOD\n    \n    # Combine results\n    result = 0\n    for i in range(1, 51):\n        result = (result + dp_non_decr[-1][i] * dp_non_incr[-1][i]) % MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def count_ways(nums):\n        dp = [[0] * 51 for _ in range(51)]\n        dp[0][0] = 1\n        \n        for num in nums:\n            new_dp = [[0] * 51 for _ in range(51)]\n            for i in range(51):\n                for j in range(51):\n                    if i + j == num:\n                        new_dp[i][j] = (new_dp[i][j] + dp[i][j]) % MOD\n                        if i > 0:\n                            new_dp[i][j] = (new_dp[i][j] + dp[i-1][j]) % MOD\n                        if j > 0:\n                            new_dp[i][j] = (new_dp[i][j] + dp[i][j-1]) % MOD\n            dp = new_dp\n        \n        return dp[0][0]\n    \n    return count_ways(nums) * count_ways(nums[::-1]) % MOD"], "passed": [false, false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base case initialization\n    dp_non_decr[0][nums[0]] = 1\n    dp_non_incr[0][nums[0]] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(1, 51):\n            if j >= nums[i]:\n                dp_non_decr[i][j] = (dp_non_decr[i-1][j] + dp_non_decr[i-1][j-nums[i]]) % MOD\n            dp_non_incr[i][j] = (dp_non_incr[i-1][j] + dp_non_incr[i-1][j+nums[i]]) % MOD\n    \n    # Combine results\n    result = 0\n    for i in range(1, 51):\n        result = (result + dp_non_decr[-1][i] * dp_non_incr[-1][i]) % MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def count_ways(nums):\n        dp = [[0] * 51 for _ in range(51)]\n        dp[0][0] = 1\n        \n        for num in nums:\n            new_dp = [[0] * 51 for _ in range(51)]\n            for i in range(51):\n                for j in range(51):\n                    if i + j == num:\n                        new_dp[i][j] = (new_dp[i][j] + dp[i][j]) % MOD\n                        if i > 0:\n                            new_dp[i][j] = (new_dp[i][j] + dp[i-1][j]) % MOD\n                        if j > 0:\n                            new_dp[i][j] = (new_dp[i][j] + dp[i][j-1]) % MOD\n            dp = new_dp\n        \n        return dp[0][0]\n    \n    return count_ways(nums) * count_ways(nums[::-1]) % MOD\n```"]}
{"task_id": "abc368_f", "codes": ["def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_one = sum(1 for x in A if x > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()"], "passed": [false, false], "raw_code": ["```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_one = sum(1 for x in A if x > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()"]}
{"task_id": "abc368_e", "codes": ["```python\ndef min_delays(N, M, X1, trains):\n    # Sort trains based on their departure times\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize delays array with the given initial delay for the first train\n    delays = [X1] * M\n    \n    # Process each train to compute the required delays\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(i):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                # Ensure the condition T_i + X_i <= S_j + X_j is satisfied\n                delays[i] = max(delays[i], delays[j] + (S_j - T_i))\n    \n    # Return the computed delays excluding the first one\n    return ' '.join(map(str, delays[1:]))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nfor i in range(M):\n    A_i = int(data[3 + 4 * i])\n    B_i = int(data[4 + 4 * i])\n    S_i = int(data[5 + 4 * i])\n    T_i = int(data[6 + 4 * i])\n    trains.append((A_i, B_i, S_i, T_i))\n\n# Compute and print the result\nresult = min_delays(N, M, X1, trains)\nprint(result)", "def min_delays(N, M, X1):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    A = [int(data[index]) for index in range(1, M + 1)]\n    B = [int(data[index]) for index in range(M + 1, 2 * M + 1)]\n    S = [int(data[index]) for index in range(2 * M + 1, 3 * M + 1)]\n    T = [int(data[index]) for index in range(3 * M + 1, 4 * M + 1)]\n    \n    # Initialize delays\n    X = [0] * M\n    \n    # Sort trains by arrival time\n    trains = [(T[i], i) for i in range(M)]\n    trains.sort()\n    \n    # Apply delays\n    max_delay = X1\n    for i, (_, j) in enumerate(trains):\n        if i > 0:\n            max_delay = max(max_delay, S[j] - T[trains[i - 1][1]])\n        X[j] = max_delay\n    \n    # Print result\n    print(\" \".join(map(str, X[1:])))"], "passed": [false, false], "raw_code": ["```python\ndef min_delays(N, M, X1, trains):\n    # Sort trains based on their departure times\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize delays array with the given initial delay for the first train\n    delays = [X1] * M\n    \n    # Process each train to compute the required delays\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(i):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                # Ensure the condition T_i + X_i <= S_j + X_j is satisfied\n                delays[i] = max(delays[i], delays[j] + (S_j - T_i))\n    \n    # Return the computed delays excluding the first one\n    return ' '.join(map(str, delays[1:]))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nfor i in range(M):\n    A_i = int(data[3 + 4 * i])\n    B_i = int(data[4 + 4 * i])\n    S_i = int(data[5 + 4 * i])\n    T_i = int(data[6 + 4 * i])\n    trains.append((A_i, B_i, S_i, T_i))\n\n# Compute and print the result\nresult = min_delays(N, M, X1, trains)\nprint(result)", "```python\ndef min_delays(N, M, X1):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    A = [int(data[index]) for index in range(1, M + 1)]\n    B = [int(data[index]) for index in range(M + 1, 2 * M + 1)]\n    S = [int(data[index]) for index in range(2 * M + 1, 3 * M + 1)]\n    T = [int(data[index]) for index in range(3 * M + 1, 4 * M + 1)]\n    \n    # Initialize delays\n    X = [0] * M\n    \n    # Sort trains by arrival time\n    trains = [(T[i], i) for i in range(M)]\n    trains.sort()\n    \n    # Apply delays\n    max_delay = X1\n    for i, (_, j) in enumerate(trains):\n        if i > 0:\n            max_delay = max(max_delay, S[j] - T[trains[i - 1][1]])\n        X[j] = max_delay\n    \n    # Print result\n    print(\" \".join(map(str, X[1:])))\n```"]}
{"task_id": "abc370_e", "codes": ["def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(K + 1):\n            dp[i][j] += dp[i-1][j]\n            if j >= A[i-1]:\n                dp[i][j] += dp[i-1][j - A[i-1]]\n            dp[i][j] %= MOD\n    \n    # Sum up all valid partitions where the last subsequence has a sum not equal to K\n    result = 0\n    for j in range(K + 1):\n        if j != K:\n            result += dp[N][j]\n    \n    return result % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))", "```python\ndef count_partitions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    MOD = 998244353\n    \n    # dp[i][j] -> number of ways to partition first i elements such that j == 1 if last subsequence sums to K\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0][0] = 1  # Empty partition\n    \n    for i in range(1, N + 1):\n        dp[i][0] += dp[i - 1][0]\n        dp[i][1] += dp[i - 1][1]\n        \n        if A[i - 1] != K:\n            dp[i][0] += dp[i - 1][0]\n        if A[i - 1] + dp[i - 1][1] * K != K:\n            dp[i][1] += dp[i - 1][1]\n        \n        dp[i][0] %= MOD\n        dp[i][1] %= MOD\n    \n    print((dp[N][0] + dp[N][1]) % MOD)\n\ncount_partitions()"], "passed": [false, false], "raw_code": ["```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(K + 1):\n            dp[i][j] += dp[i-1][j]\n            if j >= A[i-1]:\n                dp[i][j] += dp[i-1][j - A[i-1]]\n            dp[i][j] %= MOD\n    \n    # Sum up all valid partitions where the last subsequence has a sum not equal to K\n    result = 0\n    for j in range(K + 1):\n        if j != K:\n            result += dp[N][j]\n    \n    return result % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))\n```", "```python\ndef count_partitions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    MOD = 998244353\n    \n    # dp[i][j] -> number of ways to partition first i elements such that j == 1 if last subsequence sums to K\n    dp = [[0, 0] for _ in range(N + 1)]\n    dp[0][0] = 1  # Empty partition\n    \n    for i in range(1, N + 1):\n        dp[i][0] += dp[i - 1][0]\n        dp[i][1] += dp[i - 1][1]\n        \n        if A[i - 1] != K:\n            dp[i][0] += dp[i - 1][0]\n        if A[i - 1] + dp[i - 1][1] * K != K:\n            dp[i][1] += dp[i - 1][1]\n        \n        dp[i][0] %= MOD\n        dp[i][1] %= MOD\n    \n    print((dp[N][0] + dp[N][1]) % MOD)\n\ncount_partitions()"]}
{"task_id": "abc366_e", "codes": ["```python\nimport sys\nfrom bisect import bisect_left, bisect_right\n\ndef count_valid_pairs(N, D, points):\n    def count_for_dimension(points, D):\n        sorted_points = sorted(points)\n        prefix_sum = [0] * (N + 1)\n        for i in range(1, N + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + sorted_points[i - 1]\n        \n        count = 0\n        for i in range(N):\n            left = max(0, bisect_left(sorted_points, sorted_points[i] - D))\n            right = min(N, bisect_right(sorted_points, sorted_points[i] + D))\n            count += (right - left) * (2 * sorted_points[i] - sorted_points[left] - sorted_points[right - 1])\n        \n        return count\n    \n    x_count = count_for_dimension([point[0] for point in points], D)\n    y_count = count_for_dimension([point[1] for point in points], D)\n    \n    return x_count * y_count // 2\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nD = int(data[1])\npoints = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\n\n# Calculate and print the result\nresult = count_valid_pairs(N, D, points)\nprint(result)", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    points.sort(key=lambda p: p[0])\n    \n    def count_valid_y(x):\n        left = 0\n        right = 0\n        count = 0\n        while right < N:\n            while right < N and abs(points[right][0] - x) <= D:\n                count += min(D + abs(points[right][0] - x), abs(points[right][1]))\n                right += 1\n            if right == left:\n                break\n            count -= min(D + abs(points[left][0] - x), abs(points[left][1]))\n            left += 1\n        return count\n    \n    total_count = 0\n    for i in range(N):\n        total_count += count_valid_y(points[i][0])\n    \n    print(total_count)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nimport sys\nfrom bisect import bisect_left, bisect_right\n\ndef count_valid_pairs(N, D, points):\n    def count_for_dimension(points, D):\n        sorted_points = sorted(points)\n        prefix_sum = [0] * (N + 1)\n        for i in range(1, N + 1):\n            prefix_sum[i] = prefix_sum[i - 1] + sorted_points[i - 1]\n        \n        count = 0\n        for i in range(N):\n            left = max(0, bisect_left(sorted_points, sorted_points[i] - D))\n            right = min(N, bisect_right(sorted_points, sorted_points[i] + D))\n            count += (right - left) * (2 * sorted_points[i] - sorted_points[left] - sorted_points[right - 1])\n        \n        return count\n    \n    x_count = count_for_dimension([point[0] for point in points], D)\n    y_count = count_for_dimension([point[1] for point in points], D)\n    \n    return x_count * y_count // 2\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nD = int(data[1])\npoints = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\n\n# Calculate and print the result\nresult = count_valid_pairs(N, D, points)\nprint(result)", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    points.sort(key=lambda p: p[0])\n    \n    def count_valid_y(x):\n        left = 0\n        right = 0\n        count = 0\n        while right < N:\n            while right < N and abs(points[right][0] - x) <= D:\n                count += min(D + abs(points[right][0] - x), abs(points[right][1]))\n                right += 1\n            if right == left:\n                break\n            count -= min(D + abs(points[left][0] - x), abs(points[left][1]))\n            left += 1\n        return count\n    \n    total_count = 0\n    for i in range(N):\n        total_count += count_valid_y(points[i][0])\n    \n    print(total_count)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc367_g", "codes": ["```python\nMOD = 998244353\n\ndef power(x, y):\n    res = 1\n    while y > 0:\n        if y % 2 == 1:\n            res = (res * x) % MOD\n        y //= 2\n        x = (x * x) % MOD\n    return res\n\ndef xor_all_subsequences(A, M, K):\n    n = len(A)\n    total_sum = 0\n    \n    # Iterate over all possible lengths of subsequences\n    for length in range(1, n + 1):\n        if length % M != 0:\n            continue\n        \n        count = power(2, n - length)\n        xor_value = 0\n        \n        # Calculate XOR for all subsequences of the current length\n        for i in range(n):\n            if (i & (length - 1)) == 0:\n                xor_value = 0\n            xor_value ^= A[i]\n        \n        total_sum += (power(xor_value, K) * count) % MOD\n        total_sum %= MOD\n    \n    return total_sum\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Calculate and print the result\nresult = xor_all_subsequences(A, M, K)\nprint(result)", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize variables\n    total_score = 0\n    bit_count = [0] * 20\n    \n    # Iterate over each bit position\n    for bit in range(20):\n        count = 0\n        # Count how many times the bit is set in the XOR of all subsequences\n        for i in range(N):\n            if A[i] & (1 << bit):\n                count += 1\n        \n        # Number of subsequences where the bit is set\n        num_subsequences_with_bit_set = 1 << (N - 1)\n        \n        # Calculate the contribution of this bit to the total score\n        if num_subsequences_with_bit_set % M == 0:\n            total_score += pow(2, bit, MOD) * pow(count, K, MOD)\n            total_score %= MOD\n    \n    print(total_score)\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nMOD = 998244353\n\ndef power(x, y):\n    res = 1\n    while y > 0:\n        if y % 2 == 1:\n            res = (res * x) % MOD\n        y //= 2\n        x = (x * x) % MOD\n    return res\n\ndef xor_all_subsequences(A, M, K):\n    n = len(A)\n    total_sum = 0\n    \n    # Iterate over all possible lengths of subsequences\n    for length in range(1, n + 1):\n        if length % M != 0:\n            continue\n        \n        count = power(2, n - length)\n        xor_value = 0\n        \n        # Calculate XOR for all subsequences of the current length\n        for i in range(n):\n            if (i & (length - 1)) == 0:\n                xor_value = 0\n            xor_value ^= A[i]\n        \n        total_sum += (power(xor_value, K) * count) % MOD\n        total_sum %= MOD\n    \n    return total_sum\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Calculate and print the result\nresult = xor_all_subsequences(A, M, K)\nprint(result)", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize variables\n    total_score = 0\n    bit_count = [0] * 20\n    \n    # Iterate over each bit position\n    for bit in range(20):\n        count = 0\n        # Count how many times the bit is set in the XOR of all subsequences\n        for i in range(N):\n            if A[i] & (1 << bit):\n                count += 1\n        \n        # Number of subsequences where the bit is set\n        num_subsequences_with_bit_set = 1 << (N - 1)\n        \n        # Calculate the contribution of this bit to the total score\n        if num_subsequences_with_bit_set % M == 0:\n            total_score += pow(2, bit, MOD) * pow(count, K, MOD)\n            total_score %= MOD\n    \n    print(total_score)\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3550", "codes": ["def maxSumOfNonAttackingRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate column sums\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort row sums in descending order\n    row_sums.sort(reverse=True)\n    \n    # Sort column sums in descending order\n    col_sums.sort(reverse=True)\n    \n    # Select the top three highest sums from different rows and columns\n    max_sum = row_sums[0] + col_sums[1] + col_sums[2]\n    \n    return max_sum", "from itertools import product\n\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find all rows and columns with non-zero cells\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure there are at least 3 non-zero rows and columns\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Generate all combinations of selecting one cell from each row and column\n    max_sum = float('-inf')\n    for row_indices, col_indices in product(range(len(non_zero_rows)), repeat=3):\n        current_sum = sum(board[non_zero_rows[row_indices[i]]][non_zero_cols[col_indices[i]]] for i in range(3))\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"], "passed": [false, false], "raw_code": ["```python\ndef maxSumOfNonAttackingRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate column sums\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort row sums in descending order\n    row_sums.sort(reverse=True)\n    \n    # Sort column sums in descending order\n    col_sums.sort(reverse=True)\n    \n    # Select the top three highest sums from different rows and columns\n    max_sum = row_sums[0] + col_sums[1] + col_sums[2]\n    \n    return max_sum\n```", "```python\nfrom itertools import product\n\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find all rows and columns with non-zero cells\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure there are at least 3 non-zero rows and columns\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Generate all combinations of selecting one cell from each row and column\n    max_sum = float('-inf')\n    for row_indices, col_indices in product(range(len(non_zero_rows)), repeat=3):\n        current_sum = sum(board[non_zero_rows[row_indices[i]]][non_zero_cols[col_indices[i]]] for i in range(3))\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"]}
{"task_id": "3583", "codes": ["from math import gcd\nfrom typing import List\n\ndef minOperations(nums: List[int], queries: List[int]) -> List[int]:\n    max_val = max(nums)\n    freq = {}\n    \n    # Compute the GCD of all pairs and store their frequencies\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            if g not in freq:\n                freq[g] = 0\n            freq[g] += 1\n    \n    # Get the unique GCD values and sort them\n    gcd_values = sorted(freq.keys())\n    \n    # Create a prefix sum array to store cumulative counts of GCD values\n    prefix_sum = [0]\n    for val in gcd_values:\n        prefix_sum.append(prefix_sum[-1] + freq[val])\n    \n    # Answer each query using binary search on the prefix sum array\n    result = []\n    for q in queries:\n        idx = bisect_right(prefix_sum, q + 1) - 1\n        result.append(gcd_values[idx])\n    \n    return result", "def minOperations(self, nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = len(nums)\n    gcd_counts = {}\n    \n    # Count the occurrences of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g not in gcd_counts:\n                gcd_counts[g] = 0\n            gcd_counts[g] += 1\n    \n    # Convert the dictionary to a sorted list of (GCD, count) tuples\n    sorted_gcds = sorted(gcd_counts.items())\n    \n    # Function to get the value at a given rank\n    def get_value_at_rank(rank):\n        current_rank = 0\n        for g, count in sorted_gcds:\n            current_rank += count\n            if current_rank > rank:\n                return g\n            elif current_rank == rank:\n                return g\n    \n    # Process each query\n    result = []\n    for q in queries:\n        result.append(get_value_at_rank(q))\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\nfrom math import gcd\nfrom typing import List\n\ndef minOperations(nums: List[int], queries: List[int]) -> List[int]:\n    max_val = max(nums)\n    freq = {}\n    \n    # Compute the GCD of all pairs and store their frequencies\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            if g not in freq:\n                freq[g] = 0\n            freq[g] += 1\n    \n    # Get the unique GCD values and sort them\n    gcd_values = sorted(freq.keys())\n    \n    # Create a prefix sum array to store cumulative counts of GCD values\n    prefix_sum = [0]\n    for val in gcd_values:\n        prefix_sum.append(prefix_sum[-1] + freq[val])\n    \n    # Answer each query using binary search on the prefix sum array\n    result = []\n    for q in queries:\n        idx = bisect_right(prefix_sum, q + 1) - 1\n        result.append(gcd_values[idx])\n    \n    return result\n```", "```python\ndef minOperations(self, nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    n = len(nums)\n    gcd_counts = {}\n    \n    # Count the occurrences of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g not in gcd_counts:\n                gcd_counts[g] = 0\n            gcd_counts[g] += 1\n    \n    # Convert the dictionary to a sorted list of (GCD, count) tuples\n    sorted_gcds = sorted(gcd_counts.items())\n    \n    # Function to get the value at a given rank\n    def get_value_at_rank(rank):\n        current_rank = 0\n        for g, count in sorted_gcds:\n            current_rank += count\n            if current_rank > rank:\n                return g\n            elif current_rank == rank:\n                return g\n    \n    # Process each query\n    result = []\n    for q in queries:\n        result.append(get_value_at_rank(q))\n    \n    return result\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict over its lifetime\n    enemy_damages = [(d * h) for d, h in zip(damage, health)]\n    \n    # Sort enemies by their total damage in descending order\n    sorted_enemies = sorted(range(n), key=lambda x: -enemy_damages[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for enemy in sorted_enemies:\n        # Calculate how many seconds it takes to defeat this enemy\n        if health[enemy] % power == 0:\n            seconds_to_defeat = health[enemy] // power\n        else:\n            seconds_to_defeat = (health[enemy] // power) + 1\n        \n        # Add the damage received during this time to the total\n        total_damage += seconds_to_defeat * damage[enemy]\n        \n        # Update the current time\n        current_time += seconds_to_defeat\n        \n        # Reduce the health of the enemy\n        health[enemy] = 0\n    \n    return total_damage", "def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die\n    sorted_enemies = sorted(zip(times_to_die, damage))\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time_to_die, d in sorted_enemies:\n        # Calculate the number of full attacks we can make within the time frame\n        full_attacks = int(time_to_die // power)\n        remaining_damage = time_to_die % power\n        \n        # Add the damage from full attacks\n        total_damage += full_attacks * d\n        \n        # If there is any remaining time, add the damage for that partial attack\n        if remaining_damage > 0:\n            total_damage += d\n        \n        # Update the current time\n        current_time += time_to_die\n    \n    return total_damage"], "passed": [false, false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict over its lifetime\n    enemy_damages = [(d * h) for d, h in zip(damage, health)]\n    \n    # Sort enemies by their total damage in descending order\n    sorted_enemies = sorted(range(n), key=lambda x: -enemy_damages[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for enemy in sorted_enemies:\n        # Calculate how many seconds it takes to defeat this enemy\n        if health[enemy] % power == 0:\n            seconds_to_defeat = health[enemy] // power\n        else:\n            seconds_to_defeat = (health[enemy] // power) + 1\n        \n        # Add the damage received during this time to the total\n        total_damage += seconds_to_defeat * damage[enemy]\n        \n        # Update the current time\n        current_time += seconds_to_defeat\n        \n        # Reduce the health of the enemy\n        health[enemy] = 0\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die\n    sorted_enemies = sorted(zip(times_to_die, damage))\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time_to_die, d in sorted_enemies:\n        # Calculate the number of full attacks we can make within the time frame\n        full_attacks = int(time_to_die // power)\n        remaining_damage = time_to_die % power\n        \n        # Add the damage from full attacks\n        total_damage += full_attacks * d\n        \n        # If there is any remaining time, add the damage for that partial attack\n        if remaining_damage > 0:\n            total_damage += d\n        \n        # Update the current time\n        current_time += time_to_die\n    \n    return total_damage\n```"]}
{"task_id": "3575", "codes": ["def maximum_value(nums, k):\n    n = len(nums)\n    prefix_or = [0] * (n + 1)\n    \n    # Compute prefix OR array\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    max_value = 0\n    \n    # Use sliding window to find the maximum XOR value\n    for i in range(k, n - k + 1):\n        left_or = prefix_or[i]\n        right_or = prefix_or[n] ^ prefix_or[i + k]\n        max_value = max(max_value, left_or ^ right_or)\n    \n    return max_value", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[j][i] = dp[j][i - 1]\n            if j > 1:\n                dp[j][i] = max(dp[j][i], dp[j - 1][i - 1])\n            dp[j][i] |= nums[i - 1]\n    \n    max_value = 0\n    for i in range(k + 1):\n        for j in range(k + 1):\n            if i + j == k:\n                max_value = max(max_value, dp[i][i + j] ^ dp[j][i + j])\n    \n    return max_value"], "passed": [false, false], "raw_code": ["```python\ndef maximum_value(nums, k):\n    n = len(nums)\n    prefix_or = [0] * (n + 1)\n    \n    # Compute prefix OR array\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    max_value = 0\n    \n    # Use sliding window to find the maximum XOR value\n    for i in range(k, n - k + 1):\n        left_or = prefix_or[i]\n        right_or = prefix_or[n] ^ prefix_or[i + k]\n        max_value = max(max_value, left_or ^ right_or)\n    \n    return max_value\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            dp[j][i] = dp[j][i - 1]\n            if j > 1:\n                dp[j][i] = max(dp[j][i], dp[j - 1][i - 1])\n            dp[j][i] |= nums[i - 1]\n    \n    max_value = 0\n    for i in range(k + 1):\n        for j in range(k + 1):\n            if i + j == k:\n                max_value = max(max_value, dp[i][i + j] ^ dp[j][i + j])\n    \n    return max_value\n```"]}
{"task_id": "3571", "codes": ["def longestIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Build graph\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    n = len(coordinates)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[coordinates[i]].append(coordinates[j])\n                in_degree[coordinates[j]] += 1\n    \n    # Step 3: Topological sort\n    queue = deque([node for node in coordinates if in_degree[node] == 0])\n    dp = {node: 1 for node in coordinates}\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Step 4: Return the result for the k-th coordinate\n    return dp[coordinates[k]]", "def maxIncreasingPath(coordinates, k):\n    def dfs(i):\n        if dp[i] != -1:\n            return dp[i]\n        \n        dp[i] = 1\n        for dx, dy in [(1, 0), (0, 1)]:\n            nx, ny = x[i] + dx, y[i] + dy\n            pos = bisect_left(y, ny, key=lambda y: (nx, y))\n            if pos < len(y) and x[pos] == nx and y[pos] == ny and coordinates[pos] > coordinates[i]:\n                dp[i] = max(dp[i], 1 + dfs(pos))\n        \n        return dp[i]\n    \n    n = len(coordinates)\n    x, y = zip(*sorted(coordinates))\n    dp = [-1] * n\n    \n    return dfs(k)"], "passed": [false, false], "raw_code": ["```python\ndef longestIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Build graph\n    graph = defaultdict(list)\n    in_degree = defaultdict(int)\n    n = len(coordinates)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[coordinates[i]].append(coordinates[j])\n                in_degree[coordinates[j]] += 1\n    \n    # Step 3: Topological sort\n    queue = deque([node for node in coordinates if in_degree[node] == 0])\n    dp = {node: 1 for node in coordinates}\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Step 4: Return the result for the k-th coordinate\n    return dp[coordinates[k]]\n```", "```python\ndef maxIncreasingPath(coordinates, k):\n    def dfs(i):\n        if dp[i] != -1:\n            return dp[i]\n        \n        dp[i] = 1\n        for dx, dy in [(1, 0), (0, 1)]:\n            nx, ny = x[i] + dx, y[i] + dy\n            pos = bisect_left(y, ny, key=lambda y: (nx, y))\n            if pos < len(y) and x[pos] == nx and y[pos] == ny and coordinates[pos] > coordinates[i]:\n                dp[i] = max(dp[i], 1 + dfs(pos))\n        \n        return dp[i]\n    \n    n = len(coordinates)\n    x, y = zip(*sorted(coordinates))\n    dp = [-1] * n\n    \n    return dfs(k)\n```"]}
{"task_id": "3560", "codes": ["def min_moves_to_capture(kx, ky, px, py):\n    # Knight's possible moves\n    knight_moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    \n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in knight_moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[float('-inf')] * (1 << n) for _ in range(n)]\n    \n    def dfs(i, mask):\n        if i == n:\n            return 0\n        \n        if dp[i][mask] != float('-inf'):\n            return dp[i][mask]\n        \n        total_moves = 0\n        for j in range(n):\n            if mask & (1 << j) == 0:\n                moves = min_moves_to_capture(kx, ky, positions[j][0], positions[j][1])\n                if moves < float('inf'):\n                    new_mask = mask | (1 << j)\n                    total_moves = max(total_moves, moves + dfs(j, new_mask))\n        \n        dp[i][mask] = total_moves\n        return dp[i][mask]\n    \n    return dfs(0, 0)\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance between the knight and the pawn\n    return abs(kx - px) + abs(ky - py)\n\ndef max_min_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    for i in range(n):\n        dp[i][(1 << i)] = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                prev_mask = mask ^ (1 << i)\n                for j in range(n):\n                    if prev_mask & (1 << j):\n                        dp[i][mask] = min(dp[i][mask], dp[j][prev_mask] + min_moves_to_capture(positions[j][0], positions[j][1], positions[i][0], positions[i][1]))\n    return dp[n-1][(1 << n) - 1]\n"], "passed": [false, false], "raw_code": ["```python\ndef min_moves_to_capture(kx, ky, px, py):\n    # Knight's possible moves\n    knight_moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    \n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in knight_moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[float('-inf')] * (1 << n) for _ in range(n)]\n    \n    def dfs(i, mask):\n        if i == n:\n            return 0\n        \n        if dp[i][mask] != float('-inf'):\n            return dp[i][mask]\n        \n        total_moves = 0\n        for j in range(n):\n            if mask & (1 << j) == 0:\n                moves = min_moves_to_capture(kx, ky, positions[j][0], positions[j][1])\n                if moves < float('inf'):\n                    new_mask = mask | (1 << j)\n                    total_moves = max(total_moves, moves + dfs(j, new_mask))\n        \n        dp[i][mask] = total_moves\n        return dp[i][mask]\n    \n    return dfs(0, 0)\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance between the knight and the pawn\n    return abs(kx - px) + abs(ky - py)\n\ndef max_min_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    for i in range(n):\n        dp[i][(1 << i)] = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                prev_mask = mask ^ (1 << i)\n                for j in range(n):\n                    if prev_mask & (1 << j):\n                        dp[i][mask] = min(dp[i][mask], dp[j][prev_mask] + min_moves_to_capture(positions[j][0], positions[j][1], positions[i][0], positions[i][1]))\n    return dp[n-1][(1 << n) - 1]\n"]}
{"task_id": "3551", "codes": ["class TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # Helper function to insert a number into the Trie\n        def insert(num):\n            node = root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if not node.children[bit]:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n        \n        # Helper function to find the maximum XOR value\n        def maxXOR(prefix):\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (prefix >> i) & 1\n                if node.children[1 - bit]:\n                    xor_val |= (1 << i)\n                    node = node.children[1 - bit]\n                else:\n                    node = node.children[bit]\n            return xor_val\n        \n        # Sort queries based on the right boundary\n        queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)], key=lambda x: x[1])\n        result = [0] * len(queries)\n        root = TrieNode()\n        j = 0\n        prefix = 0\n        \n        for l, r, i in queries:\n            while j <= r:\n                prefix ^= nums[j]\n                insert(prefix)\n                j += 1\n            \n            max_xor = maxXOR(prefix ^ nums[l])\n            result[i] = max_xor\n        \n        return result", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_xor = 0\n\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # Step 1: Sort queries by their right endpoint\n        sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][1])\n        n = len(nums)\n        result = [0] * len(queries)\n        trie = TrieNode()\n        \n        # Step 2: Process queries in order\n        j = 0\n        prefix_xor = 0\n        \n        for i, (start, end) in sorted_queries:\n            # Add all numbers from start to end to the Trie\n            for k in range(j, end + 1):\n                prefix_xor ^= nums[k]\n                node = trie\n                for bit in range(30, -1, -1):\n                    bit_val = (prefix_xor >> bit) & 1\n                    if bit_val not in node.children:\n                        node.children[bit_val] = TrieNode()\n                    node = node.children[bit_val]\n                    node.max_xor = max(node.max_xor, prefix_xor)\n                j = k + 1\n            \n            # Find the maximum XOR for the current query\n            node = trie\n            for bit in range(30, -1, -1):\n                bit_val = (queries[i][1] ^ queries[i][0]) >> bit & 1\n                if bit_val ^ 1 in node.children:\n                    node = node.children[bit_val ^ 1]\n                else:\n                    node = node.children[bit_val]\n            result[i] = node.max_xor\n        \n        return result"], "passed": [false, false], "raw_code": ["```python\nclass TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # Helper function to insert a number into the Trie\n        def insert(num):\n            node = root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if not node.children[bit]:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n        \n        # Helper function to find the maximum XOR value\n        def maxXOR(prefix):\n            node = root\n            xor_val = 0\n            for i in range(31, -1, -1):\n                bit = (prefix >> i) & 1\n                if node.children[1 - bit]:\n                    xor_val |= (1 << i)\n                    node = node.children[1 - bit]\n                else:\n                    node = node.children[bit]\n            return xor_val\n        \n        # Sort queries based on the right boundary\n        queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)], key=lambda x: x[1])\n        result = [0] * len(queries)\n        root = TrieNode()\n        j = 0\n        prefix = 0\n        \n        for l, r, i in queries:\n            while j <= r:\n                prefix ^= nums[j]\n                insert(prefix)\n                j += 1\n            \n            max_xor = maxXOR(prefix ^ nums[l])\n            result[i] = max_xor\n        \n        return result\n```", "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_xor = 0\n\nclass Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        # Step 1: Sort queries by their right endpoint\n        sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][1])\n        n = len(nums)\n        result = [0] * len(queries)\n        trie = TrieNode()\n        \n        # Step 2: Process queries in order\n        j = 0\n        prefix_xor = 0\n        \n        for i, (start, end) in sorted_queries:\n            # Add all numbers from start to end to the Trie\n            for k in range(j, end + 1):\n                prefix_xor ^= nums[k]\n                node = trie\n                for bit in range(30, -1, -1):\n                    bit_val = (prefix_xor >> bit) & 1\n                    if bit_val not in node.children:\n                        node.children[bit_val] = TrieNode()\n                    node = node.children[bit_val]\n                    node.max_xor = max(node.max_xor, prefix_xor)\n                j = k + 1\n            \n            # Find the maximum XOR for the current query\n            node = trie\n            for bit in range(30, -1, -1):\n                bit_val = (queries[i][1] ^ queries[i][0]) >> bit & 1\n                if bit_val ^ 1 in node.children:\n                    node = node.children[bit_val ^ 1]\n                else:\n                    node = node.children[bit_val]\n            result[i] = node.max_xor\n        \n        return result\n```"]}
{"task_id": "3580", "codes": ["def find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n            if diff_count > 1:\n                break\n        if diff_count <= 1:\n            return i\n    \n    return -1", "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1"], "passed": [false, false], "raw_code": ["```python\ndef find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n            if diff_count > 1:\n                break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```", "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"]}
{"task_id": "3548", "codes": ["from itertools import permutations, combinations_with_replacement\n\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def is_divisible_by_k(num, k):\n        return int(num) % k == 0\n    \n    count = 0\n    digits = '123456789'\n    \n    # Generate all n-digit combinations of digits\n    for combo in combinations_with_replacement(digits, n):\n        # Ensure no leading zero\n        if combo[0] != '0':\n            # Generate all permutations of the combination\n            for perm in set(permutations(combo)):\n                num = ''.join(perm)\n                if is_palindrome(num) and is_divisible_by_k(num, k):\n                    count += 1\n    \n    return count\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468", "from itertools import permutations, combinations_with_replacement\n\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    count = 0\n    digits = '123456789'\n    \n    # Generate all combinations of n digits\n    for combo in combinations_with_replacement(digits, n):\n        # Generate all unique permutations of the current combination\n        for perm in set(permutations(combo)):\n            num = int(''.join(perm))\n            if is_palindrome(num) and is_divisible_by_k(num):\n                count += 1\n                \n    return count\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468"], "passed": [false, false], "raw_code": ["```python\nfrom itertools import permutations, combinations_with_replacement\n\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def is_divisible_by_k(num, k):\n        return int(num) % k == 0\n    \n    count = 0\n    digits = '123456789'\n    \n    # Generate all n-digit combinations of digits\n    for combo in combinations_with_replacement(digits, n):\n        # Ensure no leading zero\n        if combo[0] != '0':\n            # Generate all permutations of the combination\n            for perm in set(permutations(combo)):\n                num = ''.join(perm)\n                if is_palindrome(num) and is_divisible_by_k(num, k):\n                    count += 1\n    \n    return count\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468\n```", "```python\nfrom itertools import permutations, combinations_with_replacement\n\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    count = 0\n    digits = '123456789'\n    \n    # Generate all combinations of n digits\n    for combo in combinations_with_replacement(digits, n):\n        # Generate all unique permutations of the current combination\n        for perm in set(permutations(combo)):\n            num = int(''.join(perm))\n            if is_palindrome(num) and is_divisible_by_k(num):\n                count += 1\n                \n    return count\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468\n```"]}
