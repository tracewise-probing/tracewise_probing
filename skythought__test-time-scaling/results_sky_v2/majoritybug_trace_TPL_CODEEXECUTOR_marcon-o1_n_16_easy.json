"{\"difficulty\": \"easy\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"AIDC-AI/Marco-o1\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majoritybug_trace_TPL_CODEEXECUTOR_marcon-o1_n_16_easy.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"AIDC-AI/Marco-o1\", \"api_base\": \"http://10.96.183.224:63019/8002/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3555", "code": "def multiply_min_elements(nums, k, multiplier):\n    for _ in range(k):\n        min_val = min(nums)\n        index = nums.index(min_val)\n        nums[index] = min_val * multiplier\n    return nums\n", "passed": true, "raw_code": "def multiply_min_elements(nums, k, multiplier):\n    for _ in range(k):\n        min_val = min(nums)\n        index = nums.index(min_val)\n        nums[index] = min_val * multiplier\n    return nums\n"}
{"task_id": "3606", "code": "def min_after_digit_sum(nums):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(n))\n    \n    replaced_nums = [digit_sum(num) for num in nums]\n    return min(replaced_nums)\n", "passed": true, "raw_code": "def min_after_digit_sum(nums):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(n))\n    \n    replaced_nums = [digit_sum(num) for num in nums]\n    return min(replaced_nums)\n"}
{"task_id": "3567", "code": "def date_to_binary(date):\n    # Split the date into year, month, and day\n    year, month, day = date.split('-')\n    \n    # Convert each part to integer\n    year_int = int(year)\n    month_int = int(month)\n    day_int = int(day)\n    \n    # Function to convert decimal to binary without leading zeros\n    def dec_to_bin(n):\n        return bin(n)[2:]\n    \n    # Convert each part to binary\n    year_bin = dec_to_bin(year_int)\n    month_bin = dec_to_bin(month_int)\n    day_bin = dec_to_bin(day_int)\n    \n    # Combine them in the format year-month-day\n    binary_date = f\"{year_bin}-{month_bin}-{day_bin}\"\n    \n    return binary_date\n", "passed": true, "raw_code": "def date_to_binary(date):\n    # Split the date into year, month, and day\n    year, month, day = date.split('-')\n    \n    # Convert each part to integer\n    year_int = int(year)\n    month_int = int(month)\n    day_int = int(day)\n    \n    # Function to convert decimal to binary without leading zeros\n    def dec_to_bin(n):\n        return bin(n)[2:]\n    \n    # Convert each part to binary\n    year_bin = dec_to_bin(year_int)\n    month_bin = dec_to_bin(month_int)\n    day_bin = dec_to_bin(day_int)\n    \n    # Combine them in the format year-month-day\n    binary_date = f\"{year_bin}-{month_bin}-{day_bin}\"\n    \n    return binary_date\n"}
{"task_id": "3519", "code": "def count_winners(n, pick):\n    \"\"\"\n    Counts the number of players who win the game based on their picks.\n\n    Parameters:\n    n (int): The number of players.\n    pick (List[List[int]]): A 2D array where pick[i] = [x_i, y_i] represents\n                            player x_i picking a ball of color y_i.\n\n    Returns:\n    int: The number of players who win the game.\n    \"\"\"\n    # Initialize a dictionary to keep track of the number of balls each color is picked\n    color_counts = {}\n    for p in pick:\n        player, color = p\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    winners = 0\n    for i in range(n):\n        required = i + 1\n        if required in color_counts.values():\n            winners += 1\n        else:\n            # If no player has picked exactly 'required' balls of any color, check for higher counts\n            for count in color_counts.values():\n                if count > required:\n                    winners += 1\n                    break\n\n    return winners\n", "passed": false, "raw_code": "def count_winners(n, pick):\n    \"\"\"\n    Counts the number of players who win the game based on their picks.\n\n    Parameters:\n    n (int): The number of players.\n    pick (List[List[int]]): A 2D array where pick[i] = [x_i, y_i] represents\n                            player x_i picking a ball of color y_i.\n\n    Returns:\n    int: The number of players who win the game.\n    \"\"\"\n    # Initialize a dictionary to keep track of the number of balls each color is picked\n    color_counts = {}\n    for p in pick:\n        player, color = p\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    winners = 0\n    for i in range(n):\n        required = i + 1\n        if required in color_counts.values():\n            winners += 1\n        else:\n            # If no player has picked exactly 'required' balls of any color, check for higher counts\n            for count in color_counts.values():\n                if count > required:\n                    winners += 1\n                    break\n\n    return winners\n"}
{"task_id": "3568", "code": "def generate_key(num1, num2, num3):\n    # Convert numbers to strings to easily access individual digits\n    str_num1 = str(num1).zfill(4)\n    str_num2 = str(num2).zfill(4)\n    str_num3 = str(num3).zfill(4)\n    \n    key = ''\n    for i in range(4):\n        # Extract the i-th digit from each number\n        digit1 = int(str_num1[i])\n        digit2 = int(str_num2[i])\n        digit3 = int(str_num3[i])\n        \n        # Find the minimum digit among the three\n        min_digit = min(digit1, digit2, digit3)\n        \n        # Append the minimum digit to the key\n        key += str(min_digit)\n    \n    return int(key)\n", "passed": true, "raw_code": "def generate_key(num1, num2, num3):\n    # Convert numbers to strings to easily access individual digits\n    str_num1 = str(num1).zfill(4)\n    str_num2 = str(num2).zfill(4)\n    str_num3 = str(num3).zfill(4)\n    \n    key = ''\n    for i in range(4):\n        # Extract the i-th digit from each number\n        digit1 = int(str_num1[i])\n        digit2 = int(str_num2[i])\n        digit3 = int(str_num3[i])\n        \n        # Find the minimum digit among the three\n        min_digit = min(digit1, digit2, digit3)\n        \n        # Append the minimum digit to the key\n        key += str(min_digit)\n    \n    return int(key)\n"}
{"task_id": "3533", "code": "def snake_position(n, commands):\n    # Initialize starting position\n    i, j = 0, 0\n    for command in commands:\n        if command == \"UP\":\n            i -= 1\n        elif command == \"DOWN\":\n            i += 1\n        elif command == \"RIGHT\":\n            j += 1\n        elif command == \"LEFT\":\n            j -= 1\n        # Adjust indices to stay within bounds\n        if i < 0:\n            i = 0\n        if i >= n:\n            i = n - 1\n        if j < 0:\n            j = 0\n        if j >= n:\n            j = n - 1\n    return i * n + j\n", "passed": true, "raw_code": "def snake_position(n, commands):\n    # Initialize starting position\n    i, j = 0, 0\n    for command in commands:\n        if command == \"UP\":\n            i -= 1\n        elif command == \"DOWN\":\n            i += 1\n        elif command == \"RIGHT\":\n            j += 1\n        elif command == \"LEFT\":\n            j -= 1\n        # Adjust indices to stay within bounds\n        if i < 0:\n            i = 0\n        if i >= n:\n            i = n - 1\n        if j < 0:\n            j = 0\n        if j >= n:\n            j = n - 1\n    return i * n + j\n"}
{"task_id": "3543", "code": "def count_k_constrained_substrings(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if s[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            if zeros > k or ones > k:\n                break\n            count += 1\n    return count\n", "passed": false, "raw_code": "def count_k_constrained_substrings(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if s[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            if zeros > k or ones > k:\n                break\n            count += 1\n    return count\n"}
{"task_id": "3553", "code": "def same_color(coordinate1: str, coordinate2: str) -> bool:\n    # Define the chessboard rows and columns\n    rows = ['1', '2', '3', '4', '5', '6', '7', '8']\n    cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n    \n    # Convert letters to indices\n    col1_index = ord(coordinate1[0]) - ord('a')\n    col2_index = ord(coordinate2[0]) - ord('a')\n    \n    # Convert numbers to indices\n    row1_index = int(coordinate1[1]) - 1\n    row2_index = int(coordinate2[1]) - 1\n    \n    # Determine the color based on the sum of row and column indices\n    # If the sum is even, the square is black; if odd, it's white\n    return (row1_index + col1_index) % 2 == (row2_index + col2_index) % 2\n", "passed": true, "raw_code": "def same_color(coordinate1: str, coordinate2: str) -> bool:\n    # Define the chessboard rows and columns\n    rows = ['1', '2', '3', '4', '5', '6', '7', '8']\n    cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n    \n    # Convert letters to indices\n    col1_index = ord(coordinate1[0]) - ord('a')\n    col2_index = ord(coordinate2[0]) - ord('a')\n    \n    # Convert numbers to indices\n    row1_index = int(coordinate1[1]) - 1\n    row2_index = int(coordinate2[1]) - 1\n    \n    # Determine the color based on the sum of row and column indices\n    # If the sum is even, the square is black; if odd, it's white\n    return (row1_index + col1_index) % 2 == (row2_index + col2_index) % 2\n"}
{"task_id": "3600", "code": "def find_kth_character(k):\n    word = \"a\"\n    while len(word) < k:\n        new_word = \"\"\n        for char in word:\n            if char == 'z':\n                new_char = 'a'\n            else:\n                new_char = chr(ord(char) + 1)\n            new_word += new_char\n        word += new_word\n    return word[k - 1]\n", "passed": true, "raw_code": "def find_kth_character(k):\n    word = \"a\"\n    while len(word) < k:\n        new_word = \"\"\n        for char in word:\n            if char == 'z':\n                new_char = 'a'\n            else:\n                new_char = chr(ord(char) + 1)\n            new_word += new_char\n        word += new_word\n    return word[k - 1]\n"}
{"final_accuracy": "77.78%"}
{"difficulty": "easy", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_no_public_tests", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "AIDC-AI/Marco-o1", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majoritybug_trace_TPL_CODEEXECUTOR_marcon-o1_n_16_easy.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "AIDC-AI/Marco-o1", "api_base": "http://127.0.0.1:8003/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc372_a", "code": "def remove_dots_from_string():\n    import sys\n    # Read input from standard input\n    S = sys.stdin.readline().strip()\n    # Remove all '.' characters from the string\n    result = S.replace('.', '')\n    # Print the result\n    print(result)\n\n# Call the function\nremove_dots_from_string()\n", "passed": true, "raw_code": "def remove_dots_from_string():\n    import sys\n    # Read input from standard input\n    S = sys.stdin.readline().strip()\n    # Remove all '.' characters from the string\n    result = S.replace('.', '')\n    # Print the result\n    print(result)\n\n# Call the function\nremove_dots_from_string()\n"}
{"task_id": "abc370_a", "code": "def check_hand_raising():\n    import sys\n\n    # Read input from standard input\n    input_line = sys.stdin.readline().strip()\n    \n    # Split the input into two integers\n    L, R = map(int, input_line.split())\n    \n    # Check the conditions based on the instructions\n    if (L == 1 and R == 0):\n        print(\"Yes\")\n    elif (L == 0 and R == 1):\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\n# Call the function after its definition\ncheck_hand_raising()\n", "passed": true, "raw_code": "def check_hand_raising():\n    import sys\n\n    # Read input from standard input\n    input_line = sys.stdin.readline().strip()\n    \n    # Split the input into two integers\n    L, R = map(int, input_line.split())\n    \n    # Check the conditions based on the instructions\n    if (L == 1 and R == 0):\n        print(\"Yes\")\n    elif (L == 0 and R == 1):\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\n# Call the function after its definition\ncheck_hand_raising()\n"}
{"task_id": "abc373_a", "code": "def count_matching_strings():\n    count = 0\n    for i in range(1, 13):\n        line = input()\n        if len(line) == i:\n            count += 1\n    print(count)\n\n# Example usage:\n# count_matching_strings()\n", "passed": false, "raw_code": "def count_matching_strings():\n    count = 0\n    for i in range(1, 13):\n        line = input()\n        if len(line) == i:\n            count += 1\n    print(count)\n\n# Example usage:\n# count_matching_strings()\n"}
{"task_id": "abc366_a", "code": "def determine_election_outcome():\n    import sys\n\n    # Read input from stdin\n    input_line = sys.stdin.readline().strip()\n    N, T, A = map(int, input_line.split())\n\n    # Check if the outcome is already decided\n    if (T > A) or (T == A and N - (T + A) == 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function after its definition\ndetermine_election_outcome()\n", "passed": false, "raw_code": "def determine_election_outcome():\n    import sys\n\n    # Read input from stdin\n    input_line = sys.stdin.readline().strip()\n    N, T, A = map(int, input_line.split())\n\n    # Check if the outcome is already decided\n    if (T > A) or (T == A and N - (T + A) == 0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function after its definition\ndetermine_election_outcome()\n"}
{"task_id": "abc367_a", "code": "def can_shout_takoyaki():\n    # Read input from stdin\n    A, B, C = map(int, input().split())\n    \n    # Determine if Takahashi is awake at A o'clock\n    if A >= B and A < C:\n        print(\"Yes\")\n    elif A < B and A >= C:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function\ncan_shout_takoyaki()\n", "passed": false, "raw_code": "def can_shout_takoyaki():\n    # Read input from stdin\n    A, B, C = map(int, input().split())\n    \n    # Determine if Takahashi is awake at A o'clock\n    if A >= B and A < C:\n        print(\"Yes\")\n    elif A < B and A >= C:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function\ncan_shout_takoyaki()\n"}
{"task_id": "abc365_b", "code": "def find_second_largest():\n    import sys\n\n    # Read the first line to get the number of elements\n    N = int(sys.stdin.readline().strip())\n\n    # Read the second line containing the elements\n    elements = list(map(int, sys.stdin.readline().strip().split()))\n\n    # Since all elements are distinct, we can sort them in descending order\n    sorted_elements = sorted(elements, reverse=True)\n\n    # The second largest element is at index 1 after sorting\n    second_largest_index = sorted_elements[1]\n\n    # Find the original index of the second largest element\n    original_index = elements.index(second_largest_index) + 1  # Adding 1 for 1-based indexing\n\n    print(original_index)\n\n# Call the function after its definition\nfind_second_largest()\n", "passed": true, "raw_code": "def find_second_largest():\n    import sys\n\n    # Read the first line to get the number of elements\n    N = int(sys.stdin.readline().strip())\n\n    # Read the second line containing the elements\n    elements = list(map(int, sys.stdin.readline().strip().split()))\n\n    # Since all elements are distinct, we can sort them in descending order\n    sorted_elements = sorted(elements, reverse=True)\n\n    # The second largest element is at index 1 after sorting\n    second_largest_index = sorted_elements[1]\n\n    # Find the original index of the second largest element\n    original_index = elements.index(second_largest_index) + 1  # Adding 1 for 1-based indexing\n\n    print(original_index)\n\n# Call the function after its definition\nfind_second_largest()\n"}
{"task_id": "abc368_a", "code": "def shuffle_stack():\n    import sys\n    # Read input from standard input\n    line = sys.stdin.readline().strip()\n    N, K = map(int, line.split())\n    \n    # Read the list of integers on the cards\n    cards = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # Extract the K cards from the bottom\n    bottom_cards = cards[-K:]\n    \n    # Remove the K cards from the bottom\n    top_cards = cards[:-K]\n    \n    # Place the K cards on top\n    shuffled_cards = bottom_cards + top_cards\n    \n    # Print the integers from top to bottom\n    print(' '.join(map(str, shuffled_cards)))\n\n# Call the function\nshuffle_stack()\n", "passed": true, "raw_code": "def shuffle_stack():\n    import sys\n    # Read input from standard input\n    line = sys.stdin.readline().strip()\n    N, K = map(int, line.split())\n    \n    # Read the list of integers on the cards\n    cards = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # Extract the K cards from the bottom\n    bottom_cards = cards[-K:]\n    \n    # Remove the K cards from the bottom\n    top_cards = cards[:-K]\n    \n    # Place the K cards on top\n    shuffled_cards = bottom_cards + top_cards\n    \n    # Print the integers from top to bottom\n    print(' '.join(map(str, shuffled_cards)))\n\n# Call the function\nshuffle_stack()\n"}
{"task_id": "abc365_a", "code": "def count_days():\n    import sys\n    Y = int(sys.stdin.readline().strip())\n    if Y % 400 == 0:\n        print(366)\n    elif Y % 100 == 0:\n        print(365)\n    elif Y % 4 == 0:\n        print(366)\n    else:\n        print(365)\n\ncount_days()\n", "passed": true, "raw_code": "def count_days():\n    import sys\n    Y = int(sys.stdin.readline().strip())\n    if Y % 400 == 0:\n        print(366)\n    elif Y % 100 == 0:\n        print(365)\n    elif Y % 4 == 0:\n        print(366)\n    else:\n        print(365)\n\ncount_days()\n"}
{"task_id": "abc367_b", "code": "def format_number():\n    import sys\n    try:\n        X = float(sys.stdin.readline().strip())\n        if X == int(X):\n            print(int(X))\n        else:\n            # Remove trailing zeros and unnecessary decimal point\n            formatted_X = \"{:.3f}\".format(X).rstrip(\"0\").rstrip(\".\")\n            print(formatted_X)\n    except ValueError:\n        print(\"Invalid input. Please enter a valid real number.\")\n\n# Call the function\nformat_number()\n", "passed": true, "raw_code": "def format_number():\n    import sys\n    try:\n        X = float(sys.stdin.readline().strip())\n        if X == int(X):\n            print(int(X))\n        else:\n            # Remove trailing zeros and unnecessary decimal point\n            formatted_X = \"{:.3f}\".format(X).rstrip(\"0\").rstrip(\".\")\n            print(formatted_X)\n    except ValueError:\n        print(\"Invalid input. Please enter a valid real number.\")\n\n# Call the function\nformat_number()\n"}
{"task_id": "abc370_b", "code": "def process_elements():\n    import sys\n    input = sys.stdin.read().splitlines()\n    N = int(input[0])\n    A = []\n    for i in range(1, N+1):\n        A.append(list(map(int, input[i].split())))\n    \n    current_element = 1\n    for i in range(1, N+1):\n        for j in range(i):\n            if i >= j:\n                next_element = A[i-1][j]\n            else:\n                next_element = A[j][i-1]\n            current_element = next_element\n    \n    print(current_element)\n\nprocess_elements()\n", "passed": false, "raw_code": "def process_elements():\n    import sys\n    input = sys.stdin.read().splitlines()\n    N = int(input[0])\n    A = []\n    for i in range(1, N+1):\n        A.append(list(map(int, input[i].split())))\n    \n    current_element = 1\n    for i in range(1, N+1):\n        for j in range(i):\n            if i >= j:\n                next_element = A[i-1][j]\n            else:\n                next_element = A[j][i-1]\n            current_element = next_element\n    \n    print(current_element)\n\nprocess_elements()\n"}
{"task_id": "abc366_b", "code": "def convert_to_vertical():\n    import sys\n    input = sys.stdin.read().splitlines()\n    N = int(input[0])\n    strings = input[1:]\n    \n    # Find the maximum length of the strings\n    max_length = max(len(s) for s in strings)\n    \n    # Initialize the result list with empty strings\n    result = [''] * max_length\n    \n    # Iterate over each position up to max_length\n    for j in range(max_length):\n        # For each position, find the character that can be placed\n        char = '*'\n        for i in range(N):\n            if j < len(strings[i]):\n                char = strings[i][j]\n                break\n        # Ensure that the character is not '*'\n        if char == '*':\n            char = ''\n        # Append the character to the corresponding position in the result\n        result[j] += char\n    \n    # Print the result\n    for line in result:\n        print(line)\n\n# Call the function\nconvert_to_vertical()\n", "passed": false, "raw_code": "def convert_to_vertical():\n    import sys\n    input = sys.stdin.read().splitlines()\n    N = int(input[0])\n    strings = input[1:]\n    \n    # Find the maximum length of the strings\n    max_length = max(len(s) for s in strings)\n    \n    # Initialize the result list with empty strings\n    result = [''] * max_length\n    \n    # Iterate over each position up to max_length\n    for j in range(max_length):\n        # For each position, find the character that can be placed\n        char = '*'\n        for i in range(N):\n            if j < len(strings[i]):\n                char = strings[i][j]\n                break\n        # Ensure that the character is not '*'\n        if char == '*':\n            char = ''\n        # Append the character to the corresponding position in the result\n        result[j] += char\n    \n    # Print the result\n    for line in result:\n        print(line)\n\n# Call the function\nconvert_to_vertical()\n"}
{"task_id": "abc371_b", "code": "def determine_taro_names():\n    import sys\n\n    # Read the number of families and babies\n    N, M = map(int, sys.stdin.readline().split())\n\n    # Initialize a list to keep track of the earliest born boys per family\n    earliest_boys = [None] * (N + 1)\n\n    for _ in range(M):\n        A, B = sys.stdin.readline().split()\n        A = int(A)\n        B = B.strip()\n\n        # If the baby is a boy\n        if B == 'M':\n            if earliest_boys[A] is None or earliest_boys[A] > _:\n                earliest_boys[A] = _\n                # Print Yes if this is the first boy in the family\n                print(\"Yes\")\n            else:\n                # Print No if this is not the first boy in the family\n                print(\"No\")\n        else:\n            # If the baby is a girl, simply print No\n            print(\"No\")\n\n# Call the function\ndetermine_taro_names()\n", "passed": true, "raw_code": "def determine_taro_names():\n    import sys\n\n    # Read the number of families and babies\n    N, M = map(int, sys.stdin.readline().split())\n\n    # Initialize a list to keep track of the earliest born boys per family\n    earliest_boys = [None] * (N + 1)\n\n    for _ in range(M):\n        A, B = sys.stdin.readline().split()\n        A = int(A)\n        B = B.strip()\n\n        # If the baby is a boy\n        if B == 'M':\n            if earliest_boys[A] is None or earliest_boys[A] > _:\n                earliest_boys[A] = _\n                # Print Yes if this is the first boy in the family\n                print(\"Yes\")\n            else:\n                # Print No if this is not the first boy in the family\n                print(\"No\")\n        else:\n            # If the baby is a girl, simply print No\n            print(\"No\")\n\n# Call the function\ndetermine_taro_names()\n"}
{"task_id": "abc368_b", "code": "def count_operations():\n    import sys\n    input = sys.stdin.read().split()\n    N = int(input[0])\n    A = list(map(int, input[1:N+1]))\n    \n    operations = 0\n    while len(A) > 1 and max(A) > 0:\n        # Sort A in descending order\n        A_sorted = sorted(A, reverse=True)\n        # Decrease A_1 and A_2 by 1\n        if len(A_sorted) >= 2:\n            A_sorted[0] -= 1\n            A_sorted[1] -= 1\n        # Update A\n        A = A_sorted\n        operations += 1\n    \n    print(operations)\n\n# Call the function\ncount_operations()\n", "passed": false, "raw_code": "def count_operations():\n    import sys\n    input = sys.stdin.read().split()\n    N = int(input[0])\n    A = list(map(int, input[1:N+1]))\n    \n    operations = 0\n    while len(A) > 1 and max(A) > 0:\n        # Sort A in descending order\n        A_sorted = sorted(A, reverse=True)\n        # Decrease A_1 and A_2 by 1\n        if len(A_sorted) >= 2:\n            A_sorted[0] -= 1\n            A_sorted[1] -= 1\n        # Update A\n        A = A_sorted\n        operations += 1\n    \n    print(operations)\n\n# Call the function\ncount_operations()\n"}
{"task_id": "abc369_b", "code": "def calculate_min_fatigue():\n    import sys\n\n    # Read input\n    N = int(sys.stdin.readline().strip())\n    actions = []\n    for _ in range(N):\n        line = sys.stdin.readline().strip().split()\n        key = int(line[0])\n        hand = line[1]\n        actions.append((key, hand))\n\n    # Initialize positions and fatigue\n    left_hand = 0\n    right_hand = 0\n    fatigue = 0\n\n    # Dictionary to map hand to position\n    hands = {'L': left_hand, 'R': right_hand}\n\n    # Iterate through each action\n    for key, hand in actions:\n        current_hand = hands[hand]\n        # Move the hand to the desired key\n        distance = abs(key - current_hand)\n        fatigue += distance\n        hands[hand] = key\n\n    print(fatigue)\n\n# Call the function\ncalculate_min_fatigue()\n", "passed": false, "raw_code": "def calculate_min_fatigue():\n    import sys\n\n    # Read input\n    N = int(sys.stdin.readline().strip())\n    actions = []\n    for _ in range(N):\n        line = sys.stdin.readline().strip().split()\n        key = int(line[0])\n        hand = line[1]\n        actions.append((key, hand))\n\n    # Initialize positions and fatigue\n    left_hand = 0\n    right_hand = 0\n    fatigue = 0\n\n    # Dictionary to map hand to position\n    hands = {'L': left_hand, 'R': right_hand}\n\n    # Iterate through each action\n    for key, hand in actions:\n        current_hand = hands[hand]\n        # Move the hand to the desired key\n        distance = abs(key - current_hand)\n        fatigue += distance\n        hands[hand] = key\n\n    print(fatigue)\n\n# Call the function\ncalculate_min_fatigue()\n"}
{"task_id": "abc369_a", "code": "def count_valid_x():\n    import sys\n    input = sys.stdin.read().split()\n    A, B = map(int, input)\n    \n    # Calculate the differences\n    diff1 = B - A\n    diff2 = A - B\n    \n    # Possible values of x\n    x1 = A + diff1\n    x2 = A + diff2\n    x3 = B + diff1\n    x4 = B + diff2\n    \n    # Collect unique valid x values within the range [1, 100]\n    valid_x = set()\n    for x in [x1, x2, x3, x4]:\n        if 1 <= x <= 100:\n            valid_x.add(x)\n    \n    # Print the number of valid x\n    print(len(valid_x))\n\n# Call the function\ncount_valid_x()\n", "passed": false, "raw_code": "def count_valid_x():\n    import sys\n    input = sys.stdin.read().split()\n    A, B = map(int, input)\n    \n    # Calculate the differences\n    diff1 = B - A\n    diff2 = A - B\n    \n    # Possible values of x\n    x1 = A + diff1\n    x2 = A + diff2\n    x3 = B + diff1\n    x4 = B + diff2\n    \n    # Collect unique valid x values within the range [1, 100]\n    valid_x = set()\n    for x in [x1, x2, x3, x4]:\n        if 1 <= x <= 100:\n            valid_x.add(x)\n    \n    # Print the number of valid x\n    print(len(valid_x))\n\n# Call the function\ncount_valid_x()\n"}
{"task_id": "abc373_b", "code": "def calculate_minimal_distance(S):\n    # Define the positions of each letter on the number line\n    positions = {char: idx for idx, char in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n    \n    # Initialize the starting position at 'A'\n    current_position = positions['A']\n    total_distance = 0\n    \n    # Iterate through each character in the string S\n    for char in S:\n        target_position = positions[char]\n        # Calculate the distance between current position and target position\n        distance = abs(target_position - current_position)\n        total_distance += distance\n        # Move the finger to the target position\n        current_position = target_position\n    \n    return total_distance\n\n# Example usage:\nif __name__ == \"__main__\":\n    import sys\n    S = sys.stdin.readline().strip()\n    result = calculate_minimal_distance(S)\n    print(result)\n", "passed": false, "raw_code": "def calculate_minimal_distance(S):\n    # Define the positions of each letter on the number line\n    positions = {char: idx for idx, char in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n    \n    # Initialize the starting position at 'A'\n    current_position = positions['A']\n    total_distance = 0\n    \n    # Iterate through each character in the string S\n    for char in S:\n        target_position = positions[char]\n        # Calculate the distance between current position and target position\n        distance = abs(target_position - current_position)\n        total_distance += distance\n        # Move the finger to the target position\n        current_position = target_position\n    \n    return total_distance\n\n# Example usage:\nif __name__ == \"__main__\":\n    import sys\n    S = sys.stdin.readline().strip()\n    result = calculate_minimal_distance(S)\n    print(result)\n"}
{"task_id": "abc371_a", "code": "def determine_middle_brother():\n    import sys\n\n    # Read input from standard input\n    input_line = sys.stdin.readline().strip()\n    \n    # Split the input into individual characters\n    S_AB, S_AC, S_BC = input_line.split()\n    \n    # Determine the relationships\n    if S_AB == '<':\n        AB = 'A < B'\n    else:\n        AB = 'A > B'\n    \n    if S_AC == '<':\n        AC = 'A < C'\n    else:\n        AC = 'A > C'\n    \n    if S_BC == '<':\n        BC = 'B < C'\n    else:\n        BC = 'B > C'\n    \n    # Analyze the relationships to find the middle brother\n    if AB == 'A < B' and AC == 'A < C' and BC == 'B < C':\n        middle = 'B'\n    elif AB == 'A > B' and AC == 'A < C' and BC == 'B > C':\n        middle = 'C'\n    elif AB == 'A < B' and AC == 'A > C' and BC == 'B < C':\n        middle = 'A'\n    elif AB == 'A > B' and AC == 'A > C' and BC == 'B > C':\n        middle = 'B'\n    elif AB == 'A < B' and AC == 'A < C' and BC == 'B > C':\n        middle = 'C'\n    elif AB == 'A > B' and AC == 'A > C' and BC == 'B < C':\n        middle = 'A'\n    elif AB == 'A < B' and AC == 'A > C' and BC == 'B > C':\n        middle = 'B'\n    elif AB == 'A > B' and AC == 'A < C' and BC == 'B < C':\n        middle = 'C'\n    \n    print(middle)\n\n# Call the function\ndetermine_middle_brother()\n", "passed": false, "raw_code": "def determine_middle_brother():\n    import sys\n\n    # Read input from standard input\n    input_line = sys.stdin.readline().strip()\n    \n    # Split the input into individual characters\n    S_AB, S_AC, S_BC = input_line.split()\n    \n    # Determine the relationships\n    if S_AB == '<':\n        AB = 'A < B'\n    else:\n        AB = 'A > B'\n    \n    if S_AC == '<':\n        AC = 'A < C'\n    else:\n        AC = 'A > C'\n    \n    if S_BC == '<':\n        BC = 'B < C'\n    else:\n        BC = 'B > C'\n    \n    # Analyze the relationships to find the middle brother\n    if AB == 'A < B' and AC == 'A < C' and BC == 'B < C':\n        middle = 'B'\n    elif AB == 'A > B' and AC == 'A < C' and BC == 'B > C':\n        middle = 'C'\n    elif AB == 'A < B' and AC == 'A > C' and BC == 'B < C':\n        middle = 'A'\n    elif AB == 'A > B' and AC == 'A > C' and BC == 'B > C':\n        middle = 'B'\n    elif AB == 'A < B' and AC == 'A < C' and BC == 'B > C':\n        middle = 'C'\n    elif AB == 'A > B' and AC == 'A > C' and BC == 'B < C':\n        middle = 'A'\n    elif AB == 'A < B' and AC == 'A > C' and BC == 'B > C':\n        middle = 'B'\n    elif AB == 'A > B' and AC == 'A < C' and BC == 'B < C':\n        middle = 'C'\n    \n    print(middle)\n\n# Call the function\ndetermine_middle_brother()\n"}
{"final_accuracy": "53.85%"}
