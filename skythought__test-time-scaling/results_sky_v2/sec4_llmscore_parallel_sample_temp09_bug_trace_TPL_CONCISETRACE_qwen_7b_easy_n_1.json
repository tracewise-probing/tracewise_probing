{"difficulty": "easy", "num_threads": 32, "temperature": 0.9, "n": 1, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp09_bug_trace_TPL_CONCISETRACE_qwen_7b_easy_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc367_b", "code": "d", "passed": false, "raw_code": "```python\ndef format_number():\n    import sys\n    X = float(sys.stdin.read().strip())\n    X_str = '{:.3f}'.format(X)\n    if X_str.endswith('.000'):\n        print(X_str[:-4])\n    elif X_str.endswith('.00'):\n        print(X_str[:-3])\n    elif X_str.endswith('.0'):\n        print(X_str[:-2])\n    else:\n        print(X_str)\n\nformat_number()"}
{"task_id": "abc366_a", "code": "d", "passed": false, "raw_code": "```python\ndef is_election_decided():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    T = int(data[1])\n    A = int(data[2])\n    \n    if T - A > N // 2 or A - T > N // 2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nis_election_decided()"}
{"task_id": "abc367_a", "code": "def can_shout_takoyaki():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    A = int(data[0])\n    B = int(data[1])\n    C = int(data[2])\n    \n    # Check if there is an overlap between [B, C) and A\n    if B <= A < C or (A == 0 and (B >= C or C == 24)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\ncan_shout_takoyaki()", "passed": false, "raw_code": "```python\ndef can_shout_takoyaki():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    A = int(data[0])\n    B = int(data[1])\n    C = int(data[2])\n    \n    # Check if there is an overlap between [B, C) and A\n    if B <= A < C or (A == 0 and (B >= C or C == 24)):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\ncan_shout_takoyaki()\n```"}
{"task_id": "abc365_b", "code": "d", "passed": false, "raw_code": "```python\ndef find_second_largest_index():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    first, second = float('-inf'), float('-inf')\n    for num in A:\n        if num > first:\n            second = first\n            first = num\n        elif first > num > second:\n            second = num\n    \n    # Find the index of the second largest element\n    for i, num in enumerate(A):\n        if num == second:\n            print(i + 1)\n            return\n\nfind_second_largest_index()"}
{"task_id": "3519", "code": "def countWinningPlayers(n, pick):\n    player_counts = {i: {} for i in range(n)}\n    \n    for player, color in pick:\n        if color not in player_counts[player]:\n            player_counts[player][color] = 0\n        player_counts[player][color] += 1\n    \n    winning_players = 0\n    \n    for player, colors in player_counts.items():\n        for color_count in colors.values():\n            if color_count > player:\n                winning_players += 1\n                break\n    \n    return winning_players", "passed": true, "raw_code": "```python\ndef countWinningPlayers(n, pick):\n    player_counts = {i: {} for i in range(n)}\n    \n    for player, color in pick:\n        if color not in player_counts[player]:\n            player_counts[player][color] = 0\n        player_counts[player][color] += 1\n    \n    winning_players = 0\n    \n    for player, colors in player_counts.items():\n        for color_count in colors.values():\n            if color_count > player:\n                winning_players += 1\n                break\n    \n    return winning_players\n```"}
{"task_id": "abc365_a", "code": "def number_of_days_in_year(Y):\n    if Y % 4 == 0:\n        if Y % 100 == 0:\n            if Y % 400 == 0:\n                print(366)\n            else:\n                print(365)\n        else:\n            print(366)\n    else:\n        print(365)\n\n# Read input from standard input\nimport sys\nY = int(sys.stdin.read().strip())\n\n# Call the function with the input value\nnumber_of_days_in_year(Y)", "passed": true, "raw_code": "```python\ndef number_of_days_in_year(Y):\n    if Y % 4 == 0:\n        if Y % 100 == 0:\n            if Y % 400 == 0:\n                print(366)\n            else:\n                print(365)\n        else:\n            print(366)\n    else:\n        print(365)\n\n# Read input from standard input\nimport sys\nY = int(sys.stdin.read().strip())\n\n# Call the function with the input value\nnumber_of_days_in_year(Y)\n```"}
{"task_id": "3568", "code": "def getKey(num1, num2, num3):\n    # Convert numbers to strings and pad with leading zeros\n    num1_str = str(num1).zfill(4)\n    num2_str = str(num2).zfill(4)\n    num3_str = str(num3).zfill(4)\n    \n    # Initialize the key as an empty string\n    key = \"\"\n    \n    # Iterate through each digit position from 0 to 3\n    for i in range(4):\n        # Find the minimum digit at the current position\n        min_digit = min(num1_str[i], num2_str[i], num3_str[i])\n        # Append the minimum digit to the key\n        key += min_digit\n    \n    # Convert the key string to an integer and return it\n    return int(key)", "passed": true, "raw_code": "```python\ndef getKey(num1, num2, num3):\n    # Convert numbers to strings and pad with leading zeros\n    num1_str = str(num1).zfill(4)\n    num2_str = str(num2).zfill(4)\n    num3_str = str(num3).zfill(4)\n    \n    # Initialize the key as an empty string\n    key = \"\"\n    \n    # Iterate through each digit position from 0 to 3\n    for i in range(4):\n        # Find the minimum digit at the current position\n        min_digit = min(num1_str[i], num2_str[i], num3_str[i])\n        # Append the minimum digit to the key\n        key += min_digit\n    \n    # Convert the key string to an integer and return it\n    return int(key)\n```"}
{"task_id": "abc370_a", "code": "def determine_takoyaki(L, R):\n    if L == 1 and R == 0:\n        return \"Yes\"\n    elif R == 1 and L == 0:\n        return \"No\"\n    else:\n        return \"Invalid\"\n\n# Read input from stdin\nimport sys\ninput_line = sys.stdin.readline().strip()\nL, R = map(int, input_line.split())\n\n# Determine and print the result\nprint(determine_takoyaki(L, R))", "passed": true, "raw_code": "```python\ndef determine_takoyaki(L, R):\n    if L == 1 and R == 0:\n        return \"Yes\"\n    elif R == 1 and L == 0:\n        return \"No\"\n    else:\n        return \"Invalid\"\n\n# Read input from stdin\nimport sys\ninput_line = sys.stdin.readline().strip()\nL, R = map(int, input_line.split())\n\n# Determine and print the result\nprint(determine_takoyaki(L, R))\n```"}
{"task_id": "3606", "code": "def min_sum_of_digits(nums):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n    \n    transformed_nums = [sum_of_digits(num) for num in nums]\n    return min(transformed_nums)", "passed": true, "raw_code": "```python\ndef min_sum_of_digits(nums):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n    \n    transformed_nums = [sum_of_digits(num) for num in nums]\n    return min(transformed_nums)\n```"}
{"task_id": "abc373_a", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    count = 0\n    for i in range(12):\n        if len(data[i]) == i + 1:\n            count += 1\n    \n    print(count)\n\nmain()", "passed": true, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    count = 0\n    for i in range(12):\n        if len(data[i]) == i + 1:\n            count += 1\n    \n    print(count)\n\nmain()\n```"}
{"task_id": "abc368_b", "code": "d", "passed": false, "raw_code": "```python\ndef perform_operations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    operations_count = 0\n    \n    while sum(1 for x in A if x > 0) > 1:\n        A.sort(reverse=True)\n        A[0] -= 1\n        A[1] -= 1\n        operations_count += 1\n    \n    print(operations_count)\n\nperform_operations()"}
{"task_id": "abc372_a", "code": "def remove_dots():\n    # Read the input string\n    S = input()\n    # Remove all '.' characters from the string\n    result = S.replace('.', '')\n    # Print the resulting string\n    print(result)\n\n# Call the function\nremove_dots()", "passed": true, "raw_code": "```python\ndef remove_dots():\n    # Read the input string\n    S = input()\n    # Remove all '.' characters from the string\n    result = S.replace('.', '')\n    # Print the resulting string\n    print(result)\n\n# Call the function\nremove_dots()\n```"}
{"task_id": "3600", "code": "def getKthCharacter(k):\n    def full_cycles_needed(length, k):\n        return (k - 1) // length\n    \n    length = 1\n    left, right = 0, k\n    while left < right:\n        mid = (left + right) // 2\n        if full_cycles_needed(length, mid + 1) >= k:\n            right = mid\n        else:\n            left = mid + 1\n            length += length\n    \n    remaining_chars = k - full_cycles_needed(length, k) * length\n    return chr((ord('a') + remaining_chars - 1) % 26 + ord('a'))", "passed": false, "raw_code": "```python\ndef getKthCharacter(k):\n    def full_cycles_needed(length, k):\n        return (k - 1) // length\n    \n    length = 1\n    left, right = 0, k\n    while left < right:\n        mid = (left + right) // 2\n        if full_cycles_needed(length, mid + 1) >= k:\n            right = mid\n        else:\n            left = mid + 1\n            length += length\n    \n    remaining_chars = k - full_cycles_needed(length, k) * length\n    return chr((ord('a') + remaining_chars - 1) % 26 + ord('a'))\n```"}
{"task_id": "3533", "code": "def final_position(n, commands):\n    # Initial position of the snake\n    i, j = 0, 0\n    \n    # Directions mapping\n    directions = {\n        \"UP\": (-1, 0),\n        \"RIGHT\": (0, 1),\n        \"DOWN\": (1, 0),\n        \"LEFT\": (0, -1)\n    }\n    \n    # Iterate through each command\n    for command in commands:\n        di, dj = directions[command]\n        ni, nj = i + di, j + dj\n        \n        # Check if the new position is within the grid boundaries\n        if 0 <= ni < n and 0 <= nj < n:\n            i, j = ni, nj\n    \n    # Return the final position as a single integer\n    return i * n + j", "passed": true, "raw_code": "```python\ndef final_position(n, commands):\n    # Initial position of the snake\n    i, j = 0, 0\n    \n    # Directions mapping\n    directions = {\n        \"UP\": (-1, 0),\n        \"RIGHT\": (0, 1),\n        \"DOWN\": (1, 0),\n        \"LEFT\": (0, -1)\n    }\n    \n    # Iterate through each command\n    for command in commands:\n        di, dj = directions[command]\n        ni, nj = i + di, j + dj\n        \n        # Check if the new position is within the grid boundaries\n        if 0 <= ni < n and 0 <= nj < n:\n            i, j = ni, nj\n    \n    # Return the final position as a single integer\n    return i * n + j\n```"}
{"task_id": "3553", "code": "def are_squares_same_color(coordinate1: str, coordinate2: str) -> bool:\n    col1, row1 = coordinate1[0], int(coordinate1[1])\n    col2, row2 = coordinate2[0], int(coordinate2[1])\n    \n    sum1 = ord(col1) + row1\n    sum2 = ord(col2) + row2\n    \n    return sum1 % 2 == sum2 % 2", "passed": true, "raw_code": "```python\ndef are_squares_same_color(coordinate1: str, coordinate2: str) -> bool:\n    col1, row1 = coordinate1[0], int(coordinate1[1])\n    col2, row2 = coordinate2[0], int(coordinate2[1])\n    \n    sum1 = ord(col1) + row1\n    sum2 = ord(col2) + row2\n    \n    return sum1 % 2 == sum2 % 2\n```"}
{"task_id": "abc370_b", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    A = []\n    for i in range(N):\n        row = list(map(int, data[index:index + N]))\n        A.append(row)\n        index += N\n    \n    current_element = 1\n    \n    for i in range(1, N + 1):\n        if i >= current_element:\n            current_element = A[i - 1][current_element - 1]\n        else:\n            current_element = A[current_element - 1][i - 1]\n    \n    print(current_element)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    A = []\n    for i in range(N):\n        row = list(map(int, data[index:index + N]))\n        A.append(row)\n        index += N\n    \n    current_element = 1\n    \n    for i in range(1, N + 1):\n        if i >= current_element:\n            current_element = A[i - 1][current_element - 1]\n        else:\n            current_element = A[current_element - 1][i - 1]\n    \n    print(current_element)\n\nmain()\n```"}
{"task_id": "3567", "code": "def convert_date_to_binary(date):\n    # Split the date string into year, month, and day\n    year, month, day = map(int, date.split('-'))\n    \n    # Convert each part to binary and remove the '0b' prefix\n    binary_year = bin(year)[2:]\n    binary_month = bin(month)[2:].zfill(4)  # Ensure month has at least 4 bits\n    binary_day = bin(day)[2:].zfill(5)    # Ensure day has at least 5 bits\n    \n    # Concatenate the binary parts with hyphens\n    binary_date = f\"{binary_year}-{binary_month}-{binary_day}\"\n    \n    return binary_date", "passed": false, "raw_code": "```python\ndef convert_date_to_binary(date):\n    # Split the date string into year, month, and day\n    year, month, day = map(int, date.split('-'))\n    \n    # Convert each part to binary and remove the '0b' prefix\n    binary_year = bin(year)[2:]\n    binary_month = bin(month)[2:].zfill(4)  # Ensure month has at least 4 bits\n    binary_day = bin(day)[2:].zfill(5)    # Ensure day has at least 5 bits\n    \n    # Concatenate the binary parts with hyphens\n    binary_date = f\"{binary_year}-{binary_month}-{binary_day}\"\n    \n    return binary_date\n```"}
{"task_id": "abc369_b", "code": "d", "passed": false, "raw_code": "```python\ndef min_fatigue_level():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    \n    left_hand = 0\n    right_hand = 0\n    total_fatigue = 0\n    \n    for i in range(N):\n        A_i = int(data[2 * i + 1])\n        S_i = data[2 * i + 2]\n        \n        if S_i == 'L':\n            left_hand_fatigue = abs(A_i - left_hand)\n            right_hand_fatigue = abs(A_i - right_hand) + abs(right_hand - left_hand)\n        else:\n            left_hand_fatigue = abs(A_i - left_hand) + abs(left_hand - right_hand)\n            right_hand_fatigue = abs(A_i - right_hand)\n        \n        if left_hand_fatigue <= right_hand_fatigue:\n            left_hand = A_i\n            total_fatigue += left_hand_fatigue\n        else:\n            right_hand = A_i\n            total_fatigue += right_hand_fatigue\n    \n    print(total_fatigue)\n\nmin_fatigue_level()"}
{"task_id": "3555", "code": "import heapq\n\ndef modifyArray(nums, k, multiplier):\n    heapq.heapify(nums)\n    for _ in range(k):\n        min_val = heapq.heappop(nums)\n        heapq.heappush(nums, min_val * multiplier)\n    return nums", "passed": false, "raw_code": "```python\nimport heapq\n\ndef modifyArray(nums, k, multiplier):\n    heapq.heapify(nums)\n    for _ in range(k):\n        min_val = heapq.heappop(nums)\n        heapq.heappush(nums, min_val * multiplier)\n    return nums\n```"}
{"task_id": "abc369_a", "code": "def count_valid_x(A, B):\n    valid_x = set()\n    \n    # Permutation 1: A, B, x\n    if (B - A) % 2 == 0:\n        x = A + (B - A) // 2\n        valid_x.add(x)\n    \n    # Permutation 2: A, x, B\n    if (B - A) % 2 == 0:\n        x = B - (B - A) // 2\n        valid_x.add(x)\n    \n    # Permutation 3: B, A, x\n    if (A - B) % 2 == 0:\n        x = B + (A - B) // 2\n        valid_x.add(x)\n    \n    # Permutation 4: B, x, A\n    if (A - B) % 2 == 0:\n        x = A - (A - B) // 2\n        valid_x.add(x)\n    \n    # Permutation 5: x, A, B\n    if (B - A) % 2 == 0:\n        x = A + (B - A) // 2\n        valid_x.add(x)\n    \n    # Permutation 6: x, B, A\n    if (A - B) % 2 == 0:\n        x = B - (A - B) // 2\n        valid_x.add(x)\n    \n    return len(valid_x)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nA = int(data[0])\nB = int(data[1])\n\n# Count valid x\nresult = count_valid_x(A, B)\n\n# Print result\nprint(result)", "passed": false, "raw_code": "```python\ndef count_valid_x(A, B):\n    valid_x = set()\n    \n    # Permutation 1: A, B, x\n    if (B - A) % 2 == 0:\n        x = A + (B - A) // 2\n        valid_x.add(x)\n    \n    # Permutation 2: A, x, B\n    if (B - A) % 2 == 0:\n        x = B - (B - A) // 2\n        valid_x.add(x)\n    \n    # Permutation 3: B, A, x\n    if (A - B) % 2 == 0:\n        x = B + (A - B) // 2\n        valid_x.add(x)\n    \n    # Permutation 4: B, x, A\n    if (A - B) % 2 == 0:\n        x = A - (A - B) // 2\n        valid_x.add(x)\n    \n    # Permutation 5: x, A, B\n    if (B - A) % 2 == 0:\n        x = A + (B - A) // 2\n        valid_x.add(x)\n    \n    # Permutation 6: x, B, A\n    if (A - B) % 2 == 0:\n        x = B - (A - B) // 2\n        valid_x.add(x)\n    \n    return len(valid_x)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nA = int(data[0])\nB = int(data[1])\n\n# Count valid x\nresult = count_valid_x(A, B)\n\n# Print result\nprint(result)\n```"}
{"task_id": "abc373_b", "code": "import sys\n\ndef min_distance(S):\n    # Create a dictionary to map each character to its 1-based index\n    char_to_index = {char: index for index, char in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ', start=1)}\n    \n    # Initialize the current position of the finger\n    current_pos = 1\n    total_distance = 0\n    \n    # Iterate through each character in the string S\n    for char in S:\n        # Get the index of the current character\n        new_pos = char_to_index[char]\n        \n        # Calculate the distance from the current position to the new position\n        distance = abs(new_pos - current_pos)\n        \n        # Update the total distance and the current position\n        total_distance += distance\n        current_pos = new_pos\n    \n    # Print the total distance\n    print(total_distance)\n\n# Read input from standard input\nS = sys.stdin.read().strip()\n\n# Call the function with the input string\nmin_distance(S)", "passed": false, "raw_code": "```python\nimport sys\n\ndef min_distance(S):\n    # Create a dictionary to map each character to its 1-based index\n    char_to_index = {char: index for index, char in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ', start=1)}\n    \n    # Initialize the current position of the finger\n    current_pos = 1\n    total_distance = 0\n    \n    # Iterate through each character in the string S\n    for char in S:\n        # Get the index of the current character\n        new_pos = char_to_index[char]\n        \n        # Calculate the distance from the current position to the new position\n        distance = abs(new_pos - current_pos)\n        \n        # Update the total distance and the current position\n        total_distance += distance\n        current_pos = new_pos\n    \n    # Print the total distance\n    print(total_distance)\n\n# Read input from standard input\nS = sys.stdin.read().strip()\n\n# Call the function with the input string\nmin_distance(S)\n```"}
{"task_id": "abc371_b", "code": "d", "passed": false, "raw_code": "```python\ndef determine_names(N, M, babies):\n    # Initialize a list to keep track of the earliest-born male child in each family\n    earliest_male = [-1] * N\n    \n    # Process each baby\n    results = []\n    for family, gender in babies:\n        family -= 1  # Convert to zero-indexed\n        if gender == 'M':\n            if earliest_male[family] == -1:\n                results.append(\"Yes\")\n                earliest_male[family] = family\n            else:\n                results.append(\"No\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nbabies = []\nindex = 2\nfor _ in range(M):\n    family = int(data[index]) - 1\n    gender = data[index + 1]\n    babies.append((family, gender))\n    index += 2\n\n# Determine names and print results\nresults = determine_names(N, M, babies)\nfor result in results:\n    print(result)"}
{"task_id": "abc371_a", "code": "def find_middle_brother():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    S_AB, S_AC, S_BC = data\n    \n    # Mapping of symbols to age comparisons\n    comparisons = {'<': 'younger', '>': 'older'}\n    \n    # Determine the relative ages\n    if comparisons[S_AB] == 'younger':\n        if comparisons[S_AC] == 'younger':\n            if comparisons[S_BC] == 'younger':\n                # A < B < C\n                middle_brother = 'B'\n            elif comparisons[S_BC] == 'older':\n                # A < B > C\n                middle_brother = 'A'\n        elif comparisons[S_AC] == 'older':\n            if comparisons[S_BC] == 'younger':\n                # A > B < C\n                middle_brother = 'C'\n            elif comparisons[S_BC] == 'older':\n                # A > B > C\n                middle_brother = 'B'\n    elif comparisons[S_AB] == 'older':\n        if comparisons[S_AC] == 'younger':\n            if comparisons[S_BC] == 'younger':\n                # A > B < C\n                middle_brother = 'C'\n            elif comparisons[S_BC] == 'older':\n                # A > B > C\n                middle_brother = 'B'\n        elif comparisons[S_AC] == 'older':\n            if comparisons[S_BC] == 'younger':\n                # A < B > C\n                middle_brother = 'A'\n            elif comparisons[S_BC] == 'older':\n                # A < B < C\n                middle_brother = 'B'\n    \n    print(middle_brother)\n\nfind_middle_brother()", "passed": false, "raw_code": "```python\ndef find_middle_brother():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    S_AB, S_AC, S_BC = data\n    \n    # Mapping of symbols to age comparisons\n    comparisons = {'<': 'younger', '>': 'older'}\n    \n    # Determine the relative ages\n    if comparisons[S_AB] == 'younger':\n        if comparisons[S_AC] == 'younger':\n            if comparisons[S_BC] == 'younger':\n                # A < B < C\n                middle_brother = 'B'\n            elif comparisons[S_BC] == 'older':\n                # A < B > C\n                middle_brother = 'A'\n        elif comparisons[S_AC] == 'older':\n            if comparisons[S_BC] == 'younger':\n                # A > B < C\n                middle_brother = 'C'\n            elif comparisons[S_BC] == 'older':\n                # A > B > C\n                middle_brother = 'B'\n    elif comparisons[S_AB] == 'older':\n        if comparisons[S_AC] == 'younger':\n            if comparisons[S_BC] == 'younger':\n                # A > B < C\n                middle_brother = 'C'\n            elif comparisons[S_BC] == 'older':\n                # A > B > C\n                middle_brother = 'B'\n        elif comparisons[S_AC] == 'older':\n            if comparisons[S_BC] == 'younger':\n                # A < B > C\n                middle_brother = 'A'\n            elif comparisons[S_BC] == 'older':\n                # A < B < C\n                middle_brother = 'B'\n    \n    print(middle_brother)\n\nfind_middle_brother()\n```"}
{"task_id": "abc366_b", "code": "def convert_to_vertical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    strings = data[1:]\n    max_length = max(len(s) for s in strings)\n    \n    for i in range(max_length):\n        vertical_line = []\n        for j in range(N):\n            if i < len(strings[j]):\n                vertical_line.append(strings[j][i])\n            else:\n                vertical_line.append('*')\n        \n        # Remove trailing '*' from the vertical line\n        while vertical_line[-1] == '*':\n            vertical_line.pop()\n        \n        print(''.join(vertical_line))\n\nconvert_to_vertical()", "passed": false, "raw_code": "```python\ndef convert_to_vertical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    strings = data[1:]\n    max_length = max(len(s) for s in strings)\n    \n    for i in range(max_length):\n        vertical_line = []\n        for j in range(N):\n            if i < len(strings[j]):\n                vertical_line.append(strings[j][i])\n            else:\n                vertical_line.append('*')\n        \n        # Remove trailing '*' from the vertical line\n        while vertical_line[-1] == '*':\n            vertical_line.pop()\n        \n        print(''.join(vertical_line))\n\nconvert_to_vertical()\n```"}
{"task_id": "abc368_a", "code": "def rotate_stack(N, K, A):\n    return ' '.join(map(str, A[-K:] + A[:-K]))\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    result = rotate_stack(N, K, A)\n    print(result)", "passed": false, "raw_code": "def rotate_stack(N, K, A):\n    return ' '.join(map(str, A[-K:] + A[:-K]))\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    result = rotate_stack(N, K, A)\n    print(result)"}
{"task_id": "3543", "code": "def count_valid_substrings(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    \n    for i in range(n):\n        zero_count = 0\n        one_count = 0\n        for j in range(i, n):\n            if s[j] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n            if zero_count <= k or one_count <= k:\n                count += 1\n                \n    return count", "passed": true, "raw_code": "```python\ndef count_valid_substrings(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    \n    for i in range(n):\n        zero_count = 0\n        one_count = 0\n        for j in range(i, n):\n            if s[j] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n            if zero_count <= k or one_count <= k:\n                count += 1\n                \n    return count\n```"}
{"final_accuracy": "38.46%"}
