"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.2, \"n\": 1, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_temp02_bug_trace_TPL_CONCISETRACE_qwen_7b_hard_n_1.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42, \"resume\": true}"
{"task_id": "abc368_f", "codes": ["def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of elements greater than 1\n    count_greater_than_one = sum(1 for x in A if x > 1)\n    \n    # Determine the winner based on the parity of the count\n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function to execute\ndetermine_winner()"], "passed": [false], "raw_code": ["```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of elements greater than 1\n    count_greater_than_one = sum(1 for x in A if x > 1)\n    \n    # Determine the winner based on the parity of the count\n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function to execute\ndetermine_winner()\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_inc[i][j] = dp_inc[i-1][j]\n            if j > 0:\n                dp_inc[i][j] += dp_inc[i-1][j-1]\n            dp_inc[i][j] %= MOD\n            \n            dp_dec[i][j] = dp_dec[i-1][j]\n            if j < 50:\n                dp_dec[i][j] += dp_dec[i-1][j+1]\n            dp_dec[i][j] %= MOD\n    \n    # Calculate the total number of valid pairs\n    total_pairs = 0\n    for i in range(n):\n        total_pairs += dp_inc[i][nums[i]] * dp_dec[i][nums[i]]\n        total_pairs %= MOD\n    \n    return total_pairs"], "passed": [false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_inc[i][j] = dp_inc[i-1][j]\n            if j > 0:\n                dp_inc[i][j] += dp_inc[i-1][j-1]\n            dp_inc[i][j] %= MOD\n            \n            dp_dec[i][j] = dp_dec[i-1][j]\n            if j < 50:\n                dp_dec[i][j] += dp_dec[i-1][j+1]\n            dp_dec[i][j] %= MOD\n    \n    # Calculate the total number of valid pairs\n    total_pairs = 0\n    for i in range(n):\n        total_pairs += dp_inc[i][nums[i]] * dp_dec[i][nums[i]]\n        total_pairs %= MOD\n    \n    return total_pairs\n```"]}
{"task_id": "abc366_f", "codes": ["```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    # Compute the nested function composition\n    result = 1\n    for A, B in functions[:K]:\n        result = A * result + B\n    \n    print(result)\n\nmax_nested_function_value()"], "passed": [false], "raw_code": ["```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    # Compute the nested function composition\n    result = 1\n    for A, B in functions[:K]:\n        result = A * result + B\n    \n    print(result)\n\nmax_nested_function_value()"]}
{"task_id": "abc365_e", "codes": ["```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Create prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate through each element and calculate its contribution\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            xor_value = prefix_xor[j] ^ prefix_xor[i - 1]\n            result += xor_value\n    \n    print(result)\n\n# Call the function\nsolve()"], "passed": [false], "raw_code": ["```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Create prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate through each element and calculate its contribution\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            xor_value = prefix_xor[j] ^ prefix_xor[i - 1]\n            result += xor_value\n    \n    print(result)\n\n# Call the function\nsolve()"]}
{"task_id": "abc366_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(coords, D):\n        n = len(coords)\n        left = [0] * (n + 1)\n        right = [0] * (n + 1)\n        \n        for i in range(n):\n            left[i + 1] = left[i]\n            if coords[i] >= D:\n                left[i + 1] += 1\n        \n        for i in range(n - 1, -1, -1):\n            right[i] = right[i + 1]\n            if coords[n - 1] - coords[i] >= D:\n                right[i] += 1\n        \n        count = 0\n        for i in range(n):\n            if coords[i] <= D:\n                count += (i + 1) * left[i + 1] + (n - i) * right[i]\n        \n        return count\n    \n    result = count_points(x_coords, D) * count_points(y_coords, D)\n    print(result)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(coords, D):\n        n = len(coords)\n        left = [0] * (n + 1)\n        right = [0] * (n + 1)\n        \n        for i in range(n):\n            left[i + 1] = left[i]\n            if coords[i] >= D:\n                left[i + 1] += 1\n        \n        for i in range(n - 1, -1, -1):\n            right[i] = right[i + 1]\n            if coords[n - 1] - coords[i] >= D:\n                right[i] += 1\n        \n        count = 0\n        for i in range(n):\n            if coords[i] <= D:\n                count += (i + 1) * left[i + 1] + (n - i) * right[i]\n        \n        return count\n    \n    result = count_points(x_coords, D) * count_points(y_coords, D)\n    print(result)\n\nmain()\n```"]}
{"task_id": "abc368_e", "codes": ["```python\ndef find_delays(N, M, X1, trains):\n    # Initialize delays with X1\n    X = [X1] * M\n    \n    # Process each train to adjust delays\n    for i in range(M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(M):\n            if i != j and trains[j][0] == B_i and trains[j][2] <= T_i:\n                X[i] = max(X[i], trains[j][2] - T_i + X[j])\n    \n    return X[1:]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nindex = 3\nfor _ in range(M):\n    A_i = int(data[index])\n    B_i = int(data[index + 1])\n    S_i = int(data[index + 2])\n    T_i = int(data[index + 3])\n    trains.append((A_i, B_i, S_i, T_i))\n    index += 4\n\n# Find and print the delays\ndelays = find_delays(N, M, X1, trains)\nprint(' '.join(map(str, delays)))"], "passed": [false], "raw_code": ["```python\ndef find_delays(N, M, X1, trains):\n    # Initialize delays with X1\n    X = [X1] * M\n    \n    # Process each train to adjust delays\n    for i in range(M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(M):\n            if i != j and trains[j][0] == B_i and trains[j][2] <= T_i:\n                X[i] = max(X[i], trains[j][2] - T_i + X[j])\n    \n    return X[1:]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nindex = 3\nfor _ in range(M):\n    A_i = int(data[index])\n    B_i = int(data[index + 1])\n    S_i = int(data[index + 2])\n    T_i = int(data[index + 3])\n    trains.append((A_i, B_i, S_i, T_i))\n    index += 4\n\n# Find and print the delays\ndelays = find_delays(N, M, X1, trains)\nprint(' '.join(map(str, delays)))"]}
{"task_id": "abc367_e", "codes": ["def process_sequence(N, K, X, A):\n    # Determine the number of effective operations\n    effective_operations = K % N\n    \n    # If there are no effective operations, print the original sequence\n    if effective_operations == 0:\n        print(' '.join(map(str, A)))\n        return\n    \n    # Perform the effective operations\n    for _ in range(effective_operations):\n        A = [A[X[i] - 1] for i in range(N)]\n    \n    # Print the resulting sequence\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)"], "passed": [false], "raw_code": ["```python\ndef process_sequence(N, K, X, A):\n    # Determine the number of effective operations\n    effective_operations = K % N\n    \n    # If there are no effective operations, print the original sequence\n    if effective_operations == 0:\n        print(' '.join(map(str, A)))\n        return\n    \n    # Perform the effective operations\n    for _ in range(effective_operations):\n        A = [A[X[i] - 1] for i in range(N)]\n    \n    # Print the resulting sequence\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)\n```"]}
{"task_id": "abc370_e", "codes": ["def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(i, 0, -1):\n            prefix_sum += A[j - 1]\n            if prefix_sum <= K:\n                dp[i][prefix_sum] = (dp[i][prefix_sum] + dp[j - 1][prefix_sum]) % MOD\n            else:\n                break\n    \n    # Calculate the result\n    result = 0\n    for j in range(K + 1):\n        result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))"], "passed": [false], "raw_code": ["```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(i, 0, -1):\n            prefix_sum += A[j - 1]\n            if prefix_sum <= K:\n                dp[i][prefix_sum] = (dp[i][prefix_sum] + dp[j - 1][prefix_sum]) % MOD\n            else:\n                break\n    \n    # Calculate the result\n    result = 0\n    for j in range(K + 1):\n        result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))\n```"]}
{"task_id": "3532", "codes": ["def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Initialize levels\n    n = len(edges) + 1\n    levels = [-1] * n\n    levels[0] = 0\n    queue = deque([0])\n    visited = set([0])\n    \n    # Step 3: Simulate marking process\n    while queue:\n        node = queue.popleft()\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if levels[node] % 2 == 0:\n                    levels[neighbor] = levels[node] + 2\n                else:\n                    levels[neighbor] = levels[node] + 1\n                queue.append(neighbor)\n    \n    return levels"], "passed": [false], "raw_code": ["```python\ndef minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Initialize levels\n    n = len(edges) + 1\n    levels = [-1] * n\n    levels[0] = 0\n    queue = deque([0])\n    visited = set([0])\n    \n    # Step 3: Simulate marking process\n    while queue:\n        node = queue.popleft()\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if levels[node] % 2 == 0:\n                    levels[neighbor] = levels[node] + 2\n                else:\n                    levels[neighbor] = levels[node] + 1\n                queue.append(neighbor)\n    \n    return levels\n```"]}
{"task_id": "abc373_f", "codes": ["```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        \n        # Update DP array from back to front to avoid using the same item multiple times\n        for j in range(W, w - 1, -1):\n            for k in range(1, min(j // w + 1, 10**10 + 1)):\n                dp[j] = max(dp[j], dp[j - k * w] + k * v - k ** 2)\n    \n    print(dp[W])\n\nmax_happiness()"], "passed": [false], "raw_code": ["```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        \n        # Update DP array from back to front to avoid using the same item multiple times\n        for j in range(W, w - 1, -1):\n            for k in range(1, min(j // w + 1, 10**10 + 1)):\n                dp[j] = max(dp[j], dp[j - k * w] + k * v - k ** 2)\n    \n    print(dp[W])\n\nmax_happiness()"]}
{"task_id": "abc373_e", "codes": ["def min_additional_votes(N, M, K, A):\n    # Calculate the current total votes\n    current_total_votes = sum(A)\n    \n    # Determine the remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Sort the candidates based on their votes\n    sorted_indices = sorted(range(N), key=lambda x: A[x])\n    \n    # Initialize the result array\n    C = [0] * N\n    \n    # Iterate through the candidates\n    for i in range(N):\n        max_votes_without_victory = float('-inf')\n        \n        # Find the maximum number of votes another candidate could get without securing victory\n        for j in range(N):\n            if j != i:\n                max_votes_without_victory = max(max_votes_without_victory, A[j])\n        \n        # Calculate the minimum additional votes needed\n        if max_votes_without_victory >= A[i]:\n            C[i] = max(0, max_votes_without_victory - A[i] + 1)\n        else:\n            C[i] = -1\n    \n    return ' '.join(map(str, C))\n\n# Example usage:\n# N = 5\n# M = 2\n# K = 16\n# A = [3, 1, 4, 1, 5]\n# print(min_additional_votes(N, M, K, A))  # Output: 2 -1 1 -1 0\n\n# N = 12\n# M = 1\n# K = 570\n# A = [81, 62, 17, 5, 5, 86, 15, 7, 79, 26, 6, 28]\n# print(min_additional_votes(N, M, K, A))  # Output: 79 89 111 117 117 74 112 116 80 107 117 106"], "passed": [false], "raw_code": ["```python\ndef min_additional_votes(N, M, K, A):\n    # Calculate the current total votes\n    current_total_votes = sum(A)\n    \n    # Determine the remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Sort the candidates based on their votes\n    sorted_indices = sorted(range(N), key=lambda x: A[x])\n    \n    # Initialize the result array\n    C = [0] * N\n    \n    # Iterate through the candidates\n    for i in range(N):\n        max_votes_without_victory = float('-inf')\n        \n        # Find the maximum number of votes another candidate could get without securing victory\n        for j in range(N):\n            if j != i:\n                max_votes_without_victory = max(max_votes_without_victory, A[j])\n        \n        # Calculate the minimum additional votes needed\n        if max_votes_without_victory >= A[i]:\n            C[i] = max(0, max_votes_without_victory - A[i] + 1)\n        else:\n            C[i] = -1\n    \n    return ' '.join(map(str, C))\n\n# Example usage:\n# N = 5\n# M = 2\n# K = 16\n# A = [3, 1, 4, 1, 5]\n# print(min_additional_votes(N, M, K, A))  # Output: 2 -1 1 -1 0\n\n# N = 12\n# M = 1\n# K = 570\n# A = [81, 62, 17, 5, 5, 86, 15, 7, 79, 26, 6, 28]\n# print(min_additional_votes(N, M, K, A))  # Output: 79 89 111 117 117 74 112 116 80 107 117 106\n```"]}
{"task_id": "abc368_g", "codes": ["```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [(-float('inf'), -float('inf'))] * (4 * n)\n\n    def build(self, arr, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if start == end:\n            self.tree[node] = (arr[start], arr[start])\n        else:\n            mid = (start + end) // 2\n            self.build(arr, 2 * node, start, mid)\n            self.build(arr, 2 * node + 1, mid + 1, end)\n            self.tree[node] = (max(self.tree[2 * node][0], self.tree[2 * node + 1][0]),\n                               max(self.tree[2 * node][1], self.tree[2 * node + 1][1]))\n\n    def update(self, idx, val, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if start == end:\n            self.tree[node] = (val, val)\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update(idx, val, 2 * node, start, mid)\n            else:\n                self.update(idx, val, 2 * node + 1, mid + 1, end)\n            self.tree[node] = (max(self.tree[2 * node][0], self.tree[2 * node + 1][0]),\n                               max(self.tree[2 * node][1], self.tree[2 * node + 1][1]))\n\n    def query(self, l, r, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if r < start or end < l:\n            return (-float('inf'), -float('inf'))\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left = self.query(l, r, 2 * node, start, mid)\n        right = self.query(l, r, 2 * node + 1, mid + 1, end)\n        return (max(left[0], right[0]), max(left[1], right[1]))\n\ndef main():\n    n = int(data[0])\n    A = list(map(int, data[1:n+1]))\n    B = list(map(int, data[n+1:2*n+1]))\n    Q = int(data[2*n+1])\n    queries = data[2*n+2:]\n\n    st_A = SegmentTree(n)\n    st_B = SegmentTree(n)\n\n    st_A.build(A)\n    st_B.build(B)\n\n    index = 2*n+2\n    results = []\n    while index < len(queries):\n        query_type = int(queries[index])\n        if query_type == 1:\n            i = int(queries[index + 1]) - 1\n            x = int(queries[index + 2])\n            st_A.update(i, x)\n        elif query_type =="], "passed": [false], "raw_code": ["```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [(-float('inf'), -float('inf'))] * (4 * n)\n\n    def build(self, arr, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if start == end:\n            self.tree[node] = (arr[start], arr[start])\n        else:\n            mid = (start + end) // 2\n            self.build(arr, 2 * node, start, mid)\n            self.build(arr, 2 * node + 1, mid + 1, end)\n            self.tree[node] = (max(self.tree[2 * node][0], self.tree[2 * node + 1][0]),\n                               max(self.tree[2 * node][1], self.tree[2 * node + 1][1]))\n\n    def update(self, idx, val, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if start == end:\n            self.tree[node] = (val, val)\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                self.update(idx, val, 2 * node, start, mid)\n            else:\n                self.update(idx, val, 2 * node + 1, mid + 1, end)\n            self.tree[node] = (max(self.tree[2 * node][0], self.tree[2 * node + 1][0]),\n                               max(self.tree[2 * node][1], self.tree[2 * node + 1][1]))\n\n    def query(self, l, r, node=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if r < start or end < l:\n            return (-float('inf'), -float('inf'))\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left = self.query(l, r, 2 * node, start, mid)\n        right = self.query(l, r, 2 * node + 1, mid + 1, end)\n        return (max(left[0], right[0]), max(left[1], right[1]))\n\ndef main():\n    n = int(data[0])\n    A = list(map(int, data[1:n+1]))\n    B = list(map(int, data[n+1:2*n+1]))\n    Q = int(data[2*n+1])\n    queries = data[2*n+2:]\n\n    st_A = SegmentTree(n)\n    st_B = SegmentTree(n)\n\n    st_A.build(A)\n    st_B.build(B)\n\n    index = 2*n+2\n    results = []\n    while index < len(queries):\n        query_type = int(queries[index])\n        if query_type == 1:\n            i = int(queries[index + 1]) - 1\n            x = int(queries[index + 2])\n            st_A.update(i, x)\n        elif query_type =="]}
{"task_id": "abc372_g", "codes": ["def count_valid_pairs(N, A, B, C):\n    count = 0\n    max_x = 10**9 // min(A)\n    for x in range(1, max_x + 1):\n        left, right = 0, 10**9\n        while left < right:\n            mid = (left + right + 1) // 2\n            if A[x-1] * x + B[x-1] * mid < C[x-1]:\n                left = mid\n            else:\n                right = mid - 1\n        if left > 0:\n            count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        B = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        C = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef count_valid_pairs(N, A, B, C):\n    count = 0\n    max_x = 10**9 // min(A)\n    for x in range(1, max_x + 1):\n        left, right = 0, 10**9\n        while left < right:\n            mid = (left + right + 1) // 2\n            if A[x-1] * x + B[x-1] * mid < C[x-1]:\n                left = mid\n            else:\n                right = mid - 1\n        if left > 0:\n            count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        B = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        C = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc366_g", "codes": ["import sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, colors):\n    xor_sum = 0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            xor_sum ^= colors[neighbor]\n    return xor_sum\n\ndef find_solution(n, m, edges):\n    global graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    colors = [0] * (n + 1)\n    stack = [(1, None)]\n\n    while stack:\n        node, parent = stack.pop()\n        if node == 1:\n            colors[node] = 1\n        else:\n            colors[node] = dfs(node, parent, colors) ^ colors[parent]\n\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                stack.append((neighbor, node))\n\n    if any(color == 0 for color in colors[1:n+1]):\n        return 'No'\n    else:\n        return 'Yes\n' + ' '.join(map(str, colors[1:n+1]))\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = [(int(data[2*i+2]), int(data[2*i+3])) for i in range(m)]\n    result = find_solution(n, m, edges)\n    print(result)"], "passed": [false], "raw_code": ["import sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, colors):\n    xor_sum = 0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            xor_sum ^= colors[neighbor]\n    return xor_sum\n\ndef find_solution(n, m, edges):\n    global graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    colors = [0] * (n + 1)\n    stack = [(1, None)]\n\n    while stack:\n        node, parent = stack.pop()\n        if node == 1:\n            colors[node] = 1\n        else:\n            colors[node] = dfs(node, parent, colors) ^ colors[parent]\n\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                stack.append((neighbor, node))\n\n    if any(color == 0 for color in colors[1:n+1]):\n        return 'No'\n    else:\n        return 'Yes\n' + ' '.join(map(str, colors[1:n+1]))\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = [(int(data[2*i+2]), int(data[2*i+3])) for i in range(m)]\n    result = find_solution(n, m, edges)\n    print(result)"]}
{"task_id": "abc372_f", "codes": ["```python\ndef count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][1] = 1\n    \n    for i in range(1, K + 1):\n        for j in range(1, N + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j == 1:\n                dp[i][j] += dp[i - 1][N]\n            for X, Y in edges:\n                if Y == j:\n                    dp[i][j] += dp[i - 1][X]\n            dp[i][j] %= MOD\n    \n    result = sum(dp[K]) % MOD\n    print(result)\n\ncount_ways()"], "passed": [false], "raw_code": ["```python\ndef count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][1] = 1\n    \n    for i in range(1, K + 1):\n        for j in range(1, N + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j == 1:\n                dp[i][j] += dp[i - 1][N]\n            for X, Y in edges:\n                if Y == j:\n                    dp[i][j] += dp[i - 1][X]\n            dp[i][j] %= MOD\n    \n    result = sum(dp[K]) % MOD\n    print(result)\n\ncount_ways()"]}
{"task_id": "abc369_e", "codes": ["```python\nimport heapq\nfrom collections import defaultdict\n\ndef min_time_to_travel(N, M, bridges, Q, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def dijkstra(start, end, used_bridges):\n        pq = [(0, start, used_bridges)]\n        dist = {(start, used_bridges): 0}\n        \n        while pq:\n            current_dist, u, used_bridges = heapq.heappop(pq)\n            \n            if u == end:\n                return current_dist\n            \n            for v, t in graph[u]:\n                new_used_bridges = used_bridges | (1 << (v - 1))\n                new_dist = current_dist + t\n                \n                if (v, new_used_bridges) not in dist or new_dist < dist[(v, new_used_bridges)]:\n                    dist[(v, new_used_bridges)] = new_dist\n                    heapq.heappush(pq, (new_dist, v, new_used_bridges))\n        \n        return float('inf')\n    \n    results = []\n    for K, bridges in queries:\n        used_bridges = 0\n        for b in bridges:\n            used_bridges |= (1 << (b - 1))\n        \n        result = dijkstra(1, N, used_bridges)\n        results.append(result)\n    \n    return results\n\n# Read input\nN, M = map(int, input().split())\nbridges = [tuple(map(int, input().split())) for _ in range(M)]\nQ = int(input())\nqueries = [list(map(int, input().split()))[1:] for _ in range(Q)]\n\n# Get results\nresults = min_time_to_travel(N, M, bridges, Q, queries)\n\n# Print results\nfor result in results:\n    print(result)"], "passed": [false], "raw_code": ["```python\nimport heapq\nfrom collections import defaultdict\n\ndef min_time_to_travel(N, M, bridges, Q, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def dijkstra(start, end, used_bridges):\n        pq = [(0, start, used_bridges)]\n        dist = {(start, used_bridges): 0}\n        \n        while pq:\n            current_dist, u, used_bridges = heapq.heappop(pq)\n            \n            if u == end:\n                return current_dist\n            \n            for v, t in graph[u]:\n                new_used_bridges = used_bridges | (1 << (v - 1))\n                new_dist = current_dist + t\n                \n                if (v, new_used_bridges) not in dist or new_dist < dist[(v, new_used_bridges)]:\n                    dist[(v, new_used_bridges)] = new_dist\n                    heapq.heappush(pq, (new_dist, v, new_used_bridges))\n        \n        return float('inf')\n    \n    results = []\n    for K, bridges in queries:\n        used_bridges = 0\n        for b in bridges:\n            used_bridges |= (1 << (b - 1))\n        \n        result = dijkstra(1, N, used_bridges)\n        results.append(result)\n    \n    return results\n\n# Read input\nN, M = map(int, input().split())\nbridges = [tuple(map(int, input().split())) for _ in range(M)]\nQ = int(input())\nqueries = [list(map(int, input().split()))[1:] for _ in range(Q)]\n\n# Get results\nresults = min_time_to_travel(N, M, bridges, Q, queries)\n\n# Print results\nfor result in results:\n    print(result)"]}
{"task_id": "abc373_g", "codes": ["```python\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    \n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    \n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    \n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    \n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    \n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef find_permutation(N, P, Q):\n    visited = [False] * N\n    result = [-1] * N\n    \n    def dfs(i, path):\n        if len(path) == N:\n            return True\n        \n        for j in range(N):\n            if not visited[j]:\n                if len(path) == 0 or not do_intersect(P[i], Q[i], P[path[-1]], Q[path[-1]]):\n                    visited[j] = True\n                    path.append(j)\n                    if dfs(i + 1, path):\n                        return True\n                    path.pop()\n                    visited[j] = False\n        \n        return False\n    \n    for i in range(N):\n        visited[i] = True\n        if dfs(0, [i]):\n            for j in range(N):\n                result[j] = path[j]\n            break\n    \n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = []\nQ = []\n\nfor i in range(N):\n    P.append((int(data[2*i+1]), int(data[2*i+2])))\n\nfor i in range(N):\n    Q.append((int(data[2*N+2*i+1]), int(data[2*N+2*i+2])))\n\nresult = find_permutation(N, P, Q)\n\nif result == [-1]:\n    print(-1)\nelse:\n    print(' '.join(map(str, result + 1)))"], "passed": [false], "raw_code": ["```python\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    \n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    \n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    \n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    \n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    \n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef find_permutation(N, P, Q):\n    visited = [False] * N\n    result = [-1] * N\n    \n    def dfs(i, path):\n        if len(path) == N:\n            return True\n        \n        for j in range(N):\n            if not visited[j]:\n                if len(path) == 0 or not do_intersect(P[i], Q[i], P[path[-1]], Q[path[-1]]):\n                    visited[j] = True\n                    path.append(j)\n                    if dfs(i + 1, path):\n                        return True\n                    path.pop()\n                    visited[j] = False\n        \n        return False\n    \n    for i in range(N):\n        visited[i] = True\n        if dfs(0, [i]):\n            for j in range(N):\n                result[j] = path[j]\n            break\n    \n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = []\nQ = []\n\nfor i in range(N):\n    P.append((int(data[2*i+1]), int(data[2*i+2])))\n\nfor i in range(N):\n    Q.append((int(data[2*N+2*i+1]), int(data[2*N+2*i+2])))\n\nresult = find_permutation(N, P, Q)\n\nif result == [-1]:\n    print(-1)\nelse:\n    print(' '.join(map(str, result + 1)))"]}
{"task_id": "3563", "codes": ["def maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    def backtrack(row, used, score):\n        if row == len(grid):\n            return score\n        max_score = 0\n        for col in range(len(grid[0])):\n            if col not in used:\n                used.add(col)\n                max_score = max(max_score, backtrack(row + 1, used, score + grid[row][col]))\n                used.remove(col)\n        return max_score\n    \n    return backtrack(0, set(), 0)"], "passed": [false], "raw_code": ["```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    def backtrack(row, used, score):\n        if row == len(grid):\n            return score\n        max_score = 0\n        for col in range(len(grid[0])):\n            if col not in used:\n                used.add(col)\n                max_score = max(max_score, backtrack(row + 1, used, score + grid[row][col]))\n                used.remove(col)\n        return max_score\n    \n    return backtrack(0, set(), 0)\n```"]}
{"task_id": "arc181_b", "codes": ["def f(S, T, X):\n    return ''.join(S if x == '0' else T for x in X)\n\ndef check_f(S, X, Y):\n    len_X = len(X)\n    len_Y = len(Y)\n    \n    # Create a list to track positions of S in f(S, T, X) and f(S, T, Y)\n    pos_X = []\n    pos_Y = []\n    \n    # Track the current position in T\n    current_pos = 0\n    \n    # Process X\n    for i in range(len_X):\n        if X[i] == '0':\n            current_pos += len(S)\n            pos_X.append(current_pos - len(S))\n        else:\n            pos_X.append(current_pos)\n    \n    # Reset current position\n    current_pos = 0\n    \n    # Process Y\n    for i in range(len_Y):\n        if Y[i] == '0':\n            current_pos += len(S)\n            pos_Y.append(current_pos - len(S))\n        else:\n            pos_Y.append(current_pos)\n    \n    # Check if positions match\n    return pos_X == pos_Y\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        if check_f(S, X, Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef f(S, T, X):\n    return ''.join(S if x == '0' else T for x in X)\n\ndef check_f(S, X, Y):\n    len_X = len(X)\n    len_Y = len(Y)\n    \n    # Create a list to track positions of S in f(S, T, X) and f(S, T, Y)\n    pos_X = []\n    pos_Y = []\n    \n    # Track the current position in T\n    current_pos = 0\n    \n    # Process X\n    for i in range(len_X):\n        if X[i] == '0':\n            current_pos += len(S)\n            pos_X.append(current_pos - len(S))\n        else:\n            pos_X.append(current_pos)\n    \n    # Reset current position\n    current_pos = 0\n    \n    # Process Y\n    for i in range(len_Y):\n        if Y[i] == '0':\n            current_pos += len(S)\n            pos_Y.append(current_pos - len(S))\n        else:\n            pos_Y.append(current_pos)\n    \n    # Check if positions match\n    return pos_X == pos_Y\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        if check_f(S, X, Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc368_d", "codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    return map(int, sys.stdin.read().split())\n\ndef lca(tree, u, v):\n    if u not in tree or v not in tree:\n        return None\n    if u == v:\n        return u\n    stack = [(u, set([u]))]\n    while stack:\n        node, path = stack.pop()\n        for neighbor in tree[node]:\n            if neighbor not in path:\n                new_path = path.union({neighbor})\n                if neighbor == v:\n                    return node\n                stack.append((neighbor, new_path))\n    return None\n\ndef main():\n    input = read_input()\n    N, K = next(input), next(input)\n    tree = defaultdict(list)\n    for _ in range(N - 1):\n        u, v = next(input), next(input)\n        tree[u].append(v)\n        tree[v].append(u)\n    V = [next(input) for _ in range(K)]\n    lcas = set()\n    for i in range(K):\n        for j in range(i + 1, K):\n            lcas.add(lca(tree, V[i], V[j]))\n    print(len(lcas))\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    return map(int, sys.stdin.read().split())\n\ndef lca(tree, u, v):\n    if u not in tree or v not in tree:\n        return None\n    if u == v:\n        return u\n    stack = [(u, set([u]))]\n    while stack:\n        node, path = stack.pop()\n        for neighbor in tree[node]:\n            if neighbor not in path:\n                new_path = path.union({neighbor})\n                if neighbor == v:\n                    return node\n                stack.append((neighbor, new_path))\n    return None\n\ndef main():\n    input = read_input()\n    N, K = next(input), next(input)\n    tree = defaultdict(list)\n    for _ in range(N - 1):\n        u, v = next(input), next(input)\n        tree[u].append(v)\n        tree[v].append(u)\n    V = [next(input) for _ in range(K)]\n    lcas = set()\n    for i in range(K):\n        for j in range(i + 1, K):\n            lcas.add(lca(tree, V[i], V[j]))\n    print(len(lcas))\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "arc183_c", "codes": ["```python\ndef count_valid_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    conditions = []\n    index = 2\n    for _ in range(M):\n        L = int(data[index]) - 1\n        R = int(data[index + 1]) - 1\n        X = int(data[index + 2]) - 1\n        conditions.append((L, R, X))\n        index += 3\n    \n    MOD = 998244353\n    \n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[1][1] = 1\n    \n    for i in range(2, N + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = sum(dp[i - 1][k] for k in range(1, j)) % MOD\n            for L, R, X in conditions:\n                if L <= i <= R and X == j:\n                    dp[i][j] -= sum(dp[R - L + 1][k] for k in range(j + 1, i + 1)) % MOD\n                    dp[i][j] %= MOD\n    \n    result = sum(dp[N][j] for j in range(1, N + 1)) % MOD\n    print(result)\n\ncount_valid_permutations()"], "passed": [false], "raw_code": ["```python\ndef count_valid_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    conditions = []\n    index = 2\n    for _ in range(M):\n        L = int(data[index]) - 1\n        R = int(data[index + 1]) - 1\n        X = int(data[index + 2]) - 1\n        conditions.append((L, R, X))\n        index += 3\n    \n    MOD = 998244353\n    \n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[1][1] = 1\n    \n    for i in range(2, N + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = sum(dp[i - 1][k] for k in range(1, j)) % MOD\n            for L, R, X in conditions:\n                if L <= i <= R and X == j:\n                    dp[i][j] -= sum(dp[R - L + 1][k] for k in range(j + 1, i + 1)) % MOD\n                    dp[i][j] %= MOD\n    \n    result = sum(dp[N][j] for j in range(1, N + 1)) % MOD\n    print(result)\n\ncount_valid_permutations()"]}
{"task_id": "arc183_b", "codes": ["def can_make_identical(T, test_cases):\n    results = []\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a dictionary to count occurrences of each element in B\n        B_count = {}\n        for i in range(N):\n            if B[i] not in B_count:\n                B_count[B[i]] = []\n            B_count[B[i]].append(i)\n        \n        # Iterate through each element in A\n        for i in range(N):\n            if A[i] not in B_count:\n                results.append(\"No\")\n                break\n            else:\n                # Find the positions of A[i] in B\n                positions = B_count[A[i]]\n                found = False\n                for pos in positions:\n                    if abs(i - pos) <= K:\n                        found = True\n                        B_count[A[i]].remove(pos)\n                        break\n                if not found:\n                    results.append(\"No\")\n                    break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get results\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"], "passed": [false], "raw_code": ["```python\ndef can_make_identical(T, test_cases):\n    results = []\n    for case in test_cases:\n        N, K = case[0]\n        A = case[1]\n        B = case[2]\n        \n        # Create a dictionary to count occurrences of each element in B\n        B_count = {}\n        for i in range(N):\n            if B[i] not in B_count:\n                B_count[B[i]] = []\n            B_count[B[i]].append(i)\n        \n        # Iterate through each element in A\n        for i in range(N):\n            if A[i] not in B_count:\n                results.append(\"No\")\n                break\n            else:\n                # Find the positions of A[i] in B\n                positions = B_count[A[i]]\n                found = False\n                for pos in positions:\n                    if abs(i - pos) <= K:\n                        found = True\n                        B_count[A[i]].remove(pos)\n                        break\n                if not found:\n                    results.append(\"No\")\n                    break\n        else:\n            results.append(\"Yes\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Get results\nresults = can_make_identical(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)\n```"]}
{"task_id": "abc367_g", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * M for _ in range(N + 1)]\n    \n    # Base case: empty subsequence\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(M):\n            dp[i][j] = dp[i - 1][j]\n            dp[i][(j ^ A[i - 1]) % M] += dp[i - 1][j]\n            dp[i][(j ^ A[i - 1]) % M] %= MOD\n    \n    result = 0\n    for j in range(0, M, M):\n        result += pow(dp[N][j], K, MOD)\n        result %= MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * M for _ in range(N + 1)]\n    \n    # Base case: empty subsequence\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(M):\n            dp[i][j] = dp[i - 1][j]\n            dp[i][(j ^ A[i - 1]) % M] += dp[i - 1][j]\n            dp[i][(j ^ A[i - 1]) % M] %= MOD\n    \n    result = 0\n    for j in range(0, M, M):\n        result += pow(dp[N][j], K, MOD)\n        result %= MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3552", "codes": ["def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    if n == 1:\n        return str(k) if k % 2 == 0 else str(k - 1)\n    \n    if n == 2:\n        for i in range(10, 100):\n            if i % k == 0 and str(i) == str(i)[::-1]:\n                return str(i)\n    \n    if n >= 3:\n        for i in range(10**(n-1), 10**(n-1) - 1, -1):\n            num = int(str(i) + str(i)[::-1])\n            if num % k == 0:\n                return str(num)\n    \n    return \"0\"\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\""], "passed": [false], "raw_code": ["```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    if n == 1:\n        return str(k) if k % 2 == 0 else str(k - 1)\n    \n    if n == 2:\n        for i in range(10, 100):\n            if i % k == 0 and str(i) == str(i)[::-1]:\n                return str(i)\n    \n    if n >= 3:\n        for i in range(10**(n-1), 10**(n-1) - 1, -1):\n            num = int(str(i) + str(i)[::-1])\n            if num % k == 0:\n                return str(num)\n    \n    return \"0\"\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time_to_die, d, h in sorted_enemies:\n        if h > 0:\n            # Calculate the number of attacks needed to kill the enemy\n            attacks_needed = int(h // power)\n            if h % power != 0:\n                attacks_needed += 1\n            \n            # Update the total damage and current time\n            total_damage += attacks_needed * d\n            current_time += attacks_needed\n    \n    return total_damage"], "passed": [false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time_to_die, d, h in sorted_enemies:\n        if h > 0:\n            # Calculate the number of attacks needed to kill the enemy\n            attacks_needed = int(h // power)\n            if h % power != 0:\n                attacks_needed += 1\n            \n            # Update the total damage and current time\n            total_damage += attacks_needed * d\n            current_time += attacks_needed\n    \n    return total_damage\n```"]}
{"task_id": "abc371_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize variables\n    total_sum = 0\n    \n    # Iterate over all possible starting points of the subsequence\n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        # Iterate over all possible ending points of the subsequence starting from i\n        for j in range(i, N):\n            if A[j] not in seen:\n                distinct_count += 1\n                seen.add(A[j])\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize variables\n    total_sum = 0\n    \n    # Iterate over all possible starting points of the subsequence\n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        # Iterate over all possible ending points of the subsequence starting from i\n        for j in range(i, N):\n            if A[j] not in seen:\n                distinct_count += 1\n                seen.add(A[j])\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nmain()\n```"]}
{"task_id": "abc367_f", "codes": ["def can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()"], "passed": [false], "raw_code": ["```python\ndef can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()\n```"]}
{"task_id": "arc183_d", "codes": ["```python\ndef find_leaves(graph):\n    leaves = []\n    for node in graph:\n        if len(graph[node]) == 1:\n            leaves.append(node)\n    return leaves\n\ndef remove_leaf(graph, leaf):\n    neighbor = graph[leaf][0]\n    graph.pop(leaf)\n    graph[neighbor].remove(leaf)\n\ndef max_score_operations(N, edges):\n    graph = {i: [] for i in range(1, N+1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    operations = []\n    while True:\n        leaves = find_leaves(graph)\n        if not leaves or len(leaves) % 2 != 0:\n            break\n        x, y = leaves[-1], leaves[-2]\n        operations.append((x, y))\n        remove_leaf(graph, x)\n        remove_leaf(graph, y)\n    \n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[i*2+1]), int(data[i*2+2])) for i in range((N-1)//2)]\n\n# Get the result\nresult = max_score_operations(N, edges)\n\n# Print the result\nfor x, y in result:\n    print(x, y)"], "passed": [false], "raw_code": ["```python\ndef find_leaves(graph):\n    leaves = []\n    for node in graph:\n        if len(graph[node]) == 1:\n            leaves.append(node)\n    return leaves\n\ndef remove_leaf(graph, leaf):\n    neighbor = graph[leaf][0]\n    graph.pop(leaf)\n    graph[neighbor].remove(leaf)\n\ndef max_score_operations(N, edges):\n    graph = {i: [] for i in range(1, N+1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    operations = []\n    while True:\n        leaves = find_leaves(graph)\n        if not leaves or len(leaves) % 2 != 0:\n            break\n        x, y = leaves[-1], leaves[-2]\n        operations.append((x, y))\n        remove_leaf(graph, x)\n        remove_leaf(graph, y)\n    \n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[i*2+1]), int(data[i*2+2])) for i in range((N-1)//2)]\n\n# Get the result\nresult = max_score_operations(N, edges)\n\n# Print the result\nfor x, y in result:\n    print(x, y)"]}
{"task_id": "abc371_g", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n\n    # Create a mapping from each element to its position in A\n    pos = {a: i for i, a in enumerate(A)}\n\n    # Initialize the result array with zeros\n    result = [0] * N\n\n    # Process each element in A\n    for i in range(N):\n        if result[i] == 0:\n            cycle = []\n            x = i\n            while True:\n                cycle.append(x)\n                result[x] = A[i]\n                x = P[x] - 1\n                if x == i:\n                    break\n\n            # Sort the current cycle\n            cycle.sort()\n            for j, x in enumerate(cycle):\n                result[x] = A[cycle[j]]\n\n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n\n    # Create a mapping from each element to its position in A\n    pos = {a: i for i, a in enumerate(A)}\n\n    # Initialize the result array with zeros\n    result = [0] * N\n\n    # Process each element in A\n    for i in range(N):\n        if result[i] == 0:\n            cycle = []\n            x = i\n            while True:\n                cycle.append(x)\n                result[x] = A[i]\n                x = P[x] - 1\n                if x == i:\n                    break\n\n            # Sort the current cycle\n            cycle.sort()\n            for j, x in enumerate(cycle):\n                result[x] = A[cycle[j]]\n\n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3548", "codes": ["def countGoodIntegers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits, target_sum, k):\n        dp = [[0] * (target_sum + 1) for _ in range(len(digits) + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, len(digits) + 1):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= digits[i - 1]:\n                    dp[i][j] += dp[i - 1][j - digits[i - 1]]\n        \n        return dp[len(digits)][target_sum]\n    \n    def count_good_integers(n, k):\n        if n == 1:\n            return 1 if k % 2 == 0 else 0\n        \n        digits = [i for i in range(1, 10)]\n        target_sum = n * k\n        \n        count = 0\n        for mask in range(1 << len(digits)):\n            current_sum = 0\n            current_digits = []\n            for i in range(len(digits)):\n                if mask & (1 << i):\n                    current_sum += digits[i]\n                    current_digits.append(digits[i])\n            \n            if current_sum != target_sum:\n                continue\n            \n            if is_palindrome(''.join(map(str, sorted(current_digits)))):\n                count += 1\n        \n        return count\n    \n    return count_good_integers(n, k)"], "passed": [false], "raw_code": ["```python\ndef countGoodIntegers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits, target_sum, k):\n        dp = [[0] * (target_sum + 1) for _ in range(len(digits) + 1)]\n        dp[0][0] = 1\n        \n        for i in range(1, len(digits) + 1):\n            for j in range(target_sum + 1):\n                dp[i][j] = dp[i - 1][j]\n                if j >= digits[i - 1]:\n                    dp[i][j] += dp[i - 1][j - digits[i - 1]]\n        \n        return dp[len(digits)][target_sum]\n    \n    def count_good_integers(n, k):\n        if n == 1:\n            return 1 if k % 2 == 0 else 0\n        \n        digits = [i for i in range(1, 10)]\n        target_sum = n * k\n        \n        count = 0\n        for mask in range(1 << len(digits)):\n            current_sum = 0\n            current_digits = []\n            for i in range(len(digits)):\n                if mask & (1 << i):\n                    current_sum += digits[i]\n                    current_digits.append(digits[i])\n            \n            if current_sum != target_sum:\n                continue\n            \n            if is_palindrome(''.join(map(str, sorted(current_digits)))):\n                count += 1\n        \n        return count\n    \n    return count_good_integers(n, k)\n```"]}
{"task_id": "abc370_f", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Calculate the prefix sums of the masses\n    prefix_sums = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + A[i - 1]\n\n    # Initialize variables to store the result\n    min_weight = float('inf')\n    num_uncut_cuts = 0\n\n    # Iterate over possible starting points for the first person's share\n    for start in range(N):\n        current_weight = 0\n        cut_count = 0\n        for end in range(start, N):\n            current_weight += A[end]\n            if current_weight >= prefix_sums[N] // K:\n                break\n            cut_count += 1\n        if current_weight < prefix_sums[N] // K:\n            continue\n\n        # Check if the remaining pieces can be distributed to the rest of the people\n        remaining_weight = prefix_sums[N] - current_weight\n        if remaining_weight % (K - 1) == 0:\n            min_weight = min(min_weight, current_weight)\n            num_uncut_cuts = max(num_uncut_cuts, cut_count)\n\n    print(min_weight, num_uncut_cuts)\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Calculate the prefix sums of the masses\n    prefix_sums = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + A[i - 1]\n\n    # Initialize variables to store the result\n    min_weight = float('inf')\n    num_uncut_cuts = 0\n\n    # Iterate over possible starting points for the first person's share\n    for start in range(N):\n        current_weight = 0\n        cut_count = 0\n        for end in range(start, N):\n            current_weight += A[end]\n            if current_weight >= prefix_sums[N] // K:\n                break\n            cut_count += 1\n        if current_weight < prefix_sums[N] // K:\n            continue\n\n        # Check if the remaining pieces can be distributed to the rest of the people\n        remaining_weight = prefix_sums[N] - current_weight\n        if remaining_weight % (K - 1) == 0:\n            min_weight = min(min_weight, current_weight)\n            num_uncut_cuts = max(num_uncut_cuts, cut_count)\n\n    print(min_weight, num_uncut_cuts)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3583", "codes": ["def minOperations(nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_count = {}\n    \n    # Compute GCD for all pairs and count their occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g in gcd_count:\n                gcd_count[g] += 1\n            else:\n                gcd_count[g] = 1\n    \n    # Get sorted unique GCD values\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Answer the queries\n    result = []\n    for q in queries:\n        total_pairs = n * (n - 1) // 2\n        current_index = 0\n        \n        for g in sorted_gcds:\n            if current_index + gcd_count[g] > q:\n                result.append(g)\n                break\n            current_index += gcd_count[g]\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef minOperations(nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_count = {}\n    \n    # Compute GCD for all pairs and count their occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g in gcd_count:\n                gcd_count[g] += 1\n            else:\n                gcd_count[g] = 1\n    \n    # Get sorted unique GCD values\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Answer the queries\n    result = []\n    for q in queries:\n        total_pairs = n * (n - 1) // 2\n        current_index = 0\n        \n        for g in sorted_gcds:\n            if current_index + gcd_count[g] > q:\n                result.append(g)\n                break\n            current_index += gcd_count[g]\n    \n    return result\n```"]}
{"task_id": "arc181_d", "codes": ["import sys\nfrom typing import List\n\nclass FenwickTree:\n    def __init__(self, size: int):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index: int, value: int) -> None:\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef count_inversions(perm: List[int]) -> int:\n    n = len(perm)\n    ft = FenwickTree(n)\n    inversions = 0\n    rank = {value: i + 1 for i, value in enumerate(sorted(set(perm)))}\n\n    for num in perm[::-1]:\n        inversions += ft.query(rank[num] - 1)\n        ft.update(rank[num], 1)\n\n    return inversions\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    perm = list(map(int, data[1:n+1]))\n    m = int(data[n+1])\n    ops = list(map(int, data[n+2:n+m+2]))\n\n    results = []\n    current_perm = perm[:]\n\n    for op in ops:\n        for i in range(op - 1):\n            if current_perm[i] > current_perm[i + 1]:\n                current_perm[i], current_perm[i + 1] = current_perm[i + 1], current_perm[i]\n        results.append(count_inversions(current_perm))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["import sys\nfrom typing import List\n\nclass FenwickTree:\n    def __init__(self, size: int):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index: int, value: int) -> None:\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef count_inversions(perm: List[int]) -> int:\n    n = len(perm)\n    ft = FenwickTree(n)\n    inversions = 0\n    rank = {value: i + 1 for i, value in enumerate(sorted(set(perm)))}\n\n    for num in perm[::-1]:\n        inversions += ft.query(rank[num] - 1)\n        ft.update(rank[num], 1)\n\n    return inversions\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    perm = list(map(int, data[1:n+1]))\n    m = int(data[n+1])\n    ops = list(map(int, data[n+2:n+m+2]))\n\n    results = []\n    current_perm = perm[:]\n\n    for op in ops:\n        for i in range(op - 1):\n            if current_perm[i] > current_perm[i + 1]:\n                current_perm[i], current_perm[i + 1] = current_perm[i + 1], current_perm[i]\n        results.append(count_inversions(current_perm))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3575", "codes": ["def max_value_of_subsequence(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    for i in range(n - 2 * k + 1):\n        first_half = 0\n        second_half = 0\n        for j in range(i, i + k):\n            first_half |= nums[j]\n        for j in range(i + k, i + 2 * k):\n            second_half |= nums[j]\n        max_val = max(max_val, first_half ^ second_half)\n    \n    return max_val"], "passed": [false], "raw_code": ["```python\ndef max_value_of_subsequence(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    for i in range(n - 2 * k + 1):\n        first_half = 0\n        second_half = 0\n        for j in range(i, i + k):\n            first_half |= nums[j]\n        for j in range(i + k, i + 2 * k):\n            second_half |= nums[j]\n        max_val = max(max_val, first_half ^ second_half)\n    \n    return max_val\n```"]}
{"task_id": "arc181_c", "codes": ["def generate_grid(N, P, Q):\n    # Create a Latin square\n    grid = [[(i + j) % N for j in range(N)] for i in range(N)]\n    # Sort rows based on permutation P\n    sorted_rows = [grid[i - 1] for i in P]\n    # Sort columns based on permutation Q\n    sorted_columns = list(zip(*sorted_rows))\n    # Convert to the required format\n    result = [''.join(map(str, col)) for col in sorted_columns]\n    return '\\n'.join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:2*N+1]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))"], "passed": [false], "raw_code": ["def generate_grid(N, P, Q):\n    # Create a Latin square\n    grid = [[(i + j) % N for j in range(N)] for i in range(N)]\n    # Sort rows based on permutation P\n    sorted_rows = [grid[i - 1] for i in P]\n    # Sort columns based on permutation Q\n    sorted_columns = list(zip(*sorted_rows))\n    # Convert to the required format\n    result = [''.join(map(str, col)) for col in sorted_columns]\n    return '\\n'.join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:2*N+1]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))"]}
{"task_id": "arc182_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    # Calculate the frequency of each remainder when (Ck + Ai) % M is computed for k in range(K)\n    remainder_count = [0] * M\n    min_values = [float('inf')] * M\n\n    for k in range(M):\n        for ai in A:\n            remainder = (C * k + ai) % M\n            if remainder < min_values[remainder]:\n                min_values[remainder] = remainder\n            remainder_count[remainder] += 1\n\n    # Calculate the total sum based on the minimum values and their frequencies\n    total_sum = sum(min_value * count for min_value, count in zip(min_values, remainder_count))\n\n    # Adjust the total sum for the full range [0, K-1]\n    total_sum *= (K // M)\n    remaining_k = K % M\n    for k in range(remaining_k):\n        for ai in A:\n            remainder = (C * k + ai) % M\n            total_sum += min_values[remainder]\n\n    print(total_sum)\n\nmain()"], "passed": [false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    # Calculate the frequency of each remainder when (Ck + Ai) % M is computed for k in range(K)\n    remainder_count = [0] * M\n    min_values = [float('inf')] * M\n\n    for k in range(M):\n        for ai in A:\n            remainder = (C * k + ai) % M\n            if remainder < min_values[remainder]:\n                min_values[remainder] = remainder\n            remainder_count[remainder] += 1\n\n    # Calculate the total sum based on the minimum values and their frequencies\n    total_sum = sum(min_value * count for min_value, count in zip(min_values, remainder_count))\n\n    # Adjust the total sum for the full range [0, K-1]\n    total_sum *= (K // M)\n    remaining_k = K % M\n    for k in range(remaining_k):\n        for ai in A:\n            remainder = (C * k + ai) % M\n            total_sum += min_values[remainder]\n\n    print(total_sum)\n\nmain()"]}
{"task_id": "abc369_g", "codes": ["import heapq\nfrom collections import defaultdict, deque\n\ndef dijkstra(n, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    pq = [(0, 1)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\ndef min_max_score(n, edges):\n    dist = dijkstra(n, edges)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for k in range(1, n + 1):\n        for mask in range(1 << k):\n            count = bin(mask).count('1')\n            if count != k:\n                continue\n            max_dist = 0\n            for i in range(1, n + 1):\n                if mask & (1 << (i - 1)):\n                    max_dist = max(max_dist, dist[i])\n            dp[k][mask] = max_dist\n    \n    for k in range(2, n + 1):\n        for mask in range(1 << k):\n            count = bin(mask).count('1')\n            if count != k:\n                continue\n            for i in range(1, n + 1):\n                if mask & (1 << (i - 1)):\n                    new_mask = mask ^ (1 << (i - 1))\n                    dp[k][mask] = min(dp[k][mask], dp[k - 1][new_mask] + dist[i])\n    \n    for k in range(1, n + 1):\n        print(dp[k][(1 << k) - 1])\n\n# Read input\nn = int(input())\nedges = []\nfor _ in range(n - 1):\n    u, v, l = map(int, input().split())\n    edges.append((u, v, l))\n\n# Call the function\nmin_max_score(n, edges)"], "passed": [false], "raw_code": ["```python\nimport heapq\nfrom collections import defaultdict, deque\n\ndef dijkstra(n, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[1] = 0\n    pq = [(0, 1)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n\ndef min_max_score(n, edges):\n    dist = dijkstra(n, edges)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for k in range(1, n + 1):\n        for mask in range(1 << k):\n            count = bin(mask).count('1')\n            if count != k:\n                continue\n            max_dist = 0\n            for i in range(1, n + 1):\n                if mask & (1 << (i - 1)):\n                    max_dist = max(max_dist, dist[i])\n            dp[k][mask] = max_dist\n    \n    for k in range(2, n + 1):\n        for mask in range(1 << k):\n            count = bin(mask).count('1')\n            if count != k:\n                continue\n            for i in range(1, n + 1):\n                if mask & (1 << (i - 1)):\n                    new_mask = mask ^ (1 << (i - 1))\n                    dp[k][mask] = min(dp[k][mask], dp[k - 1][new_mask] + dist[i])\n    \n    for k in range(1, n + 1):\n        print(dp[k][(1 << k) - 1])\n\n# Read input\nn = int(input())\nedges = []\nfor _ in range(n - 1):\n    u, v, l = map(int, input().split())\n    edges.append((u, v, l))\n\n# Call the function\nmin_max_score(n, edges)\n```"]}
{"task_id": "arc182_c", "codes": ["def calculate_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    total_score = 0\n    for k in range(1, N + 1):\n        total_score += (M ** k) * calculate_divisors(M ** k)\n        total_score %= MOD\n    return total_score\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    print(sum_of_scores(N, M))"], "passed": [false], "raw_code": ["def calculate_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    total_score = 0\n    for k in range(1, N + 1):\n        total_score += (M ** k) * calculate_divisors(M ** k)\n        total_score %= MOD\n    return total_score\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    print(sum_of_scores(N, M))"]}
{"task_id": "3560", "codes": ["def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance\n    return abs(kx - px) + abs(ky - py)\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    if n == 0:\n        return 0\n\n    # Sort positions based on their distance from the knight\n    positions.sort(key=lambda pos: min_moves_to_capture(kx, ky, pos[0], pos[1]))\n\n    total_moves = 0\n    alice_turn = True\n\n    while positions:\n        min_moves = float('inf')\n        best_pawn_index = -1\n\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves_to_capture(kx, ky, px, py)\n            if moves < min_moves:\n                min_moves = moves\n                best_pawn_index = i\n\n        if alice_turn:\n            total_moves += min_moves\n        else:\n            total_moves -= min_moves\n\n        del positions[best_pawn_index]\n        alice_turn = not alice_turn\n\n    return total_moves"], "passed": [false], "raw_code": ["def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance\n    return abs(kx - px) + abs(ky - py)\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    if n == 0:\n        return 0\n\n    # Sort positions based on their distance from the knight\n    positions.sort(key=lambda pos: min_moves_to_capture(kx, ky, pos[0], pos[1]))\n\n    total_moves = 0\n    alice_turn = True\n\n    while positions:\n        min_moves = float('inf')\n        best_pawn_index = -1\n\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves_to_capture(kx, ky, px, py)\n            if moves < min_moves:\n                min_moves = moves\n                best_pawn_index = i\n\n        if alice_turn:\n            total_moves += min_moves\n        else:\n            total_moves -= min_moves\n\n        del positions[best_pawn_index]\n        alice_turn = not alice_turn\n\n    return total_moves"]}
{"task_id": "arc182_a", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    P = []\n    V = []\n    index = 2\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize the set of valid states\n    valid_states = {(0,) * N}\n    \n    for p, v in zip(P, V):\n        new_valid_states = set()\n        for state in valid_states:\n            if state[p - 1] <= v:\n                new_state = list(state)\n                new_state[:p] = [v] * p\n                new_valid_states.add(tuple(new_state))\n            if state[-1] <= v:\n                new_state = list(state)\n                new_state[p - 1:] = [v] * (N - p + 1)\n                new_valid_states.add(tuple(new_state))\n        valid_states = new_valid_states\n    \n    # Count the number of valid sequences\n    result = len(valid_states)\n    print(result % MOD)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    P = []\n    V = []\n    index = 2\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize the set of valid states\n    valid_states = {(0,) * N}\n    \n    for p, v in zip(P, V):\n        new_valid_states = set()\n        for state in valid_states:\n            if state[p - 1] <= v:\n                new_state = list(state)\n                new_state[:p] = [v] * p\n                new_valid_states.add(tuple(new_state))\n            if state[-1] <= v:\n                new_state = list(state)\n                new_state[p - 1:] = [v] * (N - p + 1)\n                new_valid_states.add(tuple(new_state))\n        valid_states = new_valid_states\n    \n    # Count the number of valid sequences\n    result = len(valid_states)\n    print(result % MOD)\n\nmain()\n```"]}
{"task_id": "abc370_g", "codes": ["def sum_of_divisors(n):\n    divisors_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors_sum[j] += i\n    return divisors_sum\n\ndef is_good_integer(n, divisors_sum):\n    return divisors_sum[n] % 3 == 0\n\ndef count_good_sequences(N, M):\n    MOD = 998244353\n    divisors_sum = sum_of_divisors(N)\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][1] = 1\n\n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            if is_good_integer(j, divisors_sum):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                dp[i][j] %= MOD\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n    return dp[M][N]\n\n# Read input\nN, M = map(int, input().split())\n\n# Output the result\nprint(count_good_sequences(N, M))"], "passed": [false], "raw_code": ["```python\ndef sum_of_divisors(n):\n    divisors_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors_sum[j] += i\n    return divisors_sum\n\ndef is_good_integer(n, divisors_sum):\n    return divisors_sum[n] % 3 == 0\n\ndef count_good_sequences(N, M):\n    MOD = 998244353\n    divisors_sum = sum_of_divisors(N)\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][1] = 1\n\n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            if is_good_integer(j, divisors_sum):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                dp[i][j] %= MOD\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n    return dp[M][N]\n\n# Read input\nN, M = map(int, input().split())\n\n# Output the result\nprint(count_good_sequences(N, M))\n```"]}
{"task_id": "3527", "codes": ["def count_alternating_groups(colors, queries):\n    n = len(colors)\n    # Convert circular array to linear by appending the first element at the end\n    colors += colors[:1]\n    \n    # Dictionary to store the counts of alternating groups of different sizes\n    group_counts = {}\n    \n    def add_group(size):\n        if size not in group_counts:\n            group_counts[size] = 0\n        group_counts[size] += 1\n    \n    def remove_group(size):\n        if size in group_counts:\n            group_counts[size] -= 1\n            if group_counts[size] == 0:\n                del group_counts[size]\n    \n    # Initial count of alternating groups\n    for i in range(n):\n        if colors[i] != colors[(i + 1) % n]:\n            add_group(2)\n    \n    result = []\n    \n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(group_counts.get(size, 0))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            \n            # Remove old group(s)\n            if old_color != colors[(index + 1) % n]:\n                remove_group(2)\n            if old_color != colors[(index - 1) % n]:\n                remove_group(2)\n            if old_color != colors[(index + size) % n]:\n                remove_group(size)\n            if old_color != colors[(index - size) % n]:\n                remove_group(size)\n            \n            # Add new group(s)\n            colors[index] = new_color\n            if new_color != colors[(index + 1) % n]:\n                add_group(2)\n            if new_color != colors[(index - 1) % n]:\n                add_group(2)\n            if new_color != colors[(index + size) % n]:\n                add_group(size)\n            if new_color != colors[(index - size) % n]:\n                add_group(size)\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef count_alternating_groups(colors, queries):\n    n = len(colors)\n    # Convert circular array to linear by appending the first element at the end\n    colors += colors[:1]\n    \n    # Dictionary to store the counts of alternating groups of different sizes\n    group_counts = {}\n    \n    def add_group(size):\n        if size not in group_counts:\n            group_counts[size] = 0\n        group_counts[size] += 1\n    \n    def remove_group(size):\n        if size in group_counts:\n            group_counts[size] -= 1\n            if group_counts[size] == 0:\n                del group_counts[size]\n    \n    # Initial count of alternating groups\n    for i in range(n):\n        if colors[i] != colors[(i + 1) % n]:\n            add_group(2)\n    \n    result = []\n    \n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(group_counts.get(size, 0))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            \n            # Remove old group(s)\n            if old_color != colors[(index + 1) % n]:\n                remove_group(2)\n            if old_color != colors[(index - 1) % n]:\n                remove_group(2)\n            if old_color != colors[(index + size) % n]:\n                remove_group(size)\n            if old_color != colors[(index - size) % n]:\n                remove_group(size)\n            \n            # Add new group(s)\n            colors[index] = new_color\n            if new_color != colors[(index + 1) % n]:\n                add_group(2)\n            if new_color != colors[(index - 1) % n]:\n                add_group(2)\n            if new_color != colors[(index + size) % n]:\n                add_group(size)\n            if new_color != colors[(index - size) % n]:\n                add_group(size)\n    \n    return result\n```"]}
{"task_id": "abc372_e", "codes": ["from sortedcontainers import SortedList\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = {i: SortedList() for i in range(1, N + 1)}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            \n            adj_list[u].add(v)\n            adj_list[v].add(u)\n        \n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            if len(adj_list[v]) < k:\n                results.append(-1)\n            else:\n                results.append(adj_list[v][-k])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\nfrom sortedcontainers import SortedList\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = {i: SortedList() for i in range(1, N + 1)}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            \n            adj_list[u].add(v)\n            adj_list[v].add(u)\n        \n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            if len(adj_list[v]) < k:\n                results.append(-1)\n            else:\n                results.append(adj_list[v][-k])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "arc182_d", "codes": ["def min_operations_to_transform(N, M, A, B):\n    def count_operations(x, y):\n        return min(abs(x - y), M - abs(x - y))\n    \n    total_operations = 0\n    \n    for i in range(N):\n        if A[i] != B[i]:\n            if (i == 0 or A[i-1] != A[i]) and (i == N-1 or A[i+1] != A[i]):\n                total_operations += count_operations(A[i], B[i])\n            elif (i == 0 or B[i-1] != B[i]) and (i == N-1 or B[i+1] != B[i]):\n                total_operations += count_operations(B[i], A[i])\n            else:\n                return -1\n    \n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)"], "passed": [false], "raw_code": ["```python\ndef min_operations_to_transform(N, M, A, B):\n    def count_operations(x, y):\n        return min(abs(x - y), M - abs(x - y))\n    \n    total_operations = 0\n    \n    for i in range(N):\n        if A[i] != B[i]:\n            if (i == 0 or A[i-1] != A[i]) and (i == N-1 or A[i+1] != A[i]):\n                total_operations += count_operations(A[i], B[i])\n            elif (i == 0 or B[i-1] != B[i]) and (i == N-1 or B[i+1] != B[i]):\n                total_operations += count_operations(B[i], A[i])\n            else:\n                return -1\n    \n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)\n```"]}
{"task_id": "abc371_f", "codes": ["def min_movements(N, X, Q, tasks):\n    # Sort tasks based on the target position\n    tasks.sort(key=lambda x: x[1])\n    # Initialize the current positions of people\n    current_positions = X[:]\n    # Initialize the total number of movements\n    total_moves = 0\n    # Process each task\n    for t, g in tasks:\n        # Find the index of the person who needs to move to the target position\n        idx = t - 1\n        # Calculate the distance to the target position\n        distance = abs(current_positions[idx] - g)\n        # Move the person to the target position\n        current_positions[idx] = g\n        # Add the distance to the total number of movements\n        total_moves += distance\n    # Return the total number of movements\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input data\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\ntasks = [(int(data[N+2 + 2*i]), int(data[N+3 + 2*i])) for i in range(Q)]\n\n# Call the function and print the result\nprint(min_movements(N, X, Q, tasks))"], "passed": [false], "raw_code": ["def min_movements(N, X, Q, tasks):\n    # Sort tasks based on the target position\n    tasks.sort(key=lambda x: x[1])\n    # Initialize the current positions of people\n    current_positions = X[:]\n    # Initialize the total number of movements\n    total_moves = 0\n    # Process each task\n    for t, g in tasks:\n        # Find the index of the person who needs to move to the target position\n        idx = t - 1\n        # Calculate the distance to the target position\n        distance = abs(current_positions[idx] - g)\n        # Move the person to the target position\n        current_positions[idx] = g\n        # Add the distance to the total number of movements\n        total_moves += distance\n    # Return the total number of movements\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input data\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\ntasks = [(int(data[N+2 + 2*i]), int(data[N+3 + 2*i])) for i in range(Q)]\n\n# Call the function and print the result\nprint(min_movements(N, X, Q, tasks))"]}
{"task_id": "3551", "codes": ["def max_xor_subarray(nums, queries):\n    def insert(trie, num):\n        node = trie\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n    \n    def search_max_xor(trie, num):\n        node = trie\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node:\n                xor_val |= (1 << i)\n                node = node[1 - bit]\n            else:\n                node = node[bit]\n        return xor_val\n    \n    trie = {}\n    prefix_xor = [0] * (len(nums) + 1)\n    result = []\n    \n    # Compute prefix XOR array\n    for i in range(len(nums)):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n        insert(trie, prefix_xor[i + 1])\n    \n    # Process each query\n    for l, r in queries:\n        max_xor = search_max_xor(trie, prefix_xor[l] ^ prefix_xor[r + 1])\n        result.append(max_xor)\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef max_xor_subarray(nums, queries):\n    def insert(trie, num):\n        node = trie\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n    \n    def search_max_xor(trie, num):\n        node = trie\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node:\n                xor_val |= (1 << i)\n                node = node[1 - bit]\n            else:\n                node = node[bit]\n        return xor_val\n    \n    trie = {}\n    prefix_xor = [0] * (len(nums) + 1)\n    result = []\n    \n    # Compute prefix XOR array\n    for i in range(len(nums)):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n        insert(trie, prefix_xor[i + 1])\n    \n    # Process each query\n    for l, r in queries:\n        max_xor = search_max_xor(trie, prefix_xor[l] ^ prefix_xor[r + 1])\n        result.append(max_xor)\n    \n    return result\n```"]}
{"task_id": "3550", "codes": ["def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    potential_rows = [i for i, total in enumerate(row_sums) if total != 0]\n    potential_cols = [j for j, total in enumerate(col_sums) if total != 0]\n    \n    max_sum = float('-inf')\n    for r1 in potential_rows:\n        for c1 in potential_cols:\n            for r2 in potential_rows:\n                if r2 == r1:\n                    continue\n                for c2 in potential_cols:\n                    if c2 == c1 or c2 == c1:\n                        continue\n                    for r3 in potential_rows:\n                        if r3 == r1 or r3 == r2:\n                            continue\n                        for c3 in potential_cols:\n                            if c3 == c1 or c3 == c2 or c3 == c1:\n                                continue\n                            current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                            max_sum = max(max_sum, current_sum)\n    \n    return max_sum"], "passed": [false], "raw_code": ["```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    potential_rows = [i for i, total in enumerate(row_sums) if total != 0]\n    potential_cols = [j for j, total in enumerate(col_sums) if total != 0]\n    \n    max_sum = float('-inf')\n    for r1 in potential_rows:\n        for c1 in potential_cols:\n            for r2 in potential_rows:\n                if r2 == r1:\n                    continue\n                for c2 in potential_cols:\n                    if c2 == c1 or c2 == c1:\n                        continue\n                    for r3 in potential_rows:\n                        if r3 == r1 or r3 == r2:\n                            continue\n                        for c3 in potential_cols:\n                            if c3 == c1 or c3 == c2 or c3 == c1:\n                                continue\n                            current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"]}
{"task_id": "3580", "codes": ["def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1"], "passed": [false], "raw_code": ["```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"]}
{"task_id": "3571", "codes": ["def maxIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Build adjacency list and indegree count\n    n = len(coordinates)\n    adj_list = defaultdict(list)\n    indegree = [0] * n\n    \n    for i in range(n):\n        x1, y1 = coordinates[i]\n        for j in range(i + 1, n):\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                adj_list[i].append(j)\n                indegree[j] += 1\n    \n    # Step 3: Topological sort using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        u = queue.popleft()\n        for v in adj_list[u]:\n            dp[v] = max(dp[v], dp[u] + 1)\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    return dp[k]"], "passed": [false], "raw_code": ["```python\ndef maxIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Build adjacency list and indegree count\n    n = len(coordinates)\n    adj_list = defaultdict(list)\n    indegree = [0] * n\n    \n    for i in range(n):\n        x1, y1 = coordinates[i]\n        for j in range(i + 1, n):\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                adj_list[i].append(j)\n                indegree[j] += 1\n    \n    # Step 3: Topological sort using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        u = queue.popleft()\n        for v in adj_list[u]:\n            dp[v] = max(dp[v], dp[u] + 1)\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    return dp[k]\n```"]}
{"final_accuracy": "0.00%"}
