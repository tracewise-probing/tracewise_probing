{"difficulty": "hard", "num_threads": 32, "temperature": 0.9, "n": 8, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp09_bug_trace_TPL_NEXT_qwen_7b_hard_n_8.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "import sys\n\ndef count_prime_factors(n):\n    count = 0\n    # Check for number of 2s in n\n    while n % 2 == 0:\n        count += 1\n        n //= 2\n    # Check for other primes\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            count += 1\n            n //= i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        count += 1\n    return count\n\ndef determine_winner():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_factors = sum(count_prime_factors(x) for x in A)\n    \n    if total_factors % 2 == 0:\n        print(\"Bruno\")\n    else:\n        print(\"Anna\")\n\ndetermine_winner()", "passed": false, "raw_code": "```python\nimport sys\n\ndef count_prime_factors(n):\n    count = 0\n    # Check for number of 2s in n\n    while n % 2 == 0:\n        count += 1\n        n //= 2\n    # Check for other primes\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            count += 1\n            n //= i\n    # This condition is to check if n is a prime number greater than 2\n    if n > 2:\n        count += 1\n    return count\n\ndef determine_winner():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_factors = sum(count_prime_factors(x) for x in A)\n    \n    if total_factors % 2 == 0:\n        print(\"Bruno\")\n    else:\n        print(\"Anna\")\n\ndetermine_winner()\n```"}
{"task_id": "abc366_f", "code": "i", "passed": false, "raw_code": "```python\nimport sys\n\ndef max_nested_function_value(n, k, functions):\n    max_value = float('-inf')\n    memo = [[0] * (k + 1) for _ in range(n + 1)]\n\n    def compose(i, j):\n        if memo[i][j] != 0:\n            return memo[i][j]\n        if j == 0:\n            memo[i][j] = 1\n        else:\n            memo[i][j] = functions[i - 1][0] * compose(i, j - 1) + functions[i - 1][1]\n        return memo[i][j]\n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if compose(i, j) > max_value:\n                max_value = compose(i, j)\n\n    return max_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    functions = []\n    \n    index = 2\n    for _ in range(n):\n        a = int(data[index])\n        b = int(data[index + 1])\n        functions.append((a, b))\n        index += 2\n    \n    result = max_nested_function_value(n, k, functions)\n    print(result)\n\nmain()"}
{"task_id": "abc371_f", "code": "d", "passed": false, "raw_code": "```python\ndef min_movements():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read the number of persons\n    N = int(data[0])\n    \n    # Read the initial positions of the persons\n    X = [int(data[i]) for i in range(1, N + 1)]\n    \n    # Read the number of tasks\n    Q = int(data[N + 1])\n    \n    # Initialize the index pointer for reading tasks\n    index = N + 2\n    \n    # Calculate the total number of movements required\n    total_movements = 0\n    \n    for _ in range(Q):\n        T = int(data[index])\n        G = int(data[index + 1])\n        index += 2\n        \n        # Calculate the absolute difference between the current position and the target position\n        current_position = X[T - 1]\n        total_movements += abs(current_position - G)\n    \n    # Print the total number of movements\n    print(total_movements)\n\nmin_movements()"}
{"task_id": "3532", "code": "def tree_marking_time(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    times = [0] * n\n    marked = [False] * n\n    \n    def bfs(start):\n        queue = deque([start])\n        marked[start] = True\n        times[start] = 0\n        \n        while queue:\n            node = queue.popleft()\n            current_time = times[node]\n            for neighbor in adj_list[node]:\n                if not marked[neighbor]:\n                    if node % 2 == 0:\n                        times[neighbor] = current_time + 2\n                    else:\n                        times[neighbor] = current_time + 1\n                    marked[neighbor] = True\n                    queue.append(neighbor)\n    \n    for i in range(n):\n        if not marked[i]:\n            bfs(i)\n    \n    return times[1:]", "passed": false, "raw_code": "```python\ndef tree_marking_time(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    times = [0] * n\n    marked = [False] * n\n    \n    def bfs(start):\n        queue = deque([start])\n        marked[start] = True\n        times[start] = 0\n        \n        while queue:\n            node = queue.popleft()\n            current_time = times[node]\n            for neighbor in adj_list[node]:\n                if not marked[neighbor]:\n                    if node % 2 == 0:\n                        times[neighbor] = current_time + 2\n                    else:\n                        times[neighbor] = current_time + 1\n                    marked[neighbor] = True\n                    queue.append(neighbor)\n    \n    for i in range(n):\n        if not marked[i]:\n            bfs(i)\n    \n    return times[1:]\n```"}
{"task_id": "arc181_c", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom itertools import product\n\ndef generate_grid(N, P, Q):\n    # Step 1: Generate all binary sequences of length N\n    binary_sequences = [''.join(p) for p in product('01', repeat=N)]\n    \n    # Step 2: Sort these sequences according to the permutation P\n    sorted_rows = [binary_sequences[i-1] for i in P]\n    \n    # Step 3: Rearrange the sequences to ensure columns are sorted according to Q\n    final_grid = []\n    for j in range(N):\n        column = ''.join(row[j] for row in sorted_rows)\n        sorted_column = ''.join(sorted(column))\n        final_grid.append(sorted_column)\n    \n    return '\\n'.join(final_grid)\n\n# Read input\nN = int(sys.stdin.readline().strip())\nP = list(map(int, sys.stdin.readline().strip().split()))\nQ = list(map(int, sys.stdin.readline().strip().split()))\n\n# Generate and print the grid\ngrid = generate_grid(N, P, Q)\nprint(grid)"}
{"task_id": "abc366_e", "code": "def count_valid_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    x_coords = []\n    y_coords = []\n    for i in range(N):\n        x_coords.append(int(data[index + 2 + 2 * i]))\n        y_coords.append(int(data[index + 3 + 2 * i]))\n    \n    # Sort coordinates to find medians\n    x_coords.sort()\n    y_coords.sort()\n    \n    # Function to calculate Manhattan distance\n    def manhattan_distance(x, y):\n        return sum(abs(x - xi) + abs(y - yi) for xi, yi in zip(x_coords, y_coords))\n    \n    # Count valid points using sliding window technique\n    count = 0\n    for x in range(-10**6, 10**6 + 1):\n        if manhattan_distance(x, 0) > D:\n            break\n        for y in range(-10**6, 10**6 + 1):\n            if manhattan_distance(x, y) <= D:\n                count += 1\n    \n    print(count)\n\ncount_valid_points()", "passed": false, "raw_code": "```python\ndef count_valid_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    x_coords = []\n    y_coords = []\n    for i in range(N):\n        x_coords.append(int(data[index + 2 + 2 * i]))\n        y_coords.append(int(data[index + 3 + 2 * i]))\n    \n    # Sort coordinates to find medians\n    x_coords.sort()\n    y_coords.sort()\n    \n    # Function to calculate Manhattan distance\n    def manhattan_distance(x, y):\n        return sum(abs(x - xi) + abs(y - yi) for xi, yi in zip(x_coords, y_coords))\n    \n    # Count valid points using sliding window technique\n    count = 0\n    for x in range(-10**6, 10**6 + 1):\n        if manhattan_distance(x, 0) > D:\n            break\n        for y in range(-10**6, 10**6 + 1):\n            if manhattan_distance(x, y) <= D:\n                count += 1\n    \n    print(count)\n\ncount_valid_points()\n```"}
{"task_id": "abc371_g", "code": "def smallest_permutation(N, P, A):\n    # Convert A to a list of tuples (value, index)\n    A = [(A[i], i) for i in range(N)]\n    \n    # Perform the sorting algorithm respecting the permutation P\n    for _ in range(N):\n        swapped = False\n        for i in range(1, N):\n            if A[(i - 1) % N][0] > A[i % N][0]:\n                A[(i - 1) % N], A[i % N] = A[i % N], A[(i - 1) % N]\n                swapped = True\n        if not swapped:\n            break\n    \n    # Extract the sorted values\n    result = [x[0] for x in A]\n    return ' '.join(map(str, result))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the result\nresult = smallest_permutation(N, P, A)\n\n# Print the result\nprint(result)", "passed": false, "raw_code": "```python\ndef smallest_permutation(N, P, A):\n    # Convert A to a list of tuples (value, index)\n    A = [(A[i], i) for i in range(N)]\n    \n    # Perform the sorting algorithm respecting the permutation P\n    for _ in range(N):\n        swapped = False\n        for i in range(1, N):\n            if A[(i - 1) % N][0] > A[i % N][0]:\n                A[(i - 1) % N], A[i % N] = A[i % N], A[(i - 1) % N]\n                swapped = True\n        if not swapped:\n            break\n    \n    # Extract the sorted values\n    result = [x[0] for x in A]\n    return ' '.join(map(str, result))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the result\nresult = smallest_permutation(N, P, A)\n\n# Print the result\nprint(result)\n```"}
{"task_id": "abc367_e", "code": "def find_cycle(position, X):\n    cycle = []\n    while True:\n        cycle.append(position)\n        position = X[position] - 1\n        if position in cycle:\n            break\n    return cycle\n\ndef apply_permutations(A, X, K):\n    N = len(A)\n    cycles = [find_cycle(i, X) for i in range(N)]\n    result = list(A)\n    \n    for i in range(N):\n        cycle = cycles[i]\n        position = cycle.index(i)\n        new_position = (position + K) % len(cycle)\n        result[i] = A[cycle[new_position]]\n    \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    X = list(map(int, data[2:N+2]))\n    A = list(map(int, data[N+2:]))\n    \n    result = apply_permutations(A, X, K)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef find_cycle(position, X):\n    cycle = []\n    while True:\n        cycle.append(position)\n        position = X[position] - 1\n        if position in cycle:\n            break\n    return cycle\n\ndef apply_permutations(A, X, K):\n    N = len(A)\n    cycles = [find_cycle(i, X) for i in range(N)]\n    result = list(A)\n    \n    for i in range(N):\n        cycle = cycles[i]\n        position = cycle.index(i)\n        new_position = (position + K) % len(cycle)\n        result[i] = A[cycle[new_position]]\n    \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    X = list(map(int, data[2:N+2]))\n    A = list(map(int, data[N+2:]))\n    \n    result = apply_permutations(A, X, K)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc372_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n\n        valid_pairs_count = 0\n\n        for i in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n\n            max_y = 0\n            for x in range(1, c // a + 1):\n                if b * x < c - a * x:\n                    max_y = max(max_y, (c - a * x) // b)\n\n            if max_y > 0:\n                valid_pairs_count += 1\n\n        results.append(valid_pairs_count)\n\n    for result in results:\n        print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    t = int(data[index])\n    index += 1\n\n    results = []\n\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n\n        valid_pairs_count = 0\n\n        for i in range(n):\n            a = int(data[index])\n            b = int(data[index + 1])\n            c = int(data[index + 2])\n            index += 3\n\n            max_y = 0\n            for x in range(1, c // a + 1):\n                if b * x < c - a * x:\n                    max_y = max(max_y, (c - a * x) // b)\n\n            if max_y > 0:\n                valid_pairs_count += 1\n\n        results.append(valid_pairs_count)\n\n    for result in results:\n        print(result)\n\nmain()\n```"}
{"task_id": "abc365_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Step 1: Compute the prefix XOR array\n    prefix_xor = [0]\n    current_xor = 0\n    for num in A:\n        current_xor ^= num\n        prefix_xor.append(current_xor)\n    \n    # Step 2: Initialize the result\n    total_sum = 0\n    \n    # Step 3: Iterate through all pairs (i, j) and compute the subarray XOR using prefix XOR\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            subarray_xor = prefix_xor[j] ^ prefix_xor[i - 1]\n            total_sum += subarray_xor\n    \n    # Step 4: Print the result\n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Step 1: Compute the prefix XOR array\n    prefix_xor = [0]\n    current_xor = 0\n    for num in A:\n        current_xor ^= num\n        prefix_xor.append(current_xor)\n    \n    # Step 2: Initialize the result\n    total_sum = 0\n    \n    # Step 3: Iterate through all pairs (i, j) and compute the subarray XOR using prefix XOR\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            subarray_xor = prefix_xor[j] ^ prefix_xor[i - 1]\n            total_sum += subarray_xor\n    \n    # Step 4: Print the result\n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        unique_elements = set()\n        for j in range(i, N):\n            unique_elements.add(A[j])\n            total_sum += len(unique_elements)\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        unique_elements = set()\n        for j in range(i, N):\n            unique_elements.add(A[j])\n            total_sum += len(unique_elements)\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc370_e", "code": "def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Iterate over each element in the array\n    for i in range(1, N + 1):\n        prefix_sum = [0]\n        current_sum = 0\n        \n        # Calculate prefix sums for the current element\n        for j in range(i):\n            current_sum += A[j]\n            prefix_sum.append(current_sum % (K + 1))\n        \n        # Update DP table\n        for j in range(K + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - A[i - 1]]) % MOD\n            for p in prefix_sum[:-1]:\n                if (p + A[i - 1]) % (K + 1) == j:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][p] + MOD) % MOD\n    \n    # Sum up all valid partitions where the sum of the last subsequence is not equal to K\n    result = 0\n    for j in range(K + 1):\n        if j != 0:\n            result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))", "passed": false, "raw_code": "```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Iterate over each element in the array\n    for i in range(1, N + 1):\n        prefix_sum = [0]\n        current_sum = 0\n        \n        # Calculate prefix sums for the current element\n        for j in range(i):\n            current_sum += A[j]\n            prefix_sum.append(current_sum % (K + 1))\n        \n        # Update DP table\n        for j in range(K + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - A[i - 1]]) % MOD\n            for p in prefix_sum[:-1]:\n                if (p + A[i - 1]) % (K + 1) == j:\n                    dp[i][j] = (dp[i][j] - dp[i - 1][p] + MOD) % MOD\n    \n    # Sum up all valid partitions where the sum of the last subsequence is not equal to K\n    result = 0\n    for j in range(K + 1):\n        if j != 0:\n            result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))\n```"}
{"task_id": "abc367_f", "code": "def can_rearrange_subsequence(A, B, l, r, L, R):\n    subseq_A = sorted(A[l-1:r])\n    subseq_B = sorted(B[L-1:R])\n    return subseq_A == subseq_B\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    for _ in range(Q):\n        l = int(data[index])\n        r = int(data[index + 1])\n        L = int(data[index + 2])\n        R = int(data[index + 3])\n        index += 4\n        \n        result = \"Yes\" if can_rearrange_subsequence(A, B, l, r, L, R) else \"No\"\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_rearrange_subsequence(A, B, l, r, L, R):\n    subseq_A = sorted(A[l-1:r])\n    subseq_B = sorted(B[L-1:R])\n    return subseq_A == subseq_B\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    for _ in range(Q):\n        l = int(data[index])\n        r = int(data[index + 1])\n        L = int(data[index + 2])\n        R = int(data[index + 3])\n        index += 4\n        \n        result = \"Yes\" if can_rearrange_subsequence(A, B, l, r, L, R) else \"No\"\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc372_f", "code": "d", "passed": false, "raw_code": "```python\ndef count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    edges = []\n    \n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    for k in range(K):\n        for i in range(1, N + 1):\n            dp[i][k + 1] = dp[i][k]\n            if i % N == 0:\n                dp[1][k + 1] = (dp[1][k + 1] + dp[N][k]) % MOD\n            else:\n                dp[i + 1][k + 1] = (dp[i + 1][k + 1] + dp[i][k]) % MOD\n            for X, Y in edges:\n                if X == i:\n                    dp[Y][k + 1] = (dp[Y][k + 1] + dp[X][k]) % MOD\n                if Y == i:\n                    dp[X][k + 1] = (dp[X][k + 1] + dp[Y][k]) % MOD\n    \n    result = sum(dp[i][K] for i in range(1, N + 1)) % MOD\n    print(result)\n\ncount_ways()"}
{"task_id": "abc372_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    graph = {}\n    \n    def add_edge(u, v):\n        if u not in graph:\n            graph[u] = set()\n        if v not in graph:\n            graph[v] = set()\n        graph[u].add(v)\n        graph[v].add(u)\n\n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            add_edge(u, v)\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            if v not in graph or len(graph[v]) < k:\n                results.append(-1)\n            else:\n                neighbors = sorted(list(graph[v]))\n                results.append(neighbors[-k])\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    graph = {}\n    \n    def add_edge(u, v):\n        if u not in graph:\n            graph[u] = set()\n        if v not in graph:\n            graph[v] = set()\n        graph[u].add(v)\n        graph[v].add(u)\n\n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            add_edge(u, v)\n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            if v not in graph or len(graph[v]) < k:\n                results.append(-1)\n            else:\n                neighbors = sorted(list(graph[v]))\n                results.append(neighbors[-k])\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc366_g", "code": "def solve_graph_xor(n, m, edges):\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, parent, assigned):\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor not in assigned:\n                assigned[neighbor] = assigned[node] ^ 1\n                if not dfs(neighbor, node, assigned):\n                    return False\n            elif assigned[neighbor] != assigned[node] ^ 1:\n                return False\n        return True\n\n    assigned = {1: 0}\n    if not dfs(1, None, assigned):\n        return 'No'\n\n    result = [assigned[i] + 1 for i in range(1, n + 1)]\n    return 'Yes\\n' + ' '.join(map(str, result))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\nlines = input().split()\nn = int(lines[0])\nm = int(lines[1])\nedges = [(int(lines[2 + 2 * i]), int(lines[3 + 2 * i])) for i in range(m)]\n\n# Print the result\nprint(solve_graph_xor(n, m, edges))", "passed": false, "raw_code": "def solve_graph_xor(n, m, edges):\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, parent, assigned):\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor not in assigned:\n                assigned[neighbor] = assigned[node] ^ 1\n                if not dfs(neighbor, node, assigned):\n                    return False\n            elif assigned[neighbor] != assigned[node] ^ 1:\n                return False\n        return True\n\n    assigned = {1: 0}\n    if not dfs(1, None, assigned):\n        return 'No'\n\n    result = [assigned[i] + 1 for i in range(1, n + 1)]\n    return 'Yes\\n' + ' '.join(map(str, result))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\nlines = input().split()\nn = int(lines[0])\nm = int(lines[1])\nedges = [(int(lines[2 + 2 * i]), int(lines[3 + 2 * i])) for i in range(m)]\n\n# Print the result\nprint(solve_graph_xor(n, m, edges))"}
{"task_id": "abc373_g", "code": "d", "passed": false, "raw_code": "```python\ndef find_non_intersecting_permutation():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = []\n    Q = []\n    \n    index = 1\n    for i in range(N):\n        P.append((int(data[index]), int(data[index + 1])))\n        index += 2\n    \n    for i in range(N):\n        Q.append((int(data[index]), int(data[index + 1])))\n        index += 2\n    \n    # Sort points P based on x-coordinate, and by y-coordinate if x-coordinates are the same\n    P.sort(key=lambda p: (p[0], p[1]))\n    \n    # Function to get the slope between two points\n    def slope(p1, p2):\n        return (p2[1] - p1[1]) / (p2[0] - p1[0])\n    \n    # Use a stack to keep track of the indices of points Q\n    stack = []\n    \n    for i in range(N):\n        while stack and slope(Q[i], P[i]) <= slope(Q[stack[-1]], P[i]):\n            stack.pop()\n        stack.append(i)\n    \n    if len(stack) == N:\n        result = ' '.join(map(str, [stack.index(i) + 1 for i in range(1, N + 1)]))\n        print(result)\n    else:\n        print(-1)\n\n# Call the function\nfind_non_intersecting_permutation()"}
{"task_id": "abc370_f", "code": "def min_weight_and_cut_lines(N, K, A):\n    def can_divide(min_weight):\n        total_weight = 0\n        num_groups = 0\n        ungifted = 0\n        cut_lines = 0\n        \n        for mass in A:\n            if total_weight + mass >= min_weight:\n                num_groups += 1\n                total_weight = mass\n                ungifted = 0\n            else:\n                total_weight += mass\n                ungifted += 1\n                if ungifted == 1:\n                    cut_lines += 1\n        \n        if num_groups == K:\n            return ungifted, cut_lines\n        return float('inf'), 0\n    \n    left, right = max(A), sum(A) // K\n    best_min_weight = 0\n    best_ungifted = float('inf')\n    best_cut_lines = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        ungifted, cut_lines = can_divide(mid)\n        if ungifted < best_ungifted:\n            best_ungifted = ungifted\n            best_min_weight = mid\n            best_cut_lines = cut_lines\n        elif ungifted == best_ungifted:\n            best_cut_lines = min(best_cut_lines, cut_lines)\n        left = mid + 1\n    \n    return best_min_weight, best_cut_lines\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Get the result\nresult = min_weight_and_cut_lines(N, K, A)\n\n# Print the result\nprint(result[0], result[1])", "passed": false, "raw_code": "```python\ndef min_weight_and_cut_lines(N, K, A):\n    def can_divide(min_weight):\n        total_weight = 0\n        num_groups = 0\n        ungifted = 0\n        cut_lines = 0\n        \n        for mass in A:\n            if total_weight + mass >= min_weight:\n                num_groups += 1\n                total_weight = mass\n                ungifted = 0\n            else:\n                total_weight += mass\n                ungifted += 1\n                if ungifted == 1:\n                    cut_lines += 1\n        \n        if num_groups == K:\n            return ungifted, cut_lines\n        return float('inf'), 0\n    \n    left, right = max(A), sum(A) // K\n    best_min_weight = 0\n    best_ungifted = float('inf')\n    best_cut_lines = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        ungifted, cut_lines = can_divide(mid)\n        if ungifted < best_ungifted:\n            best_ungifted = ungifted\n            best_min_weight = mid\n            best_cut_lines = cut_lines\n        elif ungifted == best_ungifted:\n            best_cut_lines = min(best_cut_lines, cut_lines)\n        left = mid + 1\n    \n    return best_min_weight, best_cut_lines\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Get the result\nresult = min_weight_and_cut_lines(N, K, A)\n\n# Print the result\nprint(result[0], result[1])\n```"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp1 = [1] * 51\n    dp2 = [1] * 51\n    result = 0\n    for num in nums:\n        new_dp1 = [0] * 51\n        new_dp2 = [0] * 51\n        for i in range(51):\n            if i + num <= 50:\n                new_dp1[i + num] += dp1[i]\n                new_dp1[i + num] %= MOD\n            if i <= num:\n                new_dp2[num - i] += dp2[i]\n                new_dp2[num - i] %= MOD\n        dp1 = new_dp1\n        dp2 = new_dp2\n        result += sum(dp1) + sum(dp2)\n        result %= MOD\n    return result", "passed": false, "raw_code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp1 = [1] * 51\n    dp2 = [1] * 51\n    result = 0\n    for num in nums:\n        new_dp1 = [0] * 51\n        new_dp2 = [0] * 51\n        for i in range(51):\n            if i + num <= 50:\n                new_dp1[i + num] += dp1[i]\n                new_dp1[i + num] %= MOD\n            if i <= num:\n                new_dp2[num - i] += dp2[i]\n                new_dp2[num - i] %= MOD\n        dp1 = new_dp1\n        dp2 = new_dp2\n        result += sum(dp1) + sum(dp2)\n        result %= MOD\n    return result"}
{"task_id": "abc373_f", "code": "def max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w_i = int(data[index])\n        v_i = int(data[index + 1])\n        index += 2\n        items.append((w_i, v_i))\n    \n    dp = [0] * (W + 1)\n    \n    for w_i, v_i in items:\n        for j in range(W, w_i - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j >= k * w_i:\n                    dp[j] = max(dp[j], dp[j - k * w_i] + k * v_i - k**2)\n                else:\n                    break\n    \n    print(max(dp))\n\nmax_happiness()", "passed": false, "raw_code": "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w_i = int(data[index])\n        v_i = int(data[index + 1])\n        index += 2\n        items.append((w_i, v_i))\n    \n    dp = [0] * (W + 1)\n    \n    for w_i, v_i in items:\n        for j in range(W, w_i - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j >= k * w_i:\n                    dp[j] = max(dp[j], dp[j - k * w_i] + k * v_i - k**2)\n                else:\n                    break\n    \n    print(max(dp))\n\nmax_happiness()\n```"}
{"task_id": "3563", "code": "def max_score(grid):\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    max_sum = float('-inf')\n    \n    def backtrack(row, col_used, current_sum):\n        nonlocal max_sum\n        \n        if row == n:\n            max_sum = max(max_sum, current_sum)\n            return\n        \n        for j in range(m):\n            if j not in col_used:\n                backtrack(row + 1, col_used | {j}, current_sum + grid[row][j])\n    \n    backtrack(0, set(), 0)\n    return max_sum", "passed": false, "raw_code": "```python\ndef max_score(grid):\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    max_sum = float('-inf')\n    \n    def backtrack(row, col_used, current_sum):\n        nonlocal max_sum\n        \n        if row == n:\n            max_sum = max(max_sum, current_sum)\n            return\n        \n        for j in range(m):\n            if j not in col_used:\n                backtrack(row + 1, col_used | {j}, current_sum + grid[row][j])\n    \n    backtrack(0, set(), 0)\n    return max_sum\n```"}
{"task_id": "abc367_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n\n    MOD = 998244353\n    total_sum = 0\n\n    for i in range(1 << N):\n        subseq = [A[j] for j in range(N) if i & (1 << j)]\n        xor_value = 0\n        for num in subseq:\n            xor_value ^= num\n\n        if len(subseq) % M == 0:\n            total_sum += pow(xor_value, K, MOD)\n            total_sum %= MOD\n\n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n\n    MOD = 998244353\n    total_sum = 0\n\n    for i in range(1 << N):\n        subseq = [A[j] for j in range(N) if i & (1 << j)]\n        xor_value = 0\n        for num in subseq:\n            xor_value ^= num\n\n        if len(subseq) % M == 0:\n            total_sum += pow(xor_value, K, MOD)\n            total_sum %= MOD\n\n    print(total_sum)\n\nmain()"}
{"task_id": "abc368_d", "code": "def find_lca(parent, depths, node1, node2):\n    while node1 != node2:\n        if depths[node1] > depths[node2]:\n            node1 = parent[node1]\n        else:\n            node2 = parent[node2]\n    return node1\n\ndef find_depths(graph, start, parent, depths):\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        for neighbor in graph[node]:\n            if neighbor != parent[node]:\n                parent[neighbor] = node\n                depths[neighbor] = depths[node] + 1\n                stack.append(neighbor)\n    return parent, depths\n\ndef find_min_vertices(N, edges, K, vertices):\n    graph = [[] for _ in range(N + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    parent = [-1] * (N + 1)\n    depths = [0] * (N + 1)\n    parent, depths = find_depths(graph, 1, parent, depths)\n    \n    lca = find_lca(parent, depths, vertices[0], vertices[1])\n    for i in range(2, K):\n        lca = find_lca(parent, depths, lca, vertices[i])\n    \n    return K - 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nedges = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(N - 1)]\nvertices = [int(data[N * 2 + 2 + i]) for i in range(K)]\n\nprint(find_min_vertices(N, edges, K, vertices))", "passed": false, "raw_code": "```python\ndef find_lca(parent, depths, node1, node2):\n    while node1 != node2:\n        if depths[node1] > depths[node2]:\n            node1 = parent[node1]\n        else:\n            node2 = parent[node2]\n    return node1\n\ndef find_depths(graph, start, parent, depths):\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        for neighbor in graph[node]:\n            if neighbor != parent[node]:\n                parent[neighbor] = node\n                depths[neighbor] = depths[node] + 1\n                stack.append(neighbor)\n    return parent, depths\n\ndef find_min_vertices(N, edges, K, vertices):\n    graph = [[] for _ in range(N + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    parent = [-1] * (N + 1)\n    depths = [0] * (N + 1)\n    parent, depths = find_depths(graph, 1, parent, depths)\n    \n    lca = find_lca(parent, depths, vertices[0], vertices[1])\n    for i in range(2, K):\n        lca = find_lca(parent, depths, lca, vertices[i])\n    \n    return K - 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nedges = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(N - 1)]\nvertices = [int(data[N * 2 + 2 + i]) for i in range(K)]\n\nprint(find_min_vertices(N, edges, K, vertices))\n```"}
{"task_id": "abc369_e", "code": "def floyd_warshall(n, edges):\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n    for u, v, t in edges:\n        u -= 1\n        v -= 1\n        dist[u][v] = min(dist[u][v], t)\n        dist[v][u] = min(dist[v][u], t)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ndef query(n, m, edges, q, queries):\n    dist = floyd_warshall(n, edges)\n    result = []\n    for qi, bridges in enumerate(queries):\n        dp = [[float('inf')] * (1 << len(bridges)) for _ in range(n)]\n        dp[0][0] = 0\n        for i in range(n):\n            for mask in range(1 << len(bridges)):\n                for j in range(len(bridges)):\n                    if mask & (1 << j):\n                        u, v, t = bridges[j]\n                        u -= 1\n                        v -= 1\n                        dp[i][mask] = min(dp[i][mask], dp[i][mask ^ (1 << j)] + dist[i][u - 1] + t)\n                        dp[i][mask] = min(dp[i][mask], dp[i][mask ^ (1 << j)] + dist[i][v - 1] + t)\n        result.append(dp[n - 1][(1 << len(bridges)) - 1])\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        t = int(data[index + 2])\n        edges.append((u, v, t))\n        index += 3\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        k = int(data[index])\n        index += 1\n        bridges = list(map(int, data[index:index + k]))\n        queries.append(bridges)\n        index += k\n    \n    result = query(n, m, edges, q, queries)\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef floyd_warshall(n, edges):\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dist[i][i] = 0\n    for u, v, t in edges:\n        u -= 1\n        v -= 1\n        dist[u][v] = min(dist[u][v], t)\n        dist[v][u] = min(dist[v][u], t)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ndef query(n, m, edges, q, queries):\n    dist = floyd_warshall(n, edges)\n    result = []\n    for qi, bridges in enumerate(queries):\n        dp = [[float('inf')] * (1 << len(bridges)) for _ in range(n)]\n        dp[0][0] = 0\n        for i in range(n):\n            for mask in range(1 << len(bridges)):\n                for j in range(len(bridges)):\n                    if mask & (1 << j):\n                        u, v, t = bridges[j]\n                        u -= 1\n                        v -= 1\n                        dp[i][mask] = min(dp[i][mask], dp[i][mask ^ (1 << j)] + dist[i][u - 1] + t)\n                        dp[i][mask] = min(dp[i][mask], dp[i][mask ^ (1 << j)] + dist[i][v - 1] + t)\n        result.append(dp[n - 1][(1 << len(bridges)) - 1])\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        t = int(data[index + 2])\n        edges.append((u, v, t))\n        index += 3\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        k = int(data[index])\n        index += 1\n        bridges = list(map(int, data[index:index + k]))\n        queries.append(bridges)\n        index += k\n    \n    result = query(n, m, edges, q, queries)\n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc181_d", "code": "def merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    \n    merged, inv_merge = merge_and_count(left, right)\n    \n    total_inversions = inv_left + inv_right + inv_merge\n    return merged, total_inversions\n\ndef merge_and_count(left, right):\n    result = []\n    i = j = inv_count = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result, inv_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    results = []\n    for k in A:\n        for i in range(1, k):\n            if P[i-1] > P[i]:\n                P[i-1], P[i] = P[i], P[i-1]\n        \n        sorted_P, inv_count = merge_sort_and_count(P)\n        results.append(inv_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, inv_left = merge_sort_and_count(arr[:mid])\n    right, inv_right = merge_sort_and_count(arr[mid:])\n    \n    merged, inv_merge = merge_and_count(left, right)\n    \n    total_inversions = inv_left + inv_right + inv_merge\n    return merged, total_inversions\n\ndef merge_and_count(left, right):\n    result = []\n    i = j = inv_count = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result, inv_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    results = []\n    for k in A:\n        for i in range(1, k):\n            if P[i-1] > P[i]:\n                P[i-1], P[i] = P[i], P[i-1]\n        \n        sorted_P, inv_count = merge_sort_and_count(P)\n        results.append(inv_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3550", "code": "def maxSumOfNonAttackingRooks(board):\n    m, n = len(board), len(board[0])\n    used_columns = set()\n    total_sum = 0\n    \n    for i in range(m):\n        max_val = float('-inf')\n        max_col = -1\n        \n        for j in range(n):\n            if j not in used_columns and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        \n        if max_col != -1:\n            used_columns.add(max_col)\n            total_sum += max_val\n    \n    return total_sum", "passed": false, "raw_code": "```python\ndef maxSumOfNonAttackingRooks(board):\n    m, n = len(board), len(board[0])\n    used_columns = set()\n    total_sum = 0\n    \n    for i in range(m):\n        max_val = float('-inf')\n        max_col = -1\n        \n        for j in range(n):\n            if j not in used_columns and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        \n        if max_col != -1:\n            used_columns.add(max_col)\n            total_sum += max_val\n    \n    return total_sum\n```"}
{"task_id": "abc373_e", "code": "d", "passed": false, "raw_code": "```python\ndef min_additional_votes():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    # Sort the votes to facilitate the calculation\n    sorted_A = sorted(A)\n    \n    # Calculate the total number of votes currently counted\n    current_votes = sum(A)\n    \n    # Calculate the remaining votes\n    remaining_votes = K - current_votes\n    \n    def can_win(votes_needed):\n        # Create a copy of sorted_A and update the votes for the target candidate\n        updated_votes = sorted_A[:]\n        updated_votes[i] += votes_needed\n        \n        # Count how many candidates have more votes than the target candidate\n        count_more_than_target = sum(1 for v in updated_votes if v > updated_votes[i])\n        \n        return count_more_than_target < M\n    \n    results = []\n    for i in range(N):\n        if A[i] >= K / M:\n            results.append(0)\n        else:\n            low, high = 0, remaining_votes\n            while low <= high:\n                mid = (low + high) // 2\n                if can_win(mid):\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            \n            if low > remaining_votes:\n                results.append(-1)\n            else:\n                results.append(low)\n    \n    print(\" \".join(map(str, results)))\n\nmin_additional_votes()"}
{"task_id": "abc368_e", "code": "import sys\n\ndef solve(N, M, X1, trains):\n    trains = sorted(trains, key=lambda x: x[2])\n    delays = [0] * M\n    delays[0] = X1\n    for i in range(1, M):\n        if trains[i][0] == trains[i-1][1] and trains[i][2] <= trains[i-1][3]:\n            delays[i] = max(0, trains[i-1][3] - trains[i][2] + delays[i-1] - delays[i])\n    return delays[1:]\n\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = [(int(data[3 + i*4]) - 1, int(data[4 + i*4]) - 1, int(data[5 + i*4]), int(data[6 + i*4])) for i in range(M)]\ndelays = solve(N, M, X1, trains)\nprint(' '.join(map(str, delays)))\n", "passed": false, "raw_code": "import sys\n\ndef solve(N, M, X1, trains):\n    trains = sorted(trains, key=lambda x: x[2])\n    delays = [0] * M\n    delays[0] = X1\n    for i in range(1, M):\n        if trains[i][0] == trains[i-1][1] and trains[i][2] <= trains[i-1][3]:\n            delays[i] = max(0, trains[i-1][3] - trains[i][2] + delays[i-1] - delays[i])\n    return delays[1:]\n\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = [(int(data[3 + i*4]) - 1, int(data[4 + i*4]) - 1, int(data[5 + i*4]), int(data[6 + i*4])) for i in range(M)]\ndelays = solve(N, M, X1, trains)\nprint(' '.join(map(str, delays)))\n"}
{"task_id": "arc181_b", "code": "def check_concatenated_strings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        # Function to generate the concatenated string based on X or Y\n        def generate_string(binary_str):\n            result = []\n            for bit in binary_str:\n                if bit == '0':\n                    result.append(S)\n                else:\n                    result.append(T)\n            return ''.join(result)\n        \n        # Try all possible T values\n        found_valid_T = False\n        for T in [ '', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' ]:\n            str_X = generate_string(X)\n            str_Y = generate_string(Y)\n            \n            if str_X == str_Y:\n                results.append('Yes')\n                found_valid_T = True\n                break\n        \n        if not found_valid_T:\n            results.append('No')\n    \n    # Print all results\n    for result in results:\n        print(result)\n\ncheck_concatenated_strings()", "passed": false, "raw_code": "```python\ndef check_concatenated_strings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        # Function to generate the concatenated string based on X or Y\n        def generate_string(binary_str):\n            result = []\n            for bit in binary_str:\n                if bit == '0':\n                    result.append(S)\n                else:\n                    result.append(T)\n            return ''.join(result)\n        \n        # Try all possible T values\n        found_valid_T = False\n        for T in [ '', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' ]:\n            str_X = generate_string(X)\n            str_Y = generate_string(Y)\n            \n            if str_X == str_Y:\n                results.append('Yes')\n                found_valid_T = True\n                break\n        \n        if not found_valid_T:\n            results.append('No')\n    \n    # Print all results\n    for result in results:\n        print(result)\n\ncheck_concatenated_strings()\n```"}
{"task_id": "arc182_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    remainders = []\n    for k in range(K):\n        min_remainder = min((C * k + a) % M for a in A)\n        remainders.append(min_remainder)\n    \n    result = sum(remainders)\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    remainders = []\n    for k in range(K):\n        min_remainder = min((C * k + a) % M for a in A)\n        remainders.append(min_remainder)\n    \n    result = sum(remainders)\n    print(result)\n\nmain()\n```"}
{"task_id": "arc182_d", "code": "def min_operations(N, M, A, B):\n    operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        if diff > M // 2:\n            diff = M - diff\n        operations += diff\n    return operations\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate the minimum number of operations required\nresult = min_operations(N, M, A, B)\n\n# Print the result\nprint(result)", "passed": false, "raw_code": "```python\ndef min_operations(N, M, A, B):\n    operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        if diff > M // 2:\n            diff = M - diff\n        operations += diff\n    return operations\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate the minimum number of operations required\nresult = min_operations(N, M, A, B)\n\n# Print the result\nprint(result)\n```"}
{"task_id": "3551", "code": "class TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(32, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[bit] is None:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(32, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if node.children[alt_bit] is not None:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    result = [0] * len(queries)\n    query_indices = list(range(len(queries)))\n    query_indices.sort(key=lambda i: queries[i][1])\n\n    trie = Trie()\n    current_xor = 0\n    left = 0\n\n    for i in query_indices:\n        l, r = queries[i]\n        while left <= r:\n            current_xor ^= nums[left]\n            trie.insert(current_xor)\n            left += 1\n\n        result[i] = trie.find_max_xor(current_xor)\n\n    return result", "passed": false, "raw_code": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(32, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[bit] is None:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(32, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if node.children[alt_bit] is not None:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    result = [0] * len(queries)\n    query_indices = list(range(len(queries)))\n    query_indices.sort(key=lambda i: queries[i][1])\n\n    trie = Trie()\n    current_xor = 0\n    left = 0\n\n    for i in query_indices:\n        l, r = queries[i]\n        while left <= r:\n            current_xor ^= nums[left]\n            trie.insert(current_xor)\n            left += 1\n\n        result[i] = trie.find_max_xor(current_xor)\n\n    return result\n```"}
{"task_id": "3552", "code": "def largest_k_palindrome(n, k):\n    half = '9' * ((n + 1) // 2)\n    while True:\n        num = int(half + half[:-1 if n % 2 == 0 else len(half) - 1][::-1])\n        if num % k == 0:\n            return str(num)\n        half = str(int(half) - 1)\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n, k):\n    half = '9' * ((n + 1) // 2)\n    while True:\n        num = int(half + half[:-1 if n % 2 == 0 else len(half) - 1][::-1])\n        if num % k == 0:\n            return str(num)\n        half = str(int(half) - 1)\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```\n\nThis code generates the largest n-digit palindrome and checks divisibility by k. If not divisible, it decrements the number and checks again until it finds the correct k-palindrome."}
{"task_id": "arc183_d", "code": "f", "passed": false, "raw_code": "```python\nfrom collections import deque\n\ndef bfs_to_leaves(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for a, b in edges:\n        adj_list[a-1].append(b-1)\n        adj_list[b-1].append(a-1)\n    \n    queue = deque()\n    visited = [False] * n\n    \n    # Initialize the queue with leaf nodes\n    for i in range(n):\n        if len(adj_list[i]) == 1:\n            queue.append(i)\n            visited[i] = True\n    \n    leaves = []\n    while queue:\n        node = queue.popleft()\n        leaves.append(node)\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    return leaves\n\ndef find_farthest_pair(leaves, adj_list):\n    def dfs(start, parent, dist):\n        max_dist = 0\n        max_node = start\n        for neighbor in adj_list[start]:\n            if neighbor != parent:\n                d, node = dfs(neighbor, start, dist + 1)\n                if d > max_dist:\n                    max_dist = d\n                    max_node = node\n        return max_dist, max_node\n    \n    _, furthest_node = dfs(leaves[0], -1, 0)\n    _, farthest_node_2 = dfs(furthest_node, -1, 0)\n    return (furthest_node + 1, farthest_node_2 + 1)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n-1)]\n    \n    leaves = bfs_to_leaves(n, edges)\n    results = []\n    \n    while len(leaves) >= 2:\n        x, y = find_farthest_pair(leaves, [[b for b in adj_list[a]] for a in leaves])\n        results.append((x, y))\n        leaves.remove(x-1)\n        leaves.remove(y-1)\n    \n    for x, y in results:\n        print(x, y)\n\nsolve()"}
{"task_id": "3531", "code": "def minimumDamage(power, damage, health):\n    n = len(damage)\n    # Sort enemies by damage output in descending order\n    enemies = sorted(range(n), key=lambda i: damage[i], reverse=True)\n    total_damage = 0\n    current_time = 0\n    \n    for i in enemies:\n        if health[i] > 0:\n            # Calculate the number of seconds to kill the enemy\n            seconds_to_kill = (health[i] + power - 1) // power\n            # Calculate the damage dealt to Bob during this time\n            damage_to_bob = seconds_to_kill * damage[i]\n            # Update the total damage and remaining time\n            total_damage += damage_to_bob\n            current_time += seconds_to_kill\n            # Update the health of the enemy\n            health[i] -= seconds_to_kill * power\n    \n    return total_damage", "passed": false, "raw_code": "```python\ndef minimumDamage(power, damage, health):\n    n = len(damage)\n    # Sort enemies by damage output in descending order\n    enemies = sorted(range(n), key=lambda i: damage[i], reverse=True)\n    total_damage = 0\n    current_time = 0\n    \n    for i in enemies:\n        if health[i] > 0:\n            # Calculate the number of seconds to kill the enemy\n            seconds_to_kill = (health[i] + power - 1) // power\n            # Calculate the damage dealt to Bob during this time\n            damage_to_bob = seconds_to_kill * damage[i]\n            # Update the total damage and remaining time\n            total_damage += damage_to_bob\n            current_time += seconds_to_kill\n            # Update the health of the enemy\n            health[i] -= seconds_to_kill * power\n    \n    return total_damage\n```"}
{"task_id": "3527", "code": "def count_alternating_groups(colors, queries):\n    def is_alternating_group(start, size):\n        for i in range(size):\n            if (i + start) % len(colors) == start:\n                continue\n            if colors[(i + start) % len(colors)] == colors[(i + start + 1) % len(colors)]:\n                return False\n        return True\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            count = 0\n            for start in range(len(colors)):\n                if is_alternating_group(start, size):\n                    count += 1\n            result.append(count)\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            if old_color != new_color:\n                colors[index] = new_color\n                # Check the two groups affected by this change\n                if is_alternating_group(index, 2):\n                    result[-1] -= 1\n                if is_alternating_group((index + 1) % len(colors), 2):\n                    result[-1] -= 1\n                if is_alternating_group(index, 2):\n                    result[-1] += 1\n                if is_alternating_group((index + 1) % len(colors), 2):\n                    result[-1] += 1\n    return result", "passed": false, "raw_code": "```python\ndef count_alternating_groups(colors, queries):\n    def is_alternating_group(start, size):\n        for i in range(size):\n            if (i + start) % len(colors) == start:\n                continue\n            if colors[(i + start) % len(colors)] == colors[(i + start + 1) % len(colors)]:\n                return False\n        return True\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            count = 0\n            for start in range(len(colors)):\n                if is_alternating_group(start, size):\n                    count += 1\n            result.append(count)\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            if old_color != new_color:\n                colors[index] = new_color\n                # Check the two groups affected by this change\n                if is_alternating_group(index, 2):\n                    result[-1] -= 1\n                if is_alternating_group((index + 1) % len(colors), 2):\n                    result[-1] -= 1\n                if is_alternating_group(index, 2):\n                    result[-1] += 1\n                if is_alternating_group((index + 1) % len(colors), 2):\n                    result[-1] += 1\n    return result\n```"}
{"task_id": "3560", "code": "def min_moves_to_capture(kx, ky, px, py):\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, d = queue.pop(0)\n        if cx == px and cy == py:\n            return d\n        for dx, dy in moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, d + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    min_moves = [min_moves_to_capture(kx, ky, px, py) for px, py in positions]\n    \n    # DP table initialization\n    dp = [[0] * (1 << n) for _ in range(n)]\n    \n    # iterate over all possible states\n    for state in range(1 << n):\n        for i in range(n):\n            if not (state & (1 << i)):\n                # calculate the number of moves for the current state\n                for j in range(n):\n                    if (state & (1 << j)) and j != i:\n                        dp[i][state] = max(dp[i][state], dp[j][state ^ (1 << i)] + min_moves[i])\n    \n    # find the maximum moves Alice can achieve\n    return max(dp[i][(1 << n) - 1] for i in range(n))\n\n# Function to get the maximum total number of moves Alice can achieve\ndef max_total_moves(kx, ky, positions):\n    alices_moves = []\n    for i in range(len(positions)):\n        alice_moves = [0]\n        for j in range(i+1, len(positions)):\n            captured_pawn = positions[j]\n            min_moves = min_moves_to_capture(kx, ky, captured_pawn[0], captured_pawn[1])\n            new_state = 1 << j\n            for state in range(1 << i):\n                alices_moves.append(alice_moves[-1] + min_moves + max_moves_alice(captured_pawn[0], captured_pawn[1], [positions[p] for p in range(len(positions)) if p != j and (state & (1 << p))]))\n        alices_moves.append(max(alice_moves))\n    return max(alices_moves)", "passed": false, "raw_code": "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    moves = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, d = queue.pop(0)\n        if cx == px and cy == py:\n            return d\n        for dx, dy in moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, d + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    min_moves = [min_moves_to_capture(kx, ky, px, py) for px, py in positions]\n    \n    # DP table initialization\n    dp = [[0] * (1 << n) for _ in range(n)]\n    \n    # iterate over all possible states\n    for state in range(1 << n):\n        for i in range(n):\n            if not (state & (1 << i)):\n                # calculate the number of moves for the current state\n                for j in range(n):\n                    if (state & (1 << j)) and j != i:\n                        dp[i][state] = max(dp[i][state], dp[j][state ^ (1 << i)] + min_moves[i])\n    \n    # find the maximum moves Alice can achieve\n    return max(dp[i][(1 << n) - 1] for i in range(n))\n\n# Function to get the maximum total number of moves Alice can achieve\ndef max_total_moves(kx, ky, positions):\n    alices_moves = []\n    for i in range(len(positions)):\n        alice_moves = [0]\n        for j in range(i+1, len(positions)):\n            captured_pawn = positions[j]\n            min_moves = min_moves_to_capture(kx, ky, captured_pawn[0], captured_pawn[1])\n            new_state = 1 << j\n            for state in range(1 << i):\n                alices_moves.append(alice_moves[-1] + min_moves + max_moves_alice(captured_pawn[0], captured_pawn[1], [positions[p] for p in range(len(positions)) if p != j and (state & (1 << p))]))\n        alices_moves.append(max(alice_moves))\n    return max(alices_moves)\n```"}
{"task_id": "arc183_b", "code": "def can_transform(A, B, K):\n    n = len(A)\n    used = [False] * n\n    \n    for b in B:\n        found = False\n        for i in range(n):\n            if not used[i] and abs(A[i] - b) <= K:\n                used[i] = True\n                found = True\n                break\n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        index += N\n        \n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_transform(A, B, K):\n    n = len(A)\n    used = [False] * n\n    \n    for b in B:\n        found = False\n        for i in range(n):\n            if not used[i] and abs(A[i] - b) <= K:\n                used[i] = True\n                found = True\n                break\n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        index += N\n        \n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc368_g", "code": "i", "passed": false, "raw_code": "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef build_segment_tree(arr):\n    n = len(arr)\n    tree = [float('inf')] * (4 * n)\n    \n    def build(index, start, end):\n        if start == end:\n            tree[index] = arr[start]\n            return tree[index]\n        \n        mid = (start + end) // 2\n        left_min = build(2 * index, start, mid)\n        right_min = build(2 * index + 1, mid + 1, end)\n        tree[index] = min(left_min, right_min)\n        return tree[index]\n    \n    build(1, 0, n - 1)\n    return tree\n\ndef update_segment_tree(tree, index, start, end, pos, new_val):\n    if start == end:\n        tree[index] = new_val\n        return\n    \n    mid = (start + end) // 2\n    if pos <= mid:\n        update_segment_tree(tree, 2 * index, start, mid, pos, new_val)\n    else:\n        update_segment_tree(tree, 2 * index + 1, mid + 1, end, pos, new_val)\n    \n    tree[index] = min(tree[2 * index], tree[2 * index + 1])\n\ndef query_segment_tree(tree, index, start, end, l, r):\n    if r < start or end < l:\n        return float('inf')\n    if l <= start and end <= r:\n        return tree[index]\n    \n    mid = (start + end) // 2\n    left_min = query_segment_tree(tree, 2 * index, start, mid, l, r)\n    right_min = query_segment_tree(tree, 2 * index + 1, mid + 1, end, l, r)\n    return min(left_min, right_min)\n\ndef process_queries(N, A, B, Q, queries):\n    A_tree = build_segment_tree(A)\n    B_tree = build_segment_tree(B)\n    \n    results = []\n    for query in queries:\n        t = int(query[0])\n        if t == 1:\n            _, i, x = map(int, query[1:])\n            update_segment_tree(A_tree, 1, 0, N - 1, i - 1, x)\n        elif t == 2:\n            _, i, x = map(int, query[1:])\n            update_segment_tree(B_tree, 1, 0, N - 1, i - 1, x)\n        elif t == 3:\n            _, l, r = map(int, query[1:])\n            v = 0\n            for i in range(l - 1, r):\n                v += query_segment_tree(A_tree, 1, 0, N - 1, i, i)\n                v *= query_segment_tree(B_tree, 1, 0, N - 1, i, i)\n            results.append(v)\n    \n    return results\n\n# Reading input\nN = int(data[0])\nA = list(map(int, data[1:N+1]))\nB = list(map(int, data[N+1:2*N+1]))\nQ = int(data[2*N+1])\nqueries = [data[2*N+2+i*3:2*N+5+i*3] for i in range(Q)]\n\n# Processing queries\nresults = process_queries(N, A, B, Q, queries)\n\n# Printing results\nfor result in results:\n    print(result)"}
{"task_id": "abc369_g", "code": "import sys\nfrom collections import defaultdict, deque\nfrom heapq import heappop, heappush\n\ndef min_max_score(N, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n\n    # Function to find the shortest path from node s to all other nodes\n    def dijkstra(s):\n        dist = [float('inf')] * (N + 1)\n        dist[s] = 0\n        pq = [(0, s)]\n        while pq:\n            current_dist, u = heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            for v, l in graph[u]:\n                distance = current_dist + l\n                if distance < dist[v]:\n                    dist[v] = distance\n                    heappush(pq, (distance, v))\n        return dist\n\n    # Calculate shortest distances from node 1 to all other nodes\n    dist_from_1 = dijkstra(1)\n\n    # Dynamic programming table to store the minimum score for each subset of vertices\n    dp = [[float('inf')] * (1 << N) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    # Fill the DP table\n    for k in range(1, N + 1):\n        for mask in range(1 << N):\n            for i in range(N + 1):\n                if mask & (1 << i):\n                    new_mask = mask ^ (1 << i)\n                    for j in range(N + 1):\n                        if new_mask & (1 << j):\n                            dp[k][mask] = min(dp[k][mask], dp[k - 1][new_mask] + dist_from_1[i] + dist_from_1[j])\n\n    # Extract the scores for each K\n    scores = [dp[k][(1 << k) - 1] for k in range(1, N + 1)]\n    return scores\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nedges = []\ni = 1\nfor _ in range(N - 1):\n    u = int(data[i])\n    v = int(data[i + 1])\n    l = int(data[i + 2])\n    edges.append((u, v, l))\n    i += 3\n\n# Compute and print the results\nresults = min_max_score(N, edges)\nfor result in results:\n    print(result)", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict, deque\nfrom heapq import heappop, heappush\n\ndef min_max_score(N, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n\n    # Function to find the shortest path from node s to all other nodes\n    def dijkstra(s):\n        dist = [float('inf')] * (N + 1)\n        dist[s] = 0\n        pq = [(0, s)]\n        while pq:\n            current_dist, u = heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            for v, l in graph[u]:\n                distance = current_dist + l\n                if distance < dist[v]:\n                    dist[v] = distance\n                    heappush(pq, (distance, v))\n        return dist\n\n    # Calculate shortest distances from node 1 to all other nodes\n    dist_from_1 = dijkstra(1)\n\n    # Dynamic programming table to store the minimum score for each subset of vertices\n    dp = [[float('inf')] * (1 << N) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    # Fill the DP table\n    for k in range(1, N + 1):\n        for mask in range(1 << N):\n            for i in range(N + 1):\n                if mask & (1 << i):\n                    new_mask = mask ^ (1 << i)\n                    for j in range(N + 1):\n                        if new_mask & (1 << j):\n                            dp[k][mask] = min(dp[k][mask], dp[k - 1][new_mask] + dist_from_1[i] + dist_from_1[j])\n\n    # Extract the scores for each K\n    scores = [dp[k][(1 << k) - 1] for k in range(1, N + 1)]\n    return scores\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nedges = []\ni = 1\nfor _ in range(N - 1):\n    u = int(data[i])\n    v = int(data[i + 1])\n    l = int(data[i + 2])\n    edges.append((u, v, l))\n    i += 3\n\n# Compute and print the results\nresults = min_max_score(N, edges)\nfor result in results:\n    print(result)"}
{"task_id": "arc183_c", "code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    total_permutations = factorial(N)\n    for l, r, x in conditions:\n        # Calculate the number of invalid permutations where max(L_i to R_i) == X_i\n        invalid_count = 0\n        for i in range(l - 1, r):\n            if x == i + 1:\n                invalid_count += factorial(r - i - 1) * factorial(i - l + 1)\n        total_permutations -= invalid_count\n    return total_permutations % MOD\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 998244353\n    return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = [(int(data[2 + 3 * i]), int(data[3 + 3 * i]), int(data[4 + 3 * i])) for i in range(M)]\n\n# Print the result\nprint(count_valid_permutations(N, M, conditions))\ncount_valid_permutations(N, M, conditions)", "passed": false, "raw_code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    total_permutations = factorial(N)\n    for l, r, x in conditions:\n        # Calculate the number of invalid permutations where max(L_i to R_i) == X_i\n        invalid_count = 0\n        for i in range(l - 1, r):\n            if x == i + 1:\n                invalid_count += factorial(r - i - 1) * factorial(i - l + 1)\n        total_permutations -= invalid_count\n    return total_permutations % MOD\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 998244353\n    return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = [(int(data[2 + 3 * i]), int(data[3 + 3 * i]), int(data[4 + 3 * i])) for i in range(M)]\n\n# Print the result\nprint(count_valid_permutations(N, M, conditions))\ncount_valid_permutations(N, M, conditions)"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def is_divisible(num, divisor):\n        return num % divisor == 0\n    \n    count = 0\n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    half_length = (n + 1) // 2\n    for digits in itertools.combinations_with_replacement(range(1, 10), half_length):\n        if len(set(digits)) > k:\n            continue\n        full_digits = digits + digits[:-1][::-1] if n % 2 == 0 else digits + digits[::-1][:-1]\n        num = int(''.join(map(str, full_digits)))\n        if is_palindrome(str(num)) and is_divisible(num, k):\n            count += 1\n    \n    return count", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def is_divisible(num, divisor):\n        return num % divisor == 0\n    \n    count = 0\n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    half_length = (n + 1) // 2\n    for digits in itertools.combinations_with_replacement(range(1, 10), half_length):\n        if len(set(digits)) > k:\n            continue\n        full_digits = digits + digits[:-1][::-1] if n % 2 == 0 else digits + digits[::-1][:-1]\n        num = int(''.join(map(str, full_digits)))\n        if is_palindrome(str(num)) and is_divisible(num, k):\n            count += 1\n    \n    return count\n```"}
{"task_id": "abc370_g", "code": "MOD = 998244353\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef smallest_power_of_primes(limit):\n    sp = [0] * (limit + 1)\n    for i in range(2, limit + 1):\n        if sp[i] == 0:\n            for j in range(i, limit + 1, i):\n                if sp[j] == 0:\n                    sp[j] = i\n    return sp\n\ndef count_good_integers(limit, max_factors):\n    dp = [[0] * (max_factors + 1) for _ in range(max_factors + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, limit + 1):\n        pf = prime_factors(i)\n        new_dp = [[0] * (max_factors + 1) for _ in range(max_factors + 1)]\n        for j in range(max_factors + 1):\n            for k in range(max_factors + 1):\n                if dp[j][k] > 0:\n                    new_dp[min(j + len(pf), max_factors)][min(k + max(pf.values()), max_factors)] += dp[j][k]\n                    new_dp[min(j + len(pf), max_factors)][k] += dp[j][k]\n        dp = new_dp\n    \n    return dp\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    limit = N\n    max_factors = 20  # Assuming the maximum number of distinct prime factors\n    \n    sp = smallest_power_of_primes(limit)\n    good_integers_count = count_good_integers(limit, max_factors)\n    \n    ans = 0\n    for i in range(M + 1):\n        ans += good_integers_count[i][i]\n        ans %= MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nMOD = 998244353\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef smallest_power_of_primes(limit):\n    sp = [0] * (limit + 1)\n    for i in range(2, limit + 1):\n        if sp[i] == 0:\n            for j in range(i, limit + 1, i):\n                if sp[j] == 0:\n                    sp[j] = i\n    return sp\n\ndef count_good_integers(limit, max_factors):\n    dp = [[0] * (max_factors + 1) for _ in range(max_factors + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, limit + 1):\n        pf = prime_factors(i)\n        new_dp = [[0] * (max_factors + 1) for _ in range(max_factors + 1)]\n        for j in range(max_factors + 1):\n            for k in range(max_factors + 1):\n                if dp[j][k] > 0:\n                    new_dp[min(j + len(pf), max_factors)][min(k + max(pf.values()), max_factors)] += dp[j][k]\n                    new_dp[min(j + len(pf), max_factors)][k] += dp[j][k]\n        dp = new_dp\n    \n    return dp\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    limit = N\n    max_factors = 20  # Assuming the maximum number of distinct prime factors\n    \n    sp = smallest_power_of_primes(limit)\n    good_integers_count = count_good_integers(limit, max_factors)\n    \n    ans = 0\n    for i in range(M + 1):\n        ans += good_integers_count[i][i]\n        ans %= MOD\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_a", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [0] * (Q + 1)\n    dp[0] = 1\n    \n    for i in range(1, Q + 1):\n        p = P[i - 1]\n        v = V[i - 1]\n        \n        new_dp = [0] * (Q + 1)\n        for j in range(i):\n            if dp[j] == 0:\n                continue\n            \n            # Replace prefix up to p\n            if p >= v:\n                new_dp[j] = (new_dp[j] + dp[j]) % MOD\n            \n            # Replace suffix starting from p\n            if p + 1 <= N and v >= max(V[j:i]):\n                new_dp[j] = (new_dp[j] + dp[j]) % MOD\n        \n        dp = new_dp\n    \n    print(dp[0])\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [0] * (Q + 1)\n    dp[0] = 1\n    \n    for i in range(1, Q + 1):\n        p = P[i - 1]\n        v = V[i - 1]\n        \n        new_dp = [0] * (Q + 1)\n        for j in range(i):\n            if dp[j] == 0:\n                continue\n            \n            # Replace prefix up to p\n            if p >= v:\n                new_dp[j] = (new_dp[j] + dp[j]) % MOD\n            \n            # Replace suffix starting from p\n            if p + 1 <= N and v >= max(V[j:i]):\n                new_dp[j] = (new_dp[j] + dp[j]) % MOD\n        \n        dp = new_dp\n    \n    print(dp[0])\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_c", "code": "def sum_of_divisors(n):\n    count = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            exponent = 1\n            while n % i == 0:\n                n //= i\n                exponent += 1\n            count *= exponent\n    if n > 1:\n        count *= 2\n    return count\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Precompute prime factorization counts\n    max_exponent = [0] * (M + 1)\n    for num in range(1, M + 1):\n        exp = 1\n        for factor in range(2, num + 1):\n            if num % factor == 0:\n                count = 1\n                while num % factor == 0:\n                    num //= factor\n                    count += 1\n                exp *= count\n    \n    dp = [[0] * (max_exponent[M] + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(max_exponent[M] + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= max_exponent[M]:\n                dp[i][j] += dp[i - 1][j - max_exponent[M]]\n            dp[i][j] %= MOD\n    \n    total_score = 0\n    for j in range(max_exponent[M] + 1):\n        total_score += sum_of_divisors(j + 1) * dp[N][j]\n        total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef sum_of_divisors(n):\n    count = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            exponent = 1\n            while n % i == 0:\n                n //= i\n                exponent += 1\n            count *= exponent\n    if n > 1:\n        count *= 2\n    return count\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Precompute prime factorization counts\n    max_exponent = [0] * (M + 1)\n    for num in range(1, M + 1):\n        exp = 1\n        for factor in range(2, num + 1):\n            if num % factor == 0:\n                count = 1\n                while num % factor == 0:\n                    num //= factor\n                    count += 1\n                exp *= count\n    \n    dp = [[0] * (max_exponent[M] + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(max_exponent[M] + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= max_exponent[M]:\n                dp[i][j] += dp[i - 1][j - max_exponent[M]]\n            dp[i][j] %= MOD\n    \n    total_score = 0\n    for j in range(max_exponent[M] + 1):\n        total_score += sum_of_divisors(j + 1) * dp[N][j]\n        total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3575", "code": "def maximum_xor(nums, k):\n    from itertools import combinations\n\n    max_xor = 0\n    n = len(nums)\n\n    for comb in combinations(nums, k):\n        part1 = 0\n        part2 = 0\n        for num in comb:\n            part1 |= num\n        for num in nums:\n            if num not in comb:\n                part2 |= num\n        max_xor = max(max_xor, part1 ^ part2)\n\n    return max_xor", "passed": false, "raw_code": "```python\ndef maximum_xor(nums, k):\n    from itertools import combinations\n\n    max_xor = 0\n    n = len(nums)\n\n    for comb in combinations(nums, k):\n        part1 = 0\n        part2 = 0\n        for num in comb:\n            part1 |= num\n        for num in nums:\n            if num not in comb:\n                part2 |= num\n        max_xor = max(max_xor, part1 ^ part2)\n\n    return max_xor\n```"}
{"task_id": "3571", "code": "def longestIncreasingPath(coordinates, k):\n    from collections import defaultdict\n    import heapq\n    \n    # Create a dictionary to store the neighbors of each point\n    neighbors = defaultdict(list)\n    coordinates_sorted = sorted(coordinates)\n    \n    # Helper function to get the index of a point in the coordinates list\n    def index(point):\n        return coordinates_sorted.index(point)\n    \n    # Populate the neighbors dictionary\n    for i in range(len(coordinates)):\n        x1, y1 = coordinates[i]\n        for j in range(i + 1, len(coordinates)):\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                neighbors[i].append(j)\n    \n    # Initialize the DP array with 1, as the minimum path length is 1\n    dp = [1] * len(coordinates)\n    \n    # Iterate through the coordinates and update the DP array\n    for i in range(len(coordinates)):\n        for neighbor in neighbors[i]:\n            if dp[neighbor] <= dp[i]:\n                dp[neighbor] = dp[i] + 1\n    \n    # Return the maximum value in the DP array\n    return dp[k]", "passed": false, "raw_code": "```python\ndef longestIncreasingPath(coordinates, k):\n    from collections import defaultdict\n    import heapq\n    \n    # Create a dictionary to store the neighbors of each point\n    neighbors = defaultdict(list)\n    coordinates_sorted = sorted(coordinates)\n    \n    # Helper function to get the index of a point in the coordinates list\n    def index(point):\n        return coordinates_sorted.index(point)\n    \n    # Populate the neighbors dictionary\n    for i in range(len(coordinates)):\n        x1, y1 = coordinates[i]\n        for j in range(i + 1, len(coordinates)):\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                neighbors[i].append(j)\n    \n    # Initialize the DP array with 1, as the minimum path length is 1\n    dp = [1] * len(coordinates)\n    \n    # Iterate through the coordinates and update the DP array\n    for i in range(len(coordinates)):\n        for neighbor in neighbors[i]:\n            if dp[neighbor] <= dp[i]:\n                dp[neighbor] = dp[i] + 1\n    \n    # Return the maximum value in the DP array\n    return dp[k]\n```"}
{"task_id": "3583", "code": "from math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Compute all unique GCDs and their frequencies\n    for i in range(n):\n        for j in range(i + 1, n):\n            current_gcd = gcd(nums[i], nums[j])\n            gcd_count[current_gcd] += 1\n    \n    # Reconstruct the sorted list of GCDs\n    sorted_gcds = []\n    for g, count in gcd_count.items():\n        sorted_gcds.extend([g] * count)\n    \n    # Answer each query\n    result = []\n    for query in queries:\n        result.append(sorted_gcds[query])\n    \n    return result", "passed": false, "raw_code": "```python\nfrom math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Compute all unique GCDs and their frequencies\n    for i in range(n):\n        for j in range(i + 1, n):\n            current_gcd = gcd(nums[i], nums[j])\n            gcd_count[current_gcd] += 1\n    \n    # Reconstruct the sorted list of GCDs\n    sorted_gcds = []\n    for g, count in gcd_count.items():\n        sorted_gcds.extend([g] * count)\n    \n    # Answer each query\n    result = []\n    for query in queries:\n        result.append(sorted_gcds[query])\n    \n    return result\n```"}
{"task_id": "3580", "code": "def smallest_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    def is_almost_equal(sub):\n        diff_count = 0\n        for i in range(m):\n            if sub[i] != pattern[i]:\n                diff_count += 1\n            if diff_count > 1:\n                return False\n        return True\n    \n    for i in range(n - m + 1):\n        if is_almost_equal(s[i:i+m]):\n            return i\n    return -1", "passed": false, "raw_code": "```python\ndef smallest_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    def is_almost_equal(sub):\n        diff_count = 0\n        for i in range(m):\n            if sub[i] != pattern[i]:\n                diff_count += 1\n            if diff_count > 1:\n                return False\n        return True\n    \n    for i in range(n - m + 1):\n        if is_almost_equal(s[i:i+m]):\n            return i\n    return -1\n```"}
{"final_accuracy": "0.00%"}
