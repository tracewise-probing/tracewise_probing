"{\"difficulty\": \"easy\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"microsoft/phi-4\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majoritybug_trace_TPL_OUR01_phi4_n_16_easy.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"microsoft/phi-4\", \"api_base\": \"http://10.96.183.224:63019/8001/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3555", "code": "def perform_operations(nums, k, multiplier):\n    for _ in range(k):\n        min_value = min(nums)\n        min_index = nums.index(min_value)\n        nums[min_index] *= multiplier\n    return nums\n", "passed": true, "raw_code": "def perform_operations(nums, k, multiplier):\n    for _ in range(k):\n        min_value = min(nums)\n        min_index = nums.index(min_value)\n        nums[min_index] *= multiplier\n    return nums\n"}
{"task_id": "3606", "code": "def minAfterDigitSum(nums):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n    \n    transformed_nums = [sum_of_digits(num) for num in nums]\n    return min(transformed_nums)\n", "passed": true, "raw_code": "def minAfterDigitSum(nums):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n    \n    transformed_nums = [sum_of_digits(num) for num in nums]\n    return min(transformed_nums)\n"}
{"task_id": "3567", "code": "def convert_date_to_binary(date):\n    parts = date.split('-')\n    binary_parts = [bin(int(part))[2:] for part in parts]\n    return '-'.join(binary_parts)\n", "passed": true, "raw_code": "def convert_date_to_binary(date):\n    parts = date.split('-')\n    binary_parts = [bin(int(part))[2:] for part in parts]\n    return '-'.join(binary_parts)\n"}
{"task_id": "3533", "code": "def final_snake_position(n, commands):\n    # Initialize starting position\n    position = 0\n\n    # Define movement directions\n    directions = {\n        \"UP\": -n,\n        \"DOWN\": n,\n        \"LEFT\": -1,\n        \"RIGHT\": 1\n    }\n\n    # Calculate new position based on commands\n    for command in commands:\n        move = directions[command]\n        \n        # Calculate new row and column\n        row, col = divmod(position, n)\n        \n        if command == \"UP\":\n            row -= 1\n        elif command == \"DOWN\":\n            row += 1\n        elif command == \"LEFT\":\n            col -= 1\n        elif command == \"RIGHT\":\n            col += 1\n        \n        # Ensure the snake stays within the grid boundaries\n        if 0 <= row < n and 0 <= col < n:\n            position = row * n + col\n    \n    return position\n", "passed": true, "raw_code": "def final_snake_position(n, commands):\n    # Initialize starting position\n    position = 0\n\n    # Define movement directions\n    directions = {\n        \"UP\": -n,\n        \"DOWN\": n,\n        \"LEFT\": -1,\n        \"RIGHT\": 1\n    }\n\n    # Calculate new position based on commands\n    for command in commands:\n        move = directions[command]\n        \n        # Calculate new row and column\n        row, col = divmod(position, n)\n        \n        if command == \"UP\":\n            row -= 1\n        elif command == \"DOWN\":\n            row += 1\n        elif command == \"LEFT\":\n            col -= 1\n        elif command == \"RIGHT\":\n            col += 1\n        \n        # Ensure the snake stays within the grid boundaries\n        if 0 <= row < n and 0 <= col < n:\n            position = row * n + col\n    \n    return position\n"}
{"task_id": "3568", "code": "def generate_key(num1, num2, num3):\n    # Convert each number to a zero-padded string of length 4\n    str_num1 = f\"{num1:04d}\"\n    str_num2 = f\"{num2:04d}\"\n    str_num3 = f\"{num3:04d}\"\n\n    # Determine the key by selecting the smallest digit among the i^th digits\n    key_digits = [\n        min(int(str_num1[i]), int(str_num2[i]), int(str_num3[i]))\n        for i in range(4)\n    ]\n\n    # Convert the list of digits to a string, and then to an integer to remove leading zeros\n    key = int(''.join(map(str, key_digits)))\n\n    return key\n", "passed": true, "raw_code": "def generate_key(num1, num2, num3):\n    # Convert each number to a zero-padded string of length 4\n    str_num1 = f\"{num1:04d}\"\n    str_num2 = f\"{num2:04d}\"\n    str_num3 = f\"{num3:04d}\"\n\n    # Determine the key by selecting the smallest digit among the i^th digits\n    key_digits = [\n        min(int(str_num1[i]), int(str_num2[i]), int(str_num3[i]))\n        for i in range(4)\n    ]\n\n    # Convert the list of digits to a string, and then to an integer to remove leading zeros\n    key = int(''.join(map(str, key_digits)))\n\n    return key\n"}
{"task_id": "3519", "code": "def count_winning_players(n, pick):\n    from collections import defaultdict\n\n    # Dictionary to track how many balls of each color each player has picked\n    picks_count = defaultdict(lambda: defaultdict(int))\n\n    # Fill the dictionary with counts\n    for player, color in pick:\n        picks_count[player][color] += 1\n\n    # Initialize the count of winning players\n    winning_players = 0\n\n    # Check each player if they win the game\n    for player in range(n):\n        # Count how many colors the player has picked the required number of balls\n        win_count = sum(1 for color_count in picks_count[player].values() if color_count >= player + 1)\n\n        # A player wins if they win in at least one color\n        if win_count > 0:\n            winning_players += 1\n\n    return winning_players\n", "passed": true, "raw_code": "def count_winning_players(n, pick):\n    from collections import defaultdict\n\n    # Dictionary to track how many balls of each color each player has picked\n    picks_count = defaultdict(lambda: defaultdict(int))\n\n    # Fill the dictionary with counts\n    for player, color in pick:\n        picks_count[player][color] += 1\n\n    # Initialize the count of winning players\n    winning_players = 0\n\n    # Check each player if they win the game\n    for player in range(n):\n        # Count how many colors the player has picked the required number of balls\n        win_count = sum(1 for color_count in picks_count[player].values() if color_count >= player + 1)\n\n        # A player wins if they win in at least one color\n        if win_count > 0:\n            winning_players += 1\n\n    return winning_players\n"}
{"task_id": "3553", "code": "def same_color_square(coordinate1: str, coordinate2: str) -> bool:\n    def get_square_color(coordinate: str) -> str:\n        column, row = coordinate[0], int(coordinate[1])\n        # Based on the chessboard pattern, a square is black if the sum of the \n        # column index and row index is odd; otherwise, it is white.\n        if (ord(column) - ord('a') + row) % 2 == 0:\n            return \"white\"\n        else:\n            return \"black\"\n    \n    return get_square_color(coordinate1) == get_square_color(coordinate2)\n", "passed": true, "raw_code": "def same_color_square(coordinate1: str, coordinate2: str) -> bool:\n    def get_square_color(coordinate: str) -> str:\n        column, row = coordinate[0], int(coordinate[1])\n        # Based on the chessboard pattern, a square is black if the sum of the \n        # column index and row index is odd; otherwise, it is white.\n        if (ord(column) - ord('a') + row) % 2 == 0:\n            return \"white\"\n        else:\n            return \"black\"\n    \n    return get_square_color(coordinate1) == get_square_color(coordinate2)\n"}
{"difficulty": "easy", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_no_public_tests", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "microsoft/phi-4", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majoritybug_trace_TPL_OUR01_phi4_n_16_easy.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "microsoft/phi-4", "api_base": "http://127.0.0.1:8002/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc373_a", "code": "def count_matching_lengths():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    count = 0\n    for i, s in enumerate(data, start=1):\n        if len(s) == i:\n            count += 1\n    \n    print(count)\n\n# Call the function\ncount_matching_lengths()\n", "passed": true, "raw_code": "def count_matching_lengths():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    count = 0\n    for i, s in enumerate(data, start=1):\n        if len(s) == i:\n            count += 1\n    \n    print(count)\n\n# Call the function\ncount_matching_lengths()\n"}
{"task_id": "abc372_a", "code": "def remove_dots():\n    import sys\n    input = sys.stdin.read().strip()\n    result = input.replace('.', '')\n    print(result)\n\n# Call the function after its definition\nremove_dots()\n", "passed": true, "raw_code": "def remove_dots():\n    import sys\n    input = sys.stdin.read().strip()\n    result = input.replace('.', '')\n    print(result)\n\n# Call the function after its definition\nremove_dots()\n"}
{"task_id": "abc365_a", "code": "def days_in_year():\n    import sys\n    input = sys.stdin.read\n    Y = int(input().strip())\n    \n    if Y % 400 == 0:\n        print(366)\n    elif Y % 100 == 0:\n        print(365)\n    elif Y % 4 == 0:\n        print(366)\n    else:\n        print(365)\n\n# Call the function when running the script\ndays_in_year()\n", "passed": true, "raw_code": "def days_in_year():\n    import sys\n    input = sys.stdin.read\n    Y = int(input().strip())\n    \n    if Y % 400 == 0:\n        print(366)\n    elif Y % 100 == 0:\n        print(365)\n    elif Y % 4 == 0:\n        print(366)\n    else:\n        print(365)\n\n# Call the function when running the script\ndays_in_year()\n"}
{"task_id": "abc370_a", "code": "def takahashi_snuke_decision():\n    # Read input from stdin\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 0 and R == 1:\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\n# Call the function\ntakahashi_snuke_decision()\n", "passed": true, "raw_code": "def takahashi_snuke_decision():\n    # Read input from stdin\n    L, R = map(int, input().split())\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 0 and R == 1:\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\n# Call the function\ntakahashi_snuke_decision()\n"}
{"task_id": "abc368_b", "code": "def takahashi_operations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    \n    while len(A) > 1 and any(x > 0 for x in A):\n        A.sort(reverse=True)\n        A[0] -= 1\n        A[1] -= 1\n        A = [x for x in A if x > 0]\n        count += 1\n    \n    print(count)\n\n# Call the function\ntakahashi_operations()\n", "passed": true, "raw_code": "def takahashi_operations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    \n    while len(A) > 1 and any(x > 0 for x in A):\n        A.sort(reverse=True)\n        A[0] -= 1\n        A[1] -= 1\n        A = [x for x in A if x > 0]\n        count += 1\n    \n    print(count)\n\n# Call the function\ntakahashi_operations()\n"}
{"task_id": "abc366_a", "code": "def determine_election_outcome():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N, T, A = map(int, data)\n    \n    # The number of remaining votes\n    remaining_votes = N - (T + A)\n    \n    # Determine if the outcome is decided\n    if T > A + remaining_votes or A > T + remaining_votes:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function\ndetermine_election_outcome()\n", "passed": true, "raw_code": "def determine_election_outcome():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    \n    N, T, A = map(int, data)\n    \n    # The number of remaining votes\n    remaining_votes = N - (T + A)\n    \n    # Determine if the outcome is decided\n    if T > A + remaining_votes or A > T + remaining_votes:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function\ndetermine_election_outcome()\n"}
{"task_id": "abc368_a", "code": "import sys\nimport io\n\ndef process_stack():\n    # Reassign stdin if needed (for testing purposes, should be standard input)\n    # sys.stdin = io.StringIO(\"6 2\\n1 2 1 2 1 2\\n\")  # Test with mock input\n    \n    # Read input\n    input_data = sys.stdin.read().strip().split()\n    \n    # Extract N and K\n    N = int(input_data[0])\n    K = int(input_data[1])\n    \n    # Extract the list of card integers\n    A = list(map(int, input_data[2:]))\n    \n    # Perform the operation\n    # Take the last K elements and move them to the front\n    result = A[-K:] + A[:-K]\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\n# Call the function\nprocess_stack()\n", "passed": true, "raw_code": "import sys\nimport io\n\ndef process_stack():\n    # Reassign stdin if needed (for testing purposes, should be standard input)\n    # sys.stdin = io.StringIO(\"6 2\\n1 2 1 2 1 2\\n\")  # Test with mock input\n    \n    # Read input\n    input_data = sys.stdin.read().strip().split()\n    \n    # Extract N and K\n    N = int(input_data[0])\n    K = int(input_data[1])\n    \n    # Extract the list of card integers\n    A = list(map(int, input_data[2:]))\n    \n    # Perform the operation\n    # Take the last K elements and move them to the front\n    result = A[-K:] + A[:-K]\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\n# Call the function\nprocess_stack()\n"}
{"task_id": "abc365_b", "code": "def find_second_largest_index():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    first_max = second_max = float('-inf')\n    first_index = second_index = -1\n    \n    for i in range(N):\n        if A[i] > first_max:\n            second_max, second_index = first_max, first_index\n            first_max, first_index = A[i], i + 1\n        elif A[i] > second_max:\n            second_max, second_index = A[i], i + 1\n    \n    print(second_index)\n\n# Call the function\nfind_second_largest_index()\n", "passed": true, "raw_code": "def find_second_largest_index():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    first_max = second_max = float('-inf')\n    first_index = second_index = -1\n    \n    for i in range(N):\n        if A[i] > first_max:\n            second_max, second_index = first_max, first_index\n            first_max, first_index = A[i], i + 1\n        elif A[i] > second_max:\n            second_max, second_index = A[i], i + 1\n    \n    print(second_index)\n\n# Call the function\nfind_second_largest_index()\n"}
{"task_id": "abc370_b", "code": "def find_final_element():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    A = []\n    \n    for i in range(N):\n        A.append(list(map(int, data[index:index + (i + 1)])))\n        index += (i + 1)\n    \n    current_element = 1\n    \n    for i in range(2, N + 1):\n        if current_element >= i:\n            current_element = A[current_element - 1][i - 1]\n        else:\n            current_element = A[i - 1][current_element - 1]\n    \n    print(current_element)\n\n# Call the function\nfind_final_element()\n", "passed": false, "raw_code": "def find_final_element():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    index = 1\n    A = []\n    \n    for i in range(N):\n        A.append(list(map(int, data[index:index + (i + 1)])))\n        index += (i + 1)\n    \n    current_element = 1\n    \n    for i in range(2, N + 1):\n        if current_element >= i:\n            current_element = A[current_element - 1][i - 1]\n        else:\n            current_element = A[i - 1][current_element - 1]\n    \n    print(current_element)\n\n# Call the function\nfind_final_element()\n"}
{"task_id": "abc367_b", "code": "def format_real_number():\n    # Read the input number as a string\n    x_str = input().strip()\n    \n    # Check if the number has a decimal point\n    if '.' in x_str:\n        # Split the number into integer and decimal parts\n        integer_part, decimal_part = x_str.split('.')\n        \n        # Remove trailing zeros from the decimal part\n        decimal_part = decimal_part.rstrip('0')\n        \n        # If the decimal part is empty, remove the decimal point\n        if decimal_part == '':\n            result = integer_part\n        else:\n            result = f\"{integer_part}.{decimal_part}\"\n    else:\n        # No decimal point, just print the integer part\n        result = x_str\n    \n    # Print the result\n    print(result)\n\n# Call the function\nformat_real_number()\n", "passed": true, "raw_code": "def format_real_number():\n    # Read the input number as a string\n    x_str = input().strip()\n    \n    # Check if the number has a decimal point\n    if '.' in x_str:\n        # Split the number into integer and decimal parts\n        integer_part, decimal_part = x_str.split('.')\n        \n        # Remove trailing zeros from the decimal part\n        decimal_part = decimal_part.rstrip('0')\n        \n        # If the decimal part is empty, remove the decimal point\n        if decimal_part == '':\n            result = integer_part\n        else:\n            result = f\"{integer_part}.{decimal_part}\"\n    else:\n        # No decimal point, just print the integer part\n        result = x_str\n    \n    # Print the result\n    print(result)\n\n# Call the function\nformat_real_number()\n"}
{"task_id": "abc367_a", "code": "import sys\n\ndef can_shout_love_for_takoyaki():\n    # Read input from stdin\n    A, B, C = map(int, sys.stdin.read().strip().split())\n    \n    # Determine the result based on sleeping and waking times\n    if B < C:\n        # Takahashi is asleep from B to C, and awake from C to B the next day\n        if not (B <= A < C):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        # Takahashi is asleep from B to 23, and from 0 to C\n        if not (A < C or B <= A):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\n# Call the function to execute\ncan_shout_love_for_takoyaki()\n", "passed": true, "raw_code": "import sys\n\ndef can_shout_love_for_takoyaki():\n    # Read input from stdin\n    A, B, C = map(int, sys.stdin.read().strip().split())\n    \n    # Determine the result based on sleeping and waking times\n    if B < C:\n        # Takahashi is asleep from B to C, and awake from C to B the next day\n        if not (B <= A < C):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        # Takahashi is asleep from B to 23, and from 0 to C\n        if not (A < C or B <= A):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\n# Call the function to execute\ncan_shout_love_for_takoyaki()\n"}
{"task_id": "abc371_a", "code": "def find_middle_brother():\n    import sys\n    input = sys.stdin.read().strip()\n    s_ab, s_ac, s_bc = input.split()\n\n    # Initialize possible orderings\n    possible_orders = []\n\n    # Define inequalities based on the input relationships\n    if s_ab == '<':\n        if s_ac == '<':\n            if s_bc == '<':\n                possible_orders.append(('A', 'B', 'C'))\n            else:\n                possible_orders.append(('A', 'C', 'B'))\n        else:\n            if s_bc == '<':\n                possible_orders.append(('B', 'A', 'C'))\n            else:\n                possible_orders.append(('C', 'A', 'B'))\n    else:\n        if s_ac == '<':\n            if s_bc == '<':\n                possible_orders.append(('B', 'C', 'A'))\n            else:\n                possible_orders.append(('C', 'B', 'A'))\n        else:\n            if s_bc == '<':\n                possible_orders.append(('C', 'A', 'B'))\n            else:\n                possible_orders.append(('A', 'C', 'B'))\n\n    # There's always one consistent ordering\n    middle_brother = possible_orders[0][1]\n    print(middle_brother)\n\n# Call the function\nfind_middle_brother()\n", "passed": false, "raw_code": "def find_middle_brother():\n    import sys\n    input = sys.stdin.read().strip()\n    s_ab, s_ac, s_bc = input.split()\n\n    # Initialize possible orderings\n    possible_orders = []\n\n    # Define inequalities based on the input relationships\n    if s_ab == '<':\n        if s_ac == '<':\n            if s_bc == '<':\n                possible_orders.append(('A', 'B', 'C'))\n            else:\n                possible_orders.append(('A', 'C', 'B'))\n        else:\n            if s_bc == '<':\n                possible_orders.append(('B', 'A', 'C'))\n            else:\n                possible_orders.append(('C', 'A', 'B'))\n    else:\n        if s_ac == '<':\n            if s_bc == '<':\n                possible_orders.append(('B', 'C', 'A'))\n            else:\n                possible_orders.append(('C', 'B', 'A'))\n        else:\n            if s_bc == '<':\n                possible_orders.append(('C', 'A', 'B'))\n            else:\n                possible_orders.append(('A', 'C', 'B'))\n\n    # There's always one consistent ordering\n    middle_brother = possible_orders[0][1]\n    print(middle_brother)\n\n# Call the function\nfind_middle_brother()\n"}
{"task_id": "abc371_b", "code": "def name_babies():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Extract N and M\n    N = int(data[0])\n    M = int(data[1])\n    \n    # Initialize data structure to keep track of the first male child in each family\n    first_male = [None] * (N + 1)\n    \n    # Iterate over each baby's data\n    index = 2\n    results = []\n    for _ in range(M):\n        A = int(data[index])\n        B = data[index + 1]\n        \n        if B == 'M':\n            if first_male[A] is None:\n                first_male[A] = True\n                results.append(\"Yes\")\n            else:\n                results.append(\"No\")\n        else:\n            results.append(\"No\")\n        \n        index += 2\n    \n    # Print results\n    for result in results:\n        print(result)\n\n# Call the function\nname_babies()\n", "passed": true, "raw_code": "def name_babies():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Extract N and M\n    N = int(data[0])\n    M = int(data[1])\n    \n    # Initialize data structure to keep track of the first male child in each family\n    first_male = [None] * (N + 1)\n    \n    # Iterate over each baby's data\n    index = 2\n    results = []\n    for _ in range(M):\n        A = int(data[index])\n        B = data[index + 1]\n        \n        if B == 'M':\n            if first_male[A] is None:\n                first_male[A] = True\n                results.append(\"Yes\")\n            else:\n                results.append(\"No\")\n        else:\n            results.append(\"No\")\n        \n        index += 2\n    \n    # Print results\n    for result in results:\n        print(result)\n\n# Call the function\nname_babies()\n"}
{"task_id": "abc366_b", "code": "def convert_to_vertical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    strings = data[1:N+1]\n    \n    M = max(len(s) for s in strings)\n    \n    # Initialize T_i lists with '*'\n    T = [['*' for _ in range(M)] for _ in range(M)]\n    \n    for i, s in enumerate(strings):\n        for j in range(len(s)):\n            T[M-j-1][i] = s[j]\n    \n    # Ensure no T_i ends with '*'\n    for i in range(M):\n        if T[i][-1] == '*':\n            T[i][-1] = '\\n'\n    \n    # Print the result\n    for row in T:\n        print(''.join(row).strip())\n\n# Call the function\nconvert_to_vertical()\n", "passed": false, "raw_code": "def convert_to_vertical():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    strings = data[1:N+1]\n    \n    M = max(len(s) for s in strings)\n    \n    # Initialize T_i lists with '*'\n    T = [['*' for _ in range(M)] for _ in range(M)]\n    \n    for i, s in enumerate(strings):\n        for j in range(len(s)):\n            T[M-j-1][i] = s[j]\n    \n    # Ensure no T_i ends with '*'\n    for i in range(M):\n        if T[i][-1] == '*':\n            T[i][-1] = '\\n'\n    \n    # Print the result\n    for row in T:\n        print(''.join(row).strip())\n\n# Call the function\nconvert_to_vertical()\n"}
{"task_id": "abc369_a", "code": "def count_valid_integers():\n    import sys\n    input = sys.stdin.read\n    A, B = map(int, input().split())\n\n    # Calculate potential x values\n    x1 = 2 * B - A\n    x2 = 2 * A - B\n    x3 = (A + B) // 2 if (A + B) % 2 == 0 else None\n\n    # Use a set to ensure unique x values\n    valid_x = {x1, x2, x3} - {None}\n\n    # Print the number of valid integers x\n    print(len(valid_x))\n\n# Call the function\ncount_valid_integers()\n", "passed": true, "raw_code": "def count_valid_integers():\n    import sys\n    input = sys.stdin.read\n    A, B = map(int, input().split())\n\n    # Calculate potential x values\n    x1 = 2 * B - A\n    x2 = 2 * A - B\n    x3 = (A + B) // 2 if (A + B) % 2 == 0 else None\n\n    # Use a set to ensure unique x values\n    valid_x = {x1, x2, x3} - {None}\n\n    # Print the number of valid integers x\n    print(len(valid_x))\n\n# Call the function\ncount_valid_integers()\n"}
{"task_id": "abc373_b", "code": "def minimal_travel_distance():\n    import sys\n    input = sys.stdin.read\n    S = input().strip()\n    \n    # Create a dictionary to map each character to its index in S\n    position_map = {char: idx for idx, char in enumerate(S)}\n    \n    # Initialize total distance\n    total_distance = 0\n    \n    # Calculate the total distance by summing the absolute differences between consecutive positions\n    for i in range(1, 26):\n        prev_char = chr(64 + i)  # ASCII value of 'A' is 65, so 'B' is 66, etc.\n        curr_char = chr(64 + i + 1)\n        total_distance += abs(position_map[curr_char] - position_map[prev_char])\n    \n    # Print the total distance\n    print(total_distance)\n\n# Call the function\nminimal_travel_distance()\n", "passed": true, "raw_code": "def minimal_travel_distance():\n    import sys\n    input = sys.stdin.read\n    S = input().strip()\n    \n    # Create a dictionary to map each character to its index in S\n    position_map = {char: idx for idx, char in enumerate(S)}\n    \n    # Initialize total distance\n    total_distance = 0\n    \n    # Calculate the total distance by summing the absolute differences between consecutive positions\n    for i in range(1, 26):\n        prev_char = chr(64 + i)  # ASCII value of 'A' is 65, so 'B' is 66, etc.\n        curr_char = chr(64 + i + 1)\n        total_distance += abs(position_map[curr_char] - position_map[prev_char])\n    \n    # Print the total distance\n    print(total_distance)\n\n# Call the function\nminimal_travel_distance()\n"}
{"task_id": "3543", "code": "def count_k_constraint_substrings(s, k):\n    n = len(s)\n    count = 0\n    \n    # Iterate over all possible starting points of substrings\n    for start in range(n):\n        zero_count = 0\n        one_count = 0\n        \n        # Iterate over all possible ending points to form substrings\n        for end in range(start, n):\n            if s[end] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n            \n            # Check if the current substring satisfies the k-constraint\n            if zero_count <= k or one_count <= k:\n                count += 1\n    \n    return count\n", "passed": true, "raw_code": "def count_k_constraint_substrings(s, k):\n    n = len(s)\n    count = 0\n    \n    # Iterate over all possible starting points of substrings\n    for start in range(n):\n        zero_count = 0\n        one_count = 0\n        \n        # Iterate over all possible ending points to form substrings\n        for end in range(start, n):\n            if s[end] == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n            \n            # Check if the current substring satisfies the k-constraint\n            if zero_count <= k or one_count <= k:\n                count += 1\n    \n    return count\n"}
{"task_id": "3600", "code": "def find_kth_character(k):\n    word = \"a\"\n    \n    while len(word) < k:\n        # Create a new string by incrementing each character\n        new_string = \"\"\n        for char in word:\n            if char == 'z':\n                new_string += 'a'\n            else:\n                new_string += chr(ord(char) + 1)\n        \n        # Append the new string to the original word\n        word += new_string\n    \n    # Return the k^th character (1-based index)\n    return word[k - 1]\n", "passed": true, "raw_code": "def find_kth_character(k):\n    word = \"a\"\n    \n    while len(word) < k:\n        # Create a new string by incrementing each character\n        new_string = \"\"\n        for char in word:\n            if char == 'z':\n                new_string += 'a'\n            else:\n                new_string += chr(ord(char) + 1)\n        \n        # Append the new string to the original word\n        word += new_string\n    \n    # Return the k^th character (1-based index)\n    return word[k - 1]\n"}
{"task_id": "abc369_b", "code": "def min_fatigue():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    presses = [(int(a), s) for a, s in (line.split() for line in data[1:])]\n    \n    # Initialize positions for left and right hands\n    left_pos = 1\n    right_pos = 1\n    fatigue = 0\n    \n    for A_i, S_i in presses:\n        if S_i == 'L':\n            # Move left hand to A_i\n            fatigue += abs(left_pos - A_i)\n            left_pos = A_i\n        else:  # S_i == 'R'\n            # Move right hand to A_i\n            fatigue += abs(right_pos - A_i)\n            right_pos = A_i\n    \n    print(fatigue)\n\n# The function can be called directly after being defined if used in a script\n# min_fatigue()  # Uncomment this line if using in a script with stdin redirection\n", "passed": false, "raw_code": "def min_fatigue():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    presses = [(int(a), s) for a, s in (line.split() for line in data[1:])]\n    \n    # Initialize positions for left and right hands\n    left_pos = 1\n    right_pos = 1\n    fatigue = 0\n    \n    for A_i, S_i in presses:\n        if S_i == 'L':\n            # Move left hand to A_i\n            fatigue += abs(left_pos - A_i)\n            left_pos = A_i\n        else:  # S_i == 'R'\n            # Move right hand to A_i\n            fatigue += abs(right_pos - A_i)\n            right_pos = A_i\n    \n    print(fatigue)\n\n# The function can be called directly after being defined if used in a script\n# min_fatigue()  # Uncomment this line if using in a script with stdin redirection\n"}
{"final_accuracy": "84.62%"}
