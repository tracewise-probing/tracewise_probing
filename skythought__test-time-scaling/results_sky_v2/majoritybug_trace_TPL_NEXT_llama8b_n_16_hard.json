"{\"difficulty\": \"hard\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"meta-llama/Llama-3.1-8B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majoritybug_trace_TPL_NEXT_llama8b_n_16_hard.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"meta-llama/Llama-3.1-8B-Instruct\", \"api_base\": \"http://10.96.183.224:63019/8004/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3563", "code": "def maximumScore(grid):\n    rows, cols = len(grid), len(grid[0])\n    values = set()\n    row_counts = [0] * rows\n    max_score = 0\n\n    def backtrack(row, current_score):\n        nonlocal max_score\n        max_score = max(max_score, current_score)\n\n        for col in range(cols):\n            if row_counts[row] < 1 and grid[row][col] not in values:\n                values.add(grid[row][col])\n                row_counts[row] += 1\n                backtrack((row + 1) % rows, current_score + grid[row][col])\n                values.remove(grid[row][col])\n                row_counts[row] -= 1\n\n    backtrack(0, 0)\n    return max_score\n", "passed": false, "raw_code": "def maximumScore(grid):\n    rows, cols = len(grid), len(grid[0])\n    values = set()\n    row_counts = [0] * rows\n    max_score = 0\n\n    def backtrack(row, current_score):\n        nonlocal max_score\n        max_score = max(max_score, current_score)\n\n        for col in range(cols):\n            if row_counts[row] < 1 and grid[row][col] not in values:\n                values.add(grid[row][col])\n                row_counts[row] += 1\n                backtrack((row + 1) % rows, current_score + grid[row][col])\n                values.remove(grid[row][col])\n                row_counts[row] -= 1\n\n    backtrack(0, 0)\n    return max_score\n"}
{"task_id": "3535", "code": "def monotonicPairsCount(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_count = [0] * (n + 1)\n    min_count = [0] * (n + 1)\n    \n    for num in range(1, 51):\n        for i in range(n):\n            if i == 0:\n                max_count[i] = min_count[i] = nums[i] <= num\n            else:\n                max_count[i] = (max_count[i - 1] + (nums[i] <= num)) % MOD\n                min_count[i] = (min_count[i - 1] + (nums[i] >= num)) % MOD\n    \n    result = 0\n    for i in range(n):\n        result = (result + max_count[i] * min_count[n - 1 - i]) % MOD\n    \n    return result\n", "passed": false, "raw_code": "def monotonicPairsCount(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_count = [0] * (n + 1)\n    min_count = [0] * (n + 1)\n    \n    for num in range(1, 51):\n        for i in range(n):\n            if i == 0:\n                max_count[i] = min_count[i] = nums[i] <= num\n            else:\n                max_count[i] = (max_count[i - 1] + (nums[i] <= num)) % MOD\n                min_count[i] = (min_count[i - 1] + (nums[i] >= num)) % MOD\n    \n    result = 0\n    for i in range(n):\n        result = (result + max_count[i] * min_count[n - 1 - i]) % MOD\n    \n    return result\n"}
{"task_id": "3527", "code": "class Solution:\n    def getAlternatingGroups(self, colors, queries):\n        n = len(colors)\n        color_map = {0: 'red', 1: 'blue'}\n        \n        # Initialize a list to store the count of alternating groups for each size\n        group_counts = [0] * (n + 1)\n        \n        # Calculate the count of alternating groups for each size\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if (colors[i] == 0 and colors[j - 1] == 1) or (colors[i] == 1 and colors[j - 1] == 0):\n                    group_counts[j] += 1\n                else:\n                    break\n        \n        # Process queries\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                # Determine the count of alternating groups with size size_i\n                size_i = query[1]\n                result.append(group_counts[size_i])\n            else:\n                # Change colors[index_i] to color_i\n                index_i, color_i = query[1], query[2]\n                if color_i == 0:\n                    color_map[index_i] = 'red'\n                else:\n                    color_map[index_i] = 'blue'\n                \n                # Update the count of alternating groups for each size\n                for i in range(n):\n                    for j in range(i + 1, n + 1):\n                        if (color_map[i] == 'red' and color_map[j - 1] == 'blue') or (color_map[i] == 'blue' and color_map[j - 1] == 'red'):\n                            group_counts[j] += 1\n                        else:\n                            break\n                        if i == index_i and j == index_i + 1:\n                            group_counts[j] -= 1\n        \n        return result\n", "passed": false, "raw_code": "class Solution:\n    def getAlternatingGroups(self, colors, queries):\n        n = len(colors)\n        color_map = {0: 'red', 1: 'blue'}\n        \n        # Initialize a list to store the count of alternating groups for each size\n        group_counts = [0] * (n + 1)\n        \n        # Calculate the count of alternating groups for each size\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if (colors[i] == 0 and colors[j - 1] == 1) or (colors[i] == 1 and colors[j - 1] == 0):\n                    group_counts[j] += 1\n                else:\n                    break\n        \n        # Process queries\n        result = []\n        for query in queries:\n            if query[0] == 1:\n                # Determine the count of alternating groups with size size_i\n                size_i = query[1]\n                result.append(group_counts[size_i])\n            else:\n                # Change colors[index_i] to color_i\n                index_i, color_i = query[1], query[2]\n                if color_i == 0:\n                    color_map[index_i] = 'red'\n                else:\n                    color_map[index_i] = 'blue'\n                \n                # Update the count of alternating groups for each size\n                for i in range(n):\n                    for j in range(i + 1, n + 1):\n                        if (color_map[i] == 'red' and color_map[j - 1] == 'blue') or (color_map[i] == 'blue' and color_map[j - 1] == 'red'):\n                            group_counts[j] += 1\n                        else:\n                            break\n                        if i == index_i and j == index_i + 1:\n                            group_counts[j] -= 1\n        \n        return result\n"}
{"task_id": "3552", "code": "def largest_k_palindrome(n: int, k: int) -> str:\n    \"\"\"\n    Generates the largest k-palindromic integer with n digits.\n    \n    Args:\n    n (int): The number of digits in the integer.\n    k (int): The divisor for the k-palindromic integer.\n    \n    Returns:\n    str: The largest k-palindromic integer with n digits as a string.\n    \"\"\"\n    \n    # If n is 1, the largest k-palindromic integer is k if k <= 9, otherwise it's the largest multiple of k less than or equal to 9\n    if n == 1:\n        if k <= 9:\n            return str(k)\n        else:\n            return str((k * (9 // k)) * (9 // k) + (9 % k))\n    \n    # Initialize the largest k-palindromic integer with n digits\n    largest_palindrome = \"9\" * n\n    \n    # If the largest k-palindromic integer is divisible by k, return it\n    if int(largest_palindrome) % k == 0:\n        return largest_palindrome\n    \n    # Otherwise, decrease the largest k-palindromic integer by 1 and check if it's divisible by k\n    for i in range(n - 1, -1, -1):\n        # Decrease the digit at the i-th position by 1\n        largest_palindrome = largest_palindrome[:i] + str(int(largest_palindrome[i]) - 1) + largest_palindrome[i + 1:]\n        \n        # If the largest k-palindromic integer is divisible by k, return it\n        if int(largest_palindrome) % k == 0:\n            return largest_palindrome\n    \n    # If no k-palindromic integer with n digits is found, return an empty string\n    return \"\"\n", "passed": false, "raw_code": "def largest_k_palindrome(n: int, k: int) -> str:\n    \"\"\"\n    Generates the largest k-palindromic integer with n digits.\n    \n    Args:\n    n (int): The number of digits in the integer.\n    k (int): The divisor for the k-palindromic integer.\n    \n    Returns:\n    str: The largest k-palindromic integer with n digits as a string.\n    \"\"\"\n    \n    # If n is 1, the largest k-palindromic integer is k if k <= 9, otherwise it's the largest multiple of k less than or equal to 9\n    if n == 1:\n        if k <= 9:\n            return str(k)\n        else:\n            return str((k * (9 // k)) * (9 // k) + (9 % k))\n    \n    # Initialize the largest k-palindromic integer with n digits\n    largest_palindrome = \"9\" * n\n    \n    # If the largest k-palindromic integer is divisible by k, return it\n    if int(largest_palindrome) % k == 0:\n        return largest_palindrome\n    \n    # Otherwise, decrease the largest k-palindromic integer by 1 and check if it's divisible by k\n    for i in range(n - 1, -1, -1):\n        # Decrease the digit at the i-th position by 1\n        largest_palindrome = largest_palindrome[:i] + str(int(largest_palindrome[i]) - 1) + largest_palindrome[i + 1:]\n        \n        # If the largest k-palindromic integer is divisible by k, return it\n        if int(largest_palindrome) % k == 0:\n            return largest_palindrome\n    \n    # If no k-palindromic integer with n digits is found, return an empty string\n    return \"\"\n"}
{"task_id": "3532", "code": "from collections import deque\n\ndef amountOfTime(edges, n):\n    graph = [[] for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    times = [0] * n\n    queue = deque([(i, 0) for i in range(n) if i % 2 == 0])\n    max_time = 0\n    \n    while queue:\n        size = len(queue)\n        prev_time = [0] * n\n        for _ in range(size):\n            node, time = queue.popleft()\n            prev_time[node] = time\n            max_time = max(max_time, time)\n            for neighbor in graph[node]:\n                if times[neighbor] == 0:\n                    if node % 2 == 0:\n                        times[neighbor] = time + 2\n                    else:\n                        times[neighbor] = time + 1\n                    queue.append((neighbor, times[neighbor]))\n        \n        if max_time % 2 == 1:\n            max_time += 1\n        else:\n            max_time += 2\n            \n    return times\n", "passed": false, "raw_code": "from collections import deque\n\ndef amountOfTime(edges, n):\n    graph = [[] for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    times = [0] * n\n    queue = deque([(i, 0) for i in range(n) if i % 2 == 0])\n    max_time = 0\n    \n    while queue:\n        size = len(queue)\n        prev_time = [0] * n\n        for _ in range(size):\n            node, time = queue.popleft()\n            prev_time[node] = time\n            max_time = max(max_time, time)\n            for neighbor in graph[node]:\n                if times[neighbor] == 0:\n                    if node % 2 == 0:\n                        times[neighbor] = time + 2\n                    else:\n                        times[neighbor] = time + 1\n                    queue.append((neighbor, times[neighbor]))\n        \n        if max_time % 2 == 1:\n            max_time += 1\n        else:\n            max_time += 2\n            \n    return times\n"}
{"task_id": "3551", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Solution:\n    def maximizeXor(self, nums, queries):\n        nums.sort()\n        queries.sort(key=lambda x: x[1])\n        root = TrieNode()\n        self.max_num = max(nums)\n        self.build_trie(root, nums)\n        ans = []\n        i = 0\n        for l, r in queries:\n            while i < len(nums) and nums[i] <= r:\n                self.update_trie(root, nums[i])\n                i += 1\n            ans.append(self.query_trie(root, l))\n        return ans\n\n    def build_trie(self, root, nums):\n        for num in nums:\n            node = root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if bit not in node.children:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n        return root\n\n    def update_trie(self, root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def query_trie(self, root, l):\n        ans = 0\n        node = root\n        for i in range(31, -1, -1):\n            bit = 1 if (self.max_num >> i) & 1 else 0\n            if l + bit not in node.children:\n                ans |= (1 << i)\n                node = node.children[0]\n            else:\n                node = node.children[1]\n        return ans\n", "passed": false, "raw_code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Solution:\n    def maximizeXor(self, nums, queries):\n        nums.sort()\n        queries.sort(key=lambda x: x[1])\n        root = TrieNode()\n        self.max_num = max(nums)\n        self.build_trie(root, nums)\n        ans = []\n        i = 0\n        for l, r in queries:\n            while i < len(nums) and nums[i] <= r:\n                self.update_trie(root, nums[i])\n                i += 1\n            ans.append(self.query_trie(root, l))\n        return ans\n\n    def build_trie(self, root, nums):\n        for num in nums:\n            node = root\n            for i in range(31, -1, -1):\n                bit = (num >> i) & 1\n                if bit not in node.children:\n                    node.children[bit] = TrieNode()\n                node = node.children[bit]\n        return root\n\n    def update_trie(self, root, num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def query_trie(self, root, l):\n        ans = 0\n        node = root\n        for i in range(31, -1, -1):\n            bit = 1 if (self.max_num >> i) & 1 else 0\n            if l + bit not in node.children:\n                ans |= (1 << i)\n                node = node.children[0]\n            else:\n                node = node.children[1]\n        return ans\n"}
{"task_id": "3575", "code": "def maximumXOR(nums, k):\n    \"\"\"\n    Returns the maximum value of any subsequence of nums having size 2 * k.\n    \n    Args:\n    nums (list): A list of integers.\n    k (int): A positive integer.\n    \n    Returns:\n    int: The maximum value of any subsequence of nums having size 2 * k.\n    \"\"\"\n    \n    # Create a Trie node class\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.end = False\n    \n    # Initialize the Trie\n    root = TrieNode()\n    \n    # Insert all numbers into the Trie\n    for num in nums:\n        node = root\n        for i in range(7, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.end = True\n    \n    # Initialize the maximum XOR value\n    max_xor = 0\n    \n    # Try to find the maximum XOR value\n    for num in nums:\n        node = root\n        xor = 0\n        for i in range(7, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor |= 1 << i\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        max_xor = max(max_xor, xor)\n    \n    return max_xor\n", "passed": false, "raw_code": "def maximumXOR(nums, k):\n    \"\"\"\n    Returns the maximum value of any subsequence of nums having size 2 * k.\n    \n    Args:\n    nums (list): A list of integers.\n    k (int): A positive integer.\n    \n    Returns:\n    int: The maximum value of any subsequence of nums having size 2 * k.\n    \"\"\"\n    \n    # Create a Trie node class\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.end = False\n    \n    # Initialize the Trie\n    root = TrieNode()\n    \n    # Insert all numbers into the Trie\n    for num in nums:\n        node = root\n        for i in range(7, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n        node.end = True\n    \n    # Initialize the maximum XOR value\n    max_xor = 0\n    \n    # Try to find the maximum XOR value\n    for num in nums:\n        node = root\n        xor = 0\n        for i in range(7, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                xor |= 1 << i\n                node = node.children[1 - bit]\n            else:\n                node = node.children[bit]\n        max_xor = max(max_xor, xor)\n    \n    return max_xor\n"}
{"task_id": "3571", "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\n\nclass Solution:\n    def longestIncreasingPath(self, coordinates, k):\n        n = len(coordinates)\n        m = max(max(x, y) for x, y in coordinates) + 1\n        uf = UnionFind(m * m)\n\n        for i in range(n):\n            x, y = coordinates[i]\n            uf.union(x * m + y, (x + 1) * m + y)\n            uf.union(x * m + y, x * m + (y + 1))\n\n        parent = uf.find(coordinates[k][0] * m + coordinates[k][1])\n        max_length = 1\n        for i in range(n):\n            x, y = coordinates[i]\n            if uf.find(x * m + y) == parent:\n                max_length = max(max_length, self.bfs(x, y, coordinates, uf))\n\n        return max_length\n\n    def bfs(self, x, y, coordinates, uf):\n        n = len(coordinates)\n        visited = {(x, y)}\n        queue = [(x, y, 1)]\n\n        while queue:\n            x, y, length = queue.pop(0)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if (0 <= nx < m and 0 <= ny < m and\n                        (nx, ny) not in visited and\n                        uf.find(nx * m + ny) == uf.find(x * m + y)):\n                    queue.append((nx, ny, length + 1))\n                    visited.add((nx, ny))\n\n        return length\n", "passed": false, "raw_code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [1] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\n\nclass Solution:\n    def longestIncreasingPath(self, coordinates, k):\n        n = len(coordinates)\n        m = max(max(x, y) for x, y in coordinates) + 1\n        uf = UnionFind(m * m)\n\n        for i in range(n):\n            x, y = coordinates[i]\n            uf.union(x * m + y, (x + 1) * m + y)\n            uf.union(x * m + y, x * m + (y + 1))\n\n        parent = uf.find(coordinates[k][0] * m + coordinates[k][1])\n        max_length = 1\n        for i in range(n):\n            x, y = coordinates[i]\n            if uf.find(x * m + y) == parent:\n                max_length = max(max_length, self.bfs(x, y, coordinates, uf))\n\n        return max_length\n\n    def bfs(self, x, y, coordinates, uf):\n        n = len(coordinates)\n        visited = {(x, y)}\n        queue = [(x, y, 1)]\n\n        while queue:\n            x, y, length = queue.pop(0)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if (0 <= nx < m and 0 <= ny < m and\n                        (nx, ny) not in visited and\n                        uf.find(nx * m + ny) == uf.find(x * m + y)):\n                    queue.append((nx, ny, length + 1))\n                    visited.add((nx, ny))\n\n        return length\n"}
{"task_id": "3583", "code": "import math\nfrom collections import defaultdict\n\ndef get_gcd_pairs(nums):\n    \"\"\"\n    Generate all possible pairs of GCDs from the input array.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    list: A list of GCDs sorted in ascending order.\n    \"\"\"\n    n = len(nums)\n    gcd_pairs = defaultdict(int)\n    \n    # Generate all possible pairs and calculate their GCD\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd = math.gcd(nums[i], nums[j])\n            gcd_pairs[gcd] += 1\n    \n    # Sort the GCDs in ascending order and store their indices\n    sorted_gcds = sorted(gcd_pairs.keys())\n    gcd_pairs = {gcd: idx for idx, gcd in enumerate(sorted_gcds)}\n    \n    return gcd_pairs\n\ndef find_gcd_pairs(nums, queries):\n    \"\"\"\n    Find the GCDs at the specified indices in the sorted GCDs array.\n    \n    Args:\n    nums (list): A list of integers.\n    queries (list): A list of indices.\n    \n    Returns:\n    list: A list of GCDs at the specified indices.\n    \"\"\"\n    gcd_pairs = get_gcd_pairs(nums)\n    answer = []\n    \n    # Find the GCDs at the specified indices\n    for query in queries:\n        gcd = sorted(gcd_pairs.keys())[query]\n        answer.append(gcd)\n    \n    return answer\n\n# Example usage\nnums = [2, 3, 4]\nqueries = [0, 2, 2]\nprint(find_gcd_pairs(nums, queries))  # Output: [1, 2, 2]\n\nnums = [4, 4, 2, 1]\nqueries = [5, 3, 1, 0]\nprint(find_gcd_pairs(nums, queries))  # Output: [4, 2, 1, 1]\n\nnums = [2, 2]\nqueries = [0, 0]\nprint(find_gcd_pairs(nums, queries))  # Output: [2, 2]\n", "passed": false, "raw_code": "import math\nfrom collections import defaultdict\n\ndef get_gcd_pairs(nums):\n    \"\"\"\n    Generate all possible pairs of GCDs from the input array.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    list: A list of GCDs sorted in ascending order.\n    \"\"\"\n    n = len(nums)\n    gcd_pairs = defaultdict(int)\n    \n    # Generate all possible pairs and calculate their GCD\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd = math.gcd(nums[i], nums[j])\n            gcd_pairs[gcd] += 1\n    \n    # Sort the GCDs in ascending order and store their indices\n    sorted_gcds = sorted(gcd_pairs.keys())\n    gcd_pairs = {gcd: idx for idx, gcd in enumerate(sorted_gcds)}\n    \n    return gcd_pairs\n\ndef find_gcd_pairs(nums, queries):\n    \"\"\"\n    Find the GCDs at the specified indices in the sorted GCDs array.\n    \n    Args:\n    nums (list): A list of integers.\n    queries (list): A list of indices.\n    \n    Returns:\n    list: A list of GCDs at the specified indices.\n    \"\"\"\n    gcd_pairs = get_gcd_pairs(nums)\n    answer = []\n    \n    # Find the GCDs at the specified indices\n    for query in queries:\n        gcd = sorted(gcd_pairs.keys())[query]\n        answer.append(gcd)\n    \n    return answer\n\n# Example usage\nnums = [2, 3, 4]\nqueries = [0, 2, 2]\nprint(find_gcd_pairs(nums, queries))  # Output: [1, 2, 2]\n\nnums = [4, 4, 2, 1]\nqueries = [5, 3, 1, 0]\nprint(find_gcd_pairs(nums, queries))  # Output: [4, 2, 1, 1]\n\nnums = [2, 2]\nqueries = [0, 0]\nprint(find_gcd_pairs(nums, queries))  # Output: [2, 2]\n"}
{"task_id": "3550", "code": "def maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    row_values = [0] * m\n    col_values = [0] * n\n    \n    def place_rook(i, j):\n        row_values[i] += board[i][j]\n        col_values[j] += board[i][j]\n    \n    def remove_rook(i, j):\n        row_values[i] -= board[i][j]\n        col_values[j] -= board[i][j]\n    \n    def backtrack(i):\n        if i == m:\n            return 0\n        \n        max_sum = 0\n        for j in range(n):\n            if row_values[i] == 0 and col_values[j] == 0:\n                place_rook(i, j)\n                max_sum = max(max_sum, backtrack(i + 1) + row_values[i])\n                remove_rook(i, j)\n        \n        return max_sum\n    \n    return backtrack(0)\n", "passed": false, "raw_code": "def maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    row_values = [0] * m\n    col_values = [0] * n\n    \n    def place_rook(i, j):\n        row_values[i] += board[i][j]\n        col_values[j] += board[i][j]\n    \n    def remove_rook(i, j):\n        row_values[i] -= board[i][j]\n        col_values[j] -= board[i][j]\n    \n    def backtrack(i):\n        if i == m:\n            return 0\n        \n        max_sum = 0\n        for j in range(n):\n            if row_values[i] == 0 and col_values[j] == 0:\n                place_rook(i, j)\n                max_sum = max(max_sum, backtrack(i + 1) + row_values[i])\n                remove_rook(i, j)\n        \n        return max_sum\n    \n    return backtrack(0)\n"}
{"task_id": "3531", "code": "import heapq\n\ndef minDamage(damage, health, power):\n    n = len(damage)\n    pq = []\n    \n    # Push all enemies into the priority queue\n    for i in range(n):\n        heapq.heappush(pq, (-damage[i] / health[i], i))\n    \n    damage_dealt = 0\n    seconds = 0\n    \n    while pq:\n        # Get the enemy with the highest damage per second\n        _, enemy_idx = heapq.heappop(pq)\n        \n        # Calculate the time it takes to kill the enemy\n        time_to_kill = -(-health[enemy_idx] // damage[enemy_idx])\n        \n        # Update the total damage dealt\n        damage_dealt += time_to_kill * power\n        \n        # Update the seconds\n        seconds += time_to_kill\n        \n        # If there are still enemies alive, push them back into the priority queue\n        if pq:\n            heapq.heappush(pq, (-damage[enemy_idx] / health[enemy_idx], enemy_idx))\n    \n    return damage_dealt\n", "passed": false, "raw_code": "import heapq\n\ndef minDamage(damage, health, power):\n    n = len(damage)\n    pq = []\n    \n    # Push all enemies into the priority queue\n    for i in range(n):\n        heapq.heappush(pq, (-damage[i] / health[i], i))\n    \n    damage_dealt = 0\n    seconds = 0\n    \n    while pq:\n        # Get the enemy with the highest damage per second\n        _, enemy_idx = heapq.heappop(pq)\n        \n        # Calculate the time it takes to kill the enemy\n        time_to_kill = -(-health[enemy_idx] // damage[enemy_idx])\n        \n        # Update the total damage dealt\n        damage_dealt += time_to_kill * power\n        \n        # Update the seconds\n        seconds += time_to_kill\n        \n        # If there are still enemies alive, push them back into the priority queue\n        if pq:\n            heapq.heappush(pq, (-damage[enemy_idx] / health[enemy_idx], enemy_idx))\n    \n    return damage_dealt\n"}
