"{\"difficulty\": \"medium\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"AIDC-AI/Marco-o1\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majoritybug_trace_TPL_OUR01_marcon-o1_n_16_medium.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"AIDC-AI/Marco-o1\", \"api_base\": \"http://10.96.183.224:63019/8002/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3528", "code": "def max_jump_score(nums):\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 0  # Starting point has no score\n\n    for i in range(1, n):\n        dp[i] = float('-inf')\n        for j in range(i):\n            if j < i:\n                jump_score = (i - j) * nums[j]\n                dp[i] = max(dp[i], dp[j] + jump_score)\n\n    return dp[-1]\n", "passed": false, "raw_code": "def max_jump_score(nums):\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 0  # Starting point has no score\n\n    for i in range(1, n):\n        dp[i] = float('-inf')\n        for j in range(i):\n            if j < i:\n                jump_score = (i - j) * nums[j]\n                dp[i] = max(dp[i], dp[j] + jump_score)\n\n    return dp[-1]\n"}
{"task_id": "3540", "code": "def hash_string(s: str, k: int) -> str:\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        if hashed_char < 0:\n            hashed_char += 26\n        result += chr(hashed_char + ord('a'))\n    return result\n", "passed": true, "raw_code": "def hash_string(s: str, k: int) -> str:\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        if hashed_char < 0:\n            hashed_char += 26\n        result += chr(hashed_char + ord('a'))\n    return result\n"}
{"task_id": "3522", "code": "def find_power_of_subarrays(nums, k):\n    results = []\n    for i in range(len(nums) - k + 1):\n        subarray = nums[i:i+k]\n        if all(subarray[j] < subarray[j+1] for j in range(len(subarray)-1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    return results\n", "passed": false, "raw_code": "def find_power_of_subarrays(nums, k):\n    results = []\n    for i in range(len(nums) - k + 1):\n        subarray = nums[i:i+k]\n        if all(subarray[j] < subarray[j+1] for j in range(len(subarray)-1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    return results\n"}
{"task_id": "3518", "code": "def max_score(a, b):\n    # Sort array 'b' in descending order\n    sorted_b = sorted(b, reverse=True)\n    # Select the top 4 elements from 'sorted_b'\n    top_4 = sorted_b[:4]\n    # Calculate the score using the formula\n    score = a[0] * top_4[0] + a[1] * top_4[1] + a[2] * top_4[2] + a[3] * top_4[3]\n    return score\n", "passed": false, "raw_code": "def max_score(a, b):\n    # Sort array 'b' in descending order\n    sorted_b = sorted(b, reverse=True)\n    # Select the top 4 elements from 'sorted_b'\n    top_4 = sorted_b[:4]\n    # Calculate the score using the formula\n    score = a[0] * top_4[0] + a[1] * top_4[1] + a[2] * top_4[2] + a[3] * top_4[3]\n    return score\n"}
{"task_id": "3541", "code": "def is_spam(message, bannedWords):\n    # Convert bannedWords to a set for O(1) lookups\n    banned_set = set(bannedWords)\n    # Iterate through each word in the message\n    for word in message:\n        if word in banned_set:\n            # If a banned word is found, check if there's at least one more\n            if len([w for w in message if w == word]) >= 2:\n                return True\n    return False\n", "passed": false, "raw_code": "def is_spam(message, bannedWords):\n    # Convert bannedWords to a set for O(1) lookups\n    banned_set = set(bannedWords)\n    # Iterate through each word in the message\n    for word in message:\n        if word in banned_set:\n            # If a banned word is found, check if there's at least one more\n            if len([w for w in message if w == word]) >= 2:\n                return True\n    return False\n"}
{"task_id": "3573", "code": "def count_valid_substrings(word1: str, word2: str) -> int:\n    from collections import Counter\n\n    # Count character frequencies in word2\n    word2_counter = Counter(word2)\n    \n    # Initialize result\n    count = 0\n    \n    # Iterate over all possible substring lengths starting from the length of word2\n    for length in range(len(word2), len(word1) + 1):\n        substring = word1[:length]\n        substring_counter = Counter(substring)\n        \n        # Check if substring can be rearranged to have word2 as a prefix\n        if substring_counter[word2[0]] >= word2_counter[word2[0]]:\n            is_prefix = True\n            for char in word2[1:]:\n                if substring_counter[char] < word2_counter[char]:\n                    is_prefix = False\n                    break\n            if is_prefix:\n                count += 1\n        # Move the window by one character\n        word1 = word1[1:]\n    \n    return count\n", "passed": false, "raw_code": "def count_valid_substrings(word1: str, word2: str) -> int:\n    from collections import Counter\n\n    # Count character frequencies in word2\n    word2_counter = Counter(word2)\n    \n    # Initialize result\n    count = 0\n    \n    # Iterate over all possible substring lengths starting from the length of word2\n    for length in range(len(word2), len(word1) + 1):\n        substring = word1[:length]\n        substring_counter = Counter(substring)\n        \n        # Check if substring can be rearranged to have word2 as a prefix\n        if substring_counter[word2[0]] >= word2_counter[word2[0]]:\n            is_prefix = True\n            for char in word2[1:]:\n                if substring_counter[char] < word2_counter[char]:\n                    is_prefix = False\n                    break\n            if is_prefix:\n                count += 1\n        # Move the window by one character\n        word1 = word1[1:]\n    \n    return count\n"}
{"task_id": "3525", "code": "def max_energy_boost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp = [[0] * 2 for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        # If we choose energy drink A at this hour\n        dp[i][0] = max(dp[i-1][0] + energyDrinkA[i-1], dp[i-1][1])\n        \n        # If we choose energy drink B at this hour\n        dp[i][1] = max(dp[i-1][1] + energyDrinkB[i-1], dp[i-1][0])\n    \n    return max(dp[n][0], dp[n][1])\n", "passed": false, "raw_code": "def max_energy_boost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp = [[0] * 2 for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        # If we choose energy drink A at this hour\n        dp[i][0] = max(dp[i-1][0] + energyDrinkA[i-1], dp[i-1][1])\n        \n        # If we choose energy drink B at this hour\n        dp[i][1] = max(dp[i-1][1] + energyDrinkB[i-1], dp[i-1][0])\n    \n    return max(dp[n][0], dp[n][1])\n"}
{"task_id": "3534", "code": "def count_almost_equal_pairs(nums):\n    def are_almost_equal(x, y):\n        str_x, str_y = str(x), str(y)\n        # If lengths differ, they can't be made equal\n        if len(str_x) != len(str_y):\n            return False\n        # If numbers are already equal\n        if str_x == str_y:\n            return True\n        # Try swapping each digit in x with every digit in y\n        for i in range(len(str_x)):\n            for j in range(len(str_y)):\n                # Swap the digits\n                new_str_x = str_x[:i] + str_y[j] + str_x[i+1:]\n                new_str_y = str_y[:j] + str_x[i] + str_y[j+1:]\n                if new_str_x == new_str_y:\n                    return True\n        return False\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if are_almost_equal(nums[i], nums[j]):\n                count += 1\n    return count\n", "passed": false, "raw_code": "def count_almost_equal_pairs(nums):\n    def are_almost_equal(x, y):\n        str_x, str_y = str(x), str(y)\n        # If lengths differ, they can't be made equal\n        if len(str_x) != len(str_y):\n            return False\n        # If numbers are already equal\n        if str_x == str_y:\n            return True\n        # Try swapping each digit in x with every digit in y\n        for i in range(len(str_x)):\n            for j in range(len(str_y)):\n                # Swap the digits\n                new_str_x = str_x[:i] + str_y[j] + str_x[i+1:]\n                new_str_y = str_y[:j] + str_x[i] + str_y[j+1:]\n                if new_str_x == new_str_y:\n                    return True\n        return False\n\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if are_almost_equal(nums[i], nums[j]):\n                count += 1\n    return count\n"}
{"task_id": "3570", "code": "def count_substrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    total = 0\n    for i in range(n):\n        seen = set()\n        consonants = 0\n        for j in range(i, n):\n            if word[j] in vowels:\n                seen.add(word[j])\n            else:\n                consonants += 1\n            if seen == vowels and consonants == k:\n                total += 1\n    return total\n", "passed": false, "raw_code": "def count_substrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    total = 0\n    for i in range(n):\n        seen = set()\n        consonants = 0\n        for j in range(i, n):\n            if word[j] in vowels:\n                seen.add(word[j])\n            else:\n                consonants += 1\n            if seen == vowels and consonants == k:\n                total += 1\n    return total\n"}
{"task_id": "3559", "code": "from typing import List\n\ndef min_valid_strings_concatenation(words: List[str], target: str) -> int:\n    \"\"\"\n    Returns the minimum number of valid strings that can be concatenated to form the target string.\n    A string is considered valid if it is a prefix of any string in the words list.\n    If it's impossible to form the target with the given words, returns -1.\n    \n    :param words: List of strings representing the available words.\n    :param target: The target string to form by concatenating prefixes.\n    :return: Minimum number of valid strings needed or -1 if impossible.\n    \"\"\"\n    from collections import defaultdict\n\n    # Create a dictionary to store the end of each word\n    word_ends = defaultdict(set)\n    for word in words:\n        for i in range(1, len(word) + 1):\n            word_ends[word[:i]].add(word)\n\n    # Initialize a DP table where dp[i] represents the minimum number of words needed to form the first i characters of target\n    dp = [float('inf')] * (len(target) + 1)\n    dp[0] = 0\n\n    for i in range(1, len(target) + 1):\n        for j in range(i):\n            if target[j:i] in word_ends:\n                for word in word_ends[target[j:i]]:\n                    if dp[j] != float('inf') and (dp[i] == float('inf') or dp[i] > dp[j] + 1):\n                        dp[i] = dp[j] + 1\n\n    return dp[len(target)] if dp[len(target)] != float('inf') else -1\n", "passed": false, "raw_code": "from typing import List\n\ndef min_valid_strings_concatenation(words: List[str], target: str) -> int:\n    \"\"\"\n    Returns the minimum number of valid strings that can be concatenated to form the target string.\n    A string is considered valid if it is a prefix of any string in the words list.\n    If it's impossible to form the target with the given words, returns -1.\n    \n    :param words: List of strings representing the available words.\n    :param target: The target string to form by concatenating prefixes.\n    :return: Minimum number of valid strings needed or -1 if impossible.\n    \"\"\"\n    from collections import defaultdict\n\n    # Create a dictionary to store the end of each word\n    word_ends = defaultdict(set)\n    for word in words:\n        for i in range(1, len(word) + 1):\n            word_ends[word[:i]].add(word)\n\n    # Initialize a DP table where dp[i] represents the minimum number of words needed to form the first i characters of target\n    dp = [float('inf')] * (len(target) + 1)\n    dp[0] = 0\n\n    for i in range(1, len(target) + 1):\n        for j in range(i):\n            if target[j:i] in word_ends:\n                for word in word_ends[target[j:i]]:\n                    if dp[j] != float('inf') and (dp[i] == float('inf') or dp[i] > dp[j] + 1):\n                        dp[i] = dp[j] + 1\n\n    return dp[len(target)] if dp[len(target)] != float('inf') else -1\n"}
{"task_id": "3558", "code": "from typing import List\n\ndef can_reach_final_cell(grid: List[List[int]], health: int) -> bool:\n    rows, cols = len(grid), len(grid[0])\n    \n    # If starting cell is unsafe\n    if grid[0][0] == 1:\n        return False\n    \n    # Directions: up, down, left, right\n    directions = [(-1,0), (1,0), (0,-1), (0,1)]\n    \n    visited = set()\n    queue = [(0, 0, health)]\n    \n    while queue:\n        r, c, h = queue.pop(0)\n        \n        if (r, c) == (rows - 1, cols - 1):\n            return True\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            # Check boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                nh = h - grid[nr][nc]\n                \n                if nh >= 1 and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc, nh))\n    \n    return False\n", "passed": false, "raw_code": "from typing import List\n\ndef can_reach_final_cell(grid: List[List[int]], health: int) -> bool:\n    rows, cols = len(grid), len(grid[0])\n    \n    # If starting cell is unsafe\n    if grid[0][0] == 1:\n        return False\n    \n    # Directions: up, down, left, right\n    directions = [(-1,0), (1,0), (0,-1), (0,1)]\n    \n    visited = set()\n    queue = [(0, 0, health)]\n    \n    while queue:\n        r, c, h = queue.pop(0)\n        \n        if (r, c) == (rows - 1, cols - 1):\n            return True\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            # Check boundaries\n            if 0 <= nr < rows and 0 <= nc < cols:\n                nh = h - grid[nr][nc]\n                \n                if nh >= 1 and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    queue.append((nr, nc, nh))\n    \n    return False\n"}
{"task_id": "3485", "code": "def max_score(start, d):\n    \"\"\"\n    Given an array of integers 'start' and an integer 'd', representing n intervals [start[i], start[i] + d],\n    this function selects n integers such that the i-th integer belongs to the i-th interval.\n    It returns the maximum possible score of the chosen integers, where the score is defined as the minimum\n    absolute difference between any two chosen integers.\n\n    :param start: List[int] - A list of starting points for each interval.\n    :param d: int - The length of each interval.\n    :return: int - The maximum possible score.\n    \"\"\"\n    # Initialize a set to store the chosen integers\n    chosen = set()\n    \n    # Iterate through each starting point\n    for s in start:\n        # Calculate the lower and upper bounds of the current interval\n        lower = s\n        upper = s + d\n        \n        # Find the smallest number greater than or equal to the current lower bound\n        # that is not already in the chosen set\n        current = lower\n        while current in chosen:\n            current += 1\n        \n        # If the current number is within the upper bound, add it to the chosen set\n        if current <= upper:\n            chosen.add(current)\n        else:\n            # If no valid number is found within the interval, return 0\n            return 0\n    \n    # Calculate the minimum absolute difference between any two chosen integers\n    if len(chosen) < 2:\n        return 0\n    min_diff = float('inf')\n    for i in range(len(chosen)):\n        for j in range(i+1, len(chosen)):\n            diff = abs(chosen[i] - chosen[j])\n            if diff < min_diff:\n                min_diff = diff\n    \n    return min_diff\n", "passed": false, "raw_code": "def max_score(start, d):\n    \"\"\"\n    Given an array of integers 'start' and an integer 'd', representing n intervals [start[i], start[i] + d],\n    this function selects n integers such that the i-th integer belongs to the i-th interval.\n    It returns the maximum possible score of the chosen integers, where the score is defined as the minimum\n    absolute difference between any two chosen integers.\n\n    :param start: List[int] - A list of starting points for each interval.\n    :param d: int - The length of each interval.\n    :return: int - The maximum possible score.\n    \"\"\"\n    # Initialize a set to store the chosen integers\n    chosen = set()\n    \n    # Iterate through each starting point\n    for s in start:\n        # Calculate the lower and upper bounds of the current interval\n        lower = s\n        upper = s + d\n        \n        # Find the smallest number greater than or equal to the current lower bound\n        # that is not already in the chosen set\n        current = lower\n        while current in chosen:\n            current += 1\n        \n        # If the current number is within the upper bound, add it to the chosen set\n        if current <= upper:\n            chosen.add(current)\n        else:\n            # If no valid number is found within the interval, return 0\n            return 0\n    \n    # Calculate the minimum absolute difference between any two chosen integers\n    if len(chosen) < 2:\n        return 0\n    min_diff = float('inf')\n    for i in range(len(chosen)):\n        for j in range(i+1, len(chosen)):\n            diff = abs(chosen[i] - chosen[j])\n            if diff < min_diff:\n                min_diff = diff\n    \n    return min_diff\n"}
{"task_id": "3579", "code": "def max_concatenated_binary(nums):\n    # Convert each number to its binary representation without leading zeros\n    binary_nums = [bin(num)[2:].zfill(7) for num in nums]\n    \n    # Initialize the maximum value as 0\n    max_value = 0\n    \n    # Iterate through all permutations of the binary representations\n    for perm in itertools.permutations(binary_nums):\n        concatenated = ''.join(perm)\n        # Convert the concatenated string back to an integer\n        current_value = int(concatenated, 2)\n        # Update the maximum value if the current value is greater\n        if current_value > max_value:\n            max_value = current_value\n    \n    return max_value\n", "passed": false, "raw_code": "def max_concatenated_binary(nums):\n    # Convert each number to its binary representation without leading zeros\n    binary_nums = [bin(num)[2:].zfill(7) for num in nums]\n    \n    # Initialize the maximum value as 0\n    max_value = 0\n    \n    # Iterate through all permutations of the binary representations\n    for perm in itertools.permutations(binary_nums):\n        concatenated = ''.join(perm)\n        # Convert the concatenated string back to an integer\n        current_value = int(concatenated, 2)\n        # Update the maximum value if the current value is greater\n        if current_value > max_value:\n            max_value = current_value\n    \n    return max_value\n"}
{"task_id": "3510", "code": "def max_total_height(maximumHeight):\n    n = len(maximumHeight)\n    if n == 0:\n        return -1\n\n    # Check if there are enough unique heights available\n    unique_heights = set()\n    for height in maximumHeight:\n        unique_heights.add(height)\n    if len(unique_heights) < n:\n        return -1\n\n    # Sort the heights in descending order\n    sorted_heights = sorted(maximumHeight, reverse=True)\n\n    # Calculate the total sum\n    total_sum = 0\n    for i in range(n):\n        total_sum += sorted_heights[i]\n\n    return total_sum\n", "passed": false, "raw_code": "def max_total_height(maximumHeight):\n    n = len(maximumHeight)\n    if n == 0:\n        return -1\n\n    # Check if there are enough unique heights available\n    unique_heights = set()\n    for height in maximumHeight:\n        unique_heights.add(height)\n    if len(unique_heights) < n:\n        return -1\n\n    # Sort the heights in descending order\n    sorted_heights = sorted(maximumHeight, reverse=True)\n\n    # Calculate the total sum\n    total_sum = 0\n    for i in range(n):\n        total_sum += sorted_heights[i]\n\n    return total_sum\n"}
{"task_id": "3496", "code": "def min_seconds_to_reduce_mountain(mountainHeight, workerTimes):\n    # Initialize a list to store the time each worker takes to reduce the mountain\n    worker_times = []\n    for time in workerTimes:\n        total_time = 0\n        current_time = time\n        for x in range(1, mountainHeight + 1):\n            total_time += current_time\n            current_time *= 2\n        worker_times.append(total_time)\n    \n    # Return the maximum time among all workers\n    return max(worker_times)\n", "passed": false, "raw_code": "def min_seconds_to_reduce_mountain(mountainHeight, workerTimes):\n    # Initialize a list to store the time each worker takes to reduce the mountain\n    worker_times = []\n    for time in workerTimes:\n        total_time = 0\n        current_time = time\n        for x in range(1, mountainHeight + 1):\n            total_time += current_time\n            current_time *= 2\n        worker_times.append(total_time)\n    \n    # Return the maximum time among all workers\n    return max(worker_times)\n"}
{"task_id": "3584", "code": "def find_lexicographically_smallest_sequence(word1, word2):\n    len_w2 = len(word2)\n    result = []\n    changes = 0\n    i, j = 0, 0\n\n    while i < len(word1) and j < len_w2:\n        if word1[i] == word2[j]:\n            result.append(i)\n            i += 1\n            j += 1\n        else:\n            if changes < 1:\n                # Find the next occurrence of word2[j] in word1\n                k = i + 1\n                while k < len(word1):\n                    if word1[k] == word2[j]:\n                        result.append(k)\n                        changes += 1\n                        i = k + 1\n                        j += 1\n                        break\n                    k += 1\n                else:\n                    # If no matching character found, try changing the current character\n                    if word1[i] in word2:\n                        result.append(i)\n                        changes += 1\n                        i += 1\n                        j += 1\n                    else:\n                        i += 1\n            else:\n                i += 1\n\n    if j == len_w2 and changes <= 1:\n        return result\n    else:\n        return []\n", "passed": false, "raw_code": "def find_lexicographically_smallest_sequence(word1, word2):\n    len_w2 = len(word2)\n    result = []\n    changes = 0\n    i, j = 0, 0\n\n    while i < len(word1) and j < len_w2:\n        if word1[i] == word2[j]:\n            result.append(i)\n            i += 1\n            j += 1\n        else:\n            if changes < 1:\n                # Find the next occurrence of word2[j] in word1\n                k = i + 1\n                while k < len(word1):\n                    if word1[k] == word2[j]:\n                        result.append(k)\n                        changes += 1\n                        i = k + 1\n                        j += 1\n                        break\n                    k += 1\n                else:\n                    # If no matching character found, try changing the current character\n                    if word1[i] in word2:\n                        result.append(i)\n                        changes += 1\n                        i += 1\n                        j += 1\n                    else:\n                        i += 1\n            else:\n                i += 1\n\n    if j == len_w2 and changes <= 1:\n        return result\n    else:\n        return []\n"}
{"task_id": "3495", "code": "import heapq\n\ndef kth_nearest_obstacles(queries, k):\n    results = []\n    obstacles = []\n    \n    for query in queries:\n        x, y = query\n        distance = abs(x) + abs(y)\n        obstacles.append((distance, x, y))\n        \n        # Maintain a min-heap of size k\n        if len(obstacles) > k:\n            heapq.heappushpop(obstacles, (distance, x, y))\n        \n        # If there are fewer than k obstacles, append -1\n        if len(obstacles) < k:\n            results.append(-1)\n        else:\n            # The k-th nearest obstacle is the root of the heap\n            _, _, _ = heapq.heappop(obstacles)\n            results.append(distance)\n            heapq.heappush(obstacles, (distance, x, y))\n    \n    return results\n", "passed": false, "raw_code": "import heapq\n\ndef kth_nearest_obstacles(queries, k):\n    results = []\n    obstacles = []\n    \n    for query in queries:\n        x, y = query\n        distance = abs(x) + abs(y)\n        obstacles.append((distance, x, y))\n        \n        # Maintain a min-heap of size k\n        if len(obstacles) > k:\n            heapq.heappushpop(obstacles, (distance, x, y))\n        \n        # If there are fewer than k obstacles, append -1\n        if len(obstacles) < k:\n            results.append(-1)\n        else:\n            # The k-th nearest obstacle is the root of the heap\n            _, _, _ = heapq.heappop(obstacles)\n            results.append(distance)\n            heapq.heappush(obstacles, (distance, x, y))\n    \n    return results\n"}
{"task_id": "3526", "code": "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    # Count flips needed for each row to make it palindromic\n    row_flips = [0] * m\n    for i in range(m):\n        left, right = 0, n - 1\n        while left < right:\n            if grid[i][left] != grid[i][right]:\n                row_flips[i] += 1\n            left += 1\n            right -= 1\n    # Count flips needed for each column to make it palindromic\n    col_flips = [0] * n\n    for j in range(n):\n        left, right = 0, m - 1\n        while left < right:\n            if grid[left][j] != grid[right][j]:\n                col_flips[j] += 1\n            left += 1\n            right -= 1\n    # Total flips needed to make all rows palindromic\n    total_row_flips = sum(row_flips)\n    # Total flips needed to make all columns palindromic\n    total_col_flips = sum(col_flips)\n    # Return the minimum of the two\n    return min(total_row_flips, total_col_flips)\n", "passed": false, "raw_code": "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    # Count flips needed for each row to make it palindromic\n    row_flips = [0] * m\n    for i in range(m):\n        left, right = 0, n - 1\n        while left < right:\n            if grid[i][left] != grid[i][right]:\n                row_flips[i] += 1\n            left += 1\n            right -= 1\n    # Count flips needed for each column to make it palindromic\n    col_flips = [0] * n\n    for j in range(n):\n        left, right = 0, m - 1\n        while left < right:\n            if grid[left][j] != grid[right][j]:\n                col_flips[j] += 1\n            left += 1\n            right -= 1\n    # Total flips needed to make all rows palindromic\n    total_row_flips = sum(row_flips)\n    # Total flips needed to make all columns palindromic\n    total_col_flips = sum(col_flips)\n    # Return the minimum of the two\n    return min(total_row_flips, total_col_flips)\n"}
{"task_id": "3517", "code": "def shortest_path_lengths(n, queries):\n    from collections import deque\n\n    # Initialize the graph with edges from 0 to 1 to n-1\n    graph = {i: set([i+1]) for i in range(n-1)}\n    graph[n-1] = set()\n\n    # Initialize the answer list\n    answer = []\n\n    for query in queries:\n        u, v = query\n        # Add the new road to the graph\n        graph[u].add(v)\n\n        # Check if adding this road connects 0 to n-1\n        if 0 in graph[n-1]:\n            answer.append(1)\n            continue\n\n        # If not connected yet, perform BFS to find the shortest path\n        visited = set()\n        queue = deque([[0, 0]])  # (current_city, distance)\n        visited.add(0)\n\n        while queue:\n            current, dist = queue.popleft()\n            if current == n-1:\n                answer.append(dist)\n                break\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append([neighbor, dist + 1])\n        else:\n            answer.append(-1)  # No path found\n\n    return answer\n", "passed": false, "raw_code": "def shortest_path_lengths(n, queries):\n    from collections import deque\n\n    # Initialize the graph with edges from 0 to 1 to n-1\n    graph = {i: set([i+1]) for i in range(n-1)}\n    graph[n-1] = set()\n\n    # Initialize the answer list\n    answer = []\n\n    for query in queries:\n        u, v = query\n        # Add the new road to the graph\n        graph[u].add(v)\n\n        # Check if adding this road connects 0 to n-1\n        if 0 in graph[n-1]:\n            answer.append(1)\n            continue\n\n        # If not connected yet, perform BFS to find the shortest path\n        visited = set()\n        queue = deque([[0, 0]])  # (current_city, distance)\n        visited.add(0)\n\n        while queue:\n            current, dist = queue.popleft()\n            if current == n-1:\n                answer.append(dist)\n                break\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append([neighbor, dist + 1])\n        else:\n            answer.append(-1)  # No path found\n\n    return answer\n"}
{"final_accuracy": "5.26%"}
