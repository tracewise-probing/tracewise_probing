{"difficulty": "hard", "num_threads": 32, "temperature": 0.5, "n": 1, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp05_bug_trace_TPL_CODEEXECUTOR_qwen_7b_hard_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc365_e", "code": "d", "passed": false, "raw_code": "```python\ndef calculate_xor_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Calculate prefix XOR array\n    P = [0] * (N + 1)\n    for i in range(1, N + 1):\n        P[i] = P[i - 1] ^ A[i - 1]\n    \n    # Calculate the sum of XOR for all subarrays\n    total_sum = 0\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            total_sum += P[j] ^ P[i - 1]\n    \n    print(total_sum)\n\ncalculate_xor_sum()"}
{"task_id": "abc368_f", "code": "d", "passed": false, "raw_code": "```python\ndef determine_winner(N, A):\n    def count_odd_divisors(x):\n        count = 0\n        while x % 2 == 0:\n            x //= 2\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                x //= i\n                count += 1\n        if x > 2:\n            count += 1\n        return count\n    \n    odd_divisor_count = 0\n    for a in A:\n        odd_divisor_count += count_odd_divisors(a)\n    \n    if odd_divisor_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine the winner and print the result\ndetermine_winner(N, A)"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(n):\n        dp[0][i] = 1\n        for j in range(1, n + 1):\n            for k in range(j + 1):\n                if nums[i] - k >= 0:\n                    dp[j][i] = (dp[j][i] + dp[k][i - 1]) % MOD\n    \n    return dp[n][n - 1]", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(n):\n        dp[0][i] = 1\n        for j in range(1, n + 1):\n            for k in range(j + 1):\n                if nums[i] - k >= 0:\n                    dp[j][i] = (dp[j][i] + dp[k][i - 1]) % MOD\n    \n    return dp[n][n - 1]\n```"}
{"task_id": "3527", "code": "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend colors to simulate the circular nature\n    group_counts = {}\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if colors[i] != colors[(i + size) % n]:\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            colors[index] = new_color\n            \n            for size in range(3, n + 1):\n                if old_color != colors[(index + size - 1) % n] and new_color != colors[(index + size) % n]:\n                    group_counts[size] -= 1\n                if old_color != colors[(index + size) % n] and new_color != colors[(index + size + 1) % n]:\n                    group_counts[size] += 1\n    \n    return result", "passed": false, "raw_code": "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend colors to simulate the circular nature\n    group_counts = {}\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if colors[i] != colors[(i + size) % n]:\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            colors[index] = new_color\n            \n            for size in range(3, n + 1):\n                if old_color != colors[(index + size - 1) % n] and new_color != colors[(index + size) % n]:\n                    group_counts[size] -= 1\n                if old_color != colors[(index + size) % n] and new_color != colors[(index + size + 1) % n]:\n                    group_counts[size] += 1\n    \n    return result\n```"}
{"task_id": "abc371_f", "code": "d", "passed": false, "raw_code": "```python\ndef min_movements():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    X = list(map(int, data[index:index+N]))\n    index += N\n    \n    Q = int(data[index])\n    index += 1\n    \n    tasks = []\n    for _ in range(Q):\n        T = int(data[index])\n        index += 1\n        G = int(data[index])\n        index += 1\n        tasks.append((T-1, G))\n    \n    total_movements = 0\n    for T, G in tasks:\n        total_movements += abs(X[T] - G)\n    \n    print(total_movements)\n\nmin_movements()"}
{"task_id": "abc371_g", "code": "d", "passed": false, "raw_code": "```python\ndef smallest_array(N, P, A):\n    # Create a list of tuples (A_i, i)\n    pairs = list(zip(A, range(N)))\n    \n    # Sort the list of tuples based on A_i\n    pairs.sort()\n    \n    # Construct the new array A\n    new_A = [0] * N\n    for i, (value, index) in enumerate(pairs):\n        new_A[P[i] - 1] = value\n    \n    # Print the new array\n    print(' '.join(map(str, new_A)))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Call the function with the input data\nsmallest_array(N, P, A)"}
{"task_id": "abc368_e", "code": "i", "passed": false, "raw_code": "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\n# Parse the trains\ntrains = []\nfor i in range(M):\n    A = int(data[3 + 4 * i])\n    B = int(data[4 + 4 * i])\n    S = int(data[5 + 4 * i])\n    T = int(data[6 + 4 * i])\n    trains.append((A, B, S, T))\n\n# Sort trains by arrival time\ntrains.sort(key=lambda x: x[3])\n\n# Initialize delays\ndelays = [0] * M\ndelays[0] = X1\n\n# Calculate delays\nfor i in range(1, M):\n    A, B, S, T = trains[i]\n    for j in range(i):\n        A_prev, B_prev, S_prev, T_prev = trains[j]\n        if B_prev == A and T_prev <= S:\n            delays[i] = max(delays[i], T - S_prev + delays[j])\n\n# Print the delays\nprint(' '.join(map(str, delays[1:])))"}
{"task_id": "abc373_f", "code": "d", "passed": false, "raw_code": "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    \n    items = []\n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j - k * w >= 0:\n                    dp[j] = max(dp[j], dp[j - k * w] + k * v - k * k)\n                else:\n                    break\n    \n    print(max(dp))\n\nmax_happiness()"}
{"task_id": "abc366_e", "code": "d", "passed": false, "raw_code": "```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    # Sort points by x-coordinate\n    points.sort(key=lambda p: p[0])\n    \n    # Function to count valid pairs for a given x-coordinate\n    def count_for_x(x):\n        y_points = [(y, i) for i, (px, py) in enumerate(points) if px == x]\n        y_points.sort()\n        \n        left_sum = [0] * (len(y_points) + 1)\n        right_sum = [0] * (len(y_points) + 1)\n        \n        for i, (y, _) in enumerate(y_points):\n            left_sum[i + 1] = left_sum[i] + y\n        \n        for i in range(len(y_points) - 1, -1, -1):\n            y, _ = y_points[i]\n            right_sum[i] = right_sum[i + 1] + y\n        \n        count = 0\n        j = len(y_points) - 1\n        for i, (_, idx) in enumerate(y_points):\n            while j > i and abs(idx - y_points[j][1]) * 2 <= D:\n                j -= 1\n            \n            count += max(0, min(D // 2, y_points[j][1] - idx) + min(D // 2, idx - y_points[j][1]))\n        \n        return count\n    \n    total_count = 0\n    for x in set(p[0] for p in points):\n        total_count += count_for_x(x)\n    \n    print(total_count)\n\ncount_valid_pairs()"}
{"task_id": "abc368_g", "code": "c", "passed": false, "raw_code": "```python\nclass SegmentTree:\n    def __init__(self, n):\n        self.n = n\n        self.tree_add = [[0] * (4 * n) for _ in range(2)]\n        self.tree_mul = [[1] * (4 * n) for _ in range(2)]\n\n    def build(self, arr, idx=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if start == end:\n            self.tree_add[0][idx] = arr[start]\n            self.tree_add[1][idx] = arr[start]\n            self.tree_mul[0][idx] = arr[start]\n            self.tree_mul[1][idx] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build(arr, 2 * idx, start, mid)\n            self.build(arr, 2 * idx + 1, mid + 1, end)\n            self.tree_add[0][idx] = max(self.tree_add[0][2 * idx], self.tree_add[0][2 * idx + 1])\n            self.tree_add[1][idx] = max(self.tree_add[1][2 * idx], self.tree_add[1][2 * idx + 1])\n            self.tree_mul[0][idx] = max(self.tree_mul[0][2 * idx], self.tree_mul[0][2 * idx + 1])\n            self.tree_mul[1][idx] = max(self.tree_mul[1][2 * idx], self.tree_mul[1][2 * idx + 1])\n\n    def update(self, arr, idx, pos, new_val, type_idx, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if start == end:\n            arr[pos] = new_val\n            self.tree_add[type_idx][idx] = new_val\n            self.tree_mul[type_idx][idx] = new_val\n        else:\n            mid = (start + end) // 2\n            if pos <= mid:\n                self.update(arr, 2 * idx, pos, new_val, type_idx, start, mid)\n            else:\n                self.update(arr, 2 * idx + 1, pos, new_val, type_idx, mid + 1, end)\n            self.tree_add[type_idx][idx] = max(self.tree_add[type_idx][2 * idx], self.tree_add[type_idx][2 * idx + 1])\n            self.tree_mul[type_idx][idx] = max(self.tree_mul[type_idx][2 * idx], self.tree_mul[type_idx][2 * idx + 1])\n\n    def query(self, left, right, idx=1, start=0, end=None):\n        if end is None:\n            end = self.n - 1\n        if right < start or end < left:\n            return 0\n        if left <= start and end <= right:\n            return max(self.tree_add[0][idx], self.tree_mul[0][idx])\n        mid = (start + end) // 2\n        left_max ="}
{"task_id": "3532", "code": "def min_time_to_mark_all_nodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start):\n        n = len(graph)\n        visited = set()\n        marked = set([start])\n        queue = deque([(start, 0)])\n        time = 0\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node, t = queue.popleft()\n                visited.add(node)\n                \n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        if t % 2 == 0:\n                            if any(neighbor2 in marked for neighbor2 in graph[neighbor]):\n                                queue.append((neighbor, t + 2))\n                                marked.add(neighbor)\n                        else:\n                            if any(neighbor2 in marked for neighbor2 in graph[neighbor]):\n                                queue.append((neighbor, t + 1))\n                                marked.add(neighbor)\n            \n            if len(marked) == n:\n                return t\n        \n        return -1\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = []\n    for i in range(n):\n        result.append(bfs(i))\n    \n    return result", "passed": false, "raw_code": "```python\ndef min_time_to_mark_all_nodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start):\n        n = len(graph)\n        visited = set()\n        marked = set([start])\n        queue = deque([(start, 0)])\n        time = 0\n        \n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node, t = queue.popleft()\n                visited.add(node)\n                \n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        if t % 2 == 0:\n                            if any(neighbor2 in marked for neighbor2 in graph[neighbor]):\n                                queue.append((neighbor, t + 2))\n                                marked.add(neighbor)\n                        else:\n                            if any(neighbor2 in marked for neighbor2 in graph[neighbor]):\n                                queue.append((neighbor, t + 1))\n                                marked.add(neighbor)\n            \n            if len(marked) == n:\n                return t\n        \n        return -1\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = []\n    for i in range(n):\n        result.append(bfs(i))\n    \n    return result\n```"}
{"task_id": "abc369_e", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef bellman_ford(n, edges, start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    for _ in range(n - 1):\n        for u, v, w in edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n            if dist[v] != float('inf') and dist[v] + w < dist[u]:\n                dist[u] = dist[v] + w\n    return dist\n\ndef min_time_to_travel(n, m, edges, queries):\n    dp = [[float('inf')] * (1 << m) for _ in range(n + 1)]\n    dp[1][0] = 0\n\n    for mask in range(1 << m):\n        for u, v, w in edges:\n            if mask & (1 << (u - 1)) and dp[u][mask] != float('inf'):\n                dp[v][mask] = min(dp[v][mask], dp[u][mask] + w)\n            if mask & (1 << (v - 1)) and dp[v][mask] != float('inf'):\n                dp[u][mask] = min(dp[u][mask], dp[v][mask] + w)\n\n    for q in queries:\n        K = q[0]\n        bridges = q[1]\n        min_time = float('inf')\n        for mask in range(1 << m):\n            if all(mask & (1 << (b - 1)) for b in bridges):\n                min_time = min(min_time, dp[N][mask])\n        print(min_time)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nedges = []\nindex = 2\nfor _ in range(M):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\nQ = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(Q):\n    K = int(data[index])\n    bridges = list(map(int, data[index + 1:index + 1 + K]))\n    queries.append((K, bridges))\n    index += 1 + K\n\n# Solve and print results\nmin_time_to_travel(N, M, edges, queries)"}
{"task_id": "abc367_f", "code": "d", "passed": false, "raw_code": "```python\ndef can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        if sorted(subseq_A) == sorted(subseq_B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()"}
{"task_id": "abc370_e", "code": "d", "passed": false, "raw_code": "```python\ndef count_partitions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    MOD = 998244353\n    \n    # dp[i][j] -> number of ways to partition A[:i+1] with j being the last element's inclusion status\n    dp = [[0] * 2 for _ in range(N)]\n    \n    if A[0] != K:\n        dp[0][1] = 1  # Include the first element\n    dp[0][0] = 1  # Exclude the first element\n    \n    for i in range(1, N):\n        dp[i][0] = (dp[i-1][0] + dp[i-1][1]) % MOD  # Exclude current element\n        if A[i] != K:\n            dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD  # Include current element if it doesn't sum to K with previous elements\n    \n    total_ways = (dp[N-1][0] + dp[N-1][1]) % MOD\n    print(total_ways)\n\ncount_partitions()"}
{"task_id": "abc369_g", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef dfs(graph, start, dist):\n    stack = [(start, 0)]\n    while stack:\n        node, d = stack.pop()\n        if node not in dist:\n            dist[node] = d\n            for neighbor, length in graph[node]:\n                stack.append((neighbor, d + length))\n\ndef min_path_length(n, edges, k, vertices):\n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    dist = {}\n    dfs(graph, 1, dist)\n    \n    dp = [[float('inf')] * (k + 1) for _ in range(1 << k)]\n    for i in range(1 << k):\n        dp[i][0] = 0\n    \n    for mask in range(1, 1 << k):\n        for i in range(k):\n            if mask & (1 << i):\n                prev_mask = mask ^ (1 << i)\n                for j in range(k):\n                    if prev_mask & (1 << j):\n                        dp[mask][i] = min(dp[mask][i], dp[prev_mask][j] + dist[vertices[j] + 1] + dist[vertices[i] + 1])\n    \n    return dp[(1 << k) - 1][k - 1]\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(n - 1):\n        u = int(data[2 * i + 1])\n        v = int(data[2 * i + 2])\n        l = int(data[2 * i + 3])\n        edges.append((u, v, l))\n    \n    for k in range(1, n + 1):\n        vertices = list(map(int, data[2 * (n - 1) + 2 * (k - 1):2 * (n - 1) + 2 * k]))\n        result = min_path_length(n, edges, k, vertices)\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef dfs(graph, start, dist):\n    stack = [(start, 0)]\n    while stack:\n        node, d = stack.pop()\n        if node not in dist:\n            dist[node] = d\n            for neighbor, length in graph[node]:\n                stack.append((neighbor, d + length))\n\ndef min_path_length(n, edges, k, vertices):\n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    dist = {}\n    dfs(graph, 1, dist)\n    \n    dp = [[float('inf')] * (k + 1) for _ in range(1 << k)]\n    for i in range(1 << k):\n        dp[i][0] = 0\n    \n    for mask in range(1, 1 << k):\n        for i in range(k):\n            if mask & (1 << i):\n                prev_mask = mask ^ (1 << i)\n                for j in range(k):\n                    if prev_mask & (1 << j):\n                        dp[mask][i] = min(dp[mask][i], dp[prev_mask][j] + dist[vertices[j] + 1] + dist[vertices[i] + 1])\n    \n    return dp[(1 << k) - 1][k - 1]\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(n - 1):\n        u = int(data[2 * i + 1])\n        v = int(data[2 * i + 2])\n        l = int(data[2 * i + 3])\n        edges.append((u, v, l))\n    \n    for k in range(1, n + 1):\n        vertices = list(map(int, data[2 * (n - 1) + 2 * (k - 1):2 * (n - 1) + 2 * k]))\n        result = min_path_length(n, edges, k, vertices)\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n```"}
{"task_id": "abc366_g", "code": "import sympy as sp\n\ndef solve_xor_graph(N, M, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Create the matrix for the system of equations\n    A = sp.Matrix.zeros(N, N)\n    for v in range(1, N + 1):\n        if adj[v]:\n            A[v-1, v-1] = 1\n            for u in adj[v]:\n                A[u-1, v-1] = 1\n    \n    # Check if the system has a solution\n    if A.rank() < N:\n        # Find a particular solution\n        solution = A.nullspace()[0]\n        # Print the solution\n        print(\"Yes\")\n        for x in solution:\n            print(x, end=\" \")\n        print()\n    else:\n        print(\"No\")\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(M)]\n\n# Solve the problem\nsolve_xor_graph(N, M, edges)", "passed": false, "raw_code": "```python\nimport sympy as sp\n\ndef solve_xor_graph(N, M, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Create the matrix for the system of equations\n    A = sp.Matrix.zeros(N, N)\n    for v in range(1, N + 1):\n        if adj[v]:\n            A[v-1, v-1] = 1\n            for u in adj[v]:\n                A[u-1, v-1] = 1\n    \n    # Check if the system has a solution\n    if A.rank() < N:\n        # Find a particular solution\n        solution = A.nullspace()[0]\n        # Print the solution\n        print(\"Yes\")\n        for x in solution:\n            print(x, end=\" \")\n        print()\n    else:\n        print(\"No\")\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(M)]\n\n# Solve the problem\nsolve_xor_graph(N, M, edges)\n```"}
{"task_id": "abc372_g", "code": "i", "passed": false, "raw_code": "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef count_valid_pairs(N, A, B, C):\n    count = 0\n    for x in range(1, max(A)):\n        for y in range(1, max(B)):\n            if all(A[i] * x + B[i] * y < C[i] for i in range(N)):\n                count += 1\n    return count\n\nindex = 0\nresults = []\nT = int(data[index])\nindex += 1\n\nfor _ in range(T):\n    N = int(data[index])\n    index += 1\n    A = [int(data[index]) for index in range(index, index + N)]\n    index += N\n    B = [int(data[index]) for index in range(index, index + N)]\n    index += N\n    C = [int(data[index]) for index in range(index, index + N)]\n    index += N\n    \n    results.append(count_valid_pairs(N, A, B, C))\n\nfor result in results:\n    print(result)"}
{"task_id": "3563", "code": "def maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each column\n    for col in range(len(grid[0])):\n        for row in range(len(grid)):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each column\n    for col in range(len(grid[0])):\n        for row in range(len(grid)):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score\n```"}
{"task_id": "abc373_g", "code": "d", "passed": false, "raw_code": "```python\ndef find_non_crossing_permutation(N, points):\n    def is_valid_pair(i, j):\n        for k in range(len(stack)):\n            if (stack[k][0] <= i <= stack[k][1]) or (stack[k][0] <= j <= stack[k][1]):\n                return False\n        return True\n\n    def backtrack(index):\n        if index == N:\n            return True\n        \n        for i in range(1, N + 1):\n            if not used[i]:\n                if is_valid_pair(index + 1, i):\n                    used[i] = True\n                    stack.append((index + 1, i))\n                    if backtrack(index + 1):\n                        return True\n                    stack.pop()\n                    used[i] = False\n        \n        return False\n\n    points.sort(key=lambda p: (p[0], p[1]))\n    used = [False] * (N + 1)\n    stack = []\n    \n    if backtrack(0):\n        return ' '.join(map(str, [x[1] for x in sorted(stack)]))\n    else:\n        return '-1'\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\npoints = []\n\nfor i in range(N):\n    points.append((int(data[2 * i + 1]), int(data[2 * i + 2])))\n\nfor i in range(N):\n    points.append((int(data[N * 2 + 2 * i + 1]), int(data[N * 2 + 2 * i + 2])))\n\nresult = find_non_crossing_permutation(N, points)\nprint(result)"}
{"task_id": "3551", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def maxXOR(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if alt_bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        xor_val = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(trie.maxXOR(xor_val))\n        trie.insert(xor_val)\n    \n    return result", "passed": false, "raw_code": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def maxXOR(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if alt_bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        xor_val = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(trie.maxXOR(xor_val))\n        trie.insert(xor_val)\n    \n    return result\n```"}
{"task_id": "arc183_d", "code": "d", "passed": false, "raw_code": "```python\ndef max_score_operations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    leaves = []\n    \n    # Collect all leaves\n    for i in range(N-1):\n        A = int(data[2*i+1])\n        B = int(data[2*i+2])\n        if A == 1 or A == N:\n            leaves.append(A)\n        elif B == 1 or B == N:\n            leaves.append(B)\n    \n    # Sort leaves by their indices\n    leaves.sort()\n    \n    # Print the pairs of leaves\n    for i in range(len(leaves)//2):\n        print(f\"{leaves[i]} {leaves[-(i+1)]}\")\n\nmax_score_operations()"}
{"task_id": "3552", "code": "def largest_k_palindrome(n, k):\n    # Helper function to check if a number is divisible by k\n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    # Construct the largest possible n-digit palindrome\n    half_length = (n + 1) // 2\n    max_half = int('9' * half_length)\n    \n    while True:\n        # Create the full palindrome\n        if n % 2 == 0:\n            palindrome = int(str(max_half) + str(max_half)[::-1])\n        else:\n            palindrome = int(str(max_half)[:-1] + str(max_half)[::-1])\n        \n        # Check if the palindrome is divisible by k\n        if is_divisible_by_k(palindrome):\n            return str(palindrome)\n        \n        # Decrement the half-length to try the next smaller palindrome\n        max_half -= 1\n        \n        # If we reach the smallest possible half-length, break the loop\n        if max_half < 10**(half_length - 1):\n            break\n    \n    # Return the largest single-digit number if no valid palindrome is found\n    return str(9 if k == 1 else 8)", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n, k):\n    # Helper function to check if a number is divisible by k\n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    # Construct the largest possible n-digit palindrome\n    half_length = (n + 1) // 2\n    max_half = int('9' * half_length)\n    \n    while True:\n        # Create the full palindrome\n        if n % 2 == 0:\n            palindrome = int(str(max_half) + str(max_half)[::-1])\n        else:\n            palindrome = int(str(max_half)[:-1] + str(max_half)[::-1])\n        \n        # Check if the palindrome is divisible by k\n        if is_divisible_by_k(palindrome):\n            return str(palindrome)\n        \n        # Decrement the half-length to try the next smaller palindrome\n        max_half -= 1\n        \n        # If we reach the smallest possible half-length, break the loop\n        if max_half < 10**(half_length - 1):\n            break\n    \n    # Return the largest single-digit number if no valid palindrome is found\n    return str(9 if k == 1 else 8)\n```"}
{"task_id": "arc183_b", "code": "def can_transform_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        # Sort both sequences\n        A_sorted = sorted(A)\n        B_sorted = sorted(B)\n        \n        # Check if they are equal\n        if A_sorted == B_sorted:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\ncan_transform_to_B()", "passed": false, "raw_code": "```python\ndef can_transform_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        # Sort both sequences\n        A_sorted = sorted(A)\n        B_sorted = sorted(B)\n        \n        # Check if they are equal\n        if A_sorted == B_sorted:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    # Print all results\n    for result in results:\n        print(result)\n\ncan_transform_to_B()\n```"}
{"task_id": "arc181_c", "code": "def generate_grid(N, P, Q):\n    grid = [[0] * N for _ in range(N)]\n    \n    # Fill the grid with zeros and then adjust to satisfy row conditions\n    for i in range(N):\n        for j in range(N):\n            grid[i][j] = 0 if (i + 1) % 2 == 1 else 1\n    \n    # Adjust columns to satisfy column conditions\n    for j in range(N):\n        for i in range(N):\n            if grid[i][j] == 1 and (i + 1) % 2 == 0:\n                grid[i][j] = 0\n    \n    # Print the grid\n    for i in range(N):\n        for j in range(N):\n            print(grid[i][j], end='')\n        print()\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Generate and print the grid\ngenerate_grid(N, P, Q)", "passed": false, "raw_code": "```python\ndef generate_grid(N, P, Q):\n    grid = [[0] * N for _ in range(N)]\n    \n    # Fill the grid with zeros and then adjust to satisfy row conditions\n    for i in range(N):\n        for j in range(N):\n            grid[i][j] = 0 if (i + 1) % 2 == 1 else 1\n    \n    # Adjust columns to satisfy column conditions\n    for j in range(N):\n        for i in range(N):\n            if grid[i][j] == 1 and (i + 1) % 2 == 0:\n                grid[i][j] = 0\n    \n    # Print the grid\n    for i in range(N):\n        for j in range(N):\n            print(grid[i][j], end='')\n        print()\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Generate and print the grid\ngenerate_grid(N, P, Q)\n```"}
{"task_id": "3548", "code": "def countGoodIntegers(n, k):\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n    \n    def count_k_palindromic(n, k):\n        if n == 1:\n            return k if k % 2 == 0 else k - 1\n        if n == 2:\n            return k * (k - 1) // 2\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[1][0] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = dp[i - 1][j] * (k - j) + dp[i - 2][j] * (k - j) * (k - j - 1) // 2\n        \n        return dp[n][0]\n    \n    return count_k_palindromic(n, k)", "passed": false, "raw_code": "```python\ndef countGoodIntegers(n, k):\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n    \n    def count_k_palindromic(n, k):\n        if n == 1:\n            return k if k % 2 == 0 else k - 1\n        if n == 2:\n            return k * (k - 1) // 2\n        \n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        dp[1][0] = 1\n        \n        for i in range(2, n + 1):\n            for j in range(k + 1):\n                dp[i][j] = dp[i - 1][j] * (k - j) + dp[i - 2][j] * (k - j) * (k - j - 1) // 2\n        \n        return dp[n][0]\n    \n    return count_k_palindromic(n, k)\n```"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [1] + [0] * (Q - 1)\n    max_val = [0] * (N + 1)\n\n    for i in range(Q - 1, -1, -1):\n        p, v = P[i], V[i]\n        dp[i] = dp[i + 1]\n        if p == 1:\n            if max_val[p] > v:\n                continue\n            dp[i] += dp[i + 1]\n        else:\n            if max_val[N] > v:\n                continue\n            dp[i] += dp[i + 1]\n        dp[i] %= MOD\n        max_val[min(p, N)] = v\n\n    return dp[0]\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nP = list(map(int, data[2::2]))\nV = list(map(int, data[3::2]))\n\n# Call the function and print the result\nprint(count_valid_sequences(N, Q, P, V))", "passed": false, "raw_code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [1] + [0] * (Q - 1)\n    max_val = [0] * (N + 1)\n\n    for i in range(Q - 1, -1, -1):\n        p, v = P[i], V[i]\n        dp[i] = dp[i + 1]\n        if p == 1:\n            if max_val[p] > v:\n                continue\n            dp[i] += dp[i + 1]\n        else:\n            if max_val[N] > v:\n                continue\n            dp[i] += dp[i + 1]\n        dp[i] %= MOD\n        max_val[min(p, N)] = v\n\n    return dp[0]\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nP = list(map(int, data[2::2]))\nV = list(map(int, data[3::2]))\n\n# Call the function and print the result\nprint(count_valid_sequences(N, Q, P, V))"}
{"task_id": "abc373_e", "code": "def min_additional_votes(N, M, K, A):\n    # Calculate the current total votes\n    current_total_votes = sum(A)\n    \n    # Determine the remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Sort the candidates based on their votes\n    sorted_indices = sorted(range(N), key=lambda x: A[x], reverse=True)\n    \n    # Initialize the result array\n    C = [-1] * N\n    \n    # Iterate through the sorted list\n    for i in range(N):\n        # Calculate the maximum number of votes any other candidate could receive\n        max_votes_other_candidates = sum(A[j] for j in range(N) if j != i)\n        \n        # Check the condition\n        if max_votes_other_candidates < remaining_votes + A[i]:\n            C[sorted_indices[i]] = remaining_votes - (max_votes_other_candidates - A[i])\n    \n    return ' '.join(map(str, C))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Get the result\nresult = min_additional_votes(N, M, K, A)\n\n# Print the result\nprint(result)", "passed": false, "raw_code": "```python\ndef min_additional_votes(N, M, K, A):\n    # Calculate the current total votes\n    current_total_votes = sum(A)\n    \n    # Determine the remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Sort the candidates based on their votes\n    sorted_indices = sorted(range(N), key=lambda x: A[x], reverse=True)\n    \n    # Initialize the result array\n    C = [-1] * N\n    \n    # Iterate through the sorted list\n    for i in range(N):\n        # Calculate the maximum number of votes any other candidate could receive\n        max_votes_other_candidates = sum(A[j] for j in range(N) if j != i)\n        \n        # Check the condition\n        if max_votes_other_candidates < remaining_votes + A[i]:\n            C[sorted_indices[i]] = remaining_votes - (max_votes_other_candidates - A[i])\n    \n    return ' '.join(map(str, C))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Get the result\nresult = min_additional_votes(N, M, K, A)\n\n# Print the result\nprint(result)\n```"}
{"task_id": "arc183_c", "code": "d", "passed": false, "raw_code": "```python\ndef count_valid_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = []\n    index = 2\n    for _ in range(M):\n        L = int(data[index]) - 1\n        R = int(data[index + 1]) - 1\n        X = int(data[index + 2]) - 1\n        conditions.append((L, R, X))\n        index += 3\n    \n    MOD = 998244353\n    \n    dp = [[0] * N for _ in range(N)]\n    for j in range(N):\n        dp[j][j] = 1\n    \n    for k in range(1, N):\n        new_dp = [[0] * N for _ in range(N)]\n        for i in range(k, N):\n            for j in range(i + 1):\n                if j == k:\n                    new_dp[j][k] = sum(dp[l][k] for l in range(j)) % MOD\n                else:\n                    new_dp[j][k] = (new_dp[j][k] + dp[j][l] * (k - l)) % MOD\n        \n        for j in range(N):\n            for x in range(N):\n                if x != j:\n                    for L, R, X in conditions:\n                        if L <= x < R:\n                            continue\n                        if max(dp[x][y] for y in range(L, R + 1)) == dp[x][x]:\n                            new_dp[j][x] = (new_dp[j][x] - dp[j][x] + MOD) % MOD\n        \n        dp = new_dp\n    \n    result = sum(dp[j][j] for j in range(N)) % MOD\n    print(result)\n\ncount_valid_permutations()"}
{"task_id": "abc368_d", "code": "def find_lca(parent, v1, v2):\n    ancestors = set()\n    \n    while v1 != -1:\n        ancestors.add(v1)\n        v1 = parent[v1]\n    \n    while v2 not in ancestors:\n        v2 = parent[v2]\n    \n    return v2\n\ndef dfs(node, parent, graph, visited, depth, lca_depths, lca_nodes):\n    if node == -1:\n        return\n    \n    visited[node] = True\n    depth[node] = depth[parent] + 1\n    \n    if len(visited) == K:\n        current_lca = find_lca(parent, node, lca_nodes[0])\n        if depth[current_lca] < lca_depths[0]:\n            lca_depths[0] = depth[current_lca]\n            lca_nodes[0] = current_lca\n    \n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, node, graph, visited, depth, lca_depths, lca_nodes)\n    \n    visited[node] = False\n\ndef min_vertices_to_include_all_k(N, K, edges, V):\n    graph = [[] for _ in range(N + 1)]\n    parent = [-1] * (N + 1)\n    depth = [0] * (N + 1)\n    lca_depths = [float('inf')]\n    lca_nodes = [None]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    for v in V:\n        visited = [False] * (N + 1)\n        dfs(v, -1, graph, visited, depth, lca_depths, lca_nodes)\n    \n    return lca_depths[0] + 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i]) - 1\n    v = int(data[3 + 2 * i]) - 1\n    edges.append((u, v))\n\nV = list(map(int, data[2 * N + 2:]))\n\nprint(min_vertices_to_include_all_k(N, K, edges, V))", "passed": false, "raw_code": "```python\ndef find_lca(parent, v1, v2):\n    ancestors = set()\n    \n    while v1 != -1:\n        ancestors.add(v1)\n        v1 = parent[v1]\n    \n    while v2 not in ancestors:\n        v2 = parent[v2]\n    \n    return v2\n\ndef dfs(node, parent, graph, visited, depth, lca_depths, lca_nodes):\n    if node == -1:\n        return\n    \n    visited[node] = True\n    depth[node] = depth[parent] + 1\n    \n    if len(visited) == K:\n        current_lca = find_lca(parent, node, lca_nodes[0])\n        if depth[current_lca] < lca_depths[0]:\n            lca_depths[0] = depth[current_lca]\n            lca_nodes[0] = current_lca\n    \n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, node, graph, visited, depth, lca_depths, lca_nodes)\n    \n    visited[node] = False\n\ndef min_vertices_to_include_all_k(N, K, edges, V):\n    graph = [[] for _ in range(N + 1)]\n    parent = [-1] * (N + 1)\n    depth = [0] * (N + 1)\n    lca_depths = [float('inf')]\n    lca_nodes = [None]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    for v in V:\n        visited = [False] * (N + 1)\n        dfs(v, -1, graph, visited, depth, lca_depths, lca_nodes)\n    \n    return lca_depths[0] + 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i]) - 1\n    v = int(data[3 + 2 * i]) - 1\n    edges.append((u, v))\n\nV = list(map(int, data[2 * N + 2:]))\n\nprint(min_vertices_to_include_all_k(N, K, edges, V))\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        for j in range(i, N):\n            if A[j] not in seen:\n                distinct_count += 1\n                seen.add(A[j])\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        for j in range(i, N):\n            if A[j] not in seen:\n                distinct_count += 1\n                seen.add(A[j])\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc367_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(N):\n        prefix_xor[i + 1] = prefix_xor[i] ^ A[i]\n    \n    # Count subsequences of length that is a multiple of M\n    total_score = 0\n    for length in range(1, N + 1):\n        if length % M == 0:\n            for start in range(N - length + 1):\n                xor_value = prefix_xor[start + length] ^ prefix_xor[start]\n                total_score += pow(xor_value, K, MOD)\n                total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(N):\n        prefix_xor[i + 1] = prefix_xor[i] ^ A[i]\n    \n    # Count subsequences of length that is a multiple of M\n    total_score = 0\n    for length in range(1, N + 1):\n        if length % M == 0:\n            for start in range(N - length + 1):\n                xor_value = prefix_xor[start + length] ^ prefix_xor[start]\n                total_score += pow(xor_value, K, MOD)\n                total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc367_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    K = int(data[1])\n    X = list(map(int, data[2:N+2]))\n    A = list(map(int, data[N+2:]))\n\n    # Find the cycle length\n    visited = set()\n    current = 0\n    cycle_length = 0\n    while current not in visited:\n        visited.add(current)\n        current = X[current] - 1\n        cycle_length += 1\n\n    # Determine the effective number of operations within the cycle\n    effective_K = K % cycle_length\n\n    # Apply the effective number of operations\n    for _ in range(effective_K):\n        new_A = [0] * N\n        for i in range(N):\n            new_A[i] = A[X[i] - 1]\n        A = new_A\n\n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    K = int(data[1])\n    X = list(map(int, data[2:N+2]))\n    A = list(map(int, data[N+2:]))\n\n    # Find the cycle length\n    visited = set()\n    current = 0\n    cycle_length = 0\n    while current not in visited:\n        visited.add(current)\n        current = X[current] - 1\n        cycle_length += 1\n\n    # Determine the effective number of operations within the cycle\n    effective_K = K % cycle_length\n\n    # Apply the effective number of operations\n    for _ in range(effective_K):\n        new_A = [0] * N\n        for i in range(N):\n            new_A[i] = A[X[i] - 1]\n        A = new_A\n\n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\nmain()"}
{"task_id": "abc366_f", "code": "import sys\nfrom itertools import permutations\n\ndef max_nested_function_value(N, K, A, B):\n    # Precompute the maximum value for each possible permutation of p\n    max_value = float('-inf')\n    for perm in permutations(range(1, N+1), K):\n        coeff_A = 1\n        coeff_B = 0\n        for p in perm:\n            coeff_A *= A[p-1]\n            coeff_B += B[p-1] * coeff_A\n        max_value = max(max_value, coeff_B)\n    \n    return int(max_value)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = [int(data[i]) for i in range(2, 2*N+1, 2)]\nB = [int(data[i]) for i in range(3, 2*N+2, 2)]\n\n# Compute and print the result\nprint(max_nested_function_value(N, K, A, B))", "passed": false, "raw_code": "```python\nimport sys\nfrom itertools import permutations\n\ndef max_nested_function_value(N, K, A, B):\n    # Precompute the maximum value for each possible permutation of p\n    max_value = float('-inf')\n    for perm in permutations(range(1, N+1), K):\n        coeff_A = 1\n        coeff_B = 0\n        for p in perm:\n            coeff_A *= A[p-1]\n            coeff_B += B[p-1] * coeff_A\n        max_value = max(max_value, coeff_B)\n    \n    return int(max_value)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = [int(data[i]) for i in range(2, 2*N+1, 2)]\nB = [int(data[i]) for i in range(3, 2*N+2, 2)]\n\n# Compute and print the result\nprint(max_nested_function_value(N, K, A, B))\n```"}
{"task_id": "3550", "code": "def maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Find the indices of the top three values in each row and column\n    row_max_indices = []\n    col_max_indices = []\n    \n    for i in range(m):\n        row_max_indices.append(sorted(range(n), key=lambda j: board[i][j], reverse=True)[:3])\n    \n    for j in range(n):\n        col_max_indices.append(sorted(range(m), key=lambda i: board[i][j], reverse=True)[:3])\n    \n    max_sum = float('-inf')\n    \n    # Check all combinations of top three indices from rows and columns\n    for r_indices in row_max_indices:\n        for c_indices in col_max_indices:\n            if len(set(r_indices).intersection(c_indices)) == 0:\n                current_sum = sum(board[r][c] for r, c in zip(r_indices, c_indices))\n                max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "passed": false, "raw_code": "```python\ndef maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Find the indices of the top three values in each row and column\n    row_max_indices = []\n    col_max_indices = []\n    \n    for i in range(m):\n        row_max_indices.append(sorted(range(n), key=lambda j: board[i][j], reverse=True)[:3])\n    \n    for j in range(n):\n        col_max_indices.append(sorted(range(m), key=lambda i: board[i][j], reverse=True)[:3])\n    \n    max_sum = float('-inf')\n    \n    # Check all combinations of top three indices from rows and columns\n    for r_indices in row_max_indices:\n        for c_indices in col_max_indices:\n            if len(set(r_indices).intersection(c_indices)) == 0:\n                current_sum = sum(board[r][c] for r, c in zip(r_indices, c_indices))\n                max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"}
{"task_id": "arc182_c", "code": "import sys\nfrom collections import defaultdict\nMOD = 998244353\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    dp = defaultdict(int)\n    dp[1] = 1\n    for i in range(1, M + 1):\n        new_dp = defaultdict(int)\n        for j in dp:\n            new_dp[j * i] += dp[j]\n            new_dp[j * i] %= MOD\n        dp = new_dp\n    total_score = 0\n    for product in dp:\n        total_score += count_divisors(product)\n        total_score %= MOD\n    print(total_score)\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict\nMOD = 998244353\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    dp = defaultdict(int)\n    dp[1] = 1\n    for i in range(1, M + 1):\n        new_dp = defaultdict(int)\n        for j in dp:\n            new_dp[j * i] += dp[j]\n            new_dp[j * i] %= MOD\n        dp = new_dp\n    total_score = 0\n    for product in dp:\n        total_score += count_divisors(product)\n        total_score %= MOD\n    print(total_score)\nif __name__ == '__main__':\n    main()"}
{"task_id": "arc182_d", "code": "def min_operations_to_transform(N, M, A, B):\n    operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        # Calculate the minimum operations needed considering wrap-around\n        min_ops = min(diff, M - diff)\n        if i > 0 and A[i-1] == A[i+1]:\n            if min_ops % 2 != 0:\n                return -1\n            operations += min_ops // 2\n        else:\n            operations += min_ops\n    return operations\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Print the result\nprint(min_operations_to_transform(N, M, A, B))", "passed": false, "raw_code": "def min_operations_to_transform(N, M, A, B):\n    operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        # Calculate the minimum operations needed considering wrap-around\n        min_ops = min(diff, M - diff)\n        if i > 0 and A[i-1] == A[i+1]:\n            if min_ops % 2 != 0:\n                return -1\n            operations += min_ops // 2\n        else:\n            operations += min_ops\n    return operations\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Print the result\nprint(min_operations_to_transform(N, M, A, B))"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time it takes for each enemy to die\n    times = [(health[i] / damage[i]) for i in range(n)]\n    # Sort enemies by the time it takes to die in descending order\n    indices = sorted(range(n), key=lambda i: times[i], reverse=True)\n    \n    total_damage = 0\n    for i in indices:\n        if health[i] > 0:\n            # Calculate how many full attacks can be made\n            full_attacks = int(health[i] // power)\n            # Calculate the remaining damage after full attacks\n            remaining_damage = health[i] % power\n            # Update total damage and reduce health of the enemy\n            total_damage += full_attacks * power + max(remaining_damage, 0)\n            health[i] = 0\n    \n    return total_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time it takes for each enemy to die\n    times = [(health[i] / damage[i]) for i in range(n)]\n    # Sort enemies by the time it takes to die in descending order\n    indices = sorted(range(n), key=lambda i: times[i], reverse=True)\n    \n    total_damage = 0\n    for i in indices:\n        if health[i] > 0:\n            # Calculate how many full attacks can be made\n            full_attacks = int(health[i] // power)\n            # Calculate the remaining damage after full attacks\n            remaining_damage = health[i] % power\n            # Update total damage and reduce health of the enemy\n            total_damage += full_attacks * power + max(remaining_damage, 0)\n            health[i] = 0\n    \n    return total_damage\n```"}
{"task_id": "3575", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\ndef insert(root, num):\n    node = root\n    for bit in range(7, -1, -1):\n        bit_val = (num >> bit) & 1\n        if bit_val not in node.children:\n            node.children[bit_val] = TrieNode()\n        node = node.children[bit_val]\n\ndef query(root, num):\n    node = root\n    xor_value = 0\n    for bit in range(7, -1, -1):\n        bit_val = (num >> bit) & 1\n        opposite_bit_val = 1 - bit_val\n        if opposite_bit_val in node.children:\n            xor_value |= (1 << bit)\n            node = node.children[opposite_bit_val]\n        else:\n            node = node.children[bit_val]\n    return xor_value\n\ndef max_xor_subsequence(nums, k):\n    nums.sort()\n    n = len(nums)\n    root = TrieNode()\n    max_xor = 0\n    \n    for i in range(n):\n        if i >= 2 * k:\n            insert(root, nums[i - 2 * k])\n        \n        if i >= k:\n            max_xor = max(max_xor, query(root, nums[i]))\n    \n    return max_xor", "passed": false, "raw_code": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n\ndef insert(root, num):\n    node = root\n    for bit in range(7, -1, -1):\n        bit_val = (num >> bit) & 1\n        if bit_val not in node.children:\n            node.children[bit_val] = TrieNode()\n        node = node.children[bit_val]\n\ndef query(root, num):\n    node = root\n    xor_value = 0\n    for bit in range(7, -1, -1):\n        bit_val = (num >> bit) & 1\n        opposite_bit_val = 1 - bit_val\n        if opposite_bit_val in node.children:\n            xor_value |= (1 << bit)\n            node = node.children[opposite_bit_val]\n        else:\n            node = node.children[bit_val]\n    return xor_value\n\ndef max_xor_subsequence(nums, k):\n    nums.sort()\n    n = len(nums)\n    root = TrieNode()\n    max_xor = 0\n    \n    for i in range(n):\n        if i >= 2 * k:\n            insert(root, nums[i - 2 * k])\n        \n        if i >= k:\n            max_xor = max(max_xor, query(root, nums[i]))\n    \n    return max_xor\n```"}
{"task_id": "arc181_b", "code": "d", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        count_X_0 = X.count('0')\n        count_X_1 = X.count('1')\n        count_Y_0 = Y.count('0')\n        count_Y_1 = Y.count('1')\n        \n        if count_X_0 == count_Y_0 and count_X_1 == count_Y_1:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nsolve()"}
{"task_id": "abc372_f", "code": "def count_ways(N, M, K):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    \n    # Initial condition\n    dp[0][1] = 1\n    \n    # Process each move\n    for k in range(1, K + 1):\n        # Transition due to circular edges\n        for i in range(1, N + 1):\n            dp[k][i] += dp[k - 1][(i % N) + 1]\n            dp[k][i] %= MOD\n        \n        # Transition due to additional edges\n        for i in range(M):\n            x, y = edges[i]\n            dp[k][y] += dp[k - 1][x]\n            dp[k][y] %= MOD\n    \n    # Sum up the number of ways to reach any vertex after K moves\n    result = sum(dp[K]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\n\nedges = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(M)]\n\n# Compute and print the result\nprint(count_ways(N, M, K))", "passed": false, "raw_code": "```python\ndef count_ways(N, M, K):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    \n    # Initial condition\n    dp[0][1] = 1\n    \n    # Process each move\n    for k in range(1, K + 1):\n        # Transition due to circular edges\n        for i in range(1, N + 1):\n            dp[k][i] += dp[k - 1][(i % N) + 1]\n            dp[k][i] %= MOD\n        \n        # Transition due to additional edges\n        for i in range(M):\n            x, y = edges[i]\n            dp[k][y] += dp[k - 1][x]\n            dp[k][y] %= MOD\n    \n    # Sum up the number of ways to reach any vertex after K moves\n    result = sum(dp[K]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\n\nedges = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(M)]\n\n# Compute and print the result\nprint(count_ways(N, M, K))\n```"}
{"task_id": "arc181_d", "code": "import sys\nfrom typing import List\n\nclass FenwickTree:\n    def __init__(self, size: int):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def add(self, index: int, value: int) -> None:\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef count_inversions(arr: List[int]) -> int:\n    sorted_arr = sorted(set(arr))\n    rank = {value: idx + 1 for idx, value in enumerate(sorted_arr)}\n    fenwick_tree = FenwickTree(len(rank))\n    inversions = 0\n    for num in arr[::-1]:\n        inversions += fenwick_tree.query(rank[num] - 1)\n        fenwick_tree.add(rank[num], 1)\n    return inversions\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    results = []\n    current_permutation = P[:]\n    for a in A:\n        for i in range(a - 1, len(current_permutation) - 1):\n            if current_permutation[i] > current_permutation[i + 1]:\n                current_permutation[i], current_permutation[i + 1] = current_permutation[i + 1], current_permutation[i]\n        results.append(count_inversions(current_permutation))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "import sys\nfrom typing import List\n\nclass FenwickTree:\n    def __init__(self, size: int):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def add(self, index: int, value: int) -> None:\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef count_inversions(arr: List[int]) -> int:\n    sorted_arr = sorted(set(arr))\n    rank = {value: idx + 1 for idx, value in enumerate(sorted_arr)}\n    fenwick_tree = FenwickTree(len(rank))\n    inversions = 0\n    for num in arr[::-1]:\n        inversions += fenwick_tree.query(rank[num] - 1)\n        fenwick_tree.add(rank[num], 1)\n    return inversions\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    results = []\n    current_permutation = P[:]\n    for a in A:\n        for i in range(a - 1, len(current_permutation) - 1):\n            if current_permutation[i] > current_permutation[i + 1]:\n                current_permutation[i], current_permutation[i + 1] = current_permutation[i + 1], current_permutation[i]\n        results.append(count_inversions(current_permutation))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "abc370_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Initialize DP table\n    dp = [[float('-inf')] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(1, min(i, K) + 1):\n            for k in range(i - 1, j - 2, -1):\n                dp[i][j] = max(dp[i][j], min(dp[k][j - 1], sum(A[k:i])))\n\n    # Find the maximum possible minimum weight\n    max_min_weight = max(dp[N][j] for j in range(1, K + 1))\n\n    # Count the number of cut lines that are never cut\n    never_cut = 0\n    for i in range(N - 1, 0, -1):\n        if dp[i][K] == dp[i + 1][K]:\n            never_cut += 1\n\n    print(max_min_weight, never_cut)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Initialize DP table\n    dp = [[float('-inf')] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(1, min(i, K) + 1):\n            for k in range(i - 1, j - 2, -1):\n                dp[i][j] = max(dp[i][j], min(dp[k][j - 1], sum(A[k:i])))\n\n    # Find the maximum possible minimum weight\n    max_min_weight = max(dp[N][j] for j in range(1, K + 1))\n\n    # Count the number of cut lines that are never cut\n    never_cut = 0\n    for i in range(N - 1, 0, -1):\n        if dp[i][K] == dp[i + 1][K]:\n            never_cut += 1\n\n    print(max_min_weight, never_cut)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "arc182_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Compute the remainders of Ck mod M for k = 0 to M-1\n    remainders = [(C * k) % M for k in range(M)]\n    \n    # Find the minimum value of (Ck + A_i) mod M for each remainder\n    min_values = [float('inf')] * M\n    for r in remainders:\n        for a in A:\n            min_values[r] = min(min_values[r], (r + a) % M)\n    \n    # Calculate the total sum\n    total_sum = 0\n    count = K // M\n    remaining = K % M\n    \n    for r in range(M):\n        if count > 0:\n            total_sum += min_values[r] * count\n        if remaining > 0 and remainders[remaining - 1] == r:\n            total_sum += min_values[r]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Compute the remainders of Ck mod M for k = 0 to M-1\n    remainders = [(C * k) % M for k in range(M)]\n    \n    # Find the minimum value of (Ck + A_i) mod M for each remainder\n    min_values = [float('inf')] * M\n    for r in remainders:\n        for a in A:\n            min_values[r] = min(min_values[r], (r + a) % M)\n    \n    # Calculate the total sum\n    total_sum = 0\n    count = K // M\n    remaining = K % M\n    \n    for r in range(M):\n        if count > 0:\n            total_sum += min_values[r] * count\n        if remaining > 0 and remainders[remaining - 1] == r:\n            total_sum += min_values[r]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc370_g", "code": "import sys\nfrom collections import defaultdict\ndef good_integer(n):\n    div_sum = sum(i for i in range(1, n + 1) if n % i == 0)\n    return div_sum % 3 == 0\n\nMOD = 998244353\nN, M = map(int, input().split())\ndp = [[defaultdict(int) for _ in range(3)] for _ in range(M + 1)]\ndp[0][1][1] = 1\nfor i in range(1, M + 1):\n    for j in range(1, N + 1):\n        if good_integer(j):\n            for k in range(3):\n                for l in range(3):\n                    dp[i][k][l] += dp[i - 1][k * j % 3][(l * j) % 3]\n                    dp[i][k][l] %= MOD\nans = 0\nfor k in range(3):\n    for l in range(3):\n        ans += dp[M][k][l]\n        ans %= MOD\nprint(ans)\n", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict\ndef good_integer(n):\n    div_sum = sum(i for i in range(1, n + 1) if n % i == 0)\n    return div_sum % 3 == 0\n\nMOD = 998244353\nN, M = map(int, input().split())\ndp = [[defaultdict(int) for _ in range(3)] for _ in range(M + 1)]\ndp[0][1][1] = 1\nfor i in range(1, M + 1):\n    for j in range(1, N + 1):\n        if good_integer(j):\n            for k in range(3):\n                for l in range(3):\n                    dp[i][k][l] += dp[i - 1][k * j % 3][(l * j) % 3]\n                    dp[i][k][l] %= MOD\nans = 0\nfor k in range(3):\n    for l in range(3):\n        ans += dp[M][k][l]\n        ans %= MOD\nprint(ans)\n"}
{"task_id": "3560", "code": "def min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, dist = queue.pop(0)\n        if (x, y) == (px, py):\n            return dist\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, dist + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    @lru_cache(None)\n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        if turn == 'Alice':\n            max_moves = 0\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    new_pawns = pawns[:i] + pawns[i+1:]\n                    max_moves = max(max_moves, moves + dfs(new_pawns, 'Bob'))\n            return max_moves\n        else:\n            min_moves = float('inf')\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    new_pawns = pawns[:i] + pawns[i+1:]\n                    min_moves = min(min_moves, dfs(new_pawns, 'Alice'))\n            return min_moves\n    \n    return dfs(tuple(positions), 'Alice')\n\ndef solution(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)", "passed": false, "raw_code": "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, dist = queue.pop(0)\n        if (x, y) == (px, py):\n            return dist\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, dist + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    @lru_cache(None)\n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        if turn == 'Alice':\n            max_moves = 0\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    new_pawns = pawns[:i] + pawns[i+1:]\n                    max_moves = max(max_moves, moves + dfs(new_pawns, 'Bob'))\n            return max_moves\n        else:\n            min_moves = float('inf')\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    new_pawns = pawns[:i] + pawns[i+1:]\n                    min_moves = min(min_moves, dfs(new_pawns, 'Alice'))\n            return min_moves\n    \n    return dfs(tuple(positions), 'Alice')\n\ndef solution(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)\n```"}
{"task_id": "abc372_e", "code": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            graph[u].append(v)\n            graph[v].append(u)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            \n            if not graph[v]:\n                results.append(-1)\n                continue\n            \n            heap = []\n            for neighbor in graph[v]:\n                if len(heap) < k:\n                    heapq.heappush(heap, neighbor)\n                else:\n                    heapq.heappushpop(heap, neighbor)\n            \n            if len(heap) < k:\n                results.append(-1)\n            else:\n                results.append(heap[0])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            graph[u].append(v)\n            graph[v].append(u)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            \n            if not graph[v]:\n                results.append(-1)\n                continue\n            \n            heap = []\n            for neighbor in graph[v]:\n                if len(heap) < k:\n                    heapq.heappush(heap, neighbor)\n                else:\n                    heapq.heappushpop(heap, neighbor)\n            \n            if len(heap) < k:\n                results.append(-1)\n            else:\n                results.append(heap[0])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    def dfs(i):\n        if dp[i] != -1:\n            return dp[i]\n        \n        dp[i] = 1\n        for j in graph[i]:\n            dp[i] = max(dp[i], dfs(j) + 1)\n        \n        return dp[i]\n    \n    n = len(coordinates)\n    coordinates.sort()\n    graph = [[] for _ in range(n)]\n    dp = [-1] * n\n    \n    # Build the graph\n    for i in range(n):\n        for j in range(n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[i].append(j)\n    \n    return dfs(k)", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    def dfs(i):\n        if dp[i] != -1:\n            return dp[i]\n        \n        dp[i] = 1\n        for j in graph[i]:\n            dp[i] = max(dp[i], dfs(j) + 1)\n        \n        return dp[i]\n    \n    n = len(coordinates)\n    coordinates.sort()\n    graph = [[] for _ in range(n)]\n    dp = [-1] * n\n    \n    # Build the graph\n    for i in range(n):\n        for j in range(n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[i].append(j)\n    \n    return dfs(k)\n```"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    n, m = len(s), len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    n, m = len(s), len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"}
{"task_id": "3583", "code": "from collections import defaultdict\nfrom math import gcd\nfrom typing import List\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Compute the GCD of all pairs and count occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    # Sort the unique GCD values\n    sorted_gcds = sorted(gcd_counts.keys())\n    \n    # Answer the queries\n    result = []\n    for query in queries:\n        index = 0\n        for g in sorted_gcds:\n            if query >= gcd_counts[g]:\n                query -= gcd_counts[g]\n                index += 1\n            else:\n                result.append(g)\n                break\n    \n    return result", "passed": false, "raw_code": "```python\nfrom collections import defaultdict\nfrom math import gcd\nfrom typing import List\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Compute the GCD of all pairs and count occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    # Sort the unique GCD values\n    sorted_gcds = sorted(gcd_counts.keys())\n    \n    # Answer the queries\n    result = []\n    for query in queries:\n        index = 0\n        for g in sorted_gcds:\n            if query >= gcd_counts[g]:\n                query -= gcd_counts[g]\n                index += 1\n            else:\n                result.append(g)\n                break\n    \n    return result\n```"}
{"final_accuracy": "0.00%"}
