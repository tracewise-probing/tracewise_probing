"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.5, \"n\": 8, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_temp05__qwen_7b_hard_n_8.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3563", "codes": ["def maxScore(grid):\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    for col in range(len(grid[0]) - 1, -1, -1):\n        for row in range(len(grid)):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score", "def maxScore(grid):\n    rows, cols = len(grid), len(grid[0])\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    for col in range(cols):\n        for row in range(rows):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score", "import heapq\n\ndef maxScore(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    # Priority queue to store the largest values\n    pq = []\n    \n    # Set to keep track of used columns\n    used_columns = set()\n    \n    for i in range(n):\n        # Find the largest value in the current row that is not in the same column as any previously chosen value\n        for j in range(m - 1, -1, -1):\n            if j not in used_columns:\n                heapq.heappush(pq, -grid[i][j])\n                used_columns.add(j)\n                break\n    \n    # Sum up the values in the priority queue to get the maximum score\n    return -sum(pq)", "def maxScore(grid):\n    def backtrack(row, selected_cols, current_score):\n        if row == len(grid):\n            return current_score\n        max_score = 0\n        for col in range(len(grid[row])):\n            if col not in selected_cols:\n                selected_cols.add(col)\n                max_score = max(max_score, backtrack(row + 1, selected_cols, current_score + grid[row][col]))\n                selected_cols.remove(col)\n        return max_score\n\n    for row in grid:\n        row.sort(reverse=True)\n    return backtrack(0, set(), 0)", "def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score", "def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score", "def maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected = set()\n    score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected:\n                selected.add(value)\n                score += value\n                break\n    \n    return score", "def maxScore(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    # Initialize dp array with negative infinity\n    dp = [-float('inf')] * (1 << m)\n    dp[0] = 0\n    \n    for mask in range(1 << m):\n        count_ones = bin(mask).count('1')\n        if count_ones > n:\n            continue\n        \n        for j in range(m):\n            if mask & (1 << j):\n                prev_mask = mask ^ (1 << j)\n                dp[mask] = max(dp[mask], dp[prev_mask] + grid[count_ones - 1][j])\n    \n    return max(dp)"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    for col in range(len(grid[0]) - 1, -1, -1):\n        for row in range(len(grid)):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    rows, cols = len(grid), len(grid[0])\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    for col in range(cols):\n        for row in range(rows):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score\n```", "```python\nimport heapq\n\ndef maxScore(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    # Priority queue to store the largest values\n    pq = []\n    \n    # Set to keep track of used columns\n    used_columns = set()\n    \n    for i in range(n):\n        # Find the largest value in the current row that is not in the same column as any previously chosen value\n        for j in range(m - 1, -1, -1):\n            if j not in used_columns:\n                heapq.heappush(pq, -grid[i][j])\n                used_columns.add(j)\n                break\n    \n    # Sum up the values in the priority queue to get the maximum score\n    return -sum(pq)\n```", "```python\ndef maxScore(grid):\n    def backtrack(row, selected_cols, current_score):\n        if row == len(grid):\n            return current_score\n        max_score = 0\n        for col in range(len(grid[row])):\n            if col not in selected_cols:\n                selected_cols.add(col)\n                max_score = max(max_score, backtrack(row + 1, selected_cols, current_score + grid[row][col]))\n                selected_cols.remove(col)\n        return max_score\n\n    for row in grid:\n        row.sort(reverse=True)\n    return backtrack(0, set(), 0)\n```", "```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected = set()\n    score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected:\n                selected.add(value)\n                score += value\n                break\n    \n    return score\n```", "```python\ndef maxScore(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    # Initialize dp array with negative infinity\n    dp = [-float('inf')] * (1 << m)\n    dp[0] = 0\n    \n    for mask in range(1 << m):\n        count_ones = bin(mask).count('1')\n        if count_ones > n:\n            continue\n        \n        for j in range(m):\n            if mask & (1 << j):\n                prev_mask = mask ^ (1 << j)\n                dp[mask] = max(dp[mask], dp[prev_mask] + grid[count_ones - 1][j])\n    \n    return max(dp)\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for _, d, h in sorted_enemies:\n        if h > 0:\n            attack_time = (h - 1) // power + 1\n            if current_time + attack_time < times_to_die[sorted_enemies.index((_, d, h))]:\n                total_damage += power * attack_time\n                current_time += attack_time\n            else:\n                remaining_health = h - (current_time * power)\n                total_damage += remaining_health\n                break\n    \n    return int(total_damage)", "def min_damage(power, damage, health):\n    n = len(damage)\n    times_to_die = [(health[i] / damage[i], i) for i in range(n)]\n    times_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time, index in times_to_die:\n        if health[index] > 0:\n            attacks_needed = math.ceil(health[index] / power)\n            total_damage += attacks_needed * power\n            current_time += attacks_needed\n    \n    return total_damage", "def min_damage(power: int, damage: list[int], health: list[int]) -> int:\n    n = len(damage)\n    enemies = sorted(range(n), key=lambda i: damage[i] / health[i], reverse=True)\n    total_damage = 0\n    time = 0\n    \n    for enemy in enemies:\n        if health[enemy] <= 0:\n            continue\n        time_to_defeat = (health[enemy] + power - 1) // power\n        total_damage += time_to_defeat * damage[enemy]\n        time += time_to_defeat\n        health[enemy] = 0\n    \n    return total_damage", "def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for _, d, h in sorted_enemies:\n        if h > 0:\n            # Calculate the number of full attacks Bob can make in the remaining time\n            full_attacks = int((current_time + h - 1) // d)\n            total_damage += full_attacks * d\n            current_time += full_attacks * d\n            \n            # If there's any remaining time after full attacks, add partial attack damage\n            remaining_time = h % d\n            if remaining_time > 0:\n                total_damage += remaining_time\n                current_time += remaining_time\n    \n    return total_damage", "def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time it takes for each enemy to die\n    times = [(health[i] / damage[i]) if damage[i] != 0 else float('inf') for i in range(n)]\n    \n    # Sort enemies by their death times\n    sorted_indices = sorted(range(n), key=lambda x: times[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for i in sorted_indices:\n        # Calculate the time until the current enemy dies\n        time_until_death = times[i]\n        \n        # Calculate the number of attacks needed to kill the current enemy\n        attacks_needed = int(time_until_death // power) + (1 if time_until_death % power != 0 else 0)\n        \n        # Update the total damage and current time\n        total_damage += attacks_needed * power\n        current_time += attacks_needed\n    \n    return total_damage", "def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time each enemy would take to kill Bob if attacked immediately\n    times = [(health[i] - 1) // power + 1 for i in range(n)]\n    \n    # Sort enemies based on the time it takes to kill Bob\n    indices = sorted(range(n), key=lambda x: times[x])\n    \n    total_damage = 0\n    current_health = sum(health)\n    \n    for i in indices:\n        if current_health <= 0:\n            break\n        # Calculate the damage dealt to this enemy\n        if times[i] * power >= current_health:\n            total_damage += current_health * damage[i] // current_health\n            current_health -= current_health\n        else:\n            total_damage += times[i] * power * damage[i] // times[i]\n            current_health -= times[i] * power\n    \n    return total_damage", "def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die\n    sorted_enemies = sorted(zip(times, damage))\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time_to_die, enemy_damage in sorted_enemies:\n        if current_time < time_to_die:\n            total_damage += power * (time_to_die - current_time)\n            current_time = time_to_die\n        else:\n            total_damage += power * (enemy_damage / power)\n    \n    return int(total_damage)", "def min_damage(power, damage, health):\n    n = len(damage)\n    # Create a list of tuples (health, damage) and sort by health\n    enemies = sorted(zip(health, damage))\n    \n    total_damage = 0\n    for h, d in enemies:\n        if h <= power:\n            # If the enemy's health is less than or equal to power, it dies immediately\n            total_damage += d\n        else:\n            # Calculate the number of seconds needed to kill the enemy\n            seconds_to_kill = (h - 1) // power + 1\n            total_damage += seconds_to_kill * d\n    \n    return total_damage"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for _, d, h in sorted_enemies:\n        if h > 0:\n            attack_time = (h - 1) // power + 1\n            if current_time + attack_time < times_to_die[sorted_enemies.index((_, d, h))]:\n                total_damage += power * attack_time\n                current_time += attack_time\n            else:\n                remaining_health = h - (current_time * power)\n                total_damage += remaining_health\n                break\n    \n    return int(total_damage)\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    times_to_die = [(health[i] / damage[i], i) for i in range(n)]\n    times_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time, index in times_to_die:\n        if health[index] > 0:\n            attacks_needed = math.ceil(health[index] / power)\n            total_damage += attacks_needed * power\n            current_time += attacks_needed\n    \n    return total_damage\n```", "```python\ndef min_damage(power: int, damage: list[int], health: list[int]) -> int:\n    n = len(damage)\n    enemies = sorted(range(n), key=lambda i: damage[i] / health[i], reverse=True)\n    total_damage = 0\n    time = 0\n    \n    for enemy in enemies:\n        if health[enemy] <= 0:\n            continue\n        time_to_defeat = (health[enemy] + power - 1) // power\n        total_damage += time_to_defeat * damage[enemy]\n        time += time_to_defeat\n        health[enemy] = 0\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for _, d, h in sorted_enemies:\n        if h > 0:\n            # Calculate the number of full attacks Bob can make in the remaining time\n            full_attacks = int((current_time + h - 1) // d)\n            total_damage += full_attacks * d\n            current_time += full_attacks * d\n            \n            # If there's any remaining time after full attacks, add partial attack damage\n            remaining_time = h % d\n            if remaining_time > 0:\n                total_damage += remaining_time\n                current_time += remaining_time\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time it takes for each enemy to die\n    times = [(health[i] / damage[i]) if damage[i] != 0 else float('inf') for i in range(n)]\n    \n    # Sort enemies by their death times\n    sorted_indices = sorted(range(n), key=lambda x: times[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for i in sorted_indices:\n        # Calculate the time until the current enemy dies\n        time_until_death = times[i]\n        \n        # Calculate the number of attacks needed to kill the current enemy\n        attacks_needed = int(time_until_death // power) + (1 if time_until_death % power != 0 else 0)\n        \n        # Update the total damage and current time\n        total_damage += attacks_needed * power\n        current_time += attacks_needed\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time each enemy would take to kill Bob if attacked immediately\n    times = [(health[i] - 1) // power + 1 for i in range(n)]\n    \n    # Sort enemies based on the time it takes to kill Bob\n    indices = sorted(range(n), key=lambda x: times[x])\n    \n    total_damage = 0\n    current_health = sum(health)\n    \n    for i in indices:\n        if current_health <= 0:\n            break\n        # Calculate the damage dealt to this enemy\n        if times[i] * power >= current_health:\n            total_damage += current_health * damage[i] // current_health\n            current_health -= current_health\n        else:\n            total_damage += times[i] * power * damage[i] // times[i]\n            current_health -= times[i] * power\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die\n    sorted_enemies = sorted(zip(times, damage))\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time_to_die, enemy_damage in sorted_enemies:\n        if current_time < time_to_die:\n            total_damage += power * (time_to_die - current_time)\n            current_time = time_to_die\n        else:\n            total_damage += power * (enemy_damage / power)\n    \n    return int(total_damage)\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Create a list of tuples (health, damage) and sort by health\n    enemies = sorted(zip(health, damage))\n    \n    total_damage = 0\n    for h, d in enemies:\n        if h <= power:\n            # If the enemy's health is less than or equal to power, it dies immediately\n            total_damage += d\n        else:\n            # Calculate the number of seconds needed to kill the enemy\n            seconds_to_kill = (h - 1) // power + 1\n            total_damage += seconds_to_kill * d\n    \n    return total_damage\n```"]}
{"task_id": "3552", "codes": ["def largest_k_palindrome(n: int, k: int) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    # Start with the highest possible number and decrease\n    for num in range(10**(n-1), 10**n):\n        num_str = str(num)\n        if is_palindrome(num_str) and num % k == 0:\n            return num_str\n    \n    # If no valid palindrome is found, return the largest single digit divisible by k\n    return str(max(i for i in range(1, 10) if i % k == 0))", "def largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    def generate_palindrome(prefix):\n        if len(prefix) == n // 2:\n            if n % 2 == 0:\n                return prefix + prefix[::-1]\n            else:\n                return prefix[:-1] + prefix[::-1]\n        \n        max_digit = min(k * (10**(n // 2 - len(prefix))) - 1, 9)\n        for d in range(max_digit, -1, -1):\n            candidate = generate_palindrome(prefix + str(d))\n            if is_divisible_by_k(int(candidate)):\n                return candidate\n        return None\n    \n    for i in range(10**(n-1), 10**n, k):\n        candidate = str(i)\n        if candidate == candidate[::-1]:\n            return candidate\n    \n    return \"0\"", "def largest_k_palindrome(n, k):\n    # Generate the largest n-digit number\n    max_num = int('9' * n)\n    \n    # Iterate from the largest n-digit number down to 1\n    for num in range(max_num, 0, -1):\n        str_num = str(num)\n        # Check if the number is a palindrome\n        if str_num == str_num[::-1]:\n            # Check if the number is divisible by k\n            if num % k == 0:\n                return str_num\n    \n    # If no such number is found, return an empty string (though constraints ensure one exists)\n    return \"\"", "def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = 10**(n-1)\n    \n    for num in range(max_num, min_num - 1, -1):\n        palindrome = int(str(num) + str(num)[-2::-1])\n        if palindrome % k == 0:\n            return str(palindrome)\n    return None", "def largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    max_palindrome = \"\"\n    \n    # Generate palindromes\n    for i in range(10**(n//2), 10**(n//2 + 1)):\n        half = str(i)\n        if n % 2 == 0:\n            candidate = int(half + half[::-1])\n        else:\n            candidate = int(half + half[-2::-1])\n        \n        if candidate % k == 0 and is_palindrome(str(candidate)) and str(candidate) > max_palindrome:\n            max_palindrome = str(candidate)\n    \n    return max_palindrome if max_palindrome else str(k)", "def largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num_str: str) -> bool:\n        return int(num_str) % k == 0\n    \n    def construct_largest_palindrome(n: int) -> str:\n        if n == 1:\n            return '9' if k > 9 else str(k)\n        \n        half_length = (n + 1) // 2\n        half = ''.join(str(9) * half_length)\n        if n % 2 == 0:\n            return half + half[::-1]\n        else:\n            return half[:-1] + str(k) + half[::-1]\n    \n    largest_palindrome = construct_largest_palindrome(n)\n    \n    while not is_divisible_by_k(largest_palindrome):\n        half_length = (len(largest_palindrome) + 1) // 2\n        half = largest_palindrome[:half_length - 1]\n        new_half = str(int(half) - 1).zfill(half_length - 1)\n        largest_palindrome = new_half + new_half[::-1]\n    \n    return largest_palindrome", "def largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k) if k <= 9 else \"0\"\n    \n    max_palindrome = 0\n    \n    # Generate palindromes\n    for i in range(10**(n//2), 10**((n+1)//2)):\n        half = str(i)\n        if n % 2 == 0:\n            palindrome = int(half + half[::-1])\n        else:\n            palindrome = int(half + half[-2::-1])\n        \n        if palindrome % k == 0:\n            max_palindrome = max(max_palindrome, palindrome)\n    \n    return str(max_palindrome)", "def is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k * (k // gcd(k, 10)))\n    \n    max_num = int('9' * n)\n    min_num = int('1' + '0' * (n - 2) + '1')\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    \n    return \"-1\"\n\nfrom math import gcd"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    # Start with the highest possible number and decrease\n    for num in range(10**(n-1), 10**n):\n        num_str = str(num)\n        if is_palindrome(num_str) and num % k == 0:\n            return num_str\n    \n    # If no valid palindrome is found, return the largest single digit divisible by k\n    return str(max(i for i in range(1, 10) if i % k == 0))\n```", "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    def generate_palindrome(prefix):\n        if len(prefix) == n // 2:\n            if n % 2 == 0:\n                return prefix + prefix[::-1]\n            else:\n                return prefix[:-1] + prefix[::-1]\n        \n        max_digit = min(k * (10**(n // 2 - len(prefix))) - 1, 9)\n        for d in range(max_digit, -1, -1):\n            candidate = generate_palindrome(prefix + str(d))\n            if is_divisible_by_k(int(candidate)):\n                return candidate\n        return None\n    \n    for i in range(10**(n-1), 10**n, k):\n        candidate = str(i)\n        if candidate == candidate[::-1]:\n            return candidate\n    \n    return \"0\"\n```", "```python\ndef largest_k_palindrome(n, k):\n    # Generate the largest n-digit number\n    max_num = int('9' * n)\n    \n    # Iterate from the largest n-digit number down to 1\n    for num in range(max_num, 0, -1):\n        str_num = str(num)\n        # Check if the number is a palindrome\n        if str_num == str_num[::-1]:\n            # Check if the number is divisible by k\n            if num % k == 0:\n                return str_num\n    \n    # If no such number is found, return an empty string (though constraints ensure one exists)\n    return \"\"\n```", "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = 10**(n-1)\n    \n    for num in range(max_num, min_num - 1, -1):\n        palindrome = int(str(num) + str(num)[-2::-1])\n        if palindrome % k == 0:\n            return str(palindrome)\n    return None\n```", "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    max_palindrome = \"\"\n    \n    # Generate palindromes\n    for i in range(10**(n//2), 10**(n//2 + 1)):\n        half = str(i)\n        if n % 2 == 0:\n            candidate = int(half + half[::-1])\n        else:\n            candidate = int(half + half[-2::-1])\n        \n        if candidate % k == 0 and is_palindrome(str(candidate)) and str(candidate) > max_palindrome:\n            max_palindrome = str(candidate)\n    \n    return max_palindrome if max_palindrome else str(k)\n```", "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num_str: str) -> bool:\n        return int(num_str) % k == 0\n    \n    def construct_largest_palindrome(n: int) -> str:\n        if n == 1:\n            return '9' if k > 9 else str(k)\n        \n        half_length = (n + 1) // 2\n        half = ''.join(str(9) * half_length)\n        if n % 2 == 0:\n            return half + half[::-1]\n        else:\n            return half[:-1] + str(k) + half[::-1]\n    \n    largest_palindrome = construct_largest_palindrome(n)\n    \n    while not is_divisible_by_k(largest_palindrome):\n        half_length = (len(largest_palindrome) + 1) // 2\n        half = largest_palindrome[:half_length - 1]\n        new_half = str(int(half) - 1).zfill(half_length - 1)\n        largest_palindrome = new_half + new_half[::-1]\n    \n    return largest_palindrome\n```", "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k) if k <= 9 else \"0\"\n    \n    max_palindrome = 0\n    \n    # Generate palindromes\n    for i in range(10**(n//2), 10**((n+1)//2)):\n        half = str(i)\n        if n % 2 == 0:\n            palindrome = int(half + half[::-1])\n        else:\n            palindrome = int(half + half[-2::-1])\n        \n        if palindrome % k == 0:\n            max_palindrome = max(max_palindrome, palindrome)\n    \n    return str(max_palindrome)\n```", "```python\ndef is_palindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k * (k // gcd(k, 10)))\n    \n    max_num = int('9' * n)\n    min_num = int('1' + '0' * (n - 2) + '1')\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    \n    return \"-1\"\n\nfrom math import gcd\n```"]}
{"task_id": "3575", "codes": ["def max_value_of_subsequence(nums, k):\n    nums.sort(reverse=True)\n    first_half_or = 0\n    second_half_or = 0\n    for i in range(2 * k):\n        if i < k:\n            first_half_or |= nums[i]\n        else:\n            second_half_or |= nums[i]\n    return first_half_or ^ second_half_or", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    nums.sort()\n    \n    # Initialize variables to store the maximum XOR value\n    max_xor = 0\n    \n    # Iterate through the array using a sliding window of size 2k\n    for i in range(n - 2 * k + 1):\n        left_half = 0\n        right_half = 0\n        \n        # Compute the bitwise OR for the left half of the window\n        for j in range(i, i + k):\n            left_half |= nums[j]\n        \n        # Compute the bitwise OR for the right half of the window\n        for j in range(i + k, i + 2 * k):\n            right_half |= nums[j]\n        \n        # Calculate the XOR of the two halves\n        current_xor = left_half ^ right_half\n        \n        # Update the maximum XOR value if the current one is greater\n        max_xor = max(max_xor, current_xor)\n    \n    return max_xor", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\ndef insert(trie, num):\n    node = trie\n    for i in range(7, -1, -1):\n        bit = (num >> i) & 1\n        if bit not in node.children:\n            node.children[bit] = TrieNode()\n        node = node.children[bit]\n\ndef search_max_xor(trie, num):\n    max_xor = 0\n    node = trie\n    for i in range(7, -1, -1):\n        bit = (num >> i) & 1\n        alt_bit = 1 - bit\n        if alt_bit in node.children:\n            max_xor |= (1 << i)\n            node = node.children[alt_bit]\n        else:\n            node = node.children[bit]\n    return max_xor\n\ndef max_value(nums, k):\n    n = len(nums)\n    trie = TrieNode()\n    max_val = 0\n    \n    # Insert first k elements into the Trie\n    for i in range(k):\n        insert(trie, nums[i])\n    \n    # Calculate initial max value\n    left_xor = 0\n    for i in range(k):\n        left_xor |= nums[i]\n    right_xor = 0\n    for i in range(k, 2 * k):\n        right_xor |= nums[i]\n    max_val = left_xor ^ right_xor\n    \n    # Slide the window across the array\n    for i in range(k, n):\n        left_xor ^= nums[i - k]\n        right_xor ^= nums[i - k]\n        \n        insert(trie, nums[i])\n        left_xor |= nums[i]\n        \n        right_xor &= ~nums[i - k]\n        max_val = max(max_val, left_xor ^ search_max_xor(trie, right_xor))\n    \n    return max_val", "def max_xor_subsequence(nums, k):\n    n = len(nums)\n    if n == 2 * k:\n        return nums[0] ^ nums[1]\n    \n    # Precompute prefix XORs\n    prefix_xor = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] | nums[i - 1]\n    \n    # DP table initialization\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i // 2 + 1, k + 1)):\n            dp[i][j] = max(dp[i - 1][j], (prefix_xor[i] ^ prefix_xor[i - 2 * j]))\n    \n    return dp[n][k]", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    dp = [[0] * 8 for _ in range(n)]\n    \n    # Initialize the first element\n    for i in range(8):\n        if nums[0] & (1 << i):\n            dp[0][i] = 1\n    \n    # Fill the DP table\n    for i in range(1, n):\n        for j in range(8):\n            dp[i][j] = dp[i-1][j]\n            if nums[i] & (1 << j):\n                dp[i][j] += 1\n    \n    # Calculate the maximum value\n    max_value = 0\n    for i in range(k):\n        for j in range(k):\n            xor_val = 0\n            for bit in range(8):\n                if dp[k+i-1][bit] > dp[j-1][bit]:\n                    xor_val |= (1 << bit)\n            max_value = max(max_value, xor_val)\n    \n    return max_value", "def maximumXOR(nums, k):\n    n = len(nums)\n    max_xor = 0\n    \n    # Precompute the prefix OR values\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    # Calculate the maximum XOR for all valid subarrays of size 2 * k\n    for i in range(k, n - k + 1):\n        left_or = prefix_or[i] ^ prefix_or[i - k]\n        right_or = prefix_or[n] ^ prefix_or[i + k]\n        max_xor = max(max_xor, left_or ^ right_or)\n    \n    return max_xor", "import heapq\n\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    max_heap = []\n    for i in range(n):\n        heapq.heappush(max_heap, (-nums[i], i))\n    \n    max_value = 0\n    for i in range(n - 1, n - 2 * k - 1, -1):\n        for j in range(i - 1, i - 2 * k - 1, -1):\n            first_half = 0\n            second_half = 0\n            count = 0\n            while count < k:\n                if count < k - (i - j):\n                    first_half |= -max_heap[0][0]\n                else:\n                    second_half |= -max_heap[0][0]\n                heapq.heappop(max_heap)\n                count += 1\n            max_value = max(max_value, first_half ^ second_half)\n            for _ in range(k):\n                heapq.heappush(max_heap, (-nums[max_heap[0][1]], max_heap[0][1]))\n    \n    return max_value", "def max_xor_subsequence(nums, k):\n    n = len(nums)\n    \n    @lru_cache(None)\n    def dp(i, j, xor):\n        if i == n // 2:\n            return xor\n        return max(dp(i + 1, j | nums[i], xor ^ (j | nums[i])), dp(i + 1, j, xor))\n    \n    return dp(0, 0, 0)"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef max_value_of_subsequence(nums, k):\n    nums.sort(reverse=True)\n    first_half_or = 0\n    second_half_or = 0\n    for i in range(2 * k):\n        if i < k:\n            first_half_or |= nums[i]\n        else:\n            second_half_or |= nums[i]\n    return first_half_or ^ second_half_or\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    nums.sort()\n    \n    # Initialize variables to store the maximum XOR value\n    max_xor = 0\n    \n    # Iterate through the array using a sliding window of size 2k\n    for i in range(n - 2 * k + 1):\n        left_half = 0\n        right_half = 0\n        \n        # Compute the bitwise OR for the left half of the window\n        for j in range(i, i + k):\n            left_half |= nums[j]\n        \n        # Compute the bitwise OR for the right half of the window\n        for j in range(i + k, i + 2 * k):\n            right_half |= nums[j]\n        \n        # Calculate the XOR of the two halves\n        current_xor = left_half ^ right_half\n        \n        # Update the maximum XOR value if the current one is greater\n        max_xor = max(max_xor, current_xor)\n    \n    return max_xor\n```", "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n\ndef insert(trie, num):\n    node = trie\n    for i in range(7, -1, -1):\n        bit = (num >> i) & 1\n        if bit not in node.children:\n            node.children[bit] = TrieNode()\n        node = node.children[bit]\n\ndef search_max_xor(trie, num):\n    max_xor = 0\n    node = trie\n    for i in range(7, -1, -1):\n        bit = (num >> i) & 1\n        alt_bit = 1 - bit\n        if alt_bit in node.children:\n            max_xor |= (1 << i)\n            node = node.children[alt_bit]\n        else:\n            node = node.children[bit]\n    return max_xor\n\ndef max_value(nums, k):\n    n = len(nums)\n    trie = TrieNode()\n    max_val = 0\n    \n    # Insert first k elements into the Trie\n    for i in range(k):\n        insert(trie, nums[i])\n    \n    # Calculate initial max value\n    left_xor = 0\n    for i in range(k):\n        left_xor |= nums[i]\n    right_xor = 0\n    for i in range(k, 2 * k):\n        right_xor |= nums[i]\n    max_val = left_xor ^ right_xor\n    \n    # Slide the window across the array\n    for i in range(k, n):\n        left_xor ^= nums[i - k]\n        right_xor ^= nums[i - k]\n        \n        insert(trie, nums[i])\n        left_xor |= nums[i]\n        \n        right_xor &= ~nums[i - k]\n        max_val = max(max_val, left_xor ^ search_max_xor(trie, right_xor))\n    \n    return max_val\n```", "```python\ndef max_xor_subsequence(nums, k):\n    n = len(nums)\n    if n == 2 * k:\n        return nums[0] ^ nums[1]\n    \n    # Precompute prefix XORs\n    prefix_xor = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] | nums[i - 1]\n    \n    # DP table initialization\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Fill DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i // 2 + 1, k + 1)):\n            dp[i][j] = max(dp[i - 1][j], (prefix_xor[i] ^ prefix_xor[i - 2 * j]))\n    \n    return dp[n][k]\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    dp = [[0] * 8 for _ in range(n)]\n    \n    # Initialize the first element\n    for i in range(8):\n        if nums[0] & (1 << i):\n            dp[0][i] = 1\n    \n    # Fill the DP table\n    for i in range(1, n):\n        for j in range(8):\n            dp[i][j] = dp[i-1][j]\n            if nums[i] & (1 << j):\n                dp[i][j] += 1\n    \n    # Calculate the maximum value\n    max_value = 0\n    for i in range(k):\n        for j in range(k):\n            xor_val = 0\n            for bit in range(8):\n                if dp[k+i-1][bit] > dp[j-1][bit]:\n                    xor_val |= (1 << bit)\n            max_value = max(max_value, xor_val)\n    \n    return max_value\n```", "```python\ndef maximumXOR(nums, k):\n    n = len(nums)\n    max_xor = 0\n    \n    # Precompute the prefix OR values\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    # Calculate the maximum XOR for all valid subarrays of size 2 * k\n    for i in range(k, n - k + 1):\n        left_or = prefix_or[i] ^ prefix_or[i - k]\n        right_or = prefix_or[n] ^ prefix_or[i + k]\n        max_xor = max(max_xor, left_or ^ right_or)\n    \n    return max_xor\n```", "```python\nimport heapq\n\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    max_heap = []\n    for i in range(n):\n        heapq.heappush(max_heap, (-nums[i], i))\n    \n    max_value = 0\n    for i in range(n - 1, n - 2 * k - 1, -1):\n        for j in range(i - 1, i - 2 * k - 1, -1):\n            first_half = 0\n            second_half = 0\n            count = 0\n            while count < k:\n                if count < k - (i - j):\n                    first_half |= -max_heap[0][0]\n                else:\n                    second_half |= -max_heap[0][0]\n                heapq.heappop(max_heap)\n                count += 1\n            max_value = max(max_value, first_half ^ second_half)\n            for _ in range(k):\n                heapq.heappush(max_heap, (-nums[max_heap[0][1]], max_heap[0][1]))\n    \n    return max_value\n```", "```python\ndef max_xor_subsequence(nums, k):\n    n = len(nums)\n    \n    @lru_cache(None)\n    def dp(i, j, xor):\n        if i == n // 2:\n            return xor\n        return max(dp(i + 1, j | nums[i], xor ^ (j | nums[i])), dp(i + 1, j, xor))\n    \n    return dp(0, 0, 0)\n```"]}
{"task_id": "3551", "codes": ["def max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute the prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    # Process each query\n    result = []\n    for l, r in queries:\n        xor_score = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(xor_score)\n    \n    return result", "def max_xor_subarray(nums, queries):\n    n = len(nums)\n    # Precompute the cumulative XOR from the end to the beginning\n    xor_arr = [0] * n\n    xor_arr[-1] = nums[-1]\n    for i in range(n-2, -1, -1):\n        xor_arr[i] = xor_arr[i+1] ^ nums[i]\n    \n    # Sort queries based on the right boundary\n    sorted_queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)])\n    \n    # Use a set to store the prefix XORs\n    prefix_xors = {xor_arr[n-1]}\n    result = [-1] * len(queries)\n    \n    j = n - 1\n    for l, r, i in sorted_queries:\n        while j > r:\n            prefix_xors.add(xor_arr[j])\n            j -= 1\n        \n        if l > 0:\n            target = xor_arr[l-1] ^ xor_arr[r]\n        else:\n            target = xor_arr[r]\n        \n        for px in prefix_xors:\n            if px ^ target < target:\n                continue\n            result[i] = px ^ target\n            break\n    \n    return result", "def max_xor_subarray(nums, queries):\n    n = len(nums)\n    # Step 1: Compute prefix XORs\n    prefix_xors = [0] * (n + 1)\n    for i in range(n):\n        prefix_xors[i + 1] = prefix_xors[i] ^ nums[i]\n    \n    # Step 2: Process each query\n    result = []\n    for l, r in queries:\n        xor_score = prefix_xors[r + 1] ^ prefix_xors[l]\n        result.append(xor_score)\n    \n    return result", "def maxXORQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    # Sort queries based on the end index\n    sorted_queries = sorted((r, l, i) for i, (l, r) in enumerate(queries))\n    \n    result = [0] * len(queries)\n    current_xor = 0\n    j = 0\n    \n    # Process each query\n    for r, l, i in sorted_queries:\n        # Add elements to the current window\n        while j <= r:\n            current_xor ^= nums[j]\n            j += 1\n        \n        # Remove elements from the current window\n        while j > l + 1:\n            current_xor ^= nums[j - 1]\n            j -= 1\n        \n        # Calculate the maximum XOR score for the current query\n        result[i] = current_xor\n    \n    return result", "def max_xor_subarray(nums, queries):\n    def insert(num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n\n    def search_max_xor(num):\n        node = root\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node:\n                xor_val |= (1 << i)\n                node = node[1 - bit]\n            else:\n                node = node[bit]\n        return xor_val\n\n    root = {}\n    prefix_xor = 0\n    results = [-1] * len(queries)\n\n    # Sort queries by their end index to process them in increasing order\n    sorted_queries = sorted((q[1], i, q[0]) for i, q in enumerate(queries))\n    j = 0\n\n    for end, i, start in sorted_queries:\n        while j <= end:\n            prefix_xor ^= nums[j]\n            insert(prefix_xor)\n            j += 1\n\n        if start > 0:\n            prefix_xor ^= nums[start - 1]\n\n        results[i] = search_max_xor(prefix_xor ^ (1 << 31) - 1)\n\n    return results", "class TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if node.children[alt_bit]:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        xor_val = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(trie.find_max_xor(xor_val))\n    \n    return result", "def maximumXorQueries(nums, queries):\n    # Sort queries by their end index to process them in order\n    sorted_queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)], key=lambda x: x[1])\n    trie = Trie()\n    result = [0] * len(queries)\n    j = 0\n    current_xor = 0\n\n    for l, r, i in sorted_queries:\n        # Add elements to the Trie that are within the current query range\n        while j <= r:\n            current_xor ^= nums[j]\n            trie.insert(current_xor)\n            j += 1\n\n        # Find the maximum XOR for the current query\n        result[i] = trie.find_max_xor(current_xor)\n\n    return result", "def max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * n\n    prefix_xor[0] = nums[0]\n    \n    # Compute prefix XORs\n    for i in range(1, n):\n        prefix_xor[i] = prefix_xor[i-1] ^ nums[i]\n    \n    # Answer each query\n    result = []\n    for l, r in queries:\n        if l == 0:\n            result.append(prefix_xor[r])\n        else:\n            result.append(prefix_xor[r] ^ prefix_xor[l-1])\n    \n    return result"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute the prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    # Process each query\n    result = []\n    for l, r in queries:\n        xor_score = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(xor_score)\n    \n    return result\n```", "```python\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    # Precompute the cumulative XOR from the end to the beginning\n    xor_arr = [0] * n\n    xor_arr[-1] = nums[-1]\n    for i in range(n-2, -1, -1):\n        xor_arr[i] = xor_arr[i+1] ^ nums[i]\n    \n    # Sort queries based on the right boundary\n    sorted_queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)])\n    \n    # Use a set to store the prefix XORs\n    prefix_xors = {xor_arr[n-1]}\n    result = [-1] * len(queries)\n    \n    j = n - 1\n    for l, r, i in sorted_queries:\n        while j > r:\n            prefix_xors.add(xor_arr[j])\n            j -= 1\n        \n        if l > 0:\n            target = xor_arr[l-1] ^ xor_arr[r]\n        else:\n            target = xor_arr[r]\n        \n        for px in prefix_xors:\n            if px ^ target < target:\n                continue\n            result[i] = px ^ target\n            break\n    \n    return result\n```", "```python\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    # Step 1: Compute prefix XORs\n    prefix_xors = [0] * (n + 1)\n    for i in range(n):\n        prefix_xors[i + 1] = prefix_xors[i] ^ nums[i]\n    \n    # Step 2: Process each query\n    result = []\n    for l, r in queries:\n        xor_score = prefix_xors[r + 1] ^ prefix_xors[l]\n        result.append(xor_score)\n    \n    return result\n```", "```python\ndef maxXORQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    # Sort queries based on the end index\n    sorted_queries = sorted((r, l, i) for i, (l, r) in enumerate(queries))\n    \n    result = [0] * len(queries)\n    current_xor = 0\n    j = 0\n    \n    # Process each query\n    for r, l, i in sorted_queries:\n        # Add elements to the current window\n        while j <= r:\n            current_xor ^= nums[j]\n            j += 1\n        \n        # Remove elements from the current window\n        while j > l + 1:\n            current_xor ^= nums[j - 1]\n            j -= 1\n        \n        # Calculate the maximum XOR score for the current query\n        result[i] = current_xor\n    \n    return result\n```", "def max_xor_subarray(nums, queries):\n    def insert(num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n\n    def search_max_xor(num):\n        node = root\n        xor_val = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node:\n                xor_val |= (1 << i)\n                node = node[1 - bit]\n            else:\n                node = node[bit]\n        return xor_val\n\n    root = {}\n    prefix_xor = 0\n    results = [-1] * len(queries)\n\n    # Sort queries by their end index to process them in increasing order\n    sorted_queries = sorted((q[1], i, q[0]) for i, q in enumerate(queries))\n    j = 0\n\n    for end, i, start in sorted_queries:\n        while j <= end:\n            prefix_xor ^= nums[j]\n            insert(prefix_xor)\n            j += 1\n\n        if start > 0:\n            prefix_xor ^= nums[start - 1]\n\n        results[i] = search_max_xor(prefix_xor ^ (1 << 31) - 1)\n\n    return results", "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if not node.children[bit]:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if node.children[alt_bit]:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        xor_val = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(trie.find_max_xor(xor_val))\n    \n    return result\n```", "```python\ndef maximumXorQueries(nums, queries):\n    # Sort queries by their end index to process them in order\n    sorted_queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)], key=lambda x: x[1])\n    trie = Trie()\n    result = [0] * len(queries)\n    j = 0\n    current_xor = 0\n\n    for l, r, i in sorted_queries:\n        # Add elements to the Trie that are within the current query range\n        while j <= r:\n            current_xor ^= nums[j]\n            trie.insert(current_xor)\n            j += 1\n\n        # Find the maximum XOR for the current query\n        result[i] = trie.find_max_xor(current_xor)\n\n    return result\n```", "```python\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * n\n    prefix_xor[0] = nums[0]\n    \n    # Compute prefix XORs\n    for i in range(1, n):\n        prefix_xor[i] = prefix_xor[i-1] ^ nums[i]\n    \n    # Answer each query\n    result = []\n    for l, r in queries:\n        if l == 0:\n            result.append(prefix_xor[r])\n        else:\n            result.append(prefix_xor[r] ^ prefix_xor[l-1])\n    \n    return result\n```"]}
{"task_id": "3532", "codes": ["def minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start):\n        n = len(graph)\n        marked = [False] * n\n        marked[start] = True\n        queue = deque([(start, 0)])\n        time = [0] * n\n        \n        while queue:\n            node, t = queue.popleft()\n            time[node] = t\n            for neighbor in graph[node]:\n                if not marked[neighbor]:\n                    marked[neighbor] = True\n                    if node % 2 == 0:\n                        queue.append((neighbor, t + 2))\n                    else:\n                        queue.append((neighbor, t + 1))\n        \n        return time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    times = [0] * n\n    for i in range(n):\n        times[i] = bfs(i)\n    \n    return times", "def get_marked_times(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def mark_node(node, parent, time, marked_times):\n        marked_times[node] = time\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                if node % 2 == 0:\n                    mark_node(neighbor, node, time + 2, marked_times)\n                else:\n                    mark_node(neighbor, node, time + 1, marked_times)\n\n    marked_times = [None] * n\n    for i in range(n):\n        if marked_times[i] is None:\n            mark_node(i, -1, 0, marked_times)\n\n    return marked_times", "def minTimeToMarkAllNodes(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(start_node):\n        queue = [start_node]\n        marked = [False] * n\n        marked[start_node] = True\n        time = 0\n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                node = queue.pop(0)\n                for neighbor in graph[node]:\n                    if not marked[neighbor]:\n                        marked[neighbor] = True\n                        queue.append(neighbor)\n            time += 1\n        return time\n\n    times = [0] * n\n    for i in range(n):\n        times[i] = bfs(i)\n\n    return times", "def minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs_mark(node):\n        times = [-1] * n\n        times[node] = 0\n        queue = deque([node])\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if times[neighbor] == -1:\n                    if current % 2 == 0:\n                        times[neighbor] = times[current] + 2\n                    else:\n                        times[neighbor] = times[current] + 1\n                    queue.append(neighbor)\n        return times\n    \n    results = []\n    for i in range(n):\n        results.append(bfs_mark(i))\n    \n    return results", "def min_time_to_mark_all_nodes(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    \n    # Build the graph\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start_node):\n        times = [-1] * n\n        times[start_node] = 0\n        queue = [start_node]\n        \n        while queue:\n            current_node = queue.pop(0)\n            \n            for neighbor in graph[current_node]:\n                if times[neighbor] == -1:\n                    if current_node % 2 == 0:\n                        times[neighbor] = times[current_node] + 2\n                    else:\n                        times[neighbor] = times[current_node] + 1\n                    queue.append(neighbor)\n        \n        return max(times)\n    \n    result = []\n    for i in range(n):\n        times = bfs(i)\n        result.append(times)\n    \n    return result", "def minTimeToMarkNodes(edges):\n    from collections import defaultdict\n    from math import ceil\n\n    def dfs(node, parent, time):\n        nonlocal max_time\n        marked[node] = True\n        max_time = max(max_time, time)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 2 if node % 2 == 0 else time + 1)\n\n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    marked = [False] * n\n    max_time = 0\n\n    for i in range(n):\n        if not marked[i]:\n            dfs(i, -1, 0)\n\n    return [max_time] * n", "def minTime(self, edges: List[List[int]]) -> List[int]:\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node, parent, time):\n        nonlocal max_time\n        max_time = max(max_time, time)\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 1)\n\n    result = [0] * n\n    for i in range(n):\n        max_time = 0\n        dfs(i, -1, 0)\n        result[i] = max_time\n\n    return result", "def minTimeToMarkNodes(edges):\n    def dfs(node, parent, time, marked_times):\n        marked_times[node] = time\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                if node % 2 == 0:\n                    dfs(neighbor, node, time + 2, marked_times)\n                else:\n                    dfs(neighbor, node, time + 1, marked_times)\n\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    marked_times = [-1] * n\n    dfs(0, -1, 0, marked_times)\n    return marked_times"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start):\n        n = len(graph)\n        marked = [False] * n\n        marked[start] = True\n        queue = deque([(start, 0)])\n        time = [0] * n\n        \n        while queue:\n            node, t = queue.popleft()\n            time[node] = t\n            for neighbor in graph[node]:\n                if not marked[neighbor]:\n                    marked[neighbor] = True\n                    if node % 2 == 0:\n                        queue.append((neighbor, t + 2))\n                    else:\n                        queue.append((neighbor, t + 1))\n        \n        return time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    times = [0] * n\n    for i in range(n):\n        times[i] = bfs(i)\n    \n    return times\n```", "def get_marked_times(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def mark_node(node, parent, time, marked_times):\n        marked_times[node] = time\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                if node % 2 == 0:\n                    mark_node(neighbor, node, time + 2, marked_times)\n                else:\n                    mark_node(neighbor, node, time + 1, marked_times)\n\n    marked_times = [None] * n\n    for i in range(n):\n        if marked_times[i] is None:\n            mark_node(i, -1, 0, marked_times)\n\n    return marked_times", "def minTimeToMarkAllNodes(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(start_node):\n        queue = [start_node]\n        marked = [False] * n\n        marked[start_node] = True\n        time = 0\n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                node = queue.pop(0)\n                for neighbor in graph[node]:\n                    if not marked[neighbor]:\n                        marked[neighbor] = True\n                        queue.append(neighbor)\n            time += 1\n        return time\n\n    times = [0] * n\n    for i in range(n):\n        times[i] = bfs(i)\n\n    return times", "```python\ndef minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs_mark(node):\n        times = [-1] * n\n        times[node] = 0\n        queue = deque([node])\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if times[neighbor] == -1:\n                    if current % 2 == 0:\n                        times[neighbor] = times[current] + 2\n                    else:\n                        times[neighbor] = times[current] + 1\n                    queue.append(neighbor)\n        return times\n    \n    results = []\n    for i in range(n):\n        results.append(bfs_mark(i))\n    \n    return results\n```", "```python\ndef min_time_to_mark_all_nodes(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    \n    # Build the graph\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start_node):\n        times = [-1] * n\n        times[start_node] = 0\n        queue = [start_node]\n        \n        while queue:\n            current_node = queue.pop(0)\n            \n            for neighbor in graph[current_node]:\n                if times[neighbor] == -1:\n                    if current_node % 2 == 0:\n                        times[neighbor] = times[current_node] + 2\n                    else:\n                        times[neighbor] = times[current_node] + 1\n                    queue.append(neighbor)\n        \n        return max(times)\n    \n    result = []\n    for i in range(n):\n        times = bfs(i)\n        result.append(times)\n    \n    return result\n```", "def minTimeToMarkNodes(edges):\n    from collections import defaultdict\n    from math import ceil\n\n    def dfs(node, parent, time):\n        nonlocal max_time\n        marked[node] = True\n        max_time = max(max_time, time)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 2 if node % 2 == 0 else time + 1)\n\n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    marked = [False] * n\n    max_time = 0\n\n    for i in range(n):\n        if not marked[i]:\n            dfs(i, -1, 0)\n\n    return [max_time] * n", "def minTime(self, edges: List[List[int]]) -> List[int]:\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node, parent, time):\n        nonlocal max_time\n        max_time = max(max_time, time)\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 1)\n\n    result = [0] * n\n    for i in range(n):\n        max_time = 0\n        dfs(i, -1, 0)\n        result[i] = max_time\n\n    return result", "def minTimeToMarkNodes(edges):\n    def dfs(node, parent, time, marked_times):\n        marked_times[node] = time\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                if node % 2 == 0:\n                    dfs(neighbor, node, time + 2, marked_times)\n                else:\n                    dfs(neighbor, node, time + 1, marked_times)\n\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    marked_times = [-1] * n\n    dfs(0, -1, 0, marked_times)\n    return marked_times"]}
{"task_id": "3550", "codes": ["def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero values\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure we have at least 3 non-zero rows and columns\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Sort rows and columns by their sums in descending order\n    non_zero_rows.sort(key=lambda i: sum(board[i]), reverse=True)\n    non_zero_cols.sort(key=lambda j: sum(board[i][j] for i in range(m)), reverse=True)\n    \n    # Select the top 3 rows and columns\n    selected_rows = non_zero_rows[:3]\n    selected_cols = non_zero_cols[:3]\n    \n    # Calculate the sum of the selected cells\n    max_sum = sum(board[i][j] for i in selected_rows for j in selected_cols)\n    \n    return max_sum", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Find rows and columns with exactly one non-zero value\n    valid_rows = [i for i, s in enumerate(row_sums) if s != 0]\n    valid_cols = [j for j, s in enumerate(col_sums) if s != 0]\n    \n    # Select three valid rows and columns\n    selected_rows = valid_rows[:3]\n    selected_cols = valid_cols[:3]\n    \n    # Calculate the sum of the selected cells\n    max_sum = sum(board[r][c] for r in selected_rows for c in selected_cols)\n    \n    return max_sum", "def maxSumOfNonAttackingRooks(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate the sum of each column\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort the row sums and column sums in descending order\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    # Select the top three elements from each list\n    selected_row_sums = row_sums[:3]\n    selected_col_sums = col_sums[:3]\n    \n    # Return the sum of the selected elements\n    return sum(selected_row_sums) + sum(selected_col_sums)", "def max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    col_used = [False] * cols\n    total_sum = 0\n    \n    for i in range(rows):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(cols):\n            if not col_used[j] and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        col_used[max_col] = True\n        total_sum += max_val\n    \n    return total_sum", "def maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [(sum(board[i]), i) for i in range(m)]\n    row_sums.sort(reverse=True)\n    \n    # Calculate column sums\n    col_sums = [(sum(board[j][i] for j in range(m)), i) for i in range(n)]\n    col_sums.sort(reverse=True)\n    \n    # Select the top three rows and columns\n    selected_rows = [row_sums[i][1] for i in range(3)]\n    selected_cols = [col_sums[i][1] for i in range(3)]\n    \n    # Ensure no overlapping rows and columns\n    selected_rows = sorted(set(selected_rows))\n    selected_cols = sorted(set(selected_cols))\n    \n    # Calculate the maximum sum\n    max_sum = sum(board[selected_rows[i]][selected_cols[j]] for i in range(3) for j in range(3))\n    \n    return max_sum", "from itertools import permutations\n\ndef max_rook_sum(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Find all possible positions for rooks in each row\n    possible_positions = []\n    for i in range(rows):\n        positions = [j for j in range(cols) if board[i][j] != -1]\n        possible_positions.append(positions)\n    \n    # Generate all valid combinations of three positions\n    max_sum = float('-inf')\n    for perm in permutations(range(rows), 3):\n        col_indices = [possible_positions[r][perm[r]] for r in range(3)]\n        current_sum = sum(board[r][c] for r, c in zip(perm, col_indices))\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "def max_rook_sum(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate the sum of each column\n    col_sums = [sum(board[row][col] for row in range(rows)) for col in range(cols)]\n    \n    # Sort row sums and column sums in descending order\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    # Select the top three elements from each list\n    selected_row_sums = row_sums[:3]\n    selected_col_sums = col_sums[:3]\n    \n    # Ensure no two selected elements come from the same row or column\n    used_rows = set()\n    used_cols = set()\n    max_sum = 0\n    \n    for i in range(3):\n        for j in range(3):\n            if i not in used_rows and j not in used_cols:\n                max_sum += selected_row_sums[i] + selected_col_sums[j]\n                used_rows.add(i)\n                used_cols.add(j)\n                break\n    \n    return max_sum", "def maxSumOfRooks(board):\n    def backtrack(row, cols, current_sum):\n        if row == len(board):\n            return current_sum\n        \n        max_sum = float('-inf')\n        for col in range(len(board[0])):\n            if col not in cols:\n                new_cols = cols.copy()\n                new_cols.add(col)\n                new_sum = current_sum + board[row][col]\n                max_sum = max(max_sum, backtrack(row + 1, new_cols, new_sum))\n        \n        return max_sum\n    \n    return backtrack(0, set(), 0)"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero values\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure we have at least 3 non-zero rows and columns\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Sort rows and columns by their sums in descending order\n    non_zero_rows.sort(key=lambda i: sum(board[i]), reverse=True)\n    non_zero_cols.sort(key=lambda j: sum(board[i][j] for i in range(m)), reverse=True)\n    \n    # Select the top 3 rows and columns\n    selected_rows = non_zero_rows[:3]\n    selected_cols = non_zero_cols[:3]\n    \n    # Calculate the sum of the selected cells\n    max_sum = sum(board[i][j] for i in selected_rows for j in selected_cols)\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Find rows and columns with exactly one non-zero value\n    valid_rows = [i for i, s in enumerate(row_sums) if s != 0]\n    valid_cols = [j for j, s in enumerate(col_sums) if s != 0]\n    \n    # Select three valid rows and columns\n    selected_rows = valid_rows[:3]\n    selected_cols = valid_cols[:3]\n    \n    # Calculate the sum of the selected cells\n    max_sum = sum(board[r][c] for r in selected_rows for c in selected_cols)\n    \n    return max_sum\n```", "```python\ndef maxSumOfNonAttackingRooks(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate the sum of each column\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort the row sums and column sums in descending order\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    # Select the top three elements from each list\n    selected_row_sums = row_sums[:3]\n    selected_col_sums = col_sums[:3]\n    \n    # Return the sum of the selected elements\n    return sum(selected_row_sums) + sum(selected_col_sums)\n```", "```python\ndef max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    col_used = [False] * cols\n    total_sum = 0\n    \n    for i in range(rows):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(cols):\n            if not col_used[j] and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        col_used[max_col] = True\n        total_sum += max_val\n    \n    return total_sum\n```", "```python\ndef maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [(sum(board[i]), i) for i in range(m)]\n    row_sums.sort(reverse=True)\n    \n    # Calculate column sums\n    col_sums = [(sum(board[j][i] for j in range(m)), i) for i in range(n)]\n    col_sums.sort(reverse=True)\n    \n    # Select the top three rows and columns\n    selected_rows = [row_sums[i][1] for i in range(3)]\n    selected_cols = [col_sums[i][1] for i in range(3)]\n    \n    # Ensure no overlapping rows and columns\n    selected_rows = sorted(set(selected_rows))\n    selected_cols = sorted(set(selected_cols))\n    \n    # Calculate the maximum sum\n    max_sum = sum(board[selected_rows[i]][selected_cols[j]] for i in range(3) for j in range(3))\n    \n    return max_sum\n```", "```python\nfrom itertools import permutations\n\ndef max_rook_sum(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Find all possible positions for rooks in each row\n    possible_positions = []\n    for i in range(rows):\n        positions = [j for j in range(cols) if board[i][j] != -1]\n        possible_positions.append(positions)\n    \n    # Generate all valid combinations of three positions\n    max_sum = float('-inf')\n    for perm in permutations(range(rows), 3):\n        col_indices = [possible_positions[r][perm[r]] for r in range(3)]\n        current_sum = sum(board[r][c] for r, c in zip(perm, col_indices))\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate the sum of each column\n    col_sums = [sum(board[row][col] for row in range(rows)) for col in range(cols)]\n    \n    # Sort row sums and column sums in descending order\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    # Select the top three elements from each list\n    selected_row_sums = row_sums[:3]\n    selected_col_sums = col_sums[:3]\n    \n    # Ensure no two selected elements come from the same row or column\n    used_rows = set()\n    used_cols = set()\n    max_sum = 0\n    \n    for i in range(3):\n        for j in range(3):\n            if i not in used_rows and j not in used_cols:\n                max_sum += selected_row_sums[i] + selected_col_sums[j]\n                used_rows.add(i)\n                used_cols.add(j)\n                break\n    \n    return max_sum\n```", "```python\ndef maxSumOfRooks(board):\n    def backtrack(row, cols, current_sum):\n        if row == len(board):\n            return current_sum\n        \n        max_sum = float('-inf')\n        for col in range(len(board[0])):\n            if col not in cols:\n                new_cols = cols.copy()\n                new_cols.add(col)\n                new_sum = current_sum + board[row][col]\n                max_sum = max(max_sum, backtrack(row + 1, new_cols, new_sum))\n        \n        return max_sum\n    \n    return backtrack(0, set(), 0)\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(nums[i] + 1):\n            k = nums[i] - j\n            if k >= 0:\n                arr1 = [j] * (i + 1)\n                arr2 = [k] * (i + 1)\n                if all(arr2[j] >= arr2[j + 1] for j in range(i)):\n                    count += 1\n                    count %= MOD\n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [0] * (max(nums) + 1)\n    dp_non_incr = [0] * (max(nums) + 1)\n    \n    dp_non_decr[nums[0]] = 1\n    dp_non_incr[nums[0]] = 1\n    \n    count = 0\n    \n    for i in range(1, n):\n        new_dp_non_decr = [0] * (max(nums) + 1)\n        new_dp_non_incr = [0] * (max(nums) + 1)\n        \n        for j in range(nums[i] + 1):\n            new_dp_non_decr[j] = (new_dp_non_decr[j] + dp_non_decr[j]) % MOD\n            new_dp_non_incr[j] = (new_dp_non_incr[j] + dp_non_incr[j]) % MOD\n        \n        for j in range(nums[i]):\n            new_dp_non_decr[nums[i] - j] = (new_dp_non_decr[nums[i] - j] + dp_non_decr[j]) % MOD\n            new_dp_non_incr[nums[i] - j] = (new_dp_non_incr[nums[i] - j] + dp_non_incr[j]) % MOD\n        \n        count = (count + dp_non_decr[nums[i]] * dp_non_incr[nums[i]]) % MOD\n        \n        dp_non_decr = new_dp_non_decr\n        dp_non_incr = new_dp_non_incr\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_incr = [[0] * 51 for _ in range(n)]\n    dp_decr = [[0] * 51 for _ in range(n)]\n    \n    # Base case: single element arrays\n    for i in range(51):\n        dp_incr[0][i] = 1\n        dp_decr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            for k in range(j, 51):\n                dp_incr[i][j] += dp_incr[i-1][k]\n                dp_incr[i][j] %= MOD\n                dp_decr[i][j] += dp_decr[i-1][k]\n                dp_decr[i][j] %= MOD\n    \n    # Count valid pairs\n    count = 0\n    for i in range(n):\n        count += dp_incr[i][nums[i]] * dp_decr[i][nums[i]]\n        count %= MOD\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Precompute possible values for arr1 and arr2\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, min(i, nums[i-1]) + 1):\n            dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n            dp[i][j] %= MOD\n    \n    count = 0\n    for i in range(n):\n        target = nums[i]\n        left, right = 0, target\n        while left < right:\n            mid = (left + right) // 2\n            if dp[i+1][mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        count += dp[i+1][left]\n        count %= MOD\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_val = max(nums)\n    \n    dp_inc = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n    dp_dec = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n    \n    dp_inc[0][0] = 1\n    dp_dec[0][0] = 1\n    \n    for num in nums:\n        new_dp_inc = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n        new_dp_dec = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(max_val * n + 1):\n                if j >= num:\n                    new_dp_inc[i][j] = (new_dp_inc[i][j] + dp_inc[i - 1][j - num]) % MOD\n        \n        for i in range(1, n + 1):\n            for j in range(max_val * n + 1):\n                if j >= num:\n                    new_dp_dec[i][j] = (new_dp_dec[i][j] + dp_dec[i - 1][j - num]) % MOD\n        \n        dp_inc = new_dp_inc\n        dp_dec = new_dp_dec\n    \n    result = 0\n    for i in range(1, n + 1):\n        for j in range(max_val * n + 1):\n            result = (result + dp_inc[i][j] * dp_dec[i][j]) % MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Precompute the number of non-decreasing sequences for arr1\n    non_decreasing_count = [[0] * 51 for _ in range(n)]\n    for i in range(51):\n        non_decreasing_count[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            non_decreasing_count[i][j] = sum(non_decreasing_count[i-1][:j+1]) % MOD\n    \n    # Precompute the number of non-increasing sequences for arr2\n    non_increasing_count = [[0] * 51 for _ in range(n)]\n    for i in range(51):\n        non_increasing_count[n-1][i] = 1\n    \n    for i in range(n-2, -1, -1):\n        for j in range(51):\n            non_increasing_count[i][j] = sum(non_increasing_count[i+1][j:]) % MOD\n    \n    # Calculate the total number of valid pairs\n    result = 0\n    for i in range(n):\n        target = nums[i]\n        for j in range(target // 2 + 1):\n            if j <= target - j:\n                result += (non_decreasing_count[i][j] * non_increasing_count[i][target - j]) % MOD\n                result %= MOD\n    \n    return result", "def count_monotonic_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decreasing = [[0] * (n + 1) for _ in range(n + 1)]\n    dp_non_increasing = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: one way to form an empty array\n    dp_non_decreasing[0][0] = 1\n    dp_non_increasing[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            if j > 0:\n                dp_non_decreasing[i][j] = dp_non_decreasing[i-1][j-1] + dp_non_decreasing[i-1][j]\n                dp_non_increasing[i][j] = dp_non_increasing[i-1][j] + dp_non_increasing[i-1][j+1]\n            else:\n                dp_non_decreasing[i][j] = dp_non_decreasing[i-1][j]\n                dp_non_increasing[i][j] = dp_non_increasing[i-1][j+1]\n    \n    total_count = 0\n    for i in range(n):\n        target = nums[i]\n        left = 0\n        right = i + 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if dp_non_decreasing[mid][mid] + dp_non_increasing[mid][right-mid] <= target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        total_count += dp_non_decreasing[left][left] + dp_non_increasing[left][right-left]\n        total_count %= MOD\n    \n    return total_count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_val = 50 * n\n    \n    dp_non_decr = [0] * (max_val + 1)\n    dp_non_incr = [0] * (max_val + 1)\n    \n    dp_non_decr[0] = 1\n    dp_non_incr[0] = 1\n    \n    for num in nums:\n        new_dp_non_decr = [0] * (max_val + 1)\n        new_dp_non_incr = [0] * (max_val + 1)\n        \n        for s in range(max_val + 1):\n            if s >= num:\n                new_dp_non_decr[s] = (new_dp_non_decr[s] + dp_non_decr[s - num]) % MOD\n            new_dp_non_decr[s] = (new_dp_non_decr[s] + dp_non_decr[s]) % MOD\n            \n            if s >= num:\n                new_dp_non_incr[s] = (new_dp_non_incr[s] + dp_non_incr[s - num]) % MOD\n            new_dp_non_incr[s] = (new_dp_non_incr[s] + dp_non_incr[s]) % MOD\n        \n        dp_non_decr = new_dp_non_decr\n        dp_non_incr = new_dp_non_incr\n    \n    result = 0\n    for s in range(max_val + 1):\n        result = (result + dp_non_decr[s] * dp_non_incr[s]) % MOD\n    \n    return result"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(nums[i] + 1):\n            k = nums[i] - j\n            if k >= 0:\n                arr1 = [j] * (i + 1)\n                arr2 = [k] * (i + 1)\n                if all(arr2[j] >= arr2[j + 1] for j in range(i)):\n                    count += 1\n                    count %= MOD\n    return count", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [0] * (max(nums) + 1)\n    dp_non_incr = [0] * (max(nums) + 1)\n    \n    dp_non_decr[nums[0]] = 1\n    dp_non_incr[nums[0]] = 1\n    \n    count = 0\n    \n    for i in range(1, n):\n        new_dp_non_decr = [0] * (max(nums) + 1)\n        new_dp_non_incr = [0] * (max(nums) + 1)\n        \n        for j in range(nums[i] + 1):\n            new_dp_non_decr[j] = (new_dp_non_decr[j] + dp_non_decr[j]) % MOD\n            new_dp_non_incr[j] = (new_dp_non_incr[j] + dp_non_incr[j]) % MOD\n        \n        for j in range(nums[i]):\n            new_dp_non_decr[nums[i] - j] = (new_dp_non_decr[nums[i] - j] + dp_non_decr[j]) % MOD\n            new_dp_non_incr[nums[i] - j] = (new_dp_non_incr[nums[i] - j] + dp_non_incr[j]) % MOD\n        \n        count = (count + dp_non_decr[nums[i]] * dp_non_incr[nums[i]]) % MOD\n        \n        dp_non_decr = new_dp_non_decr\n        dp_non_incr = new_dp_non_incr\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_incr = [[0] * 51 for _ in range(n)]\n    dp_decr = [[0] * 51 for _ in range(n)]\n    \n    # Base case: single element arrays\n    for i in range(51):\n        dp_incr[0][i] = 1\n        dp_decr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            for k in range(j, 51):\n                dp_incr[i][j] += dp_incr[i-1][k]\n                dp_incr[i][j] %= MOD\n                dp_decr[i][j] += dp_decr[i-1][k]\n                dp_decr[i][j] %= MOD\n    \n    # Count valid pairs\n    count = 0\n    for i in range(n):\n        count += dp_incr[i][nums[i]] * dp_decr[i][nums[i]]\n        count %= MOD\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Precompute possible values for arr1 and arr2\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, min(i, nums[i-1]) + 1):\n            dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n            dp[i][j] %= MOD\n    \n    count = 0\n    for i in range(n):\n        target = nums[i]\n        left, right = 0, target\n        while left < right:\n            mid = (left + right) // 2\n            if dp[i+1][mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        count += dp[i+1][left]\n        count %= MOD\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_val = max(nums)\n    \n    dp_inc = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n    dp_dec = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n    \n    dp_inc[0][0] = 1\n    dp_dec[0][0] = 1\n    \n    for num in nums:\n        new_dp_inc = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n        new_dp_dec = [[0] * (max_val * n + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(max_val * n + 1):\n                if j >= num:\n                    new_dp_inc[i][j] = (new_dp_inc[i][j] + dp_inc[i - 1][j - num]) % MOD\n        \n        for i in range(1, n + 1):\n            for j in range(max_val * n + 1):\n                if j >= num:\n                    new_dp_dec[i][j] = (new_dp_dec[i][j] + dp_dec[i - 1][j - num]) % MOD\n        \n        dp_inc = new_dp_inc\n        dp_dec = new_dp_dec\n    \n    result = 0\n    for i in range(1, n + 1):\n        for j in range(max_val * n + 1):\n            result = (result + dp_inc[i][j] * dp_dec[i][j]) % MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Precompute the number of non-decreasing sequences for arr1\n    non_decreasing_count = [[0] * 51 for _ in range(n)]\n    for i in range(51):\n        non_decreasing_count[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            non_decreasing_count[i][j] = sum(non_decreasing_count[i-1][:j+1]) % MOD\n    \n    # Precompute the number of non-increasing sequences for arr2\n    non_increasing_count = [[0] * 51 for _ in range(n)]\n    for i in range(51):\n        non_increasing_count[n-1][i] = 1\n    \n    for i in range(n-2, -1, -1):\n        for j in range(51):\n            non_increasing_count[i][j] = sum(non_increasing_count[i+1][j:]) % MOD\n    \n    # Calculate the total number of valid pairs\n    result = 0\n    for i in range(n):\n        target = nums[i]\n        for j in range(target // 2 + 1):\n            if j <= target - j:\n                result += (non_decreasing_count[i][j] * non_increasing_count[i][target - j]) % MOD\n                result %= MOD\n    \n    return result\n```", "```python\ndef count_monotonic_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decreasing = [[0] * (n + 1) for _ in range(n + 1)]\n    dp_non_increasing = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: one way to form an empty array\n    dp_non_decreasing[0][0] = 1\n    dp_non_increasing[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            if j > 0:\n                dp_non_decreasing[i][j] = dp_non_decreasing[i-1][j-1] + dp_non_decreasing[i-1][j]\n                dp_non_increasing[i][j] = dp_non_increasing[i-1][j] + dp_non_increasing[i-1][j+1]\n            else:\n                dp_non_decreasing[i][j] = dp_non_decreasing[i-1][j]\n                dp_non_increasing[i][j] = dp_non_increasing[i-1][j+1]\n    \n    total_count = 0\n    for i in range(n):\n        target = nums[i]\n        left = 0\n        right = i + 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            if dp_non_decreasing[mid][mid] + dp_non_increasing[mid][right-mid] <= target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        total_count += dp_non_decreasing[left][left] + dp_non_increasing[left][right-left]\n        total_count %= MOD\n    \n    return total_count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_val = 50 * n\n    \n    dp_non_decr = [0] * (max_val + 1)\n    dp_non_incr = [0] * (max_val + 1)\n    \n    dp_non_decr[0] = 1\n    dp_non_incr[0] = 1\n    \n    for num in nums:\n        new_dp_non_decr = [0] * (max_val + 1)\n        new_dp_non_incr = [0] * (max_val + 1)\n        \n        for s in range(max_val + 1):\n            if s >= num:\n                new_dp_non_decr[s] = (new_dp_non_decr[s] + dp_non_decr[s - num]) % MOD\n            new_dp_non_decr[s] = (new_dp_non_decr[s] + dp_non_decr[s]) % MOD\n            \n            if s >= num:\n                new_dp_non_incr[s] = (new_dp_non_incr[s] + dp_non_incr[s - num]) % MOD\n            new_dp_non_incr[s] = (new_dp_non_incr[s] + dp_non_incr[s]) % MOD\n        \n        dp_non_decr = new_dp_non_decr\n        dp_non_incr = new_dp_non_incr\n    \n    result = 0\n    for s in range(max_val + 1):\n        result = (result + dp_non_decr[s] * dp_non_incr[s]) % MOD\n    \n    return result\n```"]}
{"task_id": "3560", "codes": ["from collections import deque\n\ndef min_moves(kx, ky, px, py):\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(sorted(positions)))\n    if key in memo:\n        return memo[key]\n    \n    max_moves_alice = 0\n    for px, py in positions:\n        moves_to_capture = min_moves(kx, ky, px, py)\n        new_positions = [pos for pos in positions if pos != (px, py)]\n        moves_bob = max_moves(px, py, new_positions, memo)\n        total_moves = moves_to_capture + moves_bob\n        max_moves_alice = max(max_moves_alice, total_moves)\n    \n    memo[key] = max_moves_alice\n    return max_moves_alice\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return max_moves(kx, ky, positions, memo)", "def min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_alice_moves(kx, ky, positions):\n    n = len(positions)\n    moves = [min_moves_to_capture(kx, ky, px, py) for px, py in positions]\n    \n    def dfs(index, alice_turn, current_moves):\n        if index == n:\n            return current_moves\n        \n        if alice_turn:\n            # Alice wants to maximize the moves\n            max_moves = float('-inf')\n            for i in range(n):\n                if moves[i] > 0:\n                    new_moves = dfs(i + 1, False, current_moves + moves[i])\n                    max_moves = max(max_moves, new_moves)\n                    moves[i] = 0  # Mark as captured\n            return max_moves\n        else:\n            # Bob wants to minimize the moves\n            min_moves = float('inf')\n            for i in range(n):\n                if moves[i] > 0:\n                    new_moves = dfs(i + 1, True, current_moves + moves[i])\n                    min_moves = min(min_moves, new_moves)\n                    moves[i] = 0  # Mark as captured\n            return min_moves\n    \n    return dfs(0, True, 0)\n\n# Example usage:\nprint(max_alice_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_alice_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_alice_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3", "```python\nfrom collections import deque\nfrom functools import lru_cache\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves", "def min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    min_moves = float('inf')\n    for dx, dy in moves:\n        nx, ny = kx + dx, ky + dy\n        if 0 <= nx < 50 and 0 <= ny < 50 and abs(px - nx) + abs(py - ny) <= 3:\n            min_moves = min(min_moves, 1 + min_moves_to_capture(nx, ny, px, py))\n    return min_moves if min_moves != float('inf') else 0\n\ndef max_moves_alice(kx, ky, positions):\n    if not positions:\n        return 0\n    min_moves = float('inf')\n    for px, py in positions:\n        moves = min_moves_to_capture(kx, ky, px, py)\n        min_moves = min(min_moves, moves + max_moves_alice(px, py, [pos for pos in positions if pos != [px, py]]))\n    return min_moves\n\ndef knight_game(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance between the knight and the pawn\n    return abs(kx - px) + abs(ky - py)\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    if n == 0:\n        return 0\n\n    # Sort positions based on the minimum moves required to capture them\n    positions.sort(key=lambda pos: min_moves_to_capture(kx, ky, pos[0], pos[1]))\n\n    total_moves = 0\n    alice_turn = True\n\n    while positions:\n        min_moves = float('inf')\n        best_pawn_index = -1\n\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves_to_capture(kx, ky, px, py)\n            if moves < min_moves:\n                min_moves = moves\n                best_pawn_index = i\n\n        if alice_turn:\n            total_moves += min_moves * 2  # Alice makes two moves per capture\n        else:\n            total_moves += min_moves\n\n        del positions[best_pawn_index]\n        alice_turn = not alice_turn\n\n    return total_moves", "def min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef minimax(pawns, kx, ky, depth, is_maximizing, alpha, beta):\n    if not pawns:\n        return 0\n    \n    if is_maximizing:\n        max_value = float('-inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(kx, ky, px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            value = minimax(remaining_pawns, px, py, depth + 1, False, alpha, beta)\n            max_value = max(max_value, value + moves)\n            alpha = max(alpha, value)\n            if beta <= alpha:\n                break\n        return max_value\n    else:\n        min_value = float('inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(kx, ky, px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            value = minimax(remaining_pawns, px, py, depth + 1, True, alpha, beta)\n            min_value = min(min_value, value + moves)\n            beta = min(beta, value)\n            if beta <= alpha:\n                break\n        return min_value\n\ndef max_total_moves(kx, ky, positions):\n    return minimax(positions, kx, ky, 0, True, float('-inf'), float('inf'))", "def minKnightMoves(x: int, y: int) -> int:\n    if x == 0 and y == 0:\n        return 0\n    if x == 1 and y == 1:\n        return 2\n    dp = [[float('inf')] * 300 for _ in range(300)]\n    dp[150 + x][150 + y] = 0\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = deque([(150 + x, 150 + y)])\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 300 and 0 <= ny < 300 and dp[nx][ny] > dp[cx][cy] + 1:\n                dp[nx][ny] = dp[cx][cy] + 1\n                queue.append((nx, ny))\n    return dp[150][150]\n\ndef maxMoves(kx: int, ky: int, positions: List[List[int]]) -> int:\n    n = len(positions)\n    dp = [[[float('-inf')] * n for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = minKnightMoves(abs(positions[i][0] - positions[j][0]), abs(positions[i][1] - positions[j][1]))\n            dp[i][j][i] = dist\n            dp[i][j][j] = dist\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if i != j and i != k and j != k:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][k][k] + dp[k][j][k])\n    ans = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ans = max(ans, dp[i][j][i] + dp[i][j][j])\n    return ans", "def min_moves(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[[-1] * n for _ in range(n)] for _ in range(n)]\n    \n    def dfs(i, j, turn):\n        if i == n or j == n:\n            return 0\n        if dp[i][j][turn] != -1:\n            return dp[i][j][turn]\n        \n        px, py = positions[i]\n        qx, qy = positions[j]\n        moves_to_capture = min_moves(kx, ky, px, py)\n        moves_to_capture_q = min_moves(kx, ky, qx, qy)\n        \n        if turn == 0:  # Alice's turn\n            if moves_to_capture < moves_to_capture_q:\n                dp[i][j][turn] = moves_to_capture + dfs(i + 1, j, 1)\n            else:\n                dp[i][j][turn] = moves_to_capture_q + dfs(i, j + 1, 1)\n        else:  # Bob's turn\n            if moves_to_capture > moves_to_capture_q:\n                dp[i][j][turn] = moves_to_capture + dfs(i + 1, j, 0)\n            else:\n                dp[i][j][turn] = moves_to_capture_q + dfs(i, j + 1, 0)\n        \n        return dp[i][j][turn]\n    \n    return dfs(0, 0, 0)\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nfrom collections import deque\n\ndef min_moves(kx, ky, px, py):\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(sorted(positions)))\n    if key in memo:\n        return memo[key]\n    \n    max_moves_alice = 0\n    for px, py in positions:\n        moves_to_capture = min_moves(kx, ky, px, py)\n        new_positions = [pos for pos in positions if pos != (px, py)]\n        moves_bob = max_moves(px, py, new_positions, memo)\n        total_moves = moves_to_capture + moves_bob\n        max_moves_alice = max(max_moves_alice, total_moves)\n    \n    memo[key] = max_moves_alice\n    return max_moves_alice\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return max_moves(kx, ky, positions, memo)\n```", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_alice_moves(kx, ky, positions):\n    n = len(positions)\n    moves = [min_moves_to_capture(kx, ky, px, py) for px, py in positions]\n    \n    def dfs(index, alice_turn, current_moves):\n        if index == n:\n            return current_moves\n        \n        if alice_turn:\n            # Alice wants to maximize the moves\n            max_moves = float('-inf')\n            for i in range(n):\n                if moves[i] > 0:\n                    new_moves = dfs(i + 1, False, current_moves + moves[i])\n                    max_moves = max(max_moves, new_moves)\n                    moves[i] = 0  # Mark as captured\n            return max_moves\n        else:\n            # Bob wants to minimize the moves\n            min_moves = float('inf')\n            for i in range(n):\n                if moves[i] > 0:\n                    new_moves = dfs(i + 1, True, current_moves + moves[i])\n                    min_moves = min(min_moves, new_moves)\n                    moves[i] = 0  # Mark as captured\n            return min_moves\n    \n    return dfs(0, True, 0)\n\n# Example usage:\nprint(max_alice_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_alice_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_alice_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```", "```python\nfrom collections import deque\nfrom functools import lru_cache\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves", "def min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    min_moves = float('inf')\n    for dx, dy in moves:\n        nx, ny = kx + dx, ky + dy\n        if 0 <= nx < 50 and 0 <= ny < 50 and abs(px - nx) + abs(py - ny) <= 3:\n            min_moves = min(min_moves, 1 + min_moves_to_capture(nx, ny, px, py))\n    return min_moves if min_moves != float('inf') else 0\n\ndef max_moves_alice(kx, ky, positions):\n    if not positions:\n        return 0\n    min_moves = float('inf')\n    for px, py in positions:\n        moves = min_moves_to_capture(kx, ky, px, py)\n        min_moves = min(min_moves, moves + max_moves_alice(px, py, [pos for pos in positions if pos != [px, py]]))\n    return min_moves\n\ndef knight_game(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance between the knight and the pawn\n    return abs(kx - px) + abs(ky - py)\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    if n == 0:\n        return 0\n\n    # Sort positions based on the minimum moves required to capture them\n    positions.sort(key=lambda pos: min_moves_to_capture(kx, ky, pos[0], pos[1]))\n\n    total_moves = 0\n    alice_turn = True\n\n    while positions:\n        min_moves = float('inf')\n        best_pawn_index = -1\n\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves_to_capture(kx, ky, px, py)\n            if moves < min_moves:\n                min_moves = moves\n                best_pawn_index = i\n\n        if alice_turn:\n            total_moves += min_moves * 2  # Alice makes two moves per capture\n        else:\n            total_moves += min_moves\n\n        del positions[best_pawn_index]\n        alice_turn = not alice_turn\n\n    return total_moves", "```python\ndef min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef minimax(pawns, kx, ky, depth, is_maximizing, alpha, beta):\n    if not pawns:\n        return 0\n    \n    if is_maximizing:\n        max_value = float('-inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(kx, ky, px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            value = minimax(remaining_pawns, px, py, depth + 1, False, alpha, beta)\n            max_value = max(max_value, value + moves)\n            alpha = max(alpha, value)\n            if beta <= alpha:\n                break\n        return max_value\n    else:\n        min_value = float('inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(kx, ky, px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            value = minimax(remaining_pawns, px, py, depth + 1, True, alpha, beta)\n            min_value = min(min_value, value + moves)\n            beta = min(beta, value)\n            if beta <= alpha:\n                break\n        return min_value\n\ndef max_total_moves(kx, ky, positions):\n    return minimax(positions, kx, ky, 0, True, float('-inf'), float('inf'))\n```", "def minKnightMoves(x: int, y: int) -> int:\n    if x == 0 and y == 0:\n        return 0\n    if x == 1 and y == 1:\n        return 2\n    dp = [[float('inf')] * 300 for _ in range(300)]\n    dp[150 + x][150 + y] = 0\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = deque([(150 + x, 150 + y)])\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 300 and 0 <= ny < 300 and dp[nx][ny] > dp[cx][cy] + 1:\n                dp[nx][ny] = dp[cx][cy] + 1\n                queue.append((nx, ny))\n    return dp[150][150]\n\ndef maxMoves(kx: int, ky: int, positions: List[List[int]]) -> int:\n    n = len(positions)\n    dp = [[[float('-inf')] * n for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = minKnightMoves(abs(positions[i][0] - positions[j][0]), abs(positions[i][1] - positions[j][1]))\n            dp[i][j][i] = dist\n            dp[i][j][j] = dist\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if i != j and i != k and j != k:\n                    dp[i][j][k] = max(dp[i][j][k], dp[i][k][k] + dp[k][j][k])\n    ans = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ans = max(ans, dp[i][j][i] + dp[i][j][j])\n    return ans", "```python\ndef min_moves(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[[-1] * n for _ in range(n)] for _ in range(n)]\n    \n    def dfs(i, j, turn):\n        if i == n or j == n:\n            return 0\n        if dp[i][j][turn] != -1:\n            return dp[i][j][turn]\n        \n        px, py = positions[i]\n        qx, qy = positions[j]\n        moves_to_capture = min_moves(kx, ky, px, py)\n        moves_to_capture_q = min_moves(kx, ky, qx, qy)\n        \n        if turn == 0:  # Alice's turn\n            if moves_to_capture < moves_to_capture_q:\n                dp[i][j][turn] = moves_to_capture + dfs(i + 1, j, 1)\n            else:\n                dp[i][j][turn] = moves_to_capture_q + dfs(i, j + 1, 1)\n        else:  # Bob's turn\n            if moves_to_capture > moves_to_capture_q:\n                dp[i][j][turn] = moves_to_capture + dfs(i + 1, j, 0)\n            else:\n                dp[i][j][turn] = moves_to_capture_q + dfs(i, j + 1, 0)\n        \n        return dp[i][j][turn]\n    \n    return dfs(0, 0, 0)\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```"]}
{"task_id": "3583", "codes": ["def solve_gcd_pairs(nums, queries):\n    max_num = max(nums)\n    gcd_count = [0] * (max_num + 1)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = gcd(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n\n    prefix_sum = [0] * (max_num + 1)\n    for i in range(1, max_num + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + gcd_count[i]\n\n    result = []\n    for q in queries:\n        idx = 0\n        for i in range(1, max_num + 1):\n            if prefix_sum[i] > q:\n                idx = i\n                break\n        result.append(idx)\n\n    return result", "def getGCD(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef solve(nums, queries):\n    max_val = max(nums)\n    gcd_count = {}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in gcd_count:\n                gcd_count[gcd_val] = 0\n            gcd_count[gcd_val] += 1\n    \n    sorted_gcds = []\n    for gcd_val, count in gcd_count.items():\n        sorted_gcds.extend([gcd_val] * count)\n    \n    result = []\n    for query in queries:\n        result.append(sorted_gcds[query])\n    \n    return result", "def getGCDs(nums):\n    max_val = max(nums)\n    gcd_counts = [0] * (max_val + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_counts[d] += 1\n    \n    return gcd_counts\n\ndef processQueries(gcd_counts, queries):\n    prefix_sums = [0] * (len(gcd_counts))\n    prefix_sums[0] = gcd_counts[0]\n    \n    for i in range(1, len(gcd_counts)):\n        prefix_sums[i] = prefix_sums[i - 1] + gcd_counts[i]\n    \n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(prefix_sums, q + 1)\n        result.append(idx)\n    \n    return result\n\ndef answer_queries(nums, queries):\n    gcd_counts = getGCDs(nums)\n    return processQueries(gcd_counts, queries)", "def getGCDs(nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g not in gcd_count:\n                gcd_count[g] = 0\n            gcd_count[g] += 1\n    \n    gcd_list = sorted(gcd_count.keys())\n    return gcd_list, gcd_count\n\ndef processQueries(nums, queries):\n    gcd_list, gcd_count = getGCDs(nums)\n    result = []\n    \n    for q in queries:\n        idx = 0\n        for g in gcd_list:\n            if q >= gcd_count[g]:\n                q -= gcd_count[g]\n            else:\n                result.append(g)\n                break\n    \n    return result", "def getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    freq = [0] * (max_val + 1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            freq[gcd_val] += 1\n    \n    sorted_gcds = []\n    cum_freq = 0\n    \n    for i in range(1, max_val + 1):\n        if freq[i] > 0:\n            cum_freq += freq[i]\n            sorted_gcds.extend([i] * freq[i])\n    \n    result = []\n    for q in queries:\n        result.append(sorted_gcds[q])\n    \n    return result", "from collections import defaultdict\nimport bisect\n\ndef solve_gcd_pairs(nums, queries):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count the occurrences of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_value = gcd(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n    \n    # Get unique GCD values sorted\n    unique_gcds = sorted(gcd_count.keys())\n    \n    # Create a list to map each GCD value to its cumulative count\n    cum_counts = [0]\n    for gcd_val in unique_gcds:\n        cum_counts.append(cum_counts[-1] + gcd_count[gcd_val])\n    \n    # Answer the queries\n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(cum_counts, q + 1)\n        if idx > 0:\n            result.append(unique_gcds[idx - 1])\n    \n    return result", "from math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Count the frequency of each GCD value\n    for num in nums:\n        for i in range(1, num + 1):\n            if num % i == 0:\n                gcd_counts[i] += 1\n    \n    # Reconstruct the sorted list of GCDs\n    gcd_list = []\n    for g, count in sorted(gcd_counts.items()):\n        gcd_list.extend([g] * count)\n    \n    # Answer the queries\n    answer = [gcd_list[q] for q in queries]\n    return answer", "from collections import defaultdict\nimport bisect\n\ndef getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count the frequency of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_value = getGCD(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n    \n    # Extract unique GCD values and sort them by frequency and value\n    unique_gcds = sorted(gcd_count.items())\n    sorted_gcds = []\n    for gcd_value, freq in unique_gcds:\n        sorted_gcds.extend([gcd_value] * freq)\n    \n    # Answer for each query\n    answer = []\n    for q in queries:\n        answer.append(sorted_gcds[q])\n    \n    return answer"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["def solve_gcd_pairs(nums, queries):\n    max_num = max(nums)\n    gcd_count = [0] * (max_num + 1)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = gcd(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n\n    prefix_sum = [0] * (max_num + 1)\n    for i in range(1, max_num + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + gcd_count[i]\n\n    result = []\n    for q in queries:\n        idx = 0\n        for i in range(1, max_num + 1):\n            if prefix_sum[i] > q:\n                idx = i\n                break\n        result.append(idx)\n\n    return result", "```python\ndef getGCD(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef solve(nums, queries):\n    max_val = max(nums)\n    gcd_count = {}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in gcd_count:\n                gcd_count[gcd_val] = 0\n            gcd_count[gcd_val] += 1\n    \n    sorted_gcds = []\n    for gcd_val, count in gcd_count.items():\n        sorted_gcds.extend([gcd_val] * count)\n    \n    result = []\n    for query in queries:\n        result.append(sorted_gcds[query])\n    \n    return result\n```", "```python\ndef getGCDs(nums):\n    max_val = max(nums)\n    gcd_counts = [0] * (max_val + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_counts[d] += 1\n    \n    return gcd_counts\n\ndef processQueries(gcd_counts, queries):\n    prefix_sums = [0] * (len(gcd_counts))\n    prefix_sums[0] = gcd_counts[0]\n    \n    for i in range(1, len(gcd_counts)):\n        prefix_sums[i] = prefix_sums[i - 1] + gcd_counts[i]\n    \n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(prefix_sums, q + 1)\n        result.append(idx)\n    \n    return result\n\ndef answer_queries(nums, queries):\n    gcd_counts = getGCDs(nums)\n    return processQueries(gcd_counts, queries)\n```", "```python\ndef getGCDs(nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g not in gcd_count:\n                gcd_count[g] = 0\n            gcd_count[g] += 1\n    \n    gcd_list = sorted(gcd_count.keys())\n    return gcd_list, gcd_count\n\ndef processQueries(nums, queries):\n    gcd_list, gcd_count = getGCDs(nums)\n    result = []\n    \n    for q in queries:\n        idx = 0\n        for g in gcd_list:\n            if q >= gcd_count[g]:\n                q -= gcd_count[g]\n            else:\n                result.append(g)\n                break\n    \n    return result\n```", "```python\ndef getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    freq = [0] * (max_val + 1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            freq[gcd_val] += 1\n    \n    sorted_gcds = []\n    cum_freq = 0\n    \n    for i in range(1, max_val + 1):\n        if freq[i] > 0:\n            cum_freq += freq[i]\n            sorted_gcds.extend([i] * freq[i])\n    \n    result = []\n    for q in queries:\n        result.append(sorted_gcds[q])\n    \n    return result\n```", "```python\nfrom collections import defaultdict\nimport bisect\n\ndef solve_gcd_pairs(nums, queries):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count the occurrences of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_value = gcd(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n    \n    # Get unique GCD values sorted\n    unique_gcds = sorted(gcd_count.keys())\n    \n    # Create a list to map each GCD value to its cumulative count\n    cum_counts = [0]\n    for gcd_val in unique_gcds:\n        cum_counts.append(cum_counts[-1] + gcd_count[gcd_val])\n    \n    # Answer the queries\n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(cum_counts, q + 1)\n        if idx > 0:\n            result.append(unique_gcds[idx - 1])\n    \n    return result\n```", "```python\nfrom math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Count the frequency of each GCD value\n    for num in nums:\n        for i in range(1, num + 1):\n            if num % i == 0:\n                gcd_counts[i] += 1\n    \n    # Reconstruct the sorted list of GCDs\n    gcd_list = []\n    for g, count in sorted(gcd_counts.items()):\n        gcd_list.extend([g] * count)\n    \n    # Answer the queries\n    answer = [gcd_list[q] for q in queries]\n    return answer\n```", "```python\nfrom collections import defaultdict\nimport bisect\n\ndef getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count the frequency of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_value = getGCD(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n    \n    # Extract unique GCD values and sort them by frequency and value\n    unique_gcds = sorted(gcd_count.items())\n    sorted_gcds = []\n    for gcd_value, freq in unique_gcds:\n        sorted_gcds.extend([gcd_value] * freq)\n    \n    # Answer for each query\n    answer = []\n    for q in queries:\n        answer.append(sorted_gcds[q])\n    \n    return answer\n```"]}
