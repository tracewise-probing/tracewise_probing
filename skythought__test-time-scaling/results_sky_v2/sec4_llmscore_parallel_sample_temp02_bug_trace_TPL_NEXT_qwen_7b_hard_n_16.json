{"difficulty": "hard", "num_threads": 32, "temperature": 0.2, "n": 16, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp02_bug_trace_TPL_NEXT_qwen_7b_hard_n_16.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "passed": false, "raw_code": "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```"}
{"task_id": "abc366_f", "code": "def max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by their slope A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    x = 1\n    for A, B in functions[:K]:\n        x = A * x + B\n    \n    print(x)\n\nmax_nested_function_value()", "passed": false, "raw_code": "```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by their slope A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    x = 1\n    for A, B in functions[:K]:\n        x = A * x + B\n    \n    print(x)\n\nmax_nested_function_value()\n```"}
{"task_id": "abc365_e", "code": "d", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Step 1: Compute the prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    current_xor = 0\n    for i in range(N):\n        current_xor ^= A[i]\n        prefix_xor[i + 1] = current_xor\n    \n    # Step 2: Calculate the contribution of each element\n    xor_count = {}\n    total_sum = 0\n    \n    for i in range(1, N + 1):\n        current_xor = prefix_xor[i]\n        if current_xor in xor_count:\n            total_sum += xor_count[current_xor] * A[i - 1]\n        xor_count[current_xor] = xor_count.get(current_xor, 0) + 1\n    \n    print(total_sum)\n\n# Call the function\nmain()"}
{"task_id": "3532", "code": "def minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize variables\n    times = [float('inf')] * n\n    times[0] = 0\n    visited = set()\n    queue = deque([0])\n    \n    while queue:\n        current_node = queue.popleft()\n        visited.add(current_node)\n        \n        for neighbor in graph[current_node]:\n            if neighbor not in visited:\n                if current_node % 2 == 0:\n                    times[neighbor] = max(times[neighbor], times[current_node] + 2)\n                else:\n                    times[neighbor] = max(times[neighbor], times[current_node] + 1)\n                queue.append(neighbor)\n    \n    return times", "passed": false, "raw_code": "```python\ndef minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize variables\n    times = [float('inf')] * n\n    times[0] = 0\n    visited = set()\n    queue = deque([0])\n    \n    while queue:\n        current_node = queue.popleft()\n        visited.add(current_node)\n        \n        for neighbor in graph[current_node]:\n            if neighbor not in visited:\n                if current_node % 2 == 0:\n                    times[neighbor] = max(times[neighbor], times[current_node] + 2)\n                else:\n                    times[neighbor] = max(times[neighbor], times[current_node] + 1)\n                queue.append(neighbor)\n    \n    return times\n```"}
{"task_id": "arc181_b", "code": "def f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef check_f(S, X, Y):\n    count_X_0 = X.count('0')\n    count_Y_0 = Y.count('0')\n    return count_X_0 == count_Y_0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        if check_f(S, X, Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef check_f(S, X, Y):\n    count_X_0 = X.count('0')\n    count_Y_0 = Y.count('0')\n    return count_X_0 == count_Y_0\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        if check_f(S, X, Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc366_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(coords, D):\n        n = len(coords)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + coords[i]\n        \n        count = 0\n        \n        for i in range(n):\n            left = max(0, i - D // 2)\n            right = min(n, i + D // 2 + 1)\n            count += prefix_sum[right] - prefix_sum[left]\n        \n        return count\n    \n    x_count = count_points(x_coords, D)\n    y_count = count_points(y_coords, D)\n    \n    result = x_count * y_count\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(coords, D):\n        n = len(coords)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + coords[i]\n        \n        count = 0\n        \n        for i in range(n):\n            left = max(0, i - D // 2)\n            right = min(n, i + D // 2 + 1)\n            count += prefix_sum[right] - prefix_sum[left]\n        \n        return count\n    \n    x_count = count_points(x_coords, D)\n    y_count = count_points(y_coords, D)\n    \n    result = x_count * y_count\n    print(result)\n\nmain()\n```"}
{"task_id": "abc373_f", "code": "def max_happiness(N, W, weights, values):\n    dp = [0] * (W + 1)\n\n    for i in range(N):\n        for w in range(W, weights[i] - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if w >= k * weights[i]:\n                    dp[w] = max(dp[w], dp[w - k * weights[i]] + k * values[i] - k ** 2)\n                else:\n                    break\n\n    return dp[W]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2 * i]))\n    values.append(int(data[3 + 2 * i]))\n\nprint(max_happiness(N, W, weights, values))", "passed": false, "raw_code": "def max_happiness(N, W, weights, values):\n    dp = [0] * (W + 1)\n\n    for i in range(N):\n        for w in range(W, weights[i] - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if w >= k * weights[i]:\n                    dp[w] = max(dp[w], dp[w - k * weights[i]] + k * values[i] - k ** 2)\n                else:\n                    break\n\n    return dp[W]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2 * i]))\n    values.append(int(data[3 + 2 * i]))\n\nprint(max_happiness(N, W, weights, values))"}
{"task_id": "abc367_e", "code": "def process_sequence(N, K, X, A):\n    # Dictionary to store the current state of the sequence and its position in the cycle\n    seen_states = {}\n    \n    # Current state of the sequence\n    current_state = tuple(A)\n    seen_states[current_state] = 0\n    \n    # Apply the operation until a cycle is detected or K operations are done\n    for i in range(1, K + 1):\n        next_state = tuple(A[X[j] - 1] for j in range(N))\n        if next_state in seen_states:\n            start_of_cycle = seen_states[next_state]\n            cycle_length = i - start_of_cycle\n            break\n        seen_states[next_state] = i\n        A = list(next_state)\n    \n    # If a cycle was detected, apply the remaining operations within the cycle\n    if 'start_of_cycle' in locals():\n        effective_operations = (K - start_of_cycle) % cycle_length\n        for _ in range(effective_operations):\n            A = [A[X[j] - 1] for j in range(N)]\n    \n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)", "passed": false, "raw_code": "```python\ndef process_sequence(N, K, X, A):\n    # Dictionary to store the current state of the sequence and its position in the cycle\n    seen_states = {}\n    \n    # Current state of the sequence\n    current_state = tuple(A)\n    seen_states[current_state] = 0\n    \n    # Apply the operation until a cycle is detected or K operations are done\n    for i in range(1, K + 1):\n        next_state = tuple(A[X[j] - 1] for j in range(N))\n        if next_state in seen_states:\n            start_of_cycle = seen_states[next_state]\n            cycle_length = i - start_of_cycle\n            break\n        seen_states[next_state] = i\n        A = list(next_state)\n    \n    # If a cycle was detected, apply the remaining operations within the cycle\n    if 'start_of_cycle' in locals():\n        effective_operations = (K - start_of_cycle) % cycle_length\n        for _ in range(effective_operations):\n            A = [A[X[j] - 1] for j in range(N)]\n    \n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)\n```"}
{"task_id": "abc372_e", "code": "import heapq\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    \n    def add_edge(u, v):\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def kth_largest(v, k):\n        if len(graph[v]) < k:\n            return -1\n        heap = []\n        for neighbor in graph[v]:\n            heapq.heappush(heap, -neighbor)\n        for _ in range(k - 1):\n            heapq.heappop(heap)\n        return -heap[0]\n    \n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            add_edge(u, v)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            results.append(kth_largest(v, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport heapq\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    \n    def add_edge(u, v):\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def kth_largest(v, k):\n        if len(graph[v]) < k:\n            return -1\n        heap = []\n        for neighbor in graph[v]:\n            heapq.heappush(heap, -neighbor)\n        for _ in range(k - 1):\n            heapq.heappop(heap)\n        return -heap[0]\n    \n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            add_edge(u, v)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            results.append(kth_largest(v, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc367_f", "code": "def can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()", "passed": false, "raw_code": "```python\ndef can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()\n```"}
{"task_id": "abc371_f", "code": "def min_movements(N, X, Q, T, G):\n    # Sort the initial positions of people\n    X.sort()\n    # Initialize the total number of movements\n    total_moves = 0\n    # Iterate over each task\n    for t, g in zip(T, G):\n        # Find the index of the person who needs to move\n        idx = t - 1\n        # Calculate the distance to the target\n        distance = abs(X[idx] - g)\n        # Move the person to the target\n        X[idx] = g\n        # Add the distance to the total number of movements\n        total_moves += distance\n    # Return the total number of movements\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\nT = list(map(int, data[N+2:N+2+Q]))\nG = list(map(int, data[N+2+Q:N+2+2*Q]))\n\n# Print the result\nprint(min_movements(N, X, Q, T, G))", "passed": false, "raw_code": "def min_movements(N, X, Q, T, G):\n    # Sort the initial positions of people\n    X.sort()\n    # Initialize the total number of movements\n    total_moves = 0\n    # Iterate over each task\n    for t, g in zip(T, G):\n        # Find the index of the person who needs to move\n        idx = t - 1\n        # Calculate the distance to the target\n        distance = abs(X[idx] - g)\n        # Move the person to the target\n        X[idx] = g\n        # Add the distance to the total number of movements\n        total_moves += distance\n    # Return the total number of movements\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\nT = list(map(int, data[N+2:N+2+Q]))\nG = list(map(int, data[N+2+Q:N+2+2*Q]))\n\n# Print the result\nprint(min_movements(N, X, Q, T, G))"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp1 = [[0] * (sum(nums) + 1) for _ in range(n + 1)]\n    dp2 = [[0] * (sum(nums) + 1) for _ in range(n + 1)]\n    \n    # Base case\n    dp1[0][0] = 1\n    dp2[0][0] = 1\n    \n    # Fill DP tables\n    for i in range(1, n + 1):\n        for j in range(nums[i - 1], sum(nums) + 1):\n            dp1[i][j] = dp1[i - 1][j] + dp1[i - 1][j - nums[i - 1]]\n            dp1[i][j] %= MOD\n            dp2[i][j] = dp2[i - 1][j] + dp2[i - 1][j - nums[i - 1]]\n            dp2[i][j] %= MOD\n    \n    # Calculate the result\n    result = 0\n    for j in range(sum(nums) + 1):\n        result += dp1[n][j] * dp2[n][j]\n        result %= MOD\n    \n    return result", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp1 = [[0] * (sum(nums) + 1) for _ in range(n + 1)]\n    dp2 = [[0] * (sum(nums) + 1) for _ in range(n + 1)]\n    \n    # Base case\n    dp1[0][0] = 1\n    dp2[0][0] = 1\n    \n    # Fill DP tables\n    for i in range(1, n + 1):\n        for j in range(nums[i - 1], sum(nums) + 1):\n            dp1[i][j] = dp1[i - 1][j] + dp1[i - 1][j - nums[i - 1]]\n            dp1[i][j] %= MOD\n            dp2[i][j] = dp2[i - 1][j] + dp2[i - 1][j - nums[i - 1]]\n            dp2[i][j] %= MOD\n    \n    # Calculate the result\n    result = 0\n    for j in range(sum(nums) + 1):\n        result += dp1[n][j] * dp2[n][j]\n        result %= MOD\n    \n    return result\n```"}
{"task_id": "arc181_c", "code": "def fill_grid(N, P, Q):\n    grid = [['' for _ in range(N)] for _ in range(N)]\n    i, j = 0, 0\n    \n    for k in range(N):\n        if P[i] < Q[j]:\n            grid[i][k] = '0'\n            i += 1\n        else:\n            grid[j][k] = '1'\n            j += 1\n    \n    for row in grid:\n        print(''.join(row))\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Fill and print the grid\nfill_grid(N, P, Q)", "passed": false, "raw_code": "```python\ndef fill_grid(N, P, Q):\n    grid = [['' for _ in range(N)] for _ in range(N)]\n    i, j = 0, 0\n    \n    for k in range(N):\n        if P[i] < Q[j]:\n            grid[i][k] = '0'\n            i += 1\n        else:\n            grid[j][k] = '1'\n            j += 1\n    \n    for row in grid:\n        print(''.join(row))\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Fill and print the grid\nfill_grid(N, P, Q)\n```"}
{"task_id": "arc182_d", "code": "def min_operations_to_equalize_sequences(N, M, A, B):\n    def min_operations(a, b):\n        diff = abs(b - a)\n        return min(diff, M - diff)\n\n    total_operations = 0\n    for i in range(N):\n        if A[i] != B[i]:\n            operations = min_operations(A[i], B[i])\n            if operations == 0:\n                return -1\n            total_operations += operations\n\n    return total_operations\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Print the result\nprint(min_operations_to_equalize_sequences(N, M, A, B))", "passed": false, "raw_code": "def min_operations_to_equalize_sequences(N, M, A, B):\n    def min_operations(a, b):\n        diff = abs(b - a)\n        return min(diff, M - diff)\n\n    total_operations = 0\n    for i in range(N):\n        if A[i] != B[i]:\n            operations = min_operations(A[i], B[i])\n            if operations == 0:\n                return -1\n            total_operations += operations\n\n    return total_operations\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Print the result\nprint(min_operations_to_equalize_sequences(N, M, A, B))"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        distinct_count = set()\n        for j in range(i, N):\n            distinct_count.add(A[j])\n            total_sum += len(distinct_count)\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        distinct_count = set()\n        for j in range(i, N):\n            distinct_count.add(A[j])\n            total_sum += len(distinct_count)\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc370_e", "code": "def count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(K + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - A[i - 1]]) % MOD\n\n    total_ways = sum(dp[N]) % MOD\n    valid_ways = (total_ways - dp[N][K]) % MOD\n    return valid_ways\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Output the result\nprint(count_partitions(N, K, A))", "passed": false, "raw_code": "```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        for j in range(K + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - A[i - 1]]) % MOD\n\n    total_ways = sum(dp[N]) % MOD\n    valid_ways = (total_ways - dp[N][K]) % MOD\n    return valid_ways\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Output the result\nprint(count_partitions(N, K, A))\n```"}
{"task_id": "abc373_g", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom heapq import heappop, heappush\n\ndef find_non_intersecting_permutation(N, P, Q):\n    def slope(p1, p2):\n        return (p2[1] - p1[1]) / (p2[0] - p1[0]) if p2[0] != p1[0] else float('inf')\n    \n    def is_intersecting(p1, q1, p2, q2):\n        return (q1[0] - p1[0]) * (q2[1] - p1[1]) == (q2[0] - p1[0]) * (q1[1] - p1[1])\n    \n    result = []\n    for i in range(N):\n        pq = []\n        for j in range(N):\n            if j != i:\n                heappush(pq, (slope(P[i], Q[j]), j))\n        \n        stack = []\n        while pq:\n            _, j = heappop(pq)\n            if not stack or not is_intersecting(P[i], Q[j], P[i], Q[stack[-1]]):\n                stack.append(j)\n        \n        if len(stack) == N - 1:\n            result = stack\n            break\n    \n    if result:\n        return ' '.join(map(str, result))\n    else:\n        return '-1'\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    Q = [(int(data[2*N+2*i+1]), int(data[2*N+2*i+2])) for i in range(N)]\n    \n    result = find_non_intersecting_permutation(N, P, Q)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc369_g", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef dfs(graph, root):\n    dist = [float('inf')] * (n + 1)\n    dist[root] = 0\n    stack = [(root, 0)]\n    \n    while stack:\n        node, d = stack.pop()\n        for neighbor in graph[node]:\n            if dist[neighbor] == float('inf'):\n                dist[neighbor] = d + 1\n                stack.append((neighbor, d + 1))\n    \n    return dist\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    \n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    root = 1\n    dist = dfs(graph, root)\n    \n    scores = [0] * (n + 1)\n    for k in range(1, n + 1):\n        scores[k] = sum(dist[i] for i in range(1, n + 1)) // 2\n    \n    for score in scores[1:]:\n        print(score)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef dfs(graph, root):\n    dist = [float('inf')] * (n + 1)\n    dist[root] = 0\n    stack = [(root, 0)]\n    \n    while stack:\n        node, d = stack.pop()\n        for neighbor in graph[node]:\n            if dist[neighbor] == float('inf'):\n                dist[neighbor] = d + 1\n                stack.append((neighbor, d + 1))\n    \n    return dist\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    \n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    root = 1\n    dist = dfs(graph, root)\n    \n    scores = [0] * (n + 1)\n    for k in range(1, n + 1):\n        scores[k] = sum(dist[i] for i in range(1, n + 1)) // 2\n    \n    for score in scores[1:]:\n        print(score)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc371_g", "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n    A.sort()\n    print(' '.join(map(str, A)))\nsolve()", "passed": false, "raw_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n    A.sort()\n    print(' '.join(map(str, A)))\nsolve()"}
{"task_id": "abc372_f", "code": "def count_ways(N, M, K, edges):\n    MOD = 998244353\n    \n    # Create adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        adj[i].append((i % N + 1, 1))\n    for x, y in edges:\n        adj[x].append((y, 2))\n    \n    # Initialize DP array\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    # Fill DP array\n    for k in range(1, K + 1):\n        for v in range(1, N + 1):\n            for u, edge_type in adj[v]:\n                dp[u][k] = (dp[u][k] + dp[v][k - 1]) % MOD\n    \n    # Sum up the ways to reach any vertex after K moves\n    result = sum(dp[v][K] for v in range(1, N + 1)) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nedges = [(int(data[2 * i + 3]), int(data[2 * i + 4])) for i in range(M)]\n\n# Compute and print the result\nprint(count_ways(N, M, K, edges))", "passed": false, "raw_code": "```python\ndef count_ways(N, M, K, edges):\n    MOD = 998244353\n    \n    # Create adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        adj[i].append((i % N + 1, 1))\n    for x, y in edges:\n        adj[x].append((y, 2))\n    \n    # Initialize DP array\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    # Fill DP array\n    for k in range(1, K + 1):\n        for v in range(1, N + 1):\n            for u, edge_type in adj[v]:\n                dp[u][k] = (dp[u][k] + dp[v][k - 1]) % MOD\n    \n    # Sum up the ways to reach any vertex after K moves\n    result = sum(dp[v][K] for v in range(1, N + 1)) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nedges = [(int(data[2 * i + 3]), int(data[2 * i + 4])) for i in range(M)]\n\n# Compute and print the result\nprint(count_ways(N, M, K, edges))\n```"}
{"task_id": "abc373_e", "code": "def min_additional_votes(N, M, K, A):\n    # Calculate the maximum votes any candidate currently has\n    max_votes = max(A)\n    \n    # Initialize the result array with -1\n    C = [-1] * N\n    \n    # Iterate over each candidate\n    for i in range(N):\n        # Calculate the votes needed for candidate i to win\n        votes_needed = max(max_votes + 1, sum(A[:i]) + sum(A[i+1:]) + 1)\n        \n        # Check if candidate i can secure their victory\n        if A[i] >= votes_needed:\n            C[i] = 0\n        elif A[i] + K - sum(A) < votes_needed:\n            C[i] = -1\n        else:\n            C[i] = votes_needed - A[i]\n    \n    return ' '.join(map(str, C))\n\n# Example usage:\n# N = 5\n# M = 2\n# K = 16\n# A = [3, 1, 4, 1, 5]\n# print(min_additional_votes(N, M, K, A))  # Output: 2 -1 1 -1 0", "passed": false, "raw_code": "```python\ndef min_additional_votes(N, M, K, A):\n    # Calculate the maximum votes any candidate currently has\n    max_votes = max(A)\n    \n    # Initialize the result array with -1\n    C = [-1] * N\n    \n    # Iterate over each candidate\n    for i in range(N):\n        # Calculate the votes needed for candidate i to win\n        votes_needed = max(max_votes + 1, sum(A[:i]) + sum(A[i+1:]) + 1)\n        \n        # Check if candidate i can secure their victory\n        if A[i] >= votes_needed:\n            C[i] = 0\n        elif A[i] + K - sum(A) < votes_needed:\n            C[i] = -1\n        else:\n            C[i] = votes_needed - A[i]\n    \n    return ' '.join(map(str, C))\n\n# Example usage:\n# N = 5\n# M = 2\n# K = 16\n# A = [3, 1, 4, 1, 5]\n# print(min_additional_votes(N, M, K, A))  # Output: 2 -1 1 -1 0\n```"}
{"task_id": "3563", "code": "def maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_columns = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_columns:\n                selected_columns.add(value)\n                max_score += value\n                break\n    \n    return max_score", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_columns = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_columns:\n                selected_columns.add(value)\n                max_score += value\n                break\n    \n    return max_score\n```"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    n = len(damage)\n    time_to_defeat = [health[i] // power + (1 if health[i] % power != 0 else 0) for i in range(n)]\n    enemies = sorted(range(n), key=lambda i: time_to_defeat[i], reverse=True)\n    total_damage = 0\n    for enemy in enemies:\n        total_damage += time_to_defeat[enemy] * damage[enemy]\n    return total_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    time_to_defeat = [health[i] // power + (1 if health[i] % power != 0 else 0) for i in range(n)]\n    enemies = sorted(range(n), key=lambda i: time_to_defeat[i], reverse=True)\n    total_damage = 0\n    for enemy in enemies:\n        total_damage += time_to_defeat[enemy] * damage[enemy]\n    return total_damage\n```"}
{"task_id": "abc367_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [0] * (1 << N)\n    for i in range(N):\n        dp[1 << i] = A[i]\n    \n    # Fill DP table\n    for mask in range(1, 1 << N):\n        dp[mask] = dp[mask ^ (mask & -mask)] ^ A[(mask & -mask).bit_length() - 1]\n    \n    # Calculate the sum of scores\n    total_sum = 0\n    for mask in range(1, 1 << N):\n        if bin(mask).count('1') % M == 0:\n            total_sum += pow(dp[mask], K, MOD)\n            total_sum %= MOD\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [0] * (1 << N)\n    for i in range(N):\n        dp[1 << i] = A[i]\n    \n    # Fill DP table\n    for mask in range(1, 1 << N):\n        dp[mask] = dp[mask ^ (mask & -mask)] ^ A[(mask & -mask).bit_length() - 1]\n    \n    # Calculate the sum of scores\n    total_sum = 0\n    for mask in range(1, 1 << N):\n        if bin(mask).count('1') % M == 0:\n            total_sum += pow(dp[mask], K, MOD)\n            total_sum %= MOD\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc368_e", "code": "def min_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X1 = int(data[index + 2])\n    index += 3\n    \n    trains = []\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        index += 4\n        trains.append((A, B, S, T))\n    \n    # Sort trains by departure time\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize delays\n    X = [0] * M\n    \n    # Process each train\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(i - 1, -1, -1):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                required_delay = max(0, S_j - T_i)\n                if X[j] + required_delay < X[i]:\n                    X[i] = X[j] + required_delay\n                    break\n    \n    # Print the result\n    print(' '.join(map(str, X[1:])))\n    \nmin_delays()", "passed": false, "raw_code": "```python\ndef min_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X1 = int(data[index + 2])\n    index += 3\n    \n    trains = []\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        index += 4\n        trains.append((A, B, S, T))\n    \n    # Sort trains by departure time\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize delays\n    X = [0] * M\n    \n    # Process each train\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(i - 1, -1, -1):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                required_delay = max(0, S_j - T_i)\n                if X[j] + required_delay < X[i]:\n                    X[i] = X[j] + required_delay\n                    break\n    \n    # Print the result\n    print(' '.join(map(str, X[1:])))\n    \nmin_delays()\n```"}
{"task_id": "abc370_f", "code": "def max_min_weight(N, K, A):\n    # Step 1: Calculate prefix sums\n    prefix = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix[i] = prefix[i - 1] + A[i - 1]\n    \n    # Step 2: Binary search for the maximum possible minimum weight\n    low, high = max(A), prefix[-1]\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid, N, K, A, prefix):\n            low = mid\n        else:\n            high = mid - 1\n    \n    # Step 3: Find the number of uncut cut lines\n    uncut_cut_lines = 0\n    current_sum = 0\n    for i in range(1, N + 1):\n        current_sum += A[i - 1]\n        if current_sum >= low:\n            current_sum = 0", "passed": false, "raw_code": "def max_min_weight(N, K, A):\n    # Step 1: Calculate prefix sums\n    prefix = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix[i] = prefix[i - 1] + A[i - 1]\n    \n    # Step 2: Binary search for the maximum possible minimum weight\n    low, high = max(A), prefix[-1]\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid, N, K, A, prefix):\n            low = mid\n        else:\n            high = mid - 1\n    \n    # Step 3: Find the number of uncut cut lines\n    uncut_cut_lines = 0\n    current_sum = 0\n    for i in range(1, N + 1):\n        current_sum += A[i - 1]\n        if current_sum >= low:\n            current_sum = 0"}
{"task_id": "abc366_g", "code": "def can_assign_numbers(N, M, edges):\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # DFS function to try assigning numbers\n    def dfs(node, parent, assigned):\n        if node == N + 1:\n            return True\n        for num in range(1, 2**60):\n            valid = True\n            for neighbor in adj_list[node]:\n                if neighbor != parent and assigned[neighbor] ^ num != 0:\n                    valid = False\n                    break\n            if valid:\n                assigned[node] = num\n                if dfs(node + 1, node, assigned):\n                    return True\n                assigned[node] = 0\n        return False\n\n    # Initialize assignment array\n    assigned = [0] * (N + 1)\n\n    # Start DFS from node 1\n    if dfs(1, -1, assigned):\n        return 'Yes\\n' + ' '.join(map(str, assigned[1:]))\n    else:\n        return 'No'\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n\n# Print the result\nprint(can_assign_numbers(N, M, edges))", "passed": false, "raw_code": "def can_assign_numbers(N, M, edges):\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # DFS function to try assigning numbers\n    def dfs(node, parent, assigned):\n        if node == N + 1:\n            return True\n        for num in range(1, 2**60):\n            valid = True\n            for neighbor in adj_list[node]:\n                if neighbor != parent and assigned[neighbor] ^ num != 0:\n                    valid = False\n                    break\n            if valid:\n                assigned[node] = num\n                if dfs(node + 1, node, assigned):\n                    return True\n                assigned[node] = 0\n        return False\n\n    # Initialize assignment array\n    assigned = [0] * (N + 1)\n\n    # Start DFS from node 1\n    if dfs(1, -1, assigned):\n        return 'Yes\\n' + ' '.join(map(str, assigned[1:]))\n    else:\n        return 'No'\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n\n# Print the result\nprint(can_assign_numbers(N, M, edges))"}
{"task_id": "3527", "code": "from collections import deque, defaultdict\n\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Extend the list to handle circular nature\n    groups = defaultdict(int)\n    dq = deque()\n    result = []\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n        return count\n    \n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            colors[index] = color\n            colors[index + n] = color\n    \n    return result", "passed": false, "raw_code": "```python\nfrom collections import deque, defaultdict\n\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Extend the list to handle circular nature\n    groups = defaultdict(int)\n    dq = deque()\n    result = []\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n        return count\n    \n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            colors[index] = color\n            colors[index + n] = color\n    \n    return result\n```"}
{"task_id": "abc372_g", "code": "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef binary_search(A, B, C, y):\n    left, right = 0, C\n    while left < right:\n        mid = (left + right) // 2\n        if A * mid + B * y < C:\n            left = mid + 1\n        else:\n            right = mid\n    return left - 1\n\ndef solve_case(N, A, B, C):\n    count = 0\n    for i in range(N):\n        x = binary_search(A[i], B[i], C[i], 1)\n        if x >= 1:\n            count += 1\n    return count\n\ndef main():\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        results.append(solve_case(N, A, B, C))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef binary_search(A, B, C, y):\n    left, right = 0, C\n    while left < right:\n        mid = (left + right) // 2\n        if A * mid + B * y < C:\n            left = mid + 1\n        else:\n            right = mid\n    return left - 1\n\ndef solve_case(N, A, B, C):\n    count = 0\n    for i in range(N):\n        x = binary_search(A[i], B[i], C[i], 1)\n        if x >= 1:\n            count += 1\n    return count\n\ndef main():\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        results.append(solve_case(N, A, B, C))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc368_d", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef lca(tree, u, v):\n    if u not in tree or v not in tree:\n        return None\n    if u == v:\n        return u\n    stack = [(u, set())]\n    while stack:\n        node, ancestors = stack.pop()\n        ancestors.add(node)\n        for neighbor in tree[node]:\n            if neighbor not in ancestors:\n                stack.append((neighbor, ancestors.copy()))\n        if v in ancestors:\n            return node\n\ndef min_vertices_to_include_all(tree, k_vertices):\n    n = len(tree)\n    dp = [[None] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = i\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = lca(tree, dp[i][i + length // 2], dp[i + length // 2][j])\n    result = float('inf')\n    for i in range(k_vertices):\n        for j in range(i + 1, k_vertices):\n            result = min(result, dp[min(k_vertices - 1, i)][max(k_vertices - 1, j)])\n    return result + 1\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = data[2:2*n]\n    vertices = list(map(int, data[2*n+1:]))\n    tree = defaultdict(list)\n    for i in range(n - 1):\n        u = int(edges[2*i]) - 1\n        v = int(edges[2*i + 1]) - 1\n        tree[u].append(v)\n        tree[v].append(u)\n    print(min_vertices_to_include_all(tree, k))\n", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict, deque\n\ndef lca(tree, u, v):\n    if u not in tree or v not in tree:\n        return None\n    if u == v:\n        return u\n    stack = [(u, set())]\n    while stack:\n        node, ancestors = stack.pop()\n        ancestors.add(node)\n        for neighbor in tree[node]:\n            if neighbor not in ancestors:\n                stack.append((neighbor, ancestors.copy()))\n        if v in ancestors:\n            return node\n\ndef min_vertices_to_include_all(tree, k_vertices):\n    n = len(tree)\n    dp = [[None] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = i\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = lca(tree, dp[i][i + length // 2], dp[i + length // 2][j])\n    result = float('inf')\n    for i in range(k_vertices):\n        for j in range(i + 1, k_vertices):\n            result = min(result, dp[min(k_vertices - 1, i)][max(k_vertices - 1, j)])\n    return result + 1\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = data[2:2*n]\n    vertices = list(map(int, data[2*n+1:]))\n    tree = defaultdict(list)\n    for i in range(n - 1):\n        u = int(edges[2*i]) - 1\n        v = int(edges[2*i + 1]) - 1\n        tree[u].append(v)\n        tree[v].append(u)\n    print(min_vertices_to_include_all(tree, k))\n"}
{"task_id": "3575", "code": "def maxSubsequenceValue(nums, k):\n    nums.sort()\n    n = len(nums)\n    max_value = 0\n    \n    for i in range(k):\n        left_or = 0\n        right_or = 0\n        \n        for j in range(i, k):\n            left_or |= nums[j]\n        \n        for j in range(n - k + i, n):\n            right_or |= nums[j]\n        \n        max_value = max(max_value, left_or ^ right_or)\n    \n    return max_value", "passed": false, "raw_code": "```python\ndef maxSubsequenceValue(nums, k):\n    nums.sort()\n    n = len(nums)\n    max_value = 0\n    \n    for i in range(k):\n        left_or = 0\n        right_or = 0\n        \n        for j in range(i, k):\n            left_or |= nums[j]\n        \n        for j in range(n - k + i, n):\n            right_or |= nums[j]\n        \n        max_value = max(max_value, left_or ^ right_or)\n    \n    return max_value\n```"}
{"task_id": "abc368_g", "code": "i", "passed": false, "raw_code": "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef build_segment_tree(arr):\n    n = len(arr)\n    tree = [0] * (4 * n)\n    \n    def build(i, start, end):\n        if start == end:\n            tree[i] = arr[start]\n        else:\n            mid = (start + end) // 2\n            tree[i] = max(build(2 * i + 1, start, mid), build(2 * i + 2, mid + 1, end))\n        return tree[i]\n    \n    build(0, 0, n - 1)\n    return tree\n\ndef update_segment_tree(tree, index, value, start, end, pos):\n    if start == end:\n        tree[pos] = value\n    else:\n        mid = (start + end) // 2\n        if index <= mid:\n            update_segment_tree(tree, index, value, start, mid, 2 * pos + 1)\n        else:\n            update_segment_tree(tree, index, value, mid + 1, end, 2 * pos + 2)\n        tree[pos] = max(tree[2 * pos + 1], tree[2 * pos + 2])\n\ndef query_segment_tree(tree, start, end, left, right, pos):\n    if left > end or right < start:\n        return float('-inf')\n    if left <= start and end <= right:\n        return tree[pos]\n    mid = (start + end) // 2\n    return max(query_segment_tree(tree, start, mid, left, right, 2 * pos + 1),\n               query_segment_tree(tree, mid + 1, end, left, right, 2 * pos + 2))\n\nN = int(data[0])\nA = list(map(int, data[1:N+1]))\nB = list(map(int, data[N+1:2*N+1]))\n\nsum_tree_A = build_segment_tree(A)\nproduct_tree_B = build_segment_tree(B)\n\nindex = 2 * N + 1\nQ = int(data[index])\nqueries = data[index+1:index+1+Q*3]\n\nresults = []\n\nfor i in range(Q):\n    query_type = int(queries[i*3])\n    if query_type == 1:\n        idx = int(queries[i*3+1]) - 1\n        val = int(queries[i*3+2])\n        A[idx] = val\n        update_segment_tree(sum_tree_A, idx, val, 0, N-1, idx)\n    elif query_type == 2:\n        idx = int(queries[i*3+1]) - 1\n        val = int(queries[i*3+2])\n        B[idx] = val\n        update_segment_tree(product_tree_B, idx, val, 0, N"}
{"task_id": "3552", "code": "def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n        return \"\"\n    \n    if n == 2:\n        for i in range(99, 9, -1):\n            if i % k == 0 and is_palindrome(i):\n                return str(i)\n        return \"\"\n    \n    half_length = (n + 1) // 2\n    for i in range(10**(half_length) - 1, 10**(half_length - 1) - 1, -1):\n        num = int(str(i) + str(i)[::-1] if n % 2 == 0 else str(i)[:-1] + str(i)[::-1])\n        if num % k == 0:\n            return str(num)\n    \n    return \"\"", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n        return \"\"\n    \n    if n == 2:\n        for i in range(99, 9, -1):\n            if i % k == 0 and is_palindrome(i):\n                return str(i)\n        return \"\"\n    \n    half_length = (n + 1) // 2\n    for i in range(10**(half_length) - 1, 10**(half_length - 1) - 1, -1):\n        num = int(str(i) + str(i)[::-1] if n % 2 == 0 else str(i)[:-1] + str(i)[::-1])\n        if num % k == 0:\n            return str(num)\n    \n    return \"\"\n```"}
{"task_id": "arc181_d", "code": "d", "passed": false, "raw_code": "```python\ndef update(bit, idx, val, n):\n    while idx <= n:\n        bit[idx] += val\n        idx += idx & -idx\n\ndef query(bit, idx):\n    result = 0\n    while idx > 0:\n        result += bit[idx]\n        idx -= idx & -idx\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    bit = [0] * (N + 1)\n    inv_count = 0\n    \n    for i in range(N):\n        inv_count += i - query(bit, P[i])\n        update(bit, P[i], 1, N)\n    \n    print(inv_count)\n    \n    for a in A:\n        idx = P.index(a)\n        inv_count -= idx - query(bit, a)\n        inv_count -= (N - idx - 1) - (query(bit, N) - query(bit, a))\n        update(bit, a, -1, N)\n        P[idx] = N + 1\n        idx = P.index(a)\n        inv_count += idx - query(bit, a)\n        inv_count += (N - idx - 1) - (query(bit, N) - query(bit, a))\n        update(bit, a, 1, N)\n        print(inv_count)\n\nsolve()"}
{"task_id": "3551", "code": "class TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[bit] is None:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if node.children[alt_bit] is not None:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    xor_prefix = [0] * (n + 1)\n    for i in range(n):\n        xor_prefix[i + 1] = xor_prefix[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    for l, r in queries:\n        xor_val = xor_prefix[r + 1] ^ xor_prefix[l]\n        trie.insert(xor_val)\n        result.append(trie.find_max_xor(xor_val))\n    \n    return result", "passed": false, "raw_code": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if node.children[bit] is None:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def find_max_xor(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if node.children[alt_bit] is not None:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    xor_prefix = [0] * (n + 1)\n    for i in range(n):\n        xor_prefix[i + 1] = xor_prefix[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    for l, r in queries:\n        xor_val = xor_prefix[r + 1] ^ xor_prefix[l]\n        trie.insert(xor_val)\n        result.append(trie.find_max_xor(xor_val))\n    \n    return result\n```"}
{"task_id": "abc369_e", "code": "import heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start, end):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        \n        if current_dist > dist[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            \n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    return dist[end]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    graph = defaultdict(list)\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        t = int(data[index + 2])\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n        index += 3\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        K = int(data[index])\n        bridges = list(map(int, data[index + 1:index + 1 + K]))\n        index += 1 + K\n        \n        modified_graph = defaultdict(list)\n        for u, v, t in graph.values():\n            if (u + 1, v + 1) in bridges or (v + 1, u + 1) in bridges:\n                modified_graph[u].append((v, t))\n                modified_graph[v].append((u, t))\n        \n        result = dijkstra(modified_graph, 0, N - 1)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport heapq\nfrom collections import defaultdict\n\ndef dijkstra(graph, start, end):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        \n        if current_dist > dist[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            \n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    return dist[end]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    graph = defaultdict(list)\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        t = int(data[index + 2])\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n        index += 3\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        K = int(data[index])\n        bridges = list(map(int, data[index + 1:index + 1 + K]))\n        index += 1 + K\n        \n        modified_graph = defaultdict(list)\n        for u, v, t in graph.values():\n            if (u + 1, v + 1) in bridges or (v + 1, u + 1) in bridges:\n                modified_graph[u].append((v, t))\n                modified_graph[v].append((u, t))\n        \n        result = dijkstra(modified_graph, 0, N - 1)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc183_d", "code": "import sys\nimport heapq\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    edges = []\n    index = 1\n    for i in range(N - 1):\n        A = int(data[index])\n        B = int(data[index + 1])\n        edges.append((A, B))\n        index += 2\n    return N, edges\n\ndef find_leaves(N, edges):\n    degree = [0] * (N + 1)\n    for A, B in edges:\n        degree[A] += 1\n        degree[B] += 1\n    leaves = [i for i in range(1, N + 1) if degree[i] == 1]\n    return leaves\n\ndef find_max_distance_leaf(leaves, edges):\n    max_distance = 0\n    max_leaf = None\n    for leaf in leaves:\n        for other_leaf in leaves:\n            if leaf != other_leaf:\n                distance = 0\n                visited = set()\n                stack = [(leaf, 0)]\n                while stack:\n                    current, dist = stack.pop()\n                    if current == other_leaf:\n                        distance = dist\n                        break\n                    if current not in visited:\n                        visited.add(current)\n                        for A, B in edges:\n                            if A == current:\n                                stack.append((B, dist + 1))\n                            elif B == current:\n                                stack.append((A, dist + 1))\n                if distance > max_distance:\n                    max_distance = distance\n                    max_leaf = (leaf, other_leaf)\n    return max_leaf\n\ndef main():\n    N, edges = read_input()\n    leaves = find_leaves(N, edges)\n    result = []\n    while len(leaves) > 0:\n        leaf1, leaf2 = find_max_distance_leaf(leaves, edges)\n        result.append((leaf1, leaf2))\n        leaves.remove(leaf1)\n        leaves.remove(leaf2)\n    for leaf1, leaf2 in result:\n        print(leaf1, leaf2)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nimport heapq\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    edges = []\n    index = 1\n    for i in range(N - 1):\n        A = int(data[index])\n        B = int(data[index + 1])\n        edges.append((A, B))\n        index += 2\n    return N, edges\n\ndef find_leaves(N, edges):\n    degree = [0] * (N + 1)\n    for A, B in edges:\n        degree[A] += 1\n        degree[B] += 1\n    leaves = [i for i in range(1, N + 1) if degree[i] == 1]\n    return leaves\n\ndef find_max_distance_leaf(leaves, edges):\n    max_distance = 0\n    max_leaf = None\n    for leaf in leaves:\n        for other_leaf in leaves:\n            if leaf != other_leaf:\n                distance = 0\n                visited = set()\n                stack = [(leaf, 0)]\n                while stack:\n                    current, dist = stack.pop()\n                    if current == other_leaf:\n                        distance = dist\n                        break\n                    if current not in visited:\n                        visited.add(current)\n                        for A, B in edges:\n                            if A == current:\n                                stack.append((B, dist + 1))\n                            elif B == current:\n                                stack.append((A, dist + 1))\n                if distance > max_distance:\n                    max_distance = distance\n                    max_leaf = (leaf, other_leaf)\n    return max_leaf\n\ndef main():\n    N, edges = read_input()\n    leaves = find_leaves(N, edges)\n    result = []\n    while len(leaves) > 0:\n        leaf1, leaf2 = find_max_distance_leaf(leaves, edges)\n        result.append((leaf1, leaf2))\n        leaves.remove(leaf1)\n        leaves.remove(leaf2)\n    for leaf1, leaf2 in result:\n        print(leaf1, leaf2)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc183_b", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef can_transform(A, B, K):\n    n = len(A)\n    visited = [False] * n\n    components = []\n    \n    def bfs(start):\n        queue = deque([start])\n        component = []\n        while queue:\n            node = queue.popleft()\n            if not visited[node]:\n                visited[node] = True\n                component.append(node)\n                for neighbor in range(max(0, node - K), min(n, node + K + 1)):\n                    if not visited[neighbor] and abs(node - neighbor) <= K:\n                        queue.append(neighbor)\n        return component\n    \n    for i in range(n):\n        if not visited[i]:\n            component = bfs(i)\n            components.append(component)\n    \n    for component in components:\n        component_A = [A[i] for i in component]\n        component_B = [B[i] for i in component]\n        if sorted(component_A) != sorted(component_B):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_transform(A, B, K):\n    n = len(A)\n    visited = [False] * n\n    components = []\n    \n    def bfs(start):\n        queue = deque([start])\n        component = []\n        while queue:\n            node = queue.popleft()\n            if not visited[node]:\n                visited[node] = True\n                component.append(node)\n                for neighbor in range(max(0, node - K), min(n, node + K + 1)):\n                    if not visited[neighbor] and abs(node - neighbor) <= K:\n                        queue.append(neighbor)\n        return component\n    \n    for i in range(n):\n        if not visited[i]:\n            component = bfs(i)\n            components.append(component)\n    \n    for component in components:\n        component_A = [A[i] for i in component]\n        component_B = [B[i] for i in component]\n        if sorted(component_A) != sorted(component_B):\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3560", "code": "from collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\n@lru_cache(None)\ndef max_moves(kx, ky, positions):\n    if not positions:\n        return 0\n    \n    max_moves_alice = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = tuple(pos for j, pos in enumerate(positions) if j != i)\n        max_moves_bob = max_moves(px, py, remaining_positions)\n        max_moves_alice = max(max_moves_alice, moves + max_moves_bob)\n    \n    return max_moves_alice\n\ndef knight_game(kx, ky, positions):\n    return max_moves(kx, ky, tuple(tuple(pos) for pos in positions))\n\n# Example usage:\nprint(knight_game(1, 1, [(0, 0)]))  # Output: 4\nprint(knight_game(0, 2, [(1, 1), (2, 2), (3, 3)]))  # Output: 8\nprint(knight_game(0, 0, [(1, 2), (2, 4)]))  # Output: 3", "passed": false, "raw_code": "```python\nfrom collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\n@lru_cache(None)\ndef max_moves(kx, ky, positions):\n    if not positions:\n        return 0\n    \n    max_moves_alice = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = tuple(pos for j, pos in enumerate(positions) if j != i)\n        max_moves_bob = max_moves(px, py, remaining_positions)\n        max_moves_alice = max(max_moves_alice, moves + max_moves_bob)\n    \n    return max_moves_alice\n\ndef knight_game(kx, ky, positions):\n    return max_moves(kx, ky, tuple(tuple(pos) for pos in positions))\n\n# Example usage:\nprint(knight_game(1, 1, [(0, 0)]))  # Output: 4\nprint(knight_game(0, 2, [(1, 1), (2, 2), (3, 3)]))  # Output: 8\nprint(knight_game(0, 0, [(1, 2), (2, 4)]))  # Output: 3\n```"}
{"task_id": "3550", "code": "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero cells\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    max_sum = float('-inf')\n    \n    # Iterate over all combinations of three rows and three columns\n    for r1 in non_zero_rows:\n        for r2 in non_zero_rows:\n            if r1 == r2:\n                continue\n            for r3 in non_zero_rows:\n                if r1 == r3 or r2 == r3:\n                    continue\n                \n                for c1 in non_zero_cols:\n                    for c2 in non_zero_cols:\n                        if c1 == c2:\n                            continue\n                        for c3 in non_zero_cols:\n                            if c1 == c3 or c2 == c3:\n                                continue\n                            \n                            current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                            max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "passed": false, "raw_code": "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero cells\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    max_sum = float('-inf')\n    \n    # Iterate over all combinations of three rows and three columns\n    for r1 in non_zero_rows:\n        for r2 in non_zero_rows:\n            if r1 == r2:\n                continue\n            for r3 in non_zero_rows:\n                if r1 == r3 or r2 == r3:\n                    continue\n                \n                for c1 in non_zero_cols:\n                    for c2 in non_zero_cols:\n                        if c1 == c2:\n                            continue\n                        for c3 in non_zero_cols:\n                            if c1 == c3 or c2 == c3:\n                                continue\n                            \n                            current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"}
{"task_id": "abc370_g", "code": "def sum_of_divisors(n):\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\nMOD = 998244353\n\ndef count_sequences(N, M):\n    max_val = int(N**(1/M))\n    dp = [[0] * (max_val + 1) for _ in range(M + 1)]\n    \n    # Base case: single element sequences\n    for i in range(1, max_val + 1):\n        if is_good_integer(i):\n            dp[1][i] = 1\n    \n    # Fill the DP table\n    for length in range(2, M + 1):\n        for num in range(1, max_val + 1):\n            if is_good_integer(num):\n                for prev_num in range(1, max_val + 1):\n                    dp[length][num] = (dp[length][num] + dp[length-1][prev_num]) % MOD\n    \n    # Sum up all valid sequences of length M\n    result = sum(dp[M]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Get the result\nresult = count_sequences(N, M)\n\n# Print the result\nprint(result)", "passed": false, "raw_code": "```python\ndef sum_of_divisors(n):\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\nMOD = 998244353\n\ndef count_sequences(N, M):\n    max_val = int(N**(1/M))\n    dp = [[0] * (max_val + 1) for _ in range(M + 1)]\n    \n    # Base case: single element sequences\n    for i in range(1, max_val + 1):\n        if is_good_integer(i):\n            dp[1][i] = 1\n    \n    # Fill the DP table\n    for length in range(2, M + 1):\n        for num in range(1, max_val + 1):\n            if is_good_integer(num):\n                for prev_num in range(1, max_val + 1):\n                    dp[length][num] = (dp[length][num] + dp[length-1][prev_num]) % MOD\n    \n    # Sum up all valid sequences of length M\n    result = sum(dp[M]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Get the result\nresult = count_sequences(N, M)\n\n# Print the result\nprint(result)\n```"}
{"task_id": "arc183_c", "code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(1 << N)]\n    dp[0][0] = 1\n\n    for mask in range(1 << N):\n        for i in range(N):\n            if mask & (1 << i) == 0:\n                new_mask = mask | (1 << i)\n                max_val = -1\n                start = -1\n                end = -1\n                for j in range(N):\n                    if new_mask & (1 << j) != 0:\n                        if start == -1 or j < start:\n                            start = j\n                        if end == -1 or j > end:\n                            end = j\n                        max_val = max(max_val, j + 1)\n                for cond in conditions:\n                    l, r, x = cond\n                    if start <= x - 1 <= end and max_val == x:\n                        break\n                else:\n                    dp[new_mask][i] += dp[mask][start]\n                    dp[new_mask][i] %= MOD\n\n    return sum(dp[(1 << N) - 1]) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nconditions = []\ni = 2\nwhile i < len(data):\n    l = int(data[i])\n    r = int(data[i + 1])\n    x = int(data[i + 2])\n    conditions.append((l, r, x))\n    i += 3\n\nprint(count_valid_permutations(n, m, conditions))", "passed": false, "raw_code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(1 << N)]\n    dp[0][0] = 1\n\n    for mask in range(1 << N):\n        for i in range(N):\n            if mask & (1 << i) == 0:\n                new_mask = mask | (1 << i)\n                max_val = -1\n                start = -1\n                end = -1\n                for j in range(N):\n                    if new_mask & (1 << j) != 0:\n                        if start == -1 or j < start:\n                            start = j\n                        if end == -1 or j > end:\n                            end = j\n                        max_val = max(max_val, j + 1)\n                for cond in conditions:\n                    l, r, x = cond\n                    if start <= x - 1 <= end and max_val == x:\n                        break\n                else:\n                    dp[new_mask][i] += dp[mask][start]\n                    dp[new_mask][i] %= MOD\n\n    return sum(dp[(1 << N) - 1]) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nconditions = []\ni = 2\nwhile i < len(data):\n    l = int(data[i])\n    r = int(data[i + 1])\n    x = int(data[i + 2])\n    conditions.append((l, r, x))\n    i += 3\n\nprint(count_valid_permutations(n, m, conditions))"}
{"task_id": "arc182_c", "code": "def sum_of_divisors_modulo(N, M):\n    MOD = 998244353\n    \n    # Precompute the number of divisors for each number up to M\n    max_val = M * M\n    divisors_count = [0] * (max_val + 1)\n    \n    for i in range(1, max_val + 1):\n        for j in range(i, max_val + 1, i):\n            divisors_count[j] += 1\n    \n    # Calculate the total sum of divisors for all possible products\n    total_sum = 0\n    for k in range(1, M + 1):\n        total_sum += divisors_count[k]\n    \n    # Since there are M^N such sequences, multiply by M^(N-1)\n    total_sum *= pow(M, N - 1, MOD)\n    \n    return total_sum % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(sum_of_divisors_modulo(N, M))", "passed": false, "raw_code": "```python\ndef sum_of_divisors_modulo(N, M):\n    MOD = 998244353\n    \n    # Precompute the number of divisors for each number up to M\n    max_val = M * M\n    divisors_count = [0] * (max_val + 1)\n    \n    for i in range(1, max_val + 1):\n        for j in range(i, max_val + 1, i):\n            divisors_count[j] += 1\n    \n    # Calculate the total sum of divisors for all possible products\n    total_sum = 0\n    for k in range(1, M + 1):\n        total_sum += divisors_count[k]\n    \n    # Since there are M^N such sequences, multiply by M^(N-1)\n    total_sum *= pow(M, N - 1, MOD)\n    \n    return total_sum % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(sum_of_divisors_modulo(N, M))\n```"}
{"task_id": "3583", "code": "from math import gcd\nfrom collections import defaultdict\nfrom typing import List\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Precompute GCD counts for all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    # Sort the unique GCD values\n    sorted_gcds = sorted(gcd_counts.keys())\n    \n    # Calculate the prefix sum of GCD counts\n    prefix_sum = [0]\n    for g in sorted_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_counts[g])\n    \n    # Answer each query\n    answer = []\n    for q in queries:\n        idx = q + 1\n        for i, ps in enumerate(prefix_sum):\n            if ps >= idx:\n                answer.append(sorted_gcds[i - 1])\n                break\n    \n    return answer", "passed": false, "raw_code": "```python\nfrom math import gcd\nfrom collections import defaultdict\nfrom typing import List\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Precompute GCD counts for all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    # Sort the unique GCD values\n    sorted_gcds = sorted(gcd_counts.keys())\n    \n    # Calculate the prefix sum of GCD counts\n    prefix_sum = [0]\n    for g in sorted_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_counts[g])\n    \n    # Answer each query\n    answer = []\n    for q in queries:\n        idx = q + 1\n        for i, ps in enumerate(prefix_sum):\n            if ps >= idx:\n                answer.append(sorted_gcds[i - 1])\n                break\n    \n    return answer\n```"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    def dfs(x, y):\n        if (x, y) not in memo:\n            memo[(x, y)] = 1\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(coords) and 0 <= ny < len(coords[0]) and coords[nx][ny] > coords[x][y]:\n                    memo[(x, y)] = max(memo[(x, y)], 1 + dfs(nx, ny))\n        return memo[(x, y)]\n\n    coords = sorted((x, y) for x, y in coordinates)\n    memo = {}\n    max_path = 0\n    \n    for i, (x, y) in enumerate(coords):\n        if i == k:\n            max_path = max(max_path, dfs(i, 0))\n    \n    return max_path", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    def dfs(x, y):\n        if (x, y) not in memo:\n            memo[(x, y)] = 1\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(coords) and 0 <= ny < len(coords[0]) and coords[nx][ny] > coords[x][y]:\n                    memo[(x, y)] = max(memo[(x, y)], 1 + dfs(nx, ny))\n        return memo[(x, y)]\n\n    coords = sorted((x, y) for x, y in coordinates)\n    memo = {}\n    max_path = 0\n    \n    for i, (x, y) in enumerate(coords):\n        if i == k:\n            max_path = max(max_path, dfs(i, 0))\n    \n    return max_path\n```"}
{"task_id": "3548", "code": "from itertools import permutations, combinations_with_replacement\n\ndef count_good_integers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def can_form_palindrome(freq):\n        odd_count = sum(1 for v in freq.values() if v % 2 != 0)\n        return odd_count <= 1\n    \n    def count_combinations(digits, length):\n        count = 0\n        for comb in combinations_with_replacement(digits, length):\n            freq = {}\n            for d in comb:\n                if d in freq:\n                    freq[d] += 1\n                else:\n                    freq[d] = 1\n            if can_form_palindrome(freq) and int(''.join(map(str, comb))) % k == 0:\n                count += len(set(permutations(comb)))\n        return count\n    \n    digits = list(range(1, 10))\n    total_count = 0\n    for i in range(1, n + 1):\n        total_count += count_combinations(digits, i)\n    \n    return total_count\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468", "passed": false, "raw_code": "```python\nfrom itertools import permutations, combinations_with_replacement\n\ndef count_good_integers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def can_form_palindrome(freq):\n        odd_count = sum(1 for v in freq.values() if v % 2 != 0)\n        return odd_count <= 1\n    \n    def count_combinations(digits, length):\n        count = 0\n        for comb in combinations_with_replacement(digits, length):\n            freq = {}\n            for d in comb:\n                if d in freq:\n                    freq[d] += 1\n                else:\n                    freq[d] = 1\n            if can_form_palindrome(freq) and int(''.join(map(str, comb))) % k == 0:\n                count += len(set(permutations(comb)))\n        return count\n    \n    digits = list(range(1, 10))\n    total_count = 0\n    for i in range(1, n + 1):\n        total_count += count_combinations(digits, i)\n    \n    return total_count\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468\n```"}
{"task_id": "arc182_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Step 1: Compute the values of (Ck + A_i) % M for k = 0, 1, ..., M-1\n    mod_values = []\n    for k in range(M):\n        min_val = float('inf')\n        for a in A:\n            val = (C * k + a) % M\n            if val < min_val:\n                min_val = val\n        mod_values.append(min_val)\n    \n    # Step 2: Sum these minimum values for all k up to K\n    total_sum = 0\n    for k in range(K):\n        total_sum += mod_values[k % M]\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Step 1: Compute the values of (Ck + A_i) % M for k = 0, 1, ..., M-1\n    mod_values = []\n    for k in range(M):\n        min_val = float('inf')\n        for a in A:\n            val = (C * k + a) % M\n            if val < min_val:\n                min_val = val\n        mod_values.append(min_val)\n    \n    # Step 2: Sum these minimum values for all k up to K\n    total_sum = 0\n    for k in range(K):\n        total_sum += mod_values[k % M]\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for q in range(1, Q + 1):\n        p = P[q - 1]\n        v = V[q - 1]\n        \n        new_dp = [0] * (N + 1)\n        max_val = 0\n        \n        for i in range(1, N + 1):\n            if i >= p:\n                max_val = max(max_val, v)\n            \n            if i < p:\n                new_dp[i] = dp[q - 1][i]\n            else:\n                new_dp[i] = (new_dp[i - 1] + dp[q - 1][p - 1]) % MOD\n        \n        dp[q] = new_dp\n    \n    return sum(dp[-1]) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\n\nfor i in range(Q):\n    p = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    P.append(p)\n    V.append(v)\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)", "passed": false, "raw_code": "```python\ndef count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for q in range(1, Q + 1):\n        p = P[q - 1]\n        v = V[q - 1]\n        \n        new_dp = [0] * (N + 1)\n        max_val = 0\n        \n        for i in range(1, N + 1):\n            if i >= p:\n                max_val = max(max_val, v)\n            \n            if i < p:\n                new_dp[i] = dp[q - 1][i]\n            else:\n                new_dp[i] = (new_dp[i - 1] + dp[q - 1][p - 1]) % MOD\n        \n        dp[q] = new_dp\n    \n    return sum(dp[-1]) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\n\nfor i in range(Q):\n    p = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    P.append(p)\n    V.append(v)\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)\n```"}
{"final_accuracy": "0.00%"}
