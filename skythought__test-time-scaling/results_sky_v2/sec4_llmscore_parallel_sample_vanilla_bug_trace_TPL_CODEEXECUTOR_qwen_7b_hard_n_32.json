{"difficulty": "hard", "num_threads": 32, "temperature": 0.7, "n": 32, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_vanilla_bug_trace_TPL_CODEEXECUTOR_qwen_7b_hard_n_32.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "passed": false, "raw_code": "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```"}
{"task_id": "abc367_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = sorted(A[l_i:r_i + 1])\n        subseq_B = sorted(B[L_i:R_i + 1])\n        \n        if subseq_A == subseq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = sorted(A[l_i:r_i + 1])\n        subseq_B = sorted(B[L_i:R_i + 1])\n        \n        if subseq_A == subseq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nmain()\n```"}
{"task_id": "abc372_e", "code": "import heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = {i: [] for i in range(1, N + 1)}\n    connected_sets = {i: set() for i in range(1, N + 1)}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            \n            if u not in connected_sets[v]:\n                connected_sets[u].add(v)\n                connected_sets[v].add(u)\n                \n                adj_list[u].append(v)\n                adj_list[v].append(u)\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            index += 3\n            \n            if len(connected_sets[v]) < k:\n                results.append(-1)\n            else:\n                heap = []\n                for neighbor in connected_sets[v]:\n                    heapq.heappush(heap, neighbor)\n                    if len(heap) > k:\n                        heapq.heappop(heap)\n                \n                results.append(heap[0])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = {i: [] for i in range(1, N + 1)}\n    connected_sets = {i: set() for i in range(1, N + 1)}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            \n            if u not in connected_sets[v]:\n                connected_sets[u].add(v)\n                connected_sets[v].add(u)\n                \n                adj_list[u].append(v)\n                adj_list[v].append(u)\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            index += 3\n            \n            if len(connected_sets[v]) < k:\n                results.append(-1)\n            else:\n                heap = []\n                for neighbor in connected_sets[v]:\n                    heapq.heappush(heap, neighbor)\n                    if len(heap) > k:\n                        heapq.heappop(heap)\n                \n                results.append(heap[0])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3532", "code": "def minTimeToMarkNodes(edges):\n    import collections\n    \n    def bfs_marking_times(node):\n        n = len(graph)\n        visited = [False] * n\n        queue = collections.deque([node])\n        visited[node] = True\n        time = 0\n        \n        while queue:\n            level_size = len(queue)\n            marked_this_level = set()\n            \n            for _ in range(level_size):\n                current = queue.popleft()\n                \n                if current % 2 == 0:\n                    time += 2\n                else:\n                    time += 1\n                \n                for neighbor in graph[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n                        marked_this_level.add(neighbor)\n            \n            # Update marking times for nodes marked this level\n            for marked_node in marked_this_level:\n                marking_times[marked_node] = max(marking_times[marked_node], time)\n        \n        return marking_times\n    \n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    marking_times = [0] * n\n    \n    # Build the graph\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Simulate marking process for each node\n    for i in range(n):\n        marking_times = bfs_marking_times(i)\n    \n    return marking_times", "passed": false, "raw_code": "```python\ndef minTimeToMarkNodes(edges):\n    import collections\n    \n    def bfs_marking_times(node):\n        n = len(graph)\n        visited = [False] * n\n        queue = collections.deque([node])\n        visited[node] = True\n        time = 0\n        \n        while queue:\n            level_size = len(queue)\n            marked_this_level = set()\n            \n            for _ in range(level_size):\n                current = queue.popleft()\n                \n                if current % 2 == 0:\n                    time += 2\n                else:\n                    time += 1\n                \n                for neighbor in graph[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n                        marked_this_level.add(neighbor)\n            \n            # Update marking times for nodes marked this level\n            for marked_node in marked_this_level:\n                marking_times[marked_node] = max(marking_times[marked_node], time)\n        \n        return marking_times\n    \n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    marking_times = [0] * n\n    \n    # Build the graph\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Simulate marking process for each node\n    for i in range(n):\n        marking_times = bfs_marking_times(i)\n    \n    return marking_times\n```"}
{"task_id": "arc181_b", "code": "def check_f_s_t_x_y():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        # Check if X and Y differ only in their last bit\n        if len(X) == len(Y) and X[:-1] == Y[:-1]:\n            results.append(\"No\")\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\ncheck_f_s_t_x_y()", "passed": false, "raw_code": "```python\ndef check_f_s_t_x_y():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        # Check if X and Y differ only in their last bit\n        if len(X) == len(Y) and X[:-1] == Y[:-1]:\n            results.append(\"No\")\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\ncheck_f_s_t_x_y()\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total = 0\n    for i in range(N):\n        distinct_values = set()\n        for j in range(i, N):\n            distinct_values.add(A[j])\n            total += len(distinct_values)\n    \n    print(total)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total = 0\n    for i in range(N):\n        distinct_values = set()\n        for j in range(i, N):\n            distinct_values.add(A[j])\n            total += len(distinct_values)\n    \n    print(total)\n\nmain()\n```"}
{"task_id": "abc371_g", "code": "def smallest_array(N, P, A):\n    target = sorted(A)\n    visited = set()\n    current = A[:]\n    \n    while tuple(current) not in visited:\n        visited.add(tuple(current))\n        current = [current[P[i] - 1] for i in range(N)]\n        \n        if current == target:\n            break\n    \n    print(' '.join(map(str, current)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\nsmallest_array(N, P, A)", "passed": false, "raw_code": "```python\ndef smallest_array(N, P, A):\n    target = sorted(A)\n    visited = set()\n    current = A[:]\n    \n    while tuple(current) not in visited:\n        visited.add(tuple(current))\n        current = [current[P[i] - 1] for i in range(N)]\n        \n        if current == target:\n            break\n    \n    print(' '.join(map(str, current)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\nsmallest_array(N, P, A)\n```"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    n = len(nums)\n    mod = 10**9 + 7\n    \n    def countMonotonic(arr):\n        count = 0\n        prev = 0\n        for num in arr:\n            if num >= prev:\n                count += 1\n            prev = num\n        return count\n    \n    total_count = 0\n    for i in range(1, nums[0] + 1):\n        arr1 = [i]\n        arr2 = [nums[0] - i]\n        for j in range(1, n):\n            next_arr1 = arr1[-1] + 1\n            next_arr2 = nums[j] - next_arr1\n            if next_arr2 >= 0 and next_arr2 <= arr2[-1]:\n                arr1.append(next_arr1)\n                arr2.append(next_arr2)\n            else:\n                break\n        total_count += countMonotonic(arr2)\n        total_count %= mod\n    \n    return total_count", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    mod = 10**9 + 7\n    \n    def countMonotonic(arr):\n        count = 0\n        prev = 0\n        for num in arr:\n            if num >= prev:\n                count += 1\n            prev = num\n        return count\n    \n    total_count = 0\n    for i in range(1, nums[0] + 1):\n        arr1 = [i]\n        arr2 = [nums[0] - i]\n        for j in range(1, n):\n            next_arr1 = arr1[-1] + 1\n            next_arr2 = nums[j] - next_arr1\n            if next_arr2 >= 0 and next_arr2 <= arr2[-1]:\n                arr1.append(next_arr1)\n                arr2.append(next_arr2)\n            else:\n                break\n        total_count += countMonotonic(arr2)\n        total_count %= mod\n    \n    return total_count\n```"}
{"task_id": "arc181_c", "code": "def fill_grid(N, P, Q):\n    grid = [['' for _ in range(N)] for _ in range(N)]\n    \n    def get_next_char(row, col):\n        row_chars = [grid[i][col] for i in range(N) if grid[i][col] != '']\n        col_chars = [grid[row][i] for i in range(N) if grid[row][i] != '']\n        \n        min_char = '0'\n        for i in range(N):\n            if row == P[i] - 1 and col == Q[i] - 1:\n                min_char = '1'\n                break\n            if row == P[i] - 1 and col != Q[i] - 1:\n                min_char = '0'\n            if row != P[i] - 1 and col == Q[i] - 1:\n                min_char = '0'\n            if row != P[i] - 1 and col != Q[i] - 1:\n                min_char = '0'\n        \n        return min_char\n    \n    for i in range(N):\n        for j in range(N):\n            grid[i][j] = get_next_char(i, j)\n    \n    for row in grid:\n        print(''.join(row))\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Fill and print the grid\nfill_grid(N, P, Q)", "passed": false, "raw_code": "```python\ndef fill_grid(N, P, Q):\n    grid = [['' for _ in range(N)] for _ in range(N)]\n    \n    def get_next_char(row, col):\n        row_chars = [grid[i][col] for i in range(N) if grid[i][col] != '']\n        col_chars = [grid[row][i] for i in range(N) if grid[row][i] != '']\n        \n        min_char = '0'\n        for i in range(N):\n            if row == P[i] - 1 and col == Q[i] - 1:\n                min_char = '1'\n                break\n            if row == P[i] - 1 and col != Q[i] - 1:\n                min_char = '0'\n            if row != P[i] - 1 and col == Q[i] - 1:\n                min_char = '0'\n            if row != P[i] - 1 and col != Q[i] - 1:\n                min_char = '0'\n        \n        return min_char\n    \n    for i in range(N):\n        for j in range(N):\n            grid[i][j] = get_next_char(i, j)\n    \n    for row in grid:\n        print(''.join(row))\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\n# Fill and print the grid\nfill_grid(N, P, Q)\n```"}
{"task_id": "abc367_e", "code": "def transform_sequence(N, K, X, A):\n    def apply_operation(A, X):\n        return [A[X[i] - 1] for i in range(N)]\n    \n    # Reduce K modulo N to handle large K efficiently\n    K %= N\n    \n    # Apply the operation K times\n    for _ in range(K):\n        A = apply_operation(A, X)\n    \n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\ntransform_sequence(N, K, X, A)", "passed": false, "raw_code": "```python\ndef transform_sequence(N, K, X, A):\n    def apply_operation(A, X):\n        return [A[X[i] - 1] for i in range(N)]\n    \n    # Reduce K modulo N to handle large K efficiently\n    K %= N\n    \n    # Apply the operation K times\n    for _ in range(K):\n        A = apply_operation(A, X)\n    \n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\ntransform_sequence(N, K, X, A)\n```"}
{"task_id": "abc366_f", "code": "import sys\nfrom itertools import permutations\n\ndef max_nested_function_value(N, K, functions):\n    max_value = float('-inf')\n    \n    # Generate all permutations of the sequence [1, 2, ..., N]\n    for perm in permutations(range(1, N + 1)):\n        x = 1\n        for pi in perm[:K]:\n            x = functions[pi - 1][0] * x + functions[pi - 1][1]\n        \n        if x > max_value:\n            max_value = x\n    \n    print(max_value)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nfunctions = []\nindex = 2\nfor _ in range(N):\n    A = int(data[index])\n    B = int(data[index + 1])\n    functions.append((A, B))\n    index += 2\n\n# Call the function with the read data\nmax_nested_function_value(N, K, functions)", "passed": false, "raw_code": "```python\nimport sys\nfrom itertools import permutations\n\ndef max_nested_function_value(N, K, functions):\n    max_value = float('-inf')\n    \n    # Generate all permutations of the sequence [1, 2, ..., N]\n    for perm in permutations(range(1, N + 1)):\n        x = 1\n        for pi in perm[:K]:\n            x = functions[pi - 1][0] * x + functions[pi - 1][1]\n        \n        if x > max_value:\n            max_value = x\n    \n    print(max_value)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nfunctions = []\nindex = 2\nfor _ in range(N):\n    A = int(data[index])\n    B = int(data[index + 1])\n    functions.append((A, B))\n    index += 2\n\n# Call the function with the read data\nmax_nested_function_value(N, K, functions)\n```"}
{"task_id": "abc366_e", "code": "def count_points(N, D, points):\n    # Sort points by x-coordinate, then by y-coordinate if x-coordinates are the same\n    points.sort(key=lambda p: (p[0], p[1]))\n    \n    # Initialize prefix sums\n    prefix_x = [0] * (N + 1)\n    prefix_y = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        prefix_x[i] = prefix_x[i - 1] + abs(points[i - 1][0])\n        prefix_y[i] = prefix_y[i - 1] + abs(points[i - 1][1])\n    \n    count = 0\n    \n    for i in range(N):\n        left_x = max(-points[i][0], -(D - prefix_x[N] + prefix_x[i + 1]))\n        right_x = min(D - prefix_x[i], points[i][0] + (prefix_x[N] - prefix_x[i + 1]))\n        \n        left_y = max(-points[i][1], -(D - prefix_y[N] + prefix_y[i + 1]))\n        right_y = min(D - prefix_y[i], points[i][1] + (prefix_y[N] - prefix_y[i + 1]))\n        \n        # Count points within the bounding box defined by (left_x, left_y) and (right_x, right_y)\n        count += (right_x - left_x + 1) * (right_y - left_y + 1)\n    \n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nD = int(data[1])\n\npoints = []\nfor i in range(N):\n    x = int(data[2 + 2 * i])\n    y = int(data[3 + 2 * i])\n    points.append((x, y))\n\n# Print the result\nprint(count_points(N, D, points))", "passed": false, "raw_code": "```python\ndef count_points(N, D, points):\n    # Sort points by x-coordinate, then by y-coordinate if x-coordinates are the same\n    points.sort(key=lambda p: (p[0], p[1]))\n    \n    # Initialize prefix sums\n    prefix_x = [0] * (N + 1)\n    prefix_y = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        prefix_x[i] = prefix_x[i - 1] + abs(points[i - 1][0])\n        prefix_y[i] = prefix_y[i - 1] + abs(points[i - 1][1])\n    \n    count = 0\n    \n    for i in range(N):\n        left_x = max(-points[i][0], -(D - prefix_x[N] + prefix_x[i + 1]))\n        right_x = min(D - prefix_x[i], points[i][0] + (prefix_x[N] - prefix_x[i + 1]))\n        \n        left_y = max(-points[i][1], -(D - prefix_y[N] + prefix_y[i + 1]))\n        right_y = min(D - prefix_y[i], points[i][1] + (prefix_y[N] - prefix_y[i + 1]))\n        \n        # Count points within the bounding box defined by (left_x, left_y) and (right_x, right_y)\n        count += (right_x - left_x + 1) * (right_y - left_y + 1)\n    \n    return count\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nD = int(data[1])\n\npoints = []\nfor i in range(N):\n    x = int(data[2 + 2 * i])\n    y = int(data[3 + 2 * i])\n    points.append((x, y))\n\n# Print the result\nprint(count_points(N, D, points))\n```"}
{"task_id": "abc365_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0] * N\n    prefix_xor[0] = A[0]\n    for i in range(1, N):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i]\n    \n    total_sum = 0\n    \n    # Iterate over all pairs (i, j)\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            xor_value = prefix_xor[j] ^ prefix_xor[i - 1] if i > 0 else prefix_xor[j]\n            total_sum += xor_value\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0] * N\n    prefix_xor[0] = A[0]\n    for i in range(1, N):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i]\n    \n    total_sum = 0\n    \n    # Iterate over all pairs (i, j)\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            xor_value = prefix_xor[j] ^ prefix_xor[i - 1] if i > 0 else prefix_xor[j]\n            total_sum += xor_value\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc372_g", "code": "import sys\n\ndef count_valid_pairs(N, A, B, C):\n    count = 0\n    max_x = max((C[i] - 1) // A[i] for i in range(N))\n    max_y = max((C[i] - 1) // B[i] for i in range(N))\n    \n    for x in range(1, max_x + 1):\n        for y in range(1, max_y + 1):\n            if all(A[i] * x + B[i] * y < C[i] for i in range(N)):\n                count += 1\n                \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index + 3*i]) for i in range(N)]\n        B = [int(data[index + 3*i + 1]) for i in range(N)]\n        C = [int(data[index + 3*i + 2]) for i in range(N)]\n        index += 3*N\n        \n        results.append(count_valid_pairs(N, A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\n\ndef count_valid_pairs(N, A, B, C):\n    count = 0\n    max_x = max((C[i] - 1) // A[i] for i in range(N))\n    max_y = max((C[i] - 1) // B[i] for i in range(N))\n    \n    for x in range(1, max_x + 1):\n        for y in range(1, max_y + 1):\n            if all(A[i] * x + B[i] * y < C[i] for i in range(N)):\n                count += 1\n                \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index + 3*i]) for i in range(N)]\n        B = [int(data[index + 3*i + 1]) for i in range(N)]\n        C = [int(data[index + 3*i + 2]) for i in range(N)]\n        index += 3*N\n        \n        results.append(count_valid_pairs(N, A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc371_f", "code": "d", "passed": false, "raw_code": "```python\ndef min_movements():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read N\n    N = int(data[index])\n    index += 1\n    \n    # Read initial positions\n    X = list(map(int, data[index:index + N]))\n    index += N\n    \n    # Read Q\n    Q = int(data[index])\n    index += 1\n    \n    # Read tasks\n    tasks = []\n    for _ in range(Q):\n        T = int(data[index]) - 1\n        G = int(data[index + 1])\n        tasks.append((T, G))\n        index += 2\n    \n    # Sort initial positions\n    X.sort()\n    \n    total_moves = 0\n    \n    for T, G in tasks:\n        # Binary search to find the closest person\n        left, right = 0, N - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if X[mid] == G:\n                break\n            elif X[mid] < G:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # Calculate the minimum movements\n        if left < N:\n            moves_to_left = abs(X[left] - G)\n        else:\n            moves_to_left = float('inf')\n        \n        if right >= 0:\n            moves_to_right = abs(X[right] - G)\n        else:\n            moves_to_right = float('inf')\n        \n        moves = min(moves_to_left, moves_to_right)\n        \n        # Update total movements\n        total_moves += moves\n    \n    print(total_moves)\n\nmin_movements()"}
{"task_id": "3527", "code": "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Extend colors to handle circular nature\n    tree = [0] * (4 * n)\n\n    def update(pos, start, end, idx, val):\n        if start == end:\n            tree[pos] = val\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                update(2 * pos, start, mid, idx, val)\n            else:\n                update(2 * pos + 1, mid + 1, end, idx, val)\n            tree[pos] = tree[2 * pos] + tree[2 * pos + 1]\n\n    def query(pos, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return tree[pos]\n        mid = (start + end) // 2\n        return query(2 * pos, start, mid, l, r) + query(2 * pos + 1, mid + 1, end, l, r)\n\n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size <= 2 * n and all(colors[i + j] != colors[i + j + 1] for j in range(size - 1)):\n                count += 1\n        return count\n\n    answer = []\n    for query_type, *params in queries:\n        if query_type == 1:\n            size = params[0]\n            answer.append(count_alternating_groups(size))\n        elif query_type == 2:\n            index, color = params\n            original_color = colors[index]\n            colors[index] = color\n            colors[index + n] = color\n            if original_color != color:\n                if index > 0 and (colors[index - 1] != original_color or colors[index + n - 1] != original_color):\n                    update(1, 0, 2 * n - 1, index - 1, 1)\n                if index + 1 < 2 * n and (colors[index + 1] != original_color or colors[index] != original_color):\n                    update(1, 0, 2 * n - 1, index + 1, 1)\n                if index > 0 and (colors[index - 1] != color or colors[index + n - 1] != color):\n                    update(1, 0, 2 * n - 1, index - 1, 0)\n                if index + 1 < 2 * n and (colors[index + 1] != color or colors[index] != color):\n                    update(1, 0, 2 * n - 1, index + 1, 0)\n\n    return answer", "passed": false, "raw_code": "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Extend colors to handle circular nature\n    tree = [0] * (4 * n)\n\n    def update(pos, start, end, idx, val):\n        if start == end:\n            tree[pos] = val\n        else:\n            mid = (start + end) // 2\n            if start <= idx <= mid:\n                update(2 * pos, start, mid, idx, val)\n            else:\n                update(2 * pos + 1, mid + 1, end, idx, val)\n            tree[pos] = tree[2 * pos] + tree[2 * pos + 1]\n\n    def query(pos, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return tree[pos]\n        mid = (start + end) // 2\n        return query(2 * pos, start, mid, l, r) + query(2 * pos + 1, mid + 1, end, l, r)\n\n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size <= 2 * n and all(colors[i + j] != colors[i + j + 1] for j in range(size - 1)):\n                count += 1\n        return count\n\n    answer = []\n    for query_type, *params in queries:\n        if query_type == 1:\n            size = params[0]\n            answer.append(count_alternating_groups(size))\n        elif query_type == 2:\n            index, color = params\n            original_color = colors[index]\n            colors[index] = color\n            colors[index + n] = color\n            if original_color != color:\n                if index > 0 and (colors[index - 1] != original_color or colors[index + n - 1] != original_color):\n                    update(1, 0, 2 * n - 1, index - 1, 1)\n                if index + 1 < 2 * n and (colors[index + 1] != original_color or colors[index] != original_color):\n                    update(1, 0, 2 * n - 1, index + 1, 1)\n                if index > 0 and (colors[index - 1] != color or colors[index + n - 1] != color):\n                    update(1, 0, 2 * n - 1, index - 1, 0)\n                if index + 1 < 2 * n and (colors[index + 1] != color or colors[index] != color):\n                    update(1, 0, 2 * n - 1, index + 1, 0)\n\n    return answer\n```"}
{"task_id": "abc370_e", "code": "def count_partitions_modulo_K(N, K, A):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    prefix_sum = [0] * (N + 1)\n    prefix_sum[1] = A[0]\n    for i in range(1, N):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    dp[1] = 1\n    \n    for i in range(2, N + 1):\n        for j in range(i - 1, -1, -1):\n            if prefix_sum[i] - prefix_sum[j] != K:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[N]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Output the result\nprint(count_partitions_modulo_K(N, K, A))", "passed": false, "raw_code": "```python\ndef count_partitions_modulo_K(N, K, A):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    prefix_sum = [0] * (N + 1)\n    prefix_sum[1] = A[0]\n    for i in range(1, N):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n    \n    dp[1] = 1\n    \n    for i in range(2, N + 1):\n        for j in range(i - 1, -1, -1):\n            if prefix_sum[i] - prefix_sum[j] != K:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[N]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Output the result\nprint(count_partitions_modulo_K(N, K, A))\n```"}
{"task_id": "abc373_f", "code": "def max_happiness(N, W, weights, values):\n    dp = [0] * (W + 1)\n    for i in range(N):\n        for j in range(W, weights[i] - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j - k * weights[i] >= 0:\n                    dp[j] = max(dp[j], dp[j - k * weights[i]] + k * (values[i] - k))\n                else:\n                    break\n    return dp[W]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2 * i]))\n    values.append(int(data[3 + 2 * i]))\nprint(max_happiness(N, W, weights, values))", "passed": false, "raw_code": "def max_happiness(N, W, weights, values):\n    dp = [0] * (W + 1)\n    for i in range(N):\n        for j in range(W, weights[i] - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j - k * weights[i] >= 0:\n                    dp[j] = max(dp[j], dp[j - k * weights[i]] + k * (values[i] - k))\n                else:\n                    break\n    return dp[W]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2 * i]))\n    values.append(int(data[3 + 2 * i]))\nprint(max_happiness(N, W, weights, values))"}
{"task_id": "abc373_g", "code": "import sys\nfrom typing import List\n\ndef read_input() -> List[List[int]]:\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = [int(data[2*i+1]) for i in range(N)]\n    B = [int(data[2*i+2]) for i in range(N)]\n    C = [int(data[2*N + 2*i+1]) for i in range(N)]\n    D = [int(data[2*N + 2*i+2]) for i in range(N)]\n    return A, B, C, D\n\ndef calculate_slope(A: int, B: int, C: int, D: int) -> float:\n    return (D - B) / (C - A)\n\ndef find_permutation(A: List[int], B: List[int], C: List[int], D: List[int]) -> List[int]:\n    N = len(A)\n    # Sort points based on slope with respect to the first point (P_1)\n    slopes = [(calculate_slope(A[0], B[0], C[i], D[i]), i) for i in range(1, N)]\n    slopes.sort()\n    # Initialize permutation with the first index\n    R = [0]\n    for _, i in slopes:\n        R.append(i)\n    # Check if the permutation satisfies the non-intersection condition\n    for i in range(1, N):\n        for j in range(i+1, N):\n            x1, y1 = A[R[i]], B[R[i]]\n            x2, y2 = A[R[j]], B[R[j]]\n            x3, y3 = C[R[i]], D[R[i]]\n            x4, y4 = C[R[j]], D[R[j]]\n            if (x2-x1)*(y4-y3) == (y2-y1)*(x4-x3):\n                return [-1]\n    return R[1:]\n\nif __name__ == '__main__':\n    A, B, C, D = read_input()\n    result = find_permutation(A, B, C, D)\n    print(' '.join(map(str, result)))", "passed": false, "raw_code": "import sys\nfrom typing import List\n\ndef read_input() -> List[List[int]]:\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = [int(data[2*i+1]) for i in range(N)]\n    B = [int(data[2*i+2]) for i in range(N)]\n    C = [int(data[2*N + 2*i+1]) for i in range(N)]\n    D = [int(data[2*N + 2*i+2]) for i in range(N)]\n    return A, B, C, D\n\ndef calculate_slope(A: int, B: int, C: int, D: int) -> float:\n    return (D - B) / (C - A)\n\ndef find_permutation(A: List[int], B: List[int], C: List[int], D: List[int]) -> List[int]:\n    N = len(A)\n    # Sort points based on slope with respect to the first point (P_1)\n    slopes = [(calculate_slope(A[0], B[0], C[i], D[i]), i) for i in range(1, N)]\n    slopes.sort()\n    # Initialize permutation with the first index\n    R = [0]\n    for _, i in slopes:\n        R.append(i)\n    # Check if the permutation satisfies the non-intersection condition\n    for i in range(1, N):\n        for j in range(i+1, N):\n            x1, y1 = A[R[i]], B[R[i]]\n            x2, y2 = A[R[j]], B[R[j]]\n            x3, y3 = C[R[i]], D[R[i]]\n            x4, y4 = C[R[j]], D[R[j]]\n            if (x2-x1)*(y4-y3) == (y2-y1)*(x4-x3):\n                return [-1]\n    return R[1:]\n\nif __name__ == '__main__':\n    A, B, C, D = read_input()\n    result = find_permutation(A, B, C, D)\n    print(' '.join(map(str, result)))"}
{"task_id": "abc373_e", "code": "", "passed": false, "raw_code": ""}
{"task_id": "arc181_d", "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    def get_inversion_number(p):\n        inversions = 0\n        for i in range(len(p)):\n            for j in range(i+1, len(p)):\n                if p[i] > p[j]:\n                    inversions += 1\n        return inversions\n    def apply_operation(p, k):\n        for i in range(k-1):\n            if p[i] > p[i+1]:\n                p[i], p[i+1] = p[i+1], p[i]\n        return p\n    results = []\n    for a in A:\n        P = apply_operation(P, a)\n        results.append(get_inversion_number(P))\n    for result in results:\n        print(result)\nsolve()", "passed": false, "raw_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    def get_inversion_number(p):\n        inversions = 0\n        for i in range(len(p)):\n            for j in range(i+1, len(p)):\n                if p[i] > p[j]:\n                    inversions += 1\n        return inversions\n    def apply_operation(p, k):\n        for i in range(k-1):\n            if p[i] > p[i+1]:\n                p[i], p[i+1] = p[i+1], p[i]\n        return p\n    results = []\n    for a in A:\n        P = apply_operation(P, a)\n        results.append(get_inversion_number(P))\n    for result in results:\n        print(result)\nsolve()"}
{"task_id": "abc368_e", "code": "def min_delays(N, M, X1, trains):\n    # Sort trains based on their arrival times\n    trains.sort(key=lambda x: x[3])\n    \n    # Initialize the delay array\n    X = [0] * M\n    \n    # Set the initial delay for the first train\n    X[0] = X1\n    \n    # Calculate the delays for the rest of the trains\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        prev_B = None\n        prev_T = None\n        \n        for j in range(i - 1, -1, -1):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_j == A_i and T_j <= S_i:\n                prev_B = B_j\n                prev_T = T_j\n                break\n        \n        if prev_B is not None:\n            X[i] = max(X[i], X[j] + S_i - T_j)\n    \n    # Return the delays for trains 2 to M\n    return ' '.join(map(str, X[1:]))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nfor i in range(M):\n    A_i = int(data[3 + 4 * i])\n    B_i = int(data[4 + 4 * i])\n    S_i = int(data[5 + 4 * i])\n    T_i = int(data[6 + 4 * i])\n    trains.append((A_i, B_i, S_i, T_i))\n\n# Get the result\nresult = min_delays(N, M, X1, trains)\nprint(result)", "passed": false, "raw_code": "```python\ndef min_delays(N, M, X1, trains):\n    # Sort trains based on their arrival times\n    trains.sort(key=lambda x: x[3])\n    \n    # Initialize the delay array\n    X = [0] * M\n    \n    # Set the initial delay for the first train\n    X[0] = X1\n    \n    # Calculate the delays for the rest of the trains\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        prev_B = None\n        prev_T = None\n        \n        for j in range(i - 1, -1, -1):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_j == A_i and T_j <= S_i:\n                prev_B = B_j\n                prev_T = T_j\n                break\n        \n        if prev_B is not None:\n            X[i] = max(X[i], X[j] + S_i - T_j)\n    \n    # Return the delays for trains 2 to M\n    return ' '.join(map(str, X[1:]))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nfor i in range(M):\n    A_i = int(data[3 + 4 * i])\n    B_i = int(data[4 + 4 * i])\n    S_i = int(data[5 + 4 * i])\n    T_i = int(data[6 + 4 * i])\n    trains.append((A_i, B_i, S_i, T_i))\n\n# Get the result\nresult = min_delays(N, M, X1, trains)\nprint(result)\n```"}
{"task_id": "abc366_g", "code": "def can_assign_values(N, M, edges):\n    from collections import defaultdict\n    \n    # Step 1: Build the adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 2: Initialize the values array with -1 (indicating unassigned)\n    values = [-1] * (N + 1)\n    \n    # Step 3: Assign values using a greedy approach\n    for i in range(1, N + 1):\n        if values[i] == -1:\n            values[i] = 1  # Start with 1 and adjust if needed\n            \n            # Ensure the XOR condition is met for all neighbors\n            for neighbor in graph[i]:\n                if values[neighbor] != -1:\n                    values[i] ^= values[neighbor]\n    \n    # Check if the assignment is valid\n    for i in range(1, N + 1):\n        if i in graph[i]:\n            continue  # Self-loop, ignore\n        xor_sum = sum(values[neighbor] for neighbor in graph[i] if neighbor != i)\n        if xor_sum != 0:\n            return \"No\"\n    \n    # Step 4: Print the result\n    for i in range(1, N + 1):\n        if values[i] == -1:\n            return \"No\"\n    return \"Yes\\n\" + \" \".join(map(str, values[1:]))\n\nN, M = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\nresult = can_assign_values(N, M, edges)\nprint(result)", "passed": false, "raw_code": "```python\ndef can_assign_values(N, M, edges):\n    from collections import defaultdict\n    \n    # Step 1: Build the adjacency list\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 2: Initialize the values array with -1 (indicating unassigned)\n    values = [-1] * (N + 1)\n    \n    # Step 3: Assign values using a greedy approach\n    for i in range(1, N + 1):\n        if values[i] == -1:\n            values[i] = 1  # Start with 1 and adjust if needed\n            \n            # Ensure the XOR condition is met for all neighbors\n            for neighbor in graph[i]:\n                if values[neighbor] != -1:\n                    values[i] ^= values[neighbor]\n    \n    # Check if the assignment is valid\n    for i in range(1, N + 1):\n        if i in graph[i]:\n            continue  # Self-loop, ignore\n        xor_sum = sum(values[neighbor] for neighbor in graph[i] if neighbor != i)\n        if xor_sum != 0:\n            return \"No\"\n    \n    # Step 4: Print the result\n    for i in range(1, N + 1):\n        if values[i] == -1:\n            return \"No\"\n    return \"Yes\\n\" + \" \".join(map(str, values[1:]))\n\nN, M = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(M)]\n\nresult = can_assign_values(N, M, edges)\nprint(result)\n```"}
{"task_id": "abc369_e", "code": "import sys\nfrom collections import defaultdict, deque\nfrom itertools import permutations\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    queue = deque([start])\n    while queue:\n        u = queue.popleft()\n        for v, weight in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                queue.append(v)\n    return dist\n\ndef solve_queries(N, M, bridges, Q, queries):\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u-1].append((v-1, t))\n        graph[v-1].append((u-1, t))\n    \n    dist = [dijkstra(graph, i) for i in range(N)]\n    \n    results = []\n    for K, bridge_indices in queries:\n        bridges_to_use = [bridges[i-1] for i in bridge_indices]\n        min_time = float('inf')\n        \n        for perm in permutations(bridges_to_use):\n            current_time = 0\n            current_node = 0\n            for u, v, t in perm:\n                if dist[current_node][u-1] < dist[current_node][v-1]:\n                    current_time += dist[current_node][u-1] + t\n                    current_node = u-1\n                else:\n                    current_time += dist[current_node][v-1] + t\n                    current_node = v-1\n            if dist[current_node][N-1] < float('inf'):\n                min_time = min(min_time, current_time + dist[current_node][N-1])\n        \n        results.append(min_time)\n    \n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    bridges = []\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        t = int(data[index + 2])\n        bridges.append((u, v, t))\n        index += 3\n    \n    Q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        bridge_indices = list(map(int, data[index:index + K]))\n        queries.append((K, bridge_indices))\n        index += K\n    \n    results = solve_queries(N, M, bridges, Q, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\nfrom itertools import permutations\n\ndef dijkstra(graph, start):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    queue = deque([start])\n    while queue:\n        u = queue.popleft()\n        for v, weight in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                queue.append(v)\n    return dist\n\ndef solve_queries(N, M, bridges, Q, queries):\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u-1].append((v-1, t))\n        graph[v-1].append((u-1, t))\n    \n    dist = [dijkstra(graph, i) for i in range(N)]\n    \n    results = []\n    for K, bridge_indices in queries:\n        bridges_to_use = [bridges[i-1] for i in bridge_indices]\n        min_time = float('inf')\n        \n        for perm in permutations(bridges_to_use):\n            current_time = 0\n            current_node = 0\n            for u, v, t in perm:\n                if dist[current_node][u-1] < dist[current_node][v-1]:\n                    current_time += dist[current_node][u-1] + t\n                    current_node = u-1\n                else:\n                    current_time += dist[current_node][v-1] + t\n                    current_node = v-1\n            if dist[current_node][N-1] < float('inf'):\n                min_time = min(min_time, current_time + dist[current_node][N-1])\n        \n        results.append(min_time)\n    \n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    bridges = []\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        t = int(data[index + 2])\n        bridges.append((u, v, t))\n        index += 3\n    \n    Q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        bridge_indices = list(map(int, data[index:index + K]))\n        queries.append((K, bridge_indices))\n        index += K\n    \n    results = solve_queries(N, M, bridges, Q, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc369_g", "code": "import sys\nfrom typing import List\n\ndef floyd_warshall(n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[float('inf')] * n for _ in range(n)]\n    for u, v, l in edges:\n        dist[u-1][v-1] = l\n        dist[v-1][u-1] = l\n    for i in range(n):\n        dist[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ndef min_max_score(n: int, edges: List[List[int]], k: int) -> int:\n    dist = floyd_warshall(n, edges)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i] = dist[0][i]\n    \n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                for j in range(n):\n                    if j != i and mask & (1 << j):\n                        dp[i][mask] = min(dp[i][mask], dp[j][mask ^ (1 << i)] + dist[j][i])\n    \n    return dp[0][(1 << n) - 1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append([u, v, l])\n        index += 3\n    \n    for k in range(1, n + 1):\n        print(min_max_score(n, edges, k))\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom typing import List\n\ndef floyd_warshall(n: int, edges: List[List[int]]) -> List[List[int]]:\n    dist = [[float('inf')] * n for _ in range(n)]\n    for u, v, l in edges:\n        dist[u-1][v-1] = l\n        dist[v-1][u-1] = l\n    for i in range(n):\n        dist[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    return dist\n\ndef min_max_score(n: int, edges: List[List[int]], k: int) -> int:\n    dist = floyd_warshall(n, edges)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i] = dist[0][i]\n    \n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                for j in range(n):\n                    if j != i and mask & (1 << j):\n                        dp[i][mask] = min(dp[i][mask], dp[j][mask ^ (1 << i)] + dist[j][i])\n    \n    return dp[0][(1 << n) - 1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append([u, v, l])\n        index += 3\n    \n    for k in range(1, n + 1):\n        print(min_max_score(n, edges, k))\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc370_f", "code": "def can_divide(N, K, A, target):\n    current_sum = 0\n    cut_count = 0\n    cut_never_cut = set()\n    for i in range(N):\n        current_sum += A[i]\n        if current_sum >= target:\n            cut_count += 1\n            if current_sum > target:\n                cut_never_cut.add((i + 1) % N)\n            current_sum = 0\n    return cut_count >= K, cut_never_cut\n\ndef find_min_max_mass(N, K, A):\n    total_mass = sum(A)\n    low, high = 0, total_mass\n    best_min_mass = 0\n    best_cut_never_cut = set()\n    \n    while low <= high:\n        mid = (low + high) // 2\n        can_divide_successfully, cut_never_cut = can_divide(N, K, A, mid)\n        if can_divide_successfully:\n            best_min_mass = mid\n            best_cut_never_cut = cut_never_cut\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return best_min_mass, len(best_cut_never_cut)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    best_min_mass, cut_never_cut_count = find_min_max_mass(N, K, A)\n    print(best_min_mass, cut_never_cut_count)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_divide(N, K, A, target):\n    current_sum = 0\n    cut_count = 0\n    cut_never_cut = set()\n    for i in range(N):\n        current_sum += A[i]\n        if current_sum >= target:\n            cut_count += 1\n            if current_sum > target:\n                cut_never_cut.add((i + 1) % N)\n            current_sum = 0\n    return cut_count >= K, cut_never_cut\n\ndef find_min_max_mass(N, K, A):\n    total_mass = sum(A)\n    low, high = 0, total_mass\n    best_min_mass = 0\n    best_cut_never_cut = set()\n    \n    while low <= high:\n        mid = (low + high) // 2\n        can_divide_successfully, cut_never_cut = can_divide(N, K, A, mid)\n        if can_divide_successfully:\n            best_min_mass = mid\n            best_cut_never_cut = cut_never_cut\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return best_min_mass, len(best_cut_never_cut)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    best_min_mass, cut_never_cut_count = find_min_max_mass(N, K, A)\n    print(best_min_mass, cut_never_cut_count)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_d", "code": "def min_operations_to_transform(N, M, A, B):\n    total_operations = 0\n    \n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        \n        if diff <= M // 2:\n            total_operations += diff\n        elif diff > M // 2:\n            total_operations += M - diff\n    \n    return total_operations\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print the result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)", "passed": false, "raw_code": "```python\ndef min_operations_to_transform(N, M, A, B):\n    total_operations = 0\n    \n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        \n        if diff <= M // 2:\n            total_operations += diff\n        elif diff > M // 2:\n            total_operations += M - diff\n    \n    return total_operations\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print the result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)\n```"}
{"task_id": "abc372_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    edges = []\n    for _ in range(M):\n        X = int(data[index]) - 1\n        Y = int(data[index + 1]) - 1\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * N for _ in range(K + 1)]\n    dp[0][0] = 1  # Starting point\n    \n    # Fill dp table\n    for k in range(1, K + 1):\n        new_dp = [0] * N\n        for i in range(N):\n            if (i + 1) % N == 0:\n                new_dp[(i + 1) % N] = (new_dp[(i + 1) % N] + dp[k-1][i]) % MOD\n            else:\n                new_dp[(i + 1) % N] = (new_dp[(i + 1) % N] + dp[k-1][i]) % MOD\n            for x, y in edges:\n                if x == i:\n                    new_dp[y] = (new_dp[y] + dp[k-1][x]) % MOD\n        dp[k] = new_dp\n    \n    # Sum up the ways to reach any vertex in K moves\n    result = sum(dp[K]) % MOD\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    edges = []\n    for _ in range(M):\n        X = int(data[index]) - 1\n        Y = int(data[index + 1]) - 1\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * N for _ in range(K + 1)]\n    dp[0][0] = 1  # Starting point\n    \n    # Fill dp table\n    for k in range(1, K + 1):\n        new_dp = [0] * N\n        for i in range(N):\n            if (i + 1) % N == 0:\n                new_dp[(i + 1) % N] = (new_dp[(i + 1) % N] + dp[k-1][i]) % MOD\n            else:\n                new_dp[(i + 1) % N] = (new_dp[(i + 1) % N] + dp[k-1][i]) % MOD\n            for x, y in edges:\n                if x == i:\n                    new_dp[y] = (new_dp[y] + dp[k-1][x]) % MOD\n        dp[k] = new_dp\n    \n    # Sum up the ways to reach any vertex in K moves\n    result = sum(dp[K]) % MOD\n    print(result)\n\nmain()\n```"}
{"task_id": "abc367_g", "code": "MOD = 998244353\n\ndef mod_exp(base, exp):\n    result = 1\n    base = base % MOD\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % MOD\n        exp = exp >> 1\n        base = (base * base) % MOD\n    return result\n\ndef solve(N, M, K, A):\n    dp = [0] * (N + 1)\n    dp[1] = 1\n    for i in range(1, N + 1):\n        dp[i] = (dp[i - 1] ^ A[i - 1]) % MOD\n    \n    total_score = 0\n    for i in range(1, 1 << N):\n        length = bin(i).count('1')\n        if length % M == 0:\n            score = mod_exp(dp[length], K)\n            total_score = (total_score + score) % MOD\n    \n    print(total_score)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Solve the problem\nsolve(N, M, K, A)", "passed": false, "raw_code": "```python\nMOD = 998244353\n\ndef mod_exp(base, exp):\n    result = 1\n    base = base % MOD\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % MOD\n        exp = exp >> 1\n        base = (base * base) % MOD\n    return result\n\ndef solve(N, M, K, A):\n    dp = [0] * (N + 1)\n    dp[1] = 1\n    for i in range(1, N + 1):\n        dp[i] = (dp[i - 1] ^ A[i - 1]) % MOD\n    \n    total_score = 0\n    for i in range(1, 1 << N):\n        length = bin(i).count('1')\n        if length % M == 0:\n            score = mod_exp(dp[length], K)\n            total_score = (total_score + score) % MOD\n    \n    print(total_score)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Solve the problem\nsolve(N, M, K, A)\n```"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict over its lifetime\n    total_damage = [(d * h) // p if d % p == 0 else (d * h) // p + 1 for d, h, p in zip(damage, health, [power] * n)]\n    \n    # Sort enemies by remaining health in descending order\n    enemies = sorted(zip(health, damage, range(n)), reverse=True)\n    \n    total_bob_damage = 0\n    \n    for h, d, i in enemies:\n        if h > 0:\n            rounds = (h - 1) // power + 1\n            total_bob_damage += rounds * d\n            health[i] -= rounds * power\n    \n    return total_bob_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict over its lifetime\n    total_damage = [(d * h) // p if d % p == 0 else (d * h) // p + 1 for d, h, p in zip(damage, health, [power] * n)]\n    \n    # Sort enemies by remaining health in descending order\n    enemies = sorted(zip(health, damage, range(n)), reverse=True)\n    \n    total_bob_damage = 0\n    \n    for h, d, i in enemies:\n        if h > 0:\n            rounds = (h - 1) // power + 1\n            total_bob_damage += rounds * d\n            health[i] -= rounds * power\n    \n    return total_bob_damage\n```"}
{"task_id": "3550", "code": "from itertools import product\n\ndef max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Find all valid positions for rooks in each row\n    valid_positions = []\n    for i in range(m):\n        valid_positions.append([j for j in range(n) if board[i][j] != -3])\n    \n    max_sum = float('-inf')\n    \n    # Generate all combinations of columns\n    for cols in product(range(n), repeat=3):\n        if len(set(cols)) == 3:  # Ensure all columns are unique\n            current_sum = sum(board[row][col] for row, col in enumerate(cols))\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "passed": false, "raw_code": "```python\nfrom itertools import product\n\ndef max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Find all valid positions for rooks in each row\n    valid_positions = []\n    for i in range(m):\n        valid_positions.append([j for j in range(n) if board[i][j] != -3])\n    \n    max_sum = float('-inf')\n    \n    # Generate all combinations of columns\n    for cols in product(range(n), repeat=3):\n        if len(set(cols)) == 3:  # Ensure all columns are unique\n            current_sum = sum(board[row][col] for row, col in enumerate(cols))\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"}
{"task_id": "3563", "code": "def maxScore(grid):\n    def backtrack(row, selected_values, current_sum):\n        nonlocal max_score\n        \n        if row == len(grid):\n            max_score = max(max_score, current_sum)\n            return\n        \n        for col in range(len(grid[0])):\n            value = grid[row][col]\n            if value not in selected_values:\n                selected_values.add(value)\n                backtrack(row + 1, selected_values, current_sum + value)\n                selected_values.remove(value)\n    \n    max_score = 0\n    backtrack(0, set(), 0)\n    return max_score", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    def backtrack(row, selected_values, current_sum):\n        nonlocal max_score\n        \n        if row == len(grid):\n            max_score = max(max_score, current_sum)\n            return\n        \n        for col in range(len(grid[0])):\n            value = grid[row][col]\n            if value not in selected_values:\n                selected_values.add(value)\n                backtrack(row + 1, selected_values, current_sum + value)\n                selected_values.remove(value)\n    \n    max_score = 0\n    backtrack(0, set(), 0)\n    return max_score\n```"}
{"task_id": "abc370_g", "code": "MOD = 998244353\n\ndef sum_of_divisors(n):\n    div_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            div_sum[j] += i\n    return div_sum\n\ndef is_good_integer(n, div_sum):\n    return div_sum[n] % 3 == 0\n\ndef count_sequences(N, M):\n    div_sum = sum_of_divisors(N)\n    \n    # Initialize DP array\n    dp = [[0] * 3 for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for length in range(1, M + 1):\n        for num in range(1, N + 1):\n            if is_good_integer(num, div_sum):\n                for prev_mod in range(3):\n                    dp[length][(prev_mod * num) % 3] = (dp[length][(prev_mod * num) % 3] + dp[length - 1][prev_mod]) % MOD\n    \n    result = sum(dp[M]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Calculate and print the result\nprint(count_sequences(N, M))", "passed": false, "raw_code": "```python\nMOD = 998244353\n\ndef sum_of_divisors(n):\n    div_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            div_sum[j] += i\n    return div_sum\n\ndef is_good_integer(n, div_sum):\n    return div_sum[n] % 3 == 0\n\ndef count_sequences(N, M):\n    div_sum = sum_of_divisors(N)\n    \n    # Initialize DP array\n    dp = [[0] * 3 for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for length in range(1, M + 1):\n        for num in range(1, N + 1):\n            if is_good_integer(num, div_sum):\n                for prev_mod in range(3):\n                    dp[length][(prev_mod * num) % 3] = (dp[length][(prev_mod * num) % 3] + dp[length - 1][prev_mod]) % MOD\n    \n    result = sum(dp[M]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Calculate and print the result\nprint(count_sequences(N, M))\n```"}
{"task_id": "arc183_d", "code": "d", "passed": false, "raw_code": "```python\ndef max_score_operations(N, edges):\n    # Initialize the list of leaves\n    leaves = [i for i in range(2, N+1, 2)]\n    \n    # Perform N/2 operations\n    result = []\n    for _ in range(N // 2):\n        # Remove the first and last leaves\n        result.append((leaves[0], leaves[-1]))\n        leaves.pop(0)\n        leaves.pop()\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[i*2+1]), int(data[i*2+2])) for i in range((N-1)//2)]\n\n# Get the result\nresult = max_score_operations(N, edges)\n\n# Print the result\nfor pair in result:\n    print(pair[0], pair[1])"}
{"task_id": "abc368_d", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef dfs(graph, start, parent):\n    stack = [(start, parent)]\n    while stack:\n        node, p = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor != p:\n                    stack.append((neighbor, node))\n\ndef lca(a, b):\n    global visited\n    visited = set()\n    dfs(tree, a, -1)\n    visited.clear()\n    dfs(tree, b, -1)\n    return a if a in visited else b\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\ntree = defaultdict(list)\nfor i in range(n-1):\n    a = int(data[2+2*i])-1\n    b = int(data[3+2*i])-1\n    tree[a].append(b)\n    tree[b].append(a)\nv = list(map(int, data[2*n+1:n+2*k]))\n\n# Find the LCA of the first two vertices\nlca_node = lca(v[0]-1, v[1]-1)\n\n# Traverse the tree starting from the LCA to find the minimum subtree\nvisited = set()\ndfs(tree, lca_node, -1)\n\nprint(len(visited))", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict, deque\n\ndef dfs(graph, start, parent):\n    stack = [(start, parent)]\n    while stack:\n        node, p = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor != p:\n                    stack.append((neighbor, node))\n\ndef lca(a, b):\n    global visited\n    visited = set()\n    dfs(tree, a, -1)\n    visited.clear()\n    dfs(tree, b, -1)\n    return a if a in visited else b\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\ntree = defaultdict(list)\nfor i in range(n-1):\n    a = int(data[2+2*i])-1\n    b = int(data[3+2*i])-1\n    tree[a].append(b)\n    tree[b].append(a)\nv = list(map(int, data[2*n+1:n+2*k]))\n\n# Find the LCA of the first two vertices\nlca_node = lca(v[0]-1, v[1]-1)\n\n# Traverse the tree starting from the LCA to find the minimum subtree\nvisited = set()\ndfs(tree, lca_node, -1)\n\nprint(len(visited))"}
{"task_id": "arc183_b", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef is_connected(N, K, A):\n    # Build the graph\n    graph = defaultdict(list)\n    for i in range(N):\n        for j in range(max(0, i - K), min(N, i + K + 1)):\n            if i != j:\n                graph[i].append(j)\n    \n    # Check if the graph is connected using BFS\n    visited = [False] * N\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    return all(visited)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        if is_connected(N, K, A):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef is_connected(N, K, A):\n    # Build the graph\n    graph = defaultdict(list)\n    for i in range(N):\n        for j in range(max(0, i - K), min(N, i + K + 1)):\n            if i != j:\n                graph[i].append(j)\n    \n    # Check if the graph is connected using BFS\n    visited = [False] * N\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    return all(visited)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        index += N\n        B = list(map(int, data[index:index + N]))\n        index += N\n        \n        if is_connected(N, K, A):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Precompute the minimum values of (Ck + A_i) % M for all k from 0 to M-1\n    min_values = [float('inf')] * M\n    for i in range(N):\n        for k in range(M):\n            min_values[k] = min(min_values[k], (C * k + A[i]) % M)\n    \n    # Calculate the sum of the minimum values for the given range of k\n    total_sum = 0\n    for k in range(K):\n        total_sum += min_values[k % M]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Precompute the minimum values of (Ck + A_i) % M for all k from 0 to M-1\n    min_values = [float('inf')] * M\n    for i in range(N):\n        for k in range(M):\n            min_values[k] = min(min_values[k], (C * k + A[i]) % M)\n    \n    # Calculate the sum of the minimum values for the given range of k\n    total_sum = 0\n    for k in range(K):\n        total_sum += min_values[k % M]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3575", "code": "from itertools import combinations\n\ndef max_subsequence_value(nums, k):\n    max_value = 0\n    for subseq in combinations(nums, 2 * k):\n        first_half_or = 0\n        second_half_or = 0\n        for i in range(k):\n            first_half_or |= subseq[i]\n            second_half_or |= subseq[k + i]\n        max_value = max(max_value, first_half_or ^ second_half_or)\n    return max_value", "passed": false, "raw_code": "```python\nfrom itertools import combinations\n\ndef max_subsequence_value(nums, k):\n    max_value = 0\n    for subseq in combinations(nums, 2 * k):\n        first_half_or = 0\n        second_half_or = 0\n        for i in range(k):\n            first_half_or |= subseq[i]\n            second_half_or |= subseq[k + i]\n        max_value = max(max_value, first_half_or ^ second_half_or)\n    return max_value\n```"}
{"task_id": "3552", "code": "def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = int('1' + '0' * (n - 1))\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    \n    return \"No valid k-palindrome found\"\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = int('1' + '0' * (n - 1))\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    \n    return \"No valid k-palindrome found\"\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    from collections import Counter\n    from math import factorial\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    def count_permutations(counter):\n        total = factorial(len(counter))\n        for count in counter.values():\n            total //= factorial(count)\n        return total\n\n    def count_good(n, k):\n        if n == 1:\n            return len([x for x in range(1, 10) if x % k == 0])\n\n        good_count = 0\n        half_length = (n + 1) // 2\n        for digits in range(10**(half_length-1), 10**half_length):\n            counter = Counter(str(digits))\n            if sum(int(digit) for digit in counter) % k == 0:\n                if n % 2 == 1:\n                    # Odd length palindrome\n                    total_permutations = count_permutations(counter)\n                    good_count += total_permutations\n                else:\n                    # Even length palindrome\n                    total_permutations = count_permutations(counter)\n                    good_count += total_permutations\n\n        return good_count\n\n    return count_good(n, k)", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    from collections import Counter\n    from math import factorial\n\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    def count_permutations(counter):\n        total = factorial(len(counter))\n        for count in counter.values():\n            total //= factorial(count)\n        return total\n\n    def count_good(n, k):\n        if n == 1:\n            return len([x for x in range(1, 10) if x % k == 0])\n\n        good_count = 0\n        half_length = (n + 1) // 2\n        for digits in range(10**(half_length-1), 10**half_length):\n            counter = Counter(str(digits))\n            if sum(int(digit) for digit in counter) % k == 0:\n                if n % 2 == 1:\n                    # Odd length palindrome\n                    total_permutations = count_permutations(counter)\n                    good_count += total_permutations\n                else:\n                    # Even length palindrome\n                    total_permutations = count_permutations(counter)\n                    good_count += total_permutations\n\n        return good_count\n\n    return count_good(n, k)\n```"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    coordinates.sort()\n    \n    dp = [1] * n\n    max_path_length = 1\n    \n    for i in range(n):\n        for j in range(i):\n            if coordinates[j][0] < coordinates[i][0] and coordinates[j][1] < coordinates[i][1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_path_length = max(max_path_length, dp[i])\n    \n    return max_path_length", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    coordinates.sort()\n    \n    dp = [1] * n\n    max_path_length = 1\n    \n    for i in range(n):\n        for j in range(i):\n            if coordinates[j][0] < coordinates[i][0] and coordinates[j][1] < coordinates[i][1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_path_length = max(max_path_length, dp[i])\n    \n    return max_path_length\n```"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"}
{"task_id": "3583", "code": "def get_gcd_pairs(nums, queries):\n    from math import gcd\n    from collections import defaultdict\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Compute all GCD pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = gcd(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    # Sort the GCD values\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Answer each query\n    answer = []\n    for query in queries:\n        index = query\n        current_sum = 0\n        for i, gcd_val in enumerate(sorted_gcds):\n            current_sum += gcd_count[gcd_val]\n            if current_sum > index:\n                answer.append(gcd_val)\n                break\n    \n    return answer", "passed": false, "raw_code": "```python\ndef get_gcd_pairs(nums, queries):\n    from math import gcd\n    from collections import defaultdict\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Compute all GCD pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = gcd(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    # Sort the GCD values\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Answer each query\n    answer = []\n    for query in queries:\n        index = query\n        current_sum = 0\n        for i, gcd_val in enumerate(sorted_gcds):\n            current_sum += gcd_count[gcd_val]\n            if current_sum > index:\n                answer.append(gcd_val)\n                break\n    \n    return answer\n```"}
{"task_id": "3551", "code": "def max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR array\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ nums[i - 1]\n    \n    # Answer each query\n    result = []\n    for l, r in queries:\n        xor_score = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(xor_score)\n    \n    return result", "passed": false, "raw_code": "```python\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR array\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ nums[i - 1]\n    \n    # Answer each query\n    result = []\n    for l, r in queries:\n        xor_score = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(xor_score)\n    \n    return result\n```"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for q in range(1, Q + 1):\n        p, v = P[q - 1], V[q - 1]\n        for i in range(N, 0, -1):\n            if i >= p:\n                dp[q][i] = (dp[q][i] + dp[q - 1][i]) % MOD\n            if i < p:\n                dp[q][i] = (dp[q][i] + dp[q - 1][p]) % MOD\n    \n    result = sum(dp[Q]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\nfor i in range(Q):\n    p = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    P.append(p)\n    V.append(v)\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)", "passed": false, "raw_code": "```python\ndef count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for q in range(1, Q + 1):\n        p, v = P[q - 1], V[q - 1]\n        for i in range(N, 0, -1):\n            if i >= p:\n                dp[q][i] = (dp[q][i] + dp[q - 1][i]) % MOD\n            if i < p:\n                dp[q][i] = (dp[q][i] + dp[q - 1][p]) % MOD\n    \n    result = sum(dp[Q]) % MOD\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\nfor i in range(Q):\n    p = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    P.append(p)\n    V.append(v)\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)\n```"}
{"task_id": "arc183_c", "code": "def count_valid_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    conditions = []\n    for _ in range(M):\n        L = int(data[index]) - 1\n        R = int(data[index + 1]) - 1\n        X = int(data[index + 2]) - 1\n        conditions.append((L, R, X))\n        index += 3\n    \n    MOD = 998244353\n    \n    # dp[i][j] will store the number of valid permutations of the first i elements\n    # where the element at position j is the maximum in some subarray.\n    dp = [[0] * N for _ in range(N)]\n    \n    # Base case: There's one way to have an empty permutation.\n    dp[0][0] = 1\n    \n    for i in range(1, N):\n        for j in range(i + 1):\n            for k in range(j, i + 1):\n                if k == X:\n                    continue\n                dp[i][j] += dp[i - 1][k]\n                dp[i][j] %= MOD\n    \n    # Sum up all valid configurations for N elements.\n    result = sum(dp[N - 1]) % MOD\n    print(result)\n\ncount_valid_permutations()", "passed": false, "raw_code": "```python\ndef count_valid_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    conditions = []\n    for _ in range(M):\n        L = int(data[index]) - 1\n        R = int(data[index + 1]) - 1\n        X = int(data[index + 2]) - 1\n        conditions.append((L, R, X))\n        index += 3\n    \n    MOD = 998244353\n    \n    # dp[i][j] will store the number of valid permutations of the first i elements\n    # where the element at position j is the maximum in some subarray.\n    dp = [[0] * N for _ in range(N)]\n    \n    # Base case: There's one way to have an empty permutation.\n    dp[0][0] = 1\n    \n    for i in range(1, N):\n        for j in range(i + 1):\n            for k in range(j, i + 1):\n                if k == X:\n                    continue\n                dp[i][j] += dp[i - 1][k]\n                dp[i][j] %= MOD\n    \n    # Sum up all valid configurations for N elements.\n    result = sum(dp[N - 1]) % MOD\n    print(result)\n\ncount_valid_permutations()\n```"}
{"task_id": "3560", "code": "def min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, steps = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return steps\n        \n        for dx, dy in moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[[float('-inf')] * (1 << n) for _ in range(n)] for _ in range(2)]\n    dp[0][0][0] = 0\n    \n    def dfs(player, mask, last_pawn):\n        if mask == (1 << n) - 1:\n            return 0\n        \n        if dp[player][mask][last_pawn] != float('-inf'):\n            return dp[player][mask][last_pawn]\n        \n        max_moves = float('-inf')\n        for i in range(n):\n            if not (mask & (1 << i)):\n                continue\n                # Calculate the number of moves for the current player to capture the pawn\n                moves = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n                new_mask = mask ^ (1 << i)\n                if player == 0:\n                    max_moves = max(max_moves, moves + dfs(1, new_mask, i))\n                else:\n                    max_moves = max(max_moves, moves + dfs(0, new_mask, i))\n        \n        dp[player][mask][last_pawn] = max_moves\n        return max_moves\n    \n    return dfs(0, (1 << n) - 1, -1)\n\n# Example usage:\n# print(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\n# print(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\n# print(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3", "passed": false, "raw_code": "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, steps = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return steps\n        \n        for dx, dy in moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[[float('-inf')] * (1 << n) for _ in range(n)] for _ in range(2)]\n    dp[0][0][0] = 0\n    \n    def dfs(player, mask, last_pawn):\n        if mask == (1 << n) - 1:\n            return 0\n        \n        if dp[player][mask][last_pawn] != float('-inf'):\n            return dp[player][mask][last_pawn]\n        \n        max_moves = float('-inf')\n        for i in range(n):\n            if not (mask & (1 << i)):\n                continue\n                # Calculate the number of moves for the current player to capture the pawn\n                moves = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n                new_mask = mask ^ (1 << i)\n                if player == 0:\n                    max_moves = max(max_moves, moves + dfs(1, new_mask, i))\n                else:\n                    max_moves = max(max_moves, moves + dfs(0, new_mask, i))\n        \n        dp[player][mask][last_pawn] = max_moves\n        return max_moves\n    \n    return dfs(0, (1 << n) - 1, -1)\n\n# Example usage:\n# print(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\n# print(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\n# print(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```"}
{"task_id": "abc368_g", "code": "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    A = list(map(int, data[index:index + N]))\n    index += N\n    B = list(map(int, data[index:index + N]))\n    index += N\n    Q = int(data[index])\n    index += 1\n    \n    max_vals = [[0] * N for _ in range(N)]\n    \n    for i in range(N):\n        max_vals[i][i] = A[i]\n        for j in range(i + 1, N):\n            max_vals[i][j] = max(max_vals[i][j - 1] + A[j], max_vals[i][j - 1] * B[j])\n    \n    for i in range(N):\n        max_vals[i][i] = B[i]\n        for j in range(i + 1, N):\n            max_vals[i][j] = max(max_vals[i][j - 1] + B[j], max_vals[i][j - 1] * A[j])\n    \n    for _ in range(Q):\n        query = data[index]\n        index += 1\n        if query == '1':\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            A[i] = x\n            max_vals[i][i] = A[i]\n            for j in range(i + 1, N):\n                max_vals[i][j] = max(max_vals[i][j - 1] + A[j], max_vals[i][j - 1] * B[j])\n        elif query == '2':\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            B[i] = x\n            max_vals[i][i] = B[i]\n            for j in range(i + 1, N):\n                max_vals[i][j] = max(max_vals[i][j - 1] + B[j], max_vals[i][j - 1] * A[j])\n        elif query == '3':\n            l = int(data[index]) - 1\n            index += 1\n            r = int(data[index]) - 1\n            index += 1\n            print(max(max_vals[l][r], max_vals[l][r - 1]))\n\nprocess_queries()", "passed": false, "raw_code": "```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    A = list(map(int, data[index:index + N]))\n    index += N\n    B = list(map(int, data[index:index + N]))\n    index += N\n    Q = int(data[index])\n    index += 1\n    \n    max_vals = [[0] * N for _ in range(N)]\n    \n    for i in range(N):\n        max_vals[i][i] = A[i]\n        for j in range(i + 1, N):\n            max_vals[i][j] = max(max_vals[i][j - 1] + A[j], max_vals[i][j - 1] * B[j])\n    \n    for i in range(N):\n        max_vals[i][i] = B[i]\n        for j in range(i + 1, N):\n            max_vals[i][j] = max(max_vals[i][j - 1] + B[j], max_vals[i][j - 1] * A[j])\n    \n    for _ in range(Q):\n        query = data[index]\n        index += 1\n        if query == '1':\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            A[i] = x\n            max_vals[i][i] = A[i]\n            for j in range(i + 1, N):\n                max_vals[i][j] = max(max_vals[i][j - 1] + A[j], max_vals[i][j - 1] * B[j])\n        elif query == '2':\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            B[i] = x\n            max_vals[i][i] = B[i]\n            for j in range(i + 1, N):\n                max_vals[i][j] = max(max_vals[i][j - 1] + B[j], max_vals[i][j - 1] * A[j])\n        elif query == '3':\n            l = int(data[index]) - 1\n            index += 1\n            r = int(data[index]) - 1\n            index += 1\n            print(max(max_vals[l][r], max_vals[l][r - 1]))\n\nprocess_queries()\n```"}
{"task_id": "arc182_c", "code": "def count_divisors(n, mod):\n    count = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            power = 0\n            while n % i == 0:\n                n //= i\n                power += 1\n            count *= (power + 1)\n            count %= mod\n    if n > 1:\n        count *= 2\n        count %= mod\n    return count\n\ndef sum_of_scores(N, M, mod):\n    total_sum = 0\n    for i in range(1, M + 1):\n        total_sum += count_divisors(i, mod)\n        total_sum %= mod\n    total_sum **= N\n    total_sum %= mod\n    return total_sum\n\n# Read input\nN, M = map(int, input().split())\n\n# Calculate and print the result\nresult = sum_of_scores(N, M, 998244353)\nprint(result)", "passed": false, "raw_code": "```python\ndef count_divisors(n, mod):\n    count = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            power = 0\n            while n % i == 0:\n                n //= i\n                power += 1\n            count *= (power + 1)\n            count %= mod\n    if n > 1:\n        count *= 2\n        count %= mod\n    return count\n\ndef sum_of_scores(N, M, mod):\n    total_sum = 0\n    for i in range(1, M + 1):\n        total_sum += count_divisors(i, mod)\n        total_sum %= mod\n    total_sum **= N\n    total_sum %= mod\n    return total_sum\n\n# Read input\nN, M = map(int, input().split())\n\n# Calculate and print the result\nresult = sum_of_scores(N, M, 998244353)\nprint(result)\n```"}
{"final_accuracy": "0.00%"}
