{"difficulty": "medium", "num_threads": 32, "temperature": 0.9, "n": 2, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp09__qwen_7b_medium_n_2.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3541", "codes": ["def is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    count = {}\n    \n    for word in message:\n        if word in banned_set:\n            if word in count:\n                count[word] += 1\n                if count[word] >= 2:\n                    return True\n            else:\n                count[word] = 1\n    \n    return False", "def is_spam(message, banned_words):\n    banned_set = set(banned_words)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            word_count[word] = word_count.get(word, 0) + 1\n            if word_count[word] >= 2:\n                return True\n    \n    return False"], "passed": [false, false], "raw_code": ["```python\ndef is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    count = {}\n    \n    for word in message:\n        if word in banned_set:\n            if word in count:\n                count[word] += 1\n                if count[word] >= 2:\n                    return True\n            else:\n                count[word] = 1\n    \n    return False\n```", "```python\ndef is_spam(message, banned_words):\n    banned_set = set(banned_words)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            word_count[word] = word_count.get(word, 0) + 1\n            if word_count[word] >= 2:\n                return True\n    \n    return False\n```"]}
{"task_id": "3485", "codes": ["def maxScore(start, d):\n    adjusted_numbers = sorted([x + d for x in start])\n    return max(adjusted_numbers[i] - adjusted_numbers[i-1] for i in range(1, len(adjusted_numbers)))", "def maxScore(start, d):\n    start.sort()\n    max_score = 0\n    \n    for i in range(len(start) - 1):\n        # Consider both endpoints of the current and next interval\n        diff1 = abs(start[i] + d - start[i + 1])\n        diff2 = abs(start[i] - (start[i + 1] + d))\n        \n        # Update the maximum score with the larger of the two differences\n        max_score = max(max_score, diff1, diff2)\n    \n    return max_score"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(start, d):\n    adjusted_numbers = sorted([x + d for x in start])\n    return max(adjusted_numbers[i] - adjusted_numbers[i-1] for i in range(1, len(adjusted_numbers)))\n```", "```python\ndef maxScore(start, d):\n    start.sort()\n    max_score = 0\n    \n    for i in range(len(start) - 1):\n        # Consider both endpoints of the current and next interval\n        diff1 = abs(start[i] + d - start[i + 1])\n        diff2 = abs(start[i] - (start[i + 1] + d))\n        \n        # Update the maximum score with the larger of the two differences\n        max_score = max(max_score, diff1, diff2)\n    \n    return max_score\n```"]}
{"task_id": "3517", "codes": ["import heapq\n\ndef shortest_path(n, queries):\n    def dijkstra(graph, start, end):\n        distances = [float('inf')] * n\n        distances[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, current_node = heapq.heappop(pq)\n            \n            if current_dist > distances[current_node]:\n                continue\n            \n            for neighbor, weight in graph[current_node]:\n                distance = current_dist + weight\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        \n        return distances[end]\n    \n    graph = [[] for _ in range(n)]\n    for u, v in queries:\n        graph[u].append((v, 1))\n    \n    answer = []\n    for u, v in queries:\n        graph[u].append((v, 1))\n        answer.append(dijkstra(graph, 0, n-1))\n    \n    return answer", "def shortestPath(n, queries):\n    from collections import deque\n    \n    # Initialize the graph with initial roads\n    graph = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        graph[i].append(i + 1)\n    \n    def bfs(start, end):\n        queue = deque([start])\n        visited = set([start])\n        distance = 0\n        \n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                current = queue.popleft()\n                if current == end:\n                    return distance\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            distance += 1\n    \n    results = []\n    for u, v in queries:\n        # Add the new road to the graph\n        graph[u].append(v)\n        \n        # Find the shortest path from 0 to n-1\n        shortest_path_length = bfs(0, n - 1)\n        results.append(shortest_path_length)\n    \n    return results"], "passed": [false, true], "raw_code": ["```python\nimport heapq\n\ndef shortest_path(n, queries):\n    def dijkstra(graph, start, end):\n        distances = [float('inf')] * n\n        distances[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, current_node = heapq.heappop(pq)\n            \n            if current_dist > distances[current_node]:\n                continue\n            \n            for neighbor, weight in graph[current_node]:\n                distance = current_dist + weight\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n        \n        return distances[end]\n    \n    graph = [[] for _ in range(n)]\n    for u, v in queries:\n        graph[u].append((v, 1))\n    \n    answer = []\n    for u, v in queries:\n        graph[u].append((v, 1))\n        answer.append(dijkstra(graph, 0, n-1))\n    \n    return answer\n```", "```python\ndef shortestPath(n, queries):\n    from collections import deque\n    \n    # Initialize the graph with initial roads\n    graph = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        graph[i].append(i + 1)\n    \n    def bfs(start, end):\n        queue = deque([start])\n        visited = set([start])\n        distance = 0\n        \n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                current = queue.popleft()\n                if current == end:\n                    return distance\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            distance += 1\n    \n    results = []\n    for u, v in queries:\n        # Add the new road to the graph\n        graph[u].append(v)\n        \n        # Find the shortest path from 0 to n-1\n        shortest_path_length = bfs(0, n - 1)\n        results.append(shortest_path_length)\n    \n    return results\n```"]}
{"task_id": "3522", "codes": ["def find_subarray_power(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if all(subarray[j] == subarray[j - 1] + 1 for j in range(1, k)) and subarray == sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def findPowerOfSubarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if sorted_subarray == list(range(sorted_subarray[0], sorted_subarray[-1] + 1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results"], "passed": [true, false], "raw_code": ["```python\ndef find_subarray_power(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if all(subarray[j] == subarray[j - 1] + 1 for j in range(1, k)) and subarray == sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef findPowerOfSubarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if sorted_subarray == list(range(sorted_subarray[0], sorted_subarray[-1] + 1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```"]}
{"task_id": "3540", "codes": ["def hash_string(s: str, k: int) -> str:\n    result = []\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        total_hash = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = total_hash % 26\n        result += chr(hashed_char + ord('a'))\n    return result"], "passed": [true, true], "raw_code": ["```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        total_hash = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = total_hash % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```"]}
{"task_id": "abc366_c", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    results = []\n    \n    index = 0\n    for _ in range(Q):\n        query = queries[index]\n        index += 1\n        \n        if query[0] == '1':\n            x = int(query[2:])\n            bag.add(x)\n        elif query[0] == '2':\n            x = int(query[2:])\n            bag.remove(x)\n        elif query[0] == '3':\n            results.append(str(len(bag)))\n    \n    for result in results:\n        print(result)\n\nprocess_queries()", "```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    results = []\n    \n    index = 0\n    for _ in range(Q):\n        query_type = int(queries[index])\n        if query_type == 1:\n            x = int(queries[index + 1])\n            bag.add(x)\n        elif query_type == 2:\n            x = int(queries[index + 1])\n            bag.remove(x)\n        elif query_type == 3:\n            results.append(len(bag))\n        index += 2\n    \n    for result in results:\n        print(result)\n\n# Call the function\nprocess_queries()"]}
{"task_id": "3526", "codes": ["def minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_to_palindrome(arr):\n        return sum(a != b for a, b in zip(arr, arr[::-1]))\n    \n    row_flips = [flips_to_palindrome(row) for row in grid]\n    col_flips = [flips_to_palindrome([grid[i][j] for i in range(m)]) for j in range(n)]\n    \n    min_flips_rows = min(row_flips) + (m - sum(1 for row in grid if row == [row[0]] * n))\n    min_flips_cols = min(col_flips) + (n - sum(1 for col in zip(*grid) if col == [col[0]] * m))\n    \n    return min(min_flips_rows, min_flips_cols)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range(n // 2) if row[i] != row[-i - 1])\n    \n    def flips_for_column(col):\n        return sum(1 for i in range(m // 2) if grid[i][col] != grid[-i - 1][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_columns = sum(flips_for_column(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_columns)"], "passed": [false, true], "raw_code": ["```python\ndef minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_to_palindrome(arr):\n        return sum(a != b for a, b in zip(arr, arr[::-1]))\n    \n    row_flips = [flips_to_palindrome(row) for row in grid]\n    col_flips = [flips_to_palindrome([grid[i][j] for i in range(m)]) for j in range(n)]\n    \n    min_flips_rows = min(row_flips) + (m - sum(1 for row in grid if row == [row[0]] * n))\n    min_flips_cols = min(col_flips) + (n - sum(1 for col in zip(*grid) if col == [col[0]] * m))\n    \n    return min(min_flips_rows, min_flips_cols)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range(n // 2) if row[i] != row[-i - 1])\n    \n    def flips_for_column(col):\n        return sum(1 for i in range(m // 2) if grid[i][col] != grid[-i - 1][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_columns = sum(flips_for_column(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_columns)\n```"]}
{"task_id": "abc369_d", "codes": ["d", "def max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Sort the strengths in descending order\n    A.sort(reverse=True)\n    \n    max_points = 0\n    \n    for i in range(N):\n        if (i + 1) % 2 == 0:\n            max_points += A[i] * 2\n        else:\n            max_points += A[i]\n    \n    print(max_points)\n\nmax_experience_points()"], "passed": [false, false], "raw_code": ["```python\ndef max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Sort the monsters by their strength\n    A.sort()\n    \n    # Initialize variables to track the total experience points and the number of defeated monsters\n    total_points = 0\n    defeated_count = 0\n    \n    for i in range(N):\n        strength = A[i]\n        \n        # Calculate the experience points if we defeat this monster\n        points_if_defeat = strength * (1 + (i // 2))\n        \n        # Calculate the experience points if we let this monster go\n        points_if_let_go = 0\n        \n        # Decide whether to defeat or let go based on the cumulative points\n        if total_points + points_if_defeat >= total_points + points_if_let_go:\n            total_points += points_if_defeat\n            defeated_count += 1\n    \n    print(total_points)\n\n# Call the function to execute\nmax_experience_points()", "```python\ndef max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Sort the strengths in descending order\n    A.sort(reverse=True)\n    \n    max_points = 0\n    \n    for i in range(N):\n        if (i + 1) % 2 == 0:\n            max_points += A[i] * 2\n        else:\n            max_points += A[i]\n    \n    print(max_points)\n\nmax_experience_points()\n```"]}
{"task_id": "abc372_d", "codes": ["d", "def count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    result = []\n    \n    for i in range(N):\n        count = 0\n        max_height = -1\n        for j in range(i + 1, N):\n            if heights[j] <= heights[i]:\n                count += 1\n                max_height = heights[j]\n            elif heights[j] > max_height:\n                break\n        result.append(count)\n    \n    print(' '.join(map(str, result)))\n\ncount_valid_buildings()"], "passed": [false, false], "raw_code": ["```python\ndef count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    # Stack to keep track of building indices\n    stack = []\n    # Result array to store the count of valid buildings to the right for each building\n    result = [0] * N\n    \n    for i in range(N):\n        # Pop elements from the stack while the current building is taller or equal\n        while stack and heights[i] >= heights[stack[-1]]:\n            prev_index = stack.pop()\n            result[prev_index] = i - prev_index\n        \n        # Push the current building's index onto the stack\n        stack.append(i)\n    \n    # Any remaining indices in the stack have counts of zero\n    for idx in stack:\n        result[idx] = N - idx\n    \n    # Print the results\n    print(' '.join(map(str, result)))\n\n# Call the function to execute\ncount_valid_buildings()", "```python\ndef count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    result = []\n    \n    for i in range(N):\n        count = 0\n        max_height = -1\n        for j in range(i + 1, N):\n            if heights[j] <= heights[i]:\n                count += 1\n                max_height = heights[j]\n            elif heights[j] > max_height:\n                break\n        result.append(count)\n    \n    print(' '.join(map(str, result)))\n\ncount_valid_buildings()\n```"]}
{"task_id": "abc367_d", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    # Calculate prefix sums\n    prefix = [0]\n    current_sum = 0\n    for i in range(N):\n        current_sum += A[i]\n        prefix.append(current_sum)\n    \n    # Dictionary to store frequency of remainders\n    remainder_count = {0: 1}\n    result = 0\n    \n    for i in range(1, N + 1):\n        remainder = prefix[i] % M\n        target_remainder = (remainder * M) % M\n        \n        if target_remainder in remainder_count:\n            result += remainder_count[target_remainder]\n        \n        if remainder in remainder_count:\n            remainder_count[remainder] += 1\n        else:\n            remainder_count[remainder] = 1\n    \n    print(result)\n\n# Call the function to execute\ncount_valid_pairs()", "```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    # Calculate prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    # Initialize counter for valid pairs\n    count = 0\n    \n    # Iterate over all pairs (i, j) where i < j\n    for i in range(N):\n        for j in range(i + 1, N):\n            diff = prefix_sum[j] - prefix_sum[i]\n            if diff % M == 0:\n                count += 1\n    \n    # Print the result\n    print(count)\n\n# Call the function\ncount_valid_pairs()"]}
{"task_id": "3525", "codes": ["def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    \n    dp_no_switch = [0] * n\n    dp_switch = [0] * n\n    \n    dp_no_switch[0] = max(energyDrinkA[0], energyDrinkB[0])\n    dp_switch[0] = 0\n    \n    for i in range(1, n):\n        dp_no_switch[i] = max(dp_no_switch[i-1], dp_switch[i-1]) + max(energyDrinkA[i], energyDrinkB[i])\n        dp_switch[i] = dp_no_switch[i-1] + max(energyDrinkB[i], energyDrinkA[i])\n    \n    return max(dp_no_switch[-1], dp_switch[-1])", "def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_same = [0] * n\n    dp_switch = [0] * n\n    \n    dp_same[0] = max(energyDrinkA[0], energyDrinkB[0])\n    dp_switch[0] = 0\n    \n    for i in range(1, n):\n        dp_same[i] = max(dp_same[i-1] + energyDrinkA[i], dp_switch[i-1] + energyDrinkA[i])\n        dp_switch[i] = max(dp_same[i-1] + energyDrinkB[i], dp_switch[i-1] + energyDrinkB[i])\n    \n    return max(dp_same[n-1], dp_switch[n-1])"], "passed": [false, false], "raw_code": ["```python\ndef maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    \n    dp_no_switch = [0] * n\n    dp_switch = [0] * n\n    \n    dp_no_switch[0] = max(energyDrinkA[0], energyDrinkB[0])\n    dp_switch[0] = 0\n    \n    for i in range(1, n):\n        dp_no_switch[i] = max(dp_no_switch[i-1], dp_switch[i-1]) + max(energyDrinkA[i], energyDrinkB[i])\n        dp_switch[i] = dp_no_switch[i-1] + max(energyDrinkB[i], energyDrinkA[i])\n    \n    return max(dp_no_switch[-1], dp_switch[-1])\n```", "```python\ndef maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_same = [0] * n\n    dp_switch = [0] * n\n    \n    dp_same[0] = max(energyDrinkA[0], energyDrinkB[0])\n    dp_switch[0] = 0\n    \n    for i in range(1, n):\n        dp_same[i] = max(dp_same[i-1] + energyDrinkA[i], dp_switch[i-1] + energyDrinkA[i])\n        dp_switch[i] = max(dp_same[i-1] + energyDrinkB[i], dp_switch[i-1] + energyDrinkB[i])\n    \n    return max(dp_same[n-1], dp_switch[n-1])\n```"]}
{"task_id": "3518", "codes": ["def maxScore(a, b):\n    # Calculate the products of each coefficient in a with each element in b\n    products = [(a[0] * b_i, a[1] * b_j, a[2] * b_k, a[3] * b_l) for b_i, b_j, b_k, b_l in zip(b, b[1:], b[2:], b[3:])]\n    \n    # Flatten the list of tuples into a single list of products\n    flat_products = [prod for sublist in products for prod in sublist]\n    \n    # Sort the products based on their absolute values in descending order\n    sorted_products = sorted(flat_products, key=abs, reverse=True)\n    \n    # Select the top four largest products\n    top_four_products = sorted_products[:4]\n    \n    # Sum these products to get the maximum score\n    return sum(top_four_products)", "def maxScore(a, b):\n    b.sort()\n    score = 0\n    for x in a:\n        index = bisect.bisect_left(b, x)\n        if index < len(b):\n            score += x * b[index]\n            b.pop(index)\n        else:\n            return float('-inf')\n    return score"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(a, b):\n    # Calculate the products of each coefficient in a with each element in b\n    products = [(a[0] * b_i, a[1] * b_j, a[2] * b_k, a[3] * b_l) for b_i, b_j, b_k, b_l in zip(b, b[1:], b[2:], b[3:])]\n    \n    # Flatten the list of tuples into a single list of products\n    flat_products = [prod for sublist in products for prod in sublist]\n    \n    # Sort the products based on their absolute values in descending order\n    sorted_products = sorted(flat_products, key=abs, reverse=True)\n    \n    # Select the top four largest products\n    top_four_products = sorted_products[:4]\n    \n    # Sum these products to get the maximum score\n    return sum(top_four_products)\n```", "```python\ndef maxScore(a, b):\n    b.sort()\n    score = 0\n    for x in a:\n        index = bisect.bisect_left(b, x)\n        if index < len(b):\n            score += x * b[index]\n            b.pop(index)\n        else:\n            return float('-inf')\n    return score\n```"]}
{"task_id": "abc365_c", "codes": ["def max_subsidy_limit(N, M, A):\n    # Check if the budget allows an infinite subsidy\n    if sum(min(a, 1) for a in A) > M:\n        return \"infinite\"\n    \n    # Initialize binary search bounds\n    low, high = 0, max(A)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        total_subsidy = sum(min(a, mid) for a in A)\n        \n        if total_subsidy <= M:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Call the function to get the result\nresult = max_subsidy_limit(*map(int, input().split()), [int(x) for x in input().split()])\nprint(result)", "d"], "passed": [false, false], "raw_code": ["```python\ndef max_subsidy_limit(N, M, A):\n    # Check if the budget allows an infinite subsidy\n    if sum(min(a, 1) for a in A) > M:\n        return \"infinite\"\n    \n    # Initialize binary search bounds\n    low, high = 0, max(A)\n    \n    while low < high:\n        mid = (low + high + 1) // 2\n        total_subsidy = sum(min(a, mid) for a in A)\n        \n        if total_subsidy <= M:\n            low = mid\n        else:\n            high = mid - 1\n    \n    return low\n\n# Call the function to get the result\nresult = max_subsidy_limit(*map(int, input().split()), [int(x) for x in input().split()])\nprint(result)\n```", "```python\ndef max_subsidy_limit():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    def can_subsidize(max_x):\n        prefix_sum = 0\n        for a in A:\n            prefix_sum += min(a, max_x)\n            if prefix_sum > M:\n                return False\n        return True\n    \n    low, high = 0, max(A)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_subsidize(mid):\n            low = mid\n        else:\n            high = mid - 1\n    \n    if can_subsidize(low):\n        print(low)\n    else:\n        print(\"infinite\")\n\n# Call the function to execute it\nmax_subsidy_limit()"]}
{"task_id": "3534", "codes": ["def count_almost_equal_pairs(nums):\n    def generate_swapped_numbers(num):\n        num_str = str(num)\n        n = len(num_str)\n        swapped_set = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                swapped_num_str = list(num_str)\n                swapped_num_str[i], swapped_num_str[j] = swapped_num_str[j], swapped_num_str[i]\n                swapped_set.add(int(''.join(swapped_num_str)))\n        return swapped_set\n    \n    count = 0\n    swapped_sets = [generate_swapped_numbers(num) for num in nums]\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if any(swap in swapped_sets[j] for swap in swapped_sets[i]):\n                count += 1\n                \n    return count", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    # Create new numbers by swapping digits\n                    swapped_num1 = num1[:k] + num1[l] + num1[k+1:l] + num1[k] + num1[l+1:]\n                    swapped_num2 = num2[:k] + num2[l] + num2[k+1:l] + num2[k] + num2[l+1:]\n                    \n                    # Check if the swapped numbers are equal\n                    if int(swapped_num1) == int(swapped_num2):\n                        count += 1\n                        \n    return count"], "passed": [false, false], "raw_code": ["```python\ndef count_almost_equal_pairs(nums):\n    def generate_swapped_numbers(num):\n        num_str = str(num)\n        n = len(num_str)\n        swapped_set = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                swapped_num_str = list(num_str)\n                swapped_num_str[i], swapped_num_str[j] = swapped_num_str[j], swapped_num_str[i]\n                swapped_set.add(int(''.join(swapped_num_str)))\n        return swapped_set\n    \n    count = 0\n    swapped_sets = [generate_swapped_numbers(num) for num in nums]\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if any(swap in swapped_sets[j] for swap in swapped_sets[i]):\n                count += 1\n                \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    # Create new numbers by swapping digits\n                    swapped_num1 = num1[:k] + num1[l] + num1[k+1:l] + num1[k] + num1[l+1:]\n                    swapped_num2 = num2[:k] + num2[l] + num2[k+1:l] + num2[k] + num2[l+1:]\n                    \n                    # Check if the swapped numbers are equal\n                    if int(swapped_num1) == int(swapped_num2):\n                        count += 1\n                        \n    return count\n```"]}
{"task_id": "abc367_c", "codes": ["def find_sequences(N, K, R):\n    def backtrack(position, current_sequence, current_sum):\n        if position == N:\n            if current_sum % K == 0:\n                result.append(current_sequence[:])\n            return\n        \n        for value in range(1, R[position] + 1):\n            current_sequence[position] = value\n            backtrack(position + 1, current_sequence, current_sum + value)\n    \n    result = []\n    current_sequence = [0] * N\n    backtrack(0, current_sequence, 0)\n    \n    # Sort the result in lexicographical order\n    result.sort()\n    \n    # Print the result\n    print(len(result))\n    for seq in result:\n        print(' '.join(map(str, seq)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nR = list(map(int, data[2:]))\n\nfind_sequences(N, K, R)", "d"], "passed": [false, false], "raw_code": ["```python\ndef find_sequences(N, K, R):\n    def backtrack(position, current_sequence, current_sum):\n        if position == N:\n            if current_sum % K == 0:\n                result.append(current_sequence[:])\n            return\n        \n        for value in range(1, R[position] + 1):\n            current_sequence[position] = value\n            backtrack(position + 1, current_sequence, current_sum + value)\n    \n    result = []\n    current_sequence = [0] * N\n    backtrack(0, current_sequence, 0)\n    \n    # Sort the result in lexicographical order\n    result.sort()\n    \n    # Print the result\n    print(len(result))\n    for seq in result:\n        print(' '.join(map(str, seq)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nR = list(map(int, data[2:]))\n\nfind_sequences(N, K, R)\n```", "```python\ndef generate_sequences(N, K, R, current, current_sum, start):\n    if N == 0:\n        if current_sum % K == 0:\n            print(\" \".join(map(str, current)))\n        return\n    \n    for i in range(start, R[N-1] + 1):\n        current.append(i)\n        generate_sequences(N-1, K, R, current, current_sum + i, i)\n        current.pop()\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    R = list(map(int, data[2:]))\n    \n    generate_sequences(N, K, R, [], 0, 1)\n\nif __name__ == \"__main__\":\n    main()"]}
{"task_id": "3558", "codes": ["def hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(i, j, health):\n        if i < 0 or i >= m or j < 0 or j >= n or health <= 0:\n            return False\n        if i == m - 1 and j == n - 1:\n            return health >= 1\n        temp = grid[i][j]\n        grid[i][j] = -1  # Mark as visited\n        result = dfs(i + 1, j, health - temp) or \\\n                 dfs(i - 1, j, health - temp) or \\\n                 dfs(i, j + 1, health - temp) or \\\n                 dfs(i, j - 1, health - temp)\n        grid[i][j] = temp  # Unmark\n        return result\n    \n    return dfs(0, 0, health)", "def hasPath(grid, health):\n    def dfs(x, y, health):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or health <= 0:\n            return False\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if dfs(x + dx, y + dy, health - temp):\n                return True\n        grid[x][y] = temp\n        return False\n\n    return dfs(0, 0, health)"], "passed": [false, false], "raw_code": ["```python\ndef hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(i, j, health):\n        if i < 0 or i >= m or j < 0 or j >= n or health <= 0:\n            return False\n        if i == m - 1 and j == n - 1:\n            return health >= 1\n        temp = grid[i][j]\n        grid[i][j] = -1  # Mark as visited\n        result = dfs(i + 1, j, health - temp) or \\\n                 dfs(i - 1, j, health - temp) or \\\n                 dfs(i, j + 1, health - temp) or \\\n                 dfs(i, j - 1, health - temp)\n        grid[i][j] = temp  # Unmark\n        return result\n    \n    return dfs(0, 0, health)\n```", "```python\ndef hasPath(grid, health):\n    def dfs(x, y, health):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or health <= 0:\n            return False\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if dfs(x + dx, y + dy, health - temp):\n                return True\n        grid[x][y] = temp\n        return False\n\n    return dfs(0, 0, health)\n```"]}
{"task_id": "3496", "codes": ["def minimumTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum((time // (worker * (i + 1))) for i, worker in enumerate(workerTimes)) >= height\n    \n    left, right = 0, max(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def minimumTime(mountainHeight, workerTimes):\n    def canReduce(seconds):\n        remainingHeight = mountainHeight\n        for time in workerTimes:\n            for x in range(1, seconds // time + 1):\n                if time * (x * (x + 1) // 2) <= seconds:\n                    remainingHeight -= x\n                    if remainingHeight <= 0:\n                        break\n            if remainingHeight <= 0:\n                break\n        return remainingHeight <= 0\n    \n    left, right = 0, mountainHeight * sum(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left"], "passed": [false, false], "raw_code": ["```python\ndef minimumTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum((time // (worker * (i + 1))) for i, worker in enumerate(workerTimes)) >= height\n    \n    left, right = 0, max(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```", "```python\ndef minimumTime(mountainHeight, workerTimes):\n    def canReduce(seconds):\n        remainingHeight = mountainHeight\n        for time in workerTimes:\n            for x in range(1, seconds // time + 1):\n                if time * (x * (x + 1) // 2) <= seconds:\n                    remainingHeight -= x\n                    if remainingHeight <= 0:\n                        break\n            if remainingHeight <= 0:\n                break\n        return remainingHeight <= 0\n    \n    left, right = 0, mountainHeight * sum(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```"]}
{"task_id": "abc365_d", "codes": ["d", "def max_wins(N, S):\n    # Initialize variables\n    takahashi_move = 'P'  # Starting with Paper to maximize wins against Rock\n    wins = 0\n    \n    for move in S:\n        if takahashi_move == 'P':\n            if move == 'R':\n                takahashi_move = 'S'\n                wins += 1\n            elif move == 'S':\n                takahashi_move = 'R'\n                wins += 1\n        elif takahashi_move == 'R':\n            if move == 'S':\n                takahashi_move = 'P'\n                wins += 1\n            elif move == 'P':\n                takahashi_move = 'S'\n                wins += 1\n        elif takahashi_move == 'S':\n            if move == 'P':\n                takahashi_move = 'R'\n                wins += 1\n            elif move == 'R':\n                takahashi_move = 'P'\n                wins += 1\n        \n        # Alternate Takahashi's move\n        if takahashi_move == 'P':\n            takahashi_move = 'R'\n        elif takahashi_move == 'R':\n            takahashi_move = 'S'\n        elif takahashi_move == 'S':\n            takahashi_move = 'P'\n    \n    return wins\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Calculate and print the result\nprint(max_wins(N, S))"], "passed": [false, false], "raw_code": ["```python\ndef max_wins(N, S):\n    # Initialize variables\n    last_move = None\n    wins = 0\n    \n    # Iterate through Aoki's moves\n    for move in S:\n        if move == 'R':\n            if last_move != 'P':\n                last_move = 'P'\n                wins += 1\n            elif last_move != 'S':\n                last_move = 'S'\n                wins += 1\n        elif move == 'P':\n            if last_move != 'R':\n                last_move = 'R'\n                wins += 1\n            elif last_move != 'S':\n                last_move = 'S'\n                wins += 1\n        elif move == 'S':\n            if last_move != 'R':\n                last_move = 'R'\n                wins += 1\n            elif last_move != 'P':\n                last_move = 'P'\n                wins += 1\n    \n    return wins\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Calculate and print the result\nresult = max_wins(N, S)\nprint(result)", "```python\ndef max_wins(N, S):\n    # Initialize variables\n    takahashi_move = 'P'  # Starting with Paper to maximize wins against Rock\n    wins = 0\n    \n    for move in S:\n        if takahashi_move == 'P':\n            if move == 'R':\n                takahashi_move = 'S'\n                wins += 1\n            elif move == 'S':\n                takahashi_move = 'R'\n                wins += 1\n        elif takahashi_move == 'R':\n            if move == 'S':\n                takahashi_move = 'P'\n                wins += 1\n            elif move == 'P':\n                takahashi_move = 'S'\n                wins += 1\n        elif takahashi_move == 'S':\n            if move == 'P':\n                takahashi_move = 'R'\n                wins += 1\n            elif move == 'R':\n                takahashi_move = 'P'\n                wins += 1\n        \n        # Alternate Takahashi's move\n        if takahashi_move == 'P':\n            takahashi_move = 'R'\n        elif takahashi_move == 'R':\n            takahashi_move = 'S'\n        elif takahashi_move == 'S':\n            takahashi_move = 'P'\n    \n    return wins\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Calculate and print the result\nprint(max_wins(N, S))\n```"]}
{"task_id": "3559", "codes": ["def minimumConcatenatedWords(words, target):\n    words.sort(key=len, reverse=True)\n    trie = {}\n\n    for word in words:\n        node = trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['#'] = word\n\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(n):\n        node = trie\n        for j in range(i, -1, -1):\n            if '#' in node:\n                dp[j + len(node['#'])] = min(dp[j + len(node['#'])], dp[j] + 1)\n            if target[j] not in node:\n                break\n            node = node[target[j]]\n\n    return dp[n] if dp[n] != float('inf') else -1", "def minValidStrings(words, target):\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(n):\n        for word in words:\n            if i + 1 >= len(word) and target[i - len(word) + 1:i + 1] == word:\n                dp[i + 1] = min(dp[i + 1], dp[i - len(word) + 1] + 1)\n    \n    return dp[n] if dp[n] != float('inf') else -1"], "passed": [false, false], "raw_code": ["```python\ndef minimumConcatenatedWords(words, target):\n    words.sort(key=len, reverse=True)\n    trie = {}\n\n    for word in words:\n        node = trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['#'] = word\n\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(n):\n        node = trie\n        for j in range(i, -1, -1):\n            if '#' in node:\n                dp[j + len(node['#'])] = min(dp[j + len(node['#'])], dp[j] + 1)\n            if target[j] not in node:\n                break\n            node = node[target[j]]\n\n    return dp[n] if dp[n] != float('inf') else -1\n```", "```python\ndef minValidStrings(words, target):\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(n):\n        for word in words:\n            if i + 1 >= len(word) and target[i - len(word) + 1:i + 1] == word:\n                dp[i + 1] = min(dp[i + 1], dp[i - len(word) + 1] + 1)\n    \n    return dp[n] if dp[n] != float('inf') else -1\n```"]}
{"task_id": "3579", "codes": ["def maximumNumber(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings by length in descending order and lexicographically in reverse order within the same length\n    sorted_binary_nums = sorted(binary_nums, key=lambda x: (-len(x), x[::-1]))\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(sorted_binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def largestNumber(nums):\n    def compare(a, b):\n        return int(b + a) - int(a + b)\n    \n    nums = sorted(nums, key=functools.cmp_to_key(compare))\n    return int(\"\".join(map(str, nums)), 2)"], "passed": [false, false], "raw_code": ["```python\ndef maximumNumber(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings by length in descending order and lexicographically in reverse order within the same length\n    sorted_binary_nums = sorted(binary_nums, key=lambda x: (-len(x), x[::-1]))\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(sorted_binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef largestNumber(nums):\n    def compare(a, b):\n        return int(b + a) - int(a + b)\n    \n    nums = sorted(nums, key=functools.cmp_to_key(compare))\n    return int(\"\".join(map(str, nums)), 2)\n```"]}
{"task_id": "3573", "codes": ["from collections import Counter\n\ndef countValidSubstrings(word1, word2):\n    count = 0\n    len2 = len(word2)\n    for i in range(len(word1) - len2 + 1):\n        substring = word1[i:i + len2]\n        if Counter(substring) >= Counter(word2):\n            count += 1\n    return count", "def countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    count2 = Counter(word2)\n    len2 = len(word2)\n    count1 = Counter()\n    left = 0\n    result = 0\n    \n    for right in range(len(word1)):\n        count1[word1[right]] += 1\n        \n        # Maintain the window size to be at least the length of word2\n        while right - left + 1 > len2:\n            count1[word1[left]] -= 1\n            if count1[word1[left]] == 0:\n                del count1[word1[left]]\n            left += 1\n        \n        # Check if the current window can form word2 as a prefix\n        if count1 >= count2:\n            result += len2\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\nfrom collections import Counter\n\ndef countValidSubstrings(word1, word2):\n    count = 0\n    len2 = len(word2)\n    for i in range(len(word1) - len2 + 1):\n        substring = word1[i:i + len2]\n        if Counter(substring) >= Counter(word2):\n            count += 1\n    return count\n```", "```python\ndef countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    count2 = Counter(word2)\n    len2 = len(word2)\n    count1 = Counter()\n    left = 0\n    result = 0\n    \n    for right in range(len(word1)):\n        count1[word1[right]] += 1\n        \n        # Maintain the window size to be at least the length of word2\n        while right - left + 1 > len2:\n            count1[word1[left]] -= 1\n            if count1[word1[left]] == 0:\n                del count1[word1[left]]\n            left += 1\n        \n        # Check if the current window can form word2 as a prefix\n        if count1 >= count2:\n            result += len2\n    \n    return result\n```"]}
{"task_id": "abc371_d", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    X = [0] * N\n    P = [0] * N\n    for i in range(N):\n        X[i] = int(data[index])\n        P[i] = int(data[index + 1])\n        index += 2\n    \n    Q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(Q):\n        L = int(data[index])\n        R = int(data[index + 1])\n        queries.append((L, R))\n        index += 2\n    \n    # Create prefix sum array\n    prefix_sum = [0] * (N + 1)\n    cumulative_population = 0\n    for i in range(N):\n        cumulative_population += P[i]\n        prefix_sum[i + 1] = cumulative_population\n    \n    # Answer each query\n    for L, R in queries:\n        left_index = next(i for i in range(N) if X[i] >= L)\n        right_index = next(i for i in range(N) if X[i] > R)\n        if left_index == right_index:\n            print(0)\n        else:\n            print(prefix_sum[right_index] - prefix_sum[left_index])\n\n# Call the main function\nif __name__ == \"__main__\":\n    main()", "```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read N\n    N = int(data[index])\n    index += 1\n    \n    # Read X values\n    X = [int(data[index]) for _ in range(N)]\n    index += N\n    \n    # Read P values\n    P = [int(data[index]) for _ in range(N)]\n    index += N\n    \n    # Read Q\n    Q = int(data[index])\n    index += 1\n    \n    # Calculate prefix sums\n    prefix_sum = [0]\n    current_sum = 0\n    for p in P:\n        current_sum += p\n        prefix_sum.append(current_sum)\n    \n    # Process each query\n    for _ in range(Q):\n        L = int(data[index])\n        R = int(data[index + 1])\n        index += 2\n        \n        # Query result\n        result = prefix_sum[R + 1] - prefix_sum[L]\n        print(result)\n\n# Call the function\nprocess_queries()"]}
{"task_id": "abc372_c", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    S = data[2]\n    \n    # Initialize counters for substrings that can potentially become \"ABC\"\n    a_count = [0] * (N + 1)\n    ab_count = [0] * (N + 1)\n    abc_count = [0] * (N + 1)\n    \n    # Initial counts\n    for i in range(N):\n        if S[i] == 'A':\n            a_count[i + 1] = a_count[i] + 1\n            ab_count[i + 1] = ab_count[i]\n            abc_count[i + 1] = abc_count[i]\n        elif S[i] == 'B':\n            a_count[i + 1] = a_count[i]\n            ab_count[i + 1] = ab_count[i] + a_count[i]\n            abc_count[i + 1] = abc_count[i]\n        elif S[i] == 'C':\n            a_count[i + 1] = a_count[i]\n            ab_count[i + 1] = ab_count[i]\n            abc_count[i + 1] = abc_count[i] + ab_count[i]\n    \n    # Process each query\n    result = []\n    index = 6\n    for _ in range(Q):\n        X = int(data[index]) - 1\n        C = data[index + 1]\n        index += 2\n        \n        old_char = S[X]\n        new_char = C\n        \n        # Update counts based on the old character\n        if old_char == 'A':\n            a_count[X + 1] -= 1\n            ab_count[X + 1] -= a_count[X]\n            abc_count[X + 1] -= ab_count[X]\n        elif old_char == 'B':\n            ab_count[X + 1] -= a_count[X]\n            abc_count[X + 1] -= ab_count[X]\n        elif old_char == 'C':\n            abc_count[X + 1] -= ab_count[X]\n        \n        # Update counts based on the new character\n        if new_char == 'A':\n            a_count[X + 1] += 1\n            ab_count[X + 1] += a_count[X]\n            abc_count[X + 1] += ab_count[X]\n        elif new_char == 'B':\n            ab_count[X + 1] += a_count[X]\n            abc_count[X + 1] += ab_count[X]\n        elif new_char == 'C':\n            abc_count[X + 1] += ab_count[X]\n        \n        # Append the current count of \"ABC\" substrings\n        result.append(abc_count[-1])\n    \n    # Print all results\n    for r in result:\n        print(r)\n\n# Call the function\nprocess_queries()", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    S = data[2]\n    queries = [(int(data[2 + 2 * i]), data[2 + 2 * i + 1]) for i in range(Q)]\n    \n    # Initial counts\n    count_A = sum(1 for char in S if char == 'A')\n    count_AB = sum(S[i] == 'B' and S[i - 1] == 'A' for i in range(1, N))\n    count_ABC = sum(S[i] == 'C' and S[i - 1] == 'B' and S[i - 2] == 'A' for i in range(2, N))\n    \n    results = []\n    for X, C in queries:\n        X -= 1  # Convert to 0-indexed\n        \n        old_char = S[X]\n        \n        # Update counts based on the old character\n        if old_char == 'A':\n            count_A -= 1\n        elif old_char == 'B':\n            count_B -= 1\n        elif old_char == 'C':\n            count_C -= 1\n        \n        # Update counts based on the new character\n        if C == 'A':\n            count_A += 1\n            if X > 0 and S[X - 1] == 'B':\n                count_AB += 1\n                if X > 1 and S[X - 2] == 'A':\n                    count_ABC += 1\n        elif C == 'B':\n            count_B += 1\n            if X > 0 and S[X - 1] == 'A':\n                count_AB += 1\n        elif C == 'C':\n            count_C += 1\n            if X > 0 and S[X - 1] == 'B':\n                count_ABC += 1\n        \n        # Add the current count of ABC to results\n        results.append(count_ABC)\n        \n        # Update the string\n        S = S[:X] + C + S[X + 1:]\n    \n    for result in results:\n        print(result)\n\nmain()"]}
{"task_id": "3570", "codes": ["def countSubstrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        seen_vowels = set()\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            \n            if char in vowels:\n                seen_vowels.add(char)\n            else:\n                consonant_count += 1\n            \n            # Check if all vowels are present and exactly k consonants\n            if len(seen_vowels) == 5 and consonant_count == k:\n                count += 1\n                \n    return count", "def countSubstrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    vowel_count = [0] * (n + 1)\n    consonant_count = [0] * (n + 1)\n    \n    # Count vowels and consonants up to each index\n    for i in range(n):\n        vowel_count[i + 1] = vowel_count[i]\n        consonant_count[i + 1] = consonant_count[i]\n        if word[i] in vowels:\n            vowel_count[i + 1] += 1\n    \n    def has_all_vowels(vowel_count, left, right):\n        return len({i for i in range(5) if vowel_count[right + 1] - vowel_count[left] >= 1}) == 5\n    \n    result = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if has_all_vowels(vowel_count, i, j) and (consonant_count[j + 1] - consonant_count[i]) == k:\n                result += 1\n                \n    return result"], "passed": [true, false], "raw_code": ["```python\ndef countSubstrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        seen_vowels = set()\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            \n            if char in vowels:\n                seen_vowels.add(char)\n            else:\n                consonant_count += 1\n            \n            # Check if all vowels are present and exactly k consonants\n            if len(seen_vowels) == 5 and consonant_count == k:\n                count += 1\n                \n    return count\n```", "```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    vowel_count = [0] * (n + 1)\n    consonant_count = [0] * (n + 1)\n    \n    # Count vowels and consonants up to each index\n    for i in range(n):\n        vowel_count[i + 1] = vowel_count[i]\n        consonant_count[i + 1] = consonant_count[i]\n        if word[i] in vowels:\n            vowel_count[i + 1] += 1\n    \n    def has_all_vowels(vowel_count, left, right):\n        return len({i for i in range(5) if vowel_count[right + 1] - vowel_count[left] >= 1}) == 5\n    \n    result = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if has_all_vowels(vowel_count, i, j) and (consonant_count[j + 1] - consonant_count[i]) == k:\n                result += 1\n                \n    return result\n```"]}
{"task_id": "abc373_c", "codes": ["def max_sum_of_arrays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    \n    A.sort()\n    B.sort()\n    \n    max_sum = A[-1] + B[-1]\n    print(max_sum)\n\nmax_sum_of_arrays()", "def max_sum(A, B):\n    A.sort()\n    B.sort()\n    return A[-1] + B[-1]\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:N+1]))\nB = list(map(int, data[N+1:]))\n\n# Print the result\nprint(max_sum(A, B))"], "passed": [true, true], "raw_code": ["```python\ndef max_sum_of_arrays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    \n    A.sort()\n    B.sort()\n    \n    max_sum = A[-1] + B[-1]\n    print(max_sum)\n\nmax_sum_of_arrays()\n```", "```python\ndef max_sum(A, B):\n    A.sort()\n    B.sort()\n    return A[-1] + B[-1]\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:N+1]))\nB = list(map(int, data[N+1:]))\n\n# Print the result\nprint(max_sum(A, B))\n```"]}
{"task_id": "abc371_c", "codes": ["import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef main():\n    index = 0\n    N = int(data[index])\n    index += 1\n    M_G = int(data[index])\n    index += 1\n    edges_G = []\n    for _ in range(M_G):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        edges_G.append((u, v))\n    \n    M_H = int(data[index])\n    index += 1\n    edges_H = []\n    for _ in range(M_H):\n        a = int(data[index]) - 1\n        index += 1\n        b = int(data[index]) - 1\n        index += 1\n        edges_H.append((a, b))\n    \n    A = []\n    for i in range(N):\n        row = []\n        for j in range(i + 1, N):\n            cost = int(data[index])\n            index += 1\n            row.append(cost)\n        A.append(row)\n    \n    # Create adjacency lists for G and H\n    adj_G = [[] for _ in range(N)]\n    for u, v in edges_G:\n        adj_G[u].append(v)\n        adj_G[v].append(u)\n    \n    adj_H = [[] for _ in range(N)]\n    for a, b in edges_H:\n        adj_H[a].append(b)\n        adj_H[b].append(a)\n    \n    # Initialize DP table\n    dp = [float('inf')] * (1 << N)\n    dp[0] = 0\n    \n    # Fill DP table\n    for mask in range(1 << N):\n        for i in range(N):\n            if not (mask & (1 << i)):\n                continue\n            for j in range(i + 1, N):\n                if not (mask & (1 << j)):\n                    continue\n                    # Calculate the cost to toggle the edge between i and j\n                    cost = A[i][j]\n                    new_mask = mask ^ (1 << i) ^ (1 << j)\n                    if len(adj_H[i]) < len(adj_G[j]):\n                        dp[new_mask] = min(dp[new_mask], dp[mask] + cost)\n                    elif len(adj_H[i]) > len(adj_G[j]):\n                        dp[new_mask] = min(dp[new_mask], dp[mask] + cost)\n    \n    # Find the minimum cost to make H isomorphic to G\n    result = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            if len(adj_G[i]) == len(adj_G[j]):\n                result = min(result, dp[(1 << i) | (1 << j)])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "import itertools\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    M_G = int(data[index])\n    index += 1\n    \n    G = [set() for _ in range(N + 1)]\n    for _ in range(M_G):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        G[u].add(v)\n        G[v].add(u)\n        index += 2\n    \n    M_H = int(data[index])\n    index += 1\n    \n    H = [set() for _ in range(N + 1)]\n    for _ in range(M_H):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        H[a].add(b)\n        H[b].add(a)\n        index += 2\n    \n    costs = []\n    for perm in itertools.permutations(range(1, N + 1)):\n        cost = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if (i + 1 in G[perm[j]] and j + 1 not in H[i]) or (i + 1 not in G[perm[j]] and j + 1 in H[i]):\n                    cost += int(data[index + j * (N - i - 1) + i])\n        costs.append(cost)\n    \n    print(min(costs))\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef main():\n    index = 0\n    N = int(data[index])\n    index += 1\n    M_G = int(data[index])\n    index += 1\n    edges_G = []\n    for _ in range(M_G):\n        u = int(data[index]) - 1\n        index += 1\n        v = int(data[index]) - 1\n        index += 1\n        edges_G.append((u, v))\n    \n    M_H = int(data[index])\n    index += 1\n    edges_H = []\n    for _ in range(M_H):\n        a = int(data[index]) - 1\n        index += 1\n        b = int(data[index]) - 1\n        index += 1\n        edges_H.append((a, b))\n    \n    A = []\n    for i in range(N):\n        row = []\n        for j in range(i + 1, N):\n            cost = int(data[index])\n            index += 1\n            row.append(cost)\n        A.append(row)\n    \n    # Create adjacency lists for G and H\n    adj_G = [[] for _ in range(N)]\n    for u, v in edges_G:\n        adj_G[u].append(v)\n        adj_G[v].append(u)\n    \n    adj_H = [[] for _ in range(N)]\n    for a, b in edges_H:\n        adj_H[a].append(b)\n        adj_H[b].append(a)\n    \n    # Initialize DP table\n    dp = [float('inf')] * (1 << N)\n    dp[0] = 0\n    \n    # Fill DP table\n    for mask in range(1 << N):\n        for i in range(N):\n            if not (mask & (1 << i)):\n                continue\n            for j in range(i + 1, N):\n                if not (mask & (1 << j)):\n                    continue\n                    # Calculate the cost to toggle the edge between i and j\n                    cost = A[i][j]\n                    new_mask = mask ^ (1 << i) ^ (1 << j)\n                    if len(adj_H[i]) < len(adj_G[j]):\n                        dp[new_mask] = min(dp[new_mask], dp[mask] + cost)\n                    elif len(adj_H[i]) > len(adj_G[j]):\n                        dp[new_mask] = min(dp[new_mask], dp[mask] + cost)\n    \n    # Find the minimum cost to make H isomorphic to G\n    result = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            if len(adj_G[i]) == len(adj_G[j]):\n                result = min(result, dp[(1 << i) | (1 << j)])\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport itertools\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    M_G = int(data[index])\n    index += 1\n    \n    G = [set() for _ in range(N + 1)]\n    for _ in range(M_G):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        G[u].add(v)\n        G[v].add(u)\n        index += 2\n    \n    M_H = int(data[index])\n    index += 1\n    \n    H = [set() for _ in range(N + 1)]\n    for _ in range(M_H):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        H[a].add(b)\n        H[b].add(a)\n        index += 2\n    \n    costs = []\n    for perm in itertools.permutations(range(1, N + 1)):\n        cost = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if (i + 1 in G[perm[j]] and j + 1 not in H[i]) or (i + 1 not in G[perm[j]] and j + 1 in H[i]):\n                    cost += int(data[index + j * (N - i - 1) + i])\n        costs.append(cost)\n    \n    print(min(costs))\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3584", "codes": ["def smallestSequenceOfIndices(word1, word2):\n    n1, n2 = len(word1), len(word2)\n    mismatches = []\n    \n    # Identify all mismatches\n    for i in range(n2):\n        if word1[i] != word2[i]:\n            mismatches.append(i)\n    \n    # If there are more than one mismatch, check if we can fix them in a valid sequence\n    if len(mismatches) > 1:\n        fixed_indices = []\n        for i in range(1, len(mismatches)):\n            if word1[mismatches[i]] == word2[mismatches[i - 1]]:\n                fixed_indices.append(mismatches[i - 1])\n        \n        # Check if we can fix the last mismatch\n        if word1[mismatches[-1]] == word2[mismatches[-2]]:\n            fixed_indices.append(mismatches[-2])\n        \n        # Return the smallest lexicographical sequence\n        return sorted(fixed_indices + [mismatches[-1]])\n    \n    # If there is exactly one mismatch, check if it forms a valid sequence\n    elif len(mismatches) == 1:\n        if word1[mismatches[0]] == word2[mismatches[0] - 1] or \\\n           (mismatches[0] + 1 < n1 and word1[mismatches[0]] == word2[mismatches[0] + 1]):\n            return [mismatches[0]]\n    \n    # If no valid sequence exists\n    return []", "def smallest_sequence(word1: str, word2: str) -> List[int]:\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    for i in range(m):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n            if len(diff_indices) > 1:\n                return []\n\n    return diff_indices if diff_indices else []"], "passed": [false, false], "raw_code": ["```python\ndef smallestSequenceOfIndices(word1, word2):\n    n1, n2 = len(word1), len(word2)\n    mismatches = []\n    \n    # Identify all mismatches\n    for i in range(n2):\n        if word1[i] != word2[i]:\n            mismatches.append(i)\n    \n    # If there are more than one mismatch, check if we can fix them in a valid sequence\n    if len(mismatches) > 1:\n        fixed_indices = []\n        for i in range(1, len(mismatches)):\n            if word1[mismatches[i]] == word2[mismatches[i - 1]]:\n                fixed_indices.append(mismatches[i - 1])\n        \n        # Check if we can fix the last mismatch\n        if word1[mismatches[-1]] == word2[mismatches[-2]]:\n            fixed_indices.append(mismatches[-2])\n        \n        # Return the smallest lexicographical sequence\n        return sorted(fixed_indices + [mismatches[-1]])\n    \n    # If there is exactly one mismatch, check if it forms a valid sequence\n    elif len(mismatches) == 1:\n        if word1[mismatches[0]] == word2[mismatches[0] - 1] or \\\n           (mismatches[0] + 1 < n1 and word1[mismatches[0]] == word2[mismatches[0] + 1]):\n            return [mismatches[0]]\n    \n    # If no valid sequence exists\n    return []\n```", "def smallest_sequence(word1: str, word2: str) -> List[int]:\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    for i in range(m):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n            if len(diff_indices) > 1:\n                return []\n\n    return diff_indices if diff_indices else []"]}
{"task_id": "abc366_d", "codes": ["d", "i"], "passed": [false, false], "raw_code": ["```python\ndef answer_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    A = [[[0] * (N + 1) for _ in range(N + 1)] for _ in range(N + 1)]\n    for x in range(1, N + 1):\n        for y in range(1, N + 1):\n            A[x][y][1] = int(data[index])\n            index += 1\n            for z in range(2, N + 1):\n                A[x][y][z] = A[x][y][z - 1] + int(data[index])\n                index += 1\n    \n    for y in range(2, N + 1):\n        for z in range(1, N + 1):\n            for x in range(1, N + 1):\n                A[x][y][z] += A[x - 1][y][z]\n    \n    for z in range(2, N + 1):\n        for x in range(1, N + 1):\n            for y in range(1, N + 1):\n                A[x][y][z] += A[x][y - 1][z]\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, data[index:index + 6])\n        index += 6\n        total_sum = A[Rx][Ry][Rz]\n        if Lx > 1:\n            total_sum -= A[Lx - 1][Ry][Rz]\n        if Ly > 1:\n            total_sum -= A[Rx][Ly - 1][Rz]\n        if Lz > 1:\n            total_sum -= A[Rx][Ry][Lz - 1]\n        if Lx > 1 and Ly > 1:\n            total_sum += A[Lx - 1][Ly - 1][Rz]\n        if Lx > 1 and Lz > 1:\n            total_sum += A[Lx - 1][Ry][Lz - 1]\n        if Ly > 1 and Lz > 1:\n            total_sum += A[Rx][Ly - 1][Lz - 1]\n        if Lx > 1 and Ly > 1 and Lz > 1:\n            total_sum -= A[Lx - 1][Ly - 1][Lz - 1]\n        results.append(total_sum)\n    \n    for result in results:\n        print(result)\n\nanswer_queries()", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nN = int(data[index])\nindex += 1\n\nA = []\nfor _ in range(N):\n    row = [int(data[index]) for _ in range(N)]\n    A.append(row)\n    index += N\n\nQ = int(data[index])\nindex += 1\n\nqueries = []\nfor _ in range(Q):\n    query = tuple(int(data[index + i]) for i in range(6))\n    queries.append(query)\n    index += 6\n\nP = [[[0] * (N + 1) for _ in range(N + 1)] for _ in range(N + 1)]\n\nfor x in range(1, N + 1):\n    for y in range(1"]}
{"task_id": "3495", "codes": ["import heapq\n\ndef kthObstacleDistance(queries, k):\n    def manhattan_distance(x, y):\n        return abs(x) + abs(y)\n    \n    heap = []\n    results = []\n    \n    for x, y in queries:\n        dist = manhattan_distance(x, y)\n        if len(heap) < k:\n            heapq.heappush(heap, -dist)\n        elif dist < -heap[0]:\n            heapq.heapreplace(heap, -dist)\n    \n    while heap:\n        results.append(-heapq.heappop(heap))\n    results.reverse()\n    \n    while len(results) < k:\n        results.append(-1)\n    \n    return results[:k]", "def getKthDistances(queries, k):\n    import heapq\n    \n    # List to store the distances of obstacles\n    distances = []\n    \n    # List to store the result\n    results = []\n    \n    for x, y in queries:\n        # Calculate the Manhattan distance from the origin\n        distance = abs(x) + abs(y)\n        \n        # Push the distance onto the heap\n        heapq.heappush(distances, distance)\n        \n        # If there are fewer than k elements, append -1\n        if len(distances) < k:\n            results.append(-1)\n        else:\n            # The k-th smallest element is at index k-1\n            results.append(heapq.nsmallest(k, distances)[-1])\n    \n    return results"], "passed": [false, false], "raw_code": ["```python\nimport heapq\n\ndef kthObstacleDistance(queries, k):\n    def manhattan_distance(x, y):\n        return abs(x) + abs(y)\n    \n    heap = []\n    results = []\n    \n    for x, y in queries:\n        dist = manhattan_distance(x, y)\n        if len(heap) < k:\n            heapq.heappush(heap, -dist)\n        elif dist < -heap[0]:\n            heapq.heapreplace(heap, -dist)\n    \n    while heap:\n        results.append(-heapq.heappop(heap))\n    results.reverse()\n    \n    while len(results) < k:\n        results.append(-1)\n    \n    return results[:k]\n```", "```python\ndef getKthDistances(queries, k):\n    import heapq\n    \n    # List to store the distances of obstacles\n    distances = []\n    \n    # List to store the result\n    results = []\n    \n    for x, y in queries:\n        # Calculate the Manhattan distance from the origin\n        distance = abs(x) + abs(y)\n        \n        # Push the distance onto the heap\n        heapq.heappush(distances, distance)\n        \n        # If there are fewer than k elements, append -1\n        if len(distances) < k:\n            results.append(-1)\n        else:\n            # The k-th smallest element is at index k-1\n            results.append(heapq.nsmallest(k, distances)[-1])\n    \n    return results\n```"]}
{"task_id": "abc369_c", "codes": ["d", "def count_arithmetic_progressions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    \n    for end in range(1, N):\n        diff_count = {}\n        \n        for start in range(end):\n            diff = A[end] - A[start]\n            if diff not in diff_count:\n                diff_count[diff] = 0\n            \n            count += diff_count[diff]\n            diff_count[diff] += 1\n    \n    # Each element itself is an arithmetic progression\n    count += N\n    \n    print(count)\n\ncount_arithmetic_progressions()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    \n    for d in range(1, max(A) - min(A) + 1):\n        diff_map = {}\n        for i in range(N):\n            if A[i] - d in diff_map:\n                count += diff_map[A[i] - d]\n            diff_map[A[i]] = diff_map.get(A[i], 0) + 1\n    \n    print(count)\n\nmain()", "```python\ndef count_arithmetic_progressions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    \n    for end in range(1, N):\n        diff_count = {}\n        \n        for start in range(end):\n            diff = A[end] - A[start]\n            if diff not in diff_count:\n                diff_count[diff] = 0\n            \n            count += diff_count[diff]\n            diff_count[diff] += 1\n    \n    # Each element itself is an arithmetic progression\n    count += N\n    \n    print(count)\n\ncount_arithmetic_progressions()\n```"]}
{"task_id": "3510", "codes": ["def maxTowerSum(maximumHeight):\n    # Sort the maximumHeight array\n    maximumHeight.sort()\n    \n    # Set to keep track of used heights\n    used_heights = set()\n    \n    # Variable to store the total sum of assigned heights\n    total_sum = 0\n    \n    # Iterate through each height in the sorted array\n    for height in maximumHeight:\n        # Find the smallest unused height that does not exceed the current maximum height\n        assigned_height = 1\n        while assigned_height in used_heights or assigned_height > height:\n            assigned_height += 1\n        \n        # If no valid height is found, return -1\n        if assigned_height > height:\n            return -1\n        \n        # Add the assigned height to the total sum\n        total_sum += assigned_height\n        \n        # Mark the assigned height as used\n        used_heights.add(assigned_height)\n    \n    # Return the total sum of assigned heights\n    return total_sum", "def maxTowerHeight(maximumHeight):\n    maximumHeight.sort()\n    max_height = len(maximumHeight)\n    total_sum = 0\n    \n    for i in range(max_height):\n        if i + 1 > maximumHeight[i]:\n            return -1\n        total_sum += i + 1\n    \n    return total_sum"], "passed": [false, false], "raw_code": ["```python\ndef maxTowerSum(maximumHeight):\n    # Sort the maximumHeight array\n    maximumHeight.sort()\n    \n    # Set to keep track of used heights\n    used_heights = set()\n    \n    # Variable to store the total sum of assigned heights\n    total_sum = 0\n    \n    # Iterate through each height in the sorted array\n    for height in maximumHeight:\n        # Find the smallest unused height that does not exceed the current maximum height\n        assigned_height = 1\n        while assigned_height in used_heights or assigned_height > height:\n            assigned_height += 1\n        \n        # If no valid height is found, return -1\n        if assigned_height > height:\n            return -1\n        \n        # Add the assigned height to the total sum\n        total_sum += assigned_height\n        \n        # Mark the assigned height as used\n        used_heights.add(assigned_height)\n    \n    # Return the total sum of assigned heights\n    return total_sum\n```", "```python\ndef maxTowerHeight(maximumHeight):\n    maximumHeight.sort()\n    max_height = len(maximumHeight)\n    total_sum = 0\n    \n    for i in range(max_height):\n        if i + 1 > maximumHeight[i]:\n            return -1\n        total_sum += i + 1\n    \n    return total_sum\n```"]}
{"task_id": "arc183_a", "codes": ["from itertools import permutations\n\ndef get_good_sequences(N, K):\n    elements = [i for i in range(1, N + 1)] * K\n    return sorted(set(permutations(elements)))\n\ndef find_sequence(N, K, target_position):\n    good_sequences = get_good_sequences(N, K)\n    total_sequences = len(good_sequences)\n    desired_index = (total_sequences + 1) // 2 - 1\n    return ' '.join(map(str, good_sequences[desired_index]))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\n\n# Get the result and print it\nresult = find_sequence(N, K, None)\nprint(result)", "import sys\nfrom itertools import permutations\n\ndef find_good_sequence(N, K):\n    # Generate all possible good integer sequences\n    good_sequences = set()\n    for perm in permutations(range(1, N+1), N*K):\n        counts = [perm.count(i) for i in range(1, N+1)]\n        if counts == [K]*N:\n            good_sequences.add(tuple(sorted(perm)))\n\n    # Sort the good sequences lexicographically\n    sorted_sequences = sorted(good_sequences)\n\n    # Find the floor((S+1)/2)-th sequence\n    index = (len(sorted_sequences) + 1) // 2 - 1\n    return ' '.join(map(str, sorted_sequences[index]))\n\nif __name__ == '__main__':\n    N, K = map(int, input().split())\n    result = find_good_sequence(N, K)\n    print(result)\n"], "passed": [false, false], "raw_code": ["```python\nfrom itertools import permutations\n\ndef get_good_sequences(N, K):\n    elements = [i for i in range(1, N + 1)] * K\n    return sorted(set(permutations(elements)))\n\ndef find_sequence(N, K, target_position):\n    good_sequences = get_good_sequences(N, K)\n    total_sequences = len(good_sequences)\n    desired_index = (total_sequences + 1) // 2 - 1\n    return ' '.join(map(str, good_sequences[desired_index]))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\n\n# Get the result and print it\nresult = find_sequence(N, K, None)\nprint(result)\n```", "import sys\nfrom itertools import permutations\n\ndef find_good_sequence(N, K):\n    # Generate all possible good integer sequences\n    good_sequences = set()\n    for perm in permutations(range(1, N+1), N*K):\n        counts = [perm.count(i) for i in range(1, N+1)]\n        if counts == [K]*N:\n            good_sequences.add(tuple(sorted(perm)))\n\n    # Sort the good sequences lexicographically\n    sorted_sequences = sorted(good_sequences)\n\n    # Find the floor((S+1)/2)-th sequence\n    index = (len(sorted_sequences) + 1) // 2 - 1\n    return ' '.join(map(str, sorted_sequences[index]))\n\nif __name__ == '__main__':\n    N, K = map(int, input().split())\n    result = find_good_sequence(N, K)\n    print(result)\n"]}
{"task_id": "abc370_d", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read input values\n    H = int(data[0])\n    W = int(data[1])\n    Q = int(data[2])\n\n    # Initialize the grid with walls\n    walls = {(i, j) for i in range(1, H + 1) for j in range(1, W + 1)}\n\n    # Process each query\n    index = 3\n    for _ in range(Q):\n        R = int(data[index])\n        C = int(data[index + 1])\n        index += 2\n\n        if (R, C) in walls:\n            walls.remove((R, C))\n        else:\n            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n            for dr, dc in directions:\n                r, c = R, C\n                while True:\n                    r += dr\n                    c += dc\n                    if 1 <= r <= H and 1 <= c <= W and (r, c) in walls:\n                        walls.remove((r, c))\n                        break\n\n    # Output the number of remaining walls\n    print(len(walls))\n\nif __name__ == \"__main__\":\n    main()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    H = int(data[index])\n    index += 1\n    W = int(data[index])\n    index += 1\n    Q = int(data[index])\n    index += 1\n    \n    grid = [[1] * W for _ in range(H)]\n    \n    destroyed = set()\n    \n    for _ in range(Q):\n        R = int(data[index]) - 1\n        index += 1\n        C = int(data[index]) - 1\n        index += 1\n        \n        if grid[R][C] == 0:\n            # Destroy the first walls in each direction\n            if R > 0 and (R-1, C) not in destroyed and grid[R-1][C] == 1:\n                destroyed.add((R-1, C))\n            if R < H-1 and (R+1, C) not in destroyed and grid[R+1][C] == 1:\n                destroyed.add((R+1, C))\n            if C > 0 and (R, C-1) not in destroyed and grid[R][C-1] == 1:\n                destroyed.add((R, C-1))\n            if C < W-1 and (R, C+1) not in destroyed and grid[R][C+1] == 1:\n                destroyed.add((R, C+1))\n        else:\n            # Destroy the wall at (R, C)\n            destroyed.add((R, C))\n            grid[R][C] = 0\n    \n    # Count the remaining walls\n    remaining_walls = H * W - len(destroyed)\n    print(remaining_walls)\n\n# Call the main function\nmain()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read input values\n    H = int(data[0])\n    W = int(data[1])\n    Q = int(data[2])\n\n    # Initialize the grid with walls\n    walls = {(i, j) for i in range(1, H + 1) for j in range(1, W + 1)}\n\n    # Process each query\n    index = 3\n    for _ in range(Q):\n        R = int(data[index])\n        C = int(data[index + 1])\n        index += 2\n\n        if (R, C) in walls:\n            walls.remove((R, C))\n        else:\n            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n            for dr, dc in directions:\n                r, c = R, C\n                while True:\n                    r += dr\n                    c += dc\n                    if 1 <= r <= H and 1 <= c <= W and (r, c) in walls:\n                        walls.remove((r, c))\n                        break\n\n    # Output the number of remaining walls\n    print(len(walls))\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    H = int(data[index])\n    index += 1\n    W = int(data[index])\n    index += 1\n    Q = int(data[index])\n    index += 1\n    \n    grid = [[1] * W for _ in range(H)]\n    \n    destroyed = set()\n    \n    for _ in range(Q):\n        R = int(data[index]) - 1\n        index += 1\n        C = int(data[index]) - 1\n        index += 1\n        \n        if grid[R][C] == 0:\n            # Destroy the first walls in each direction\n            if R > 0 and (R-1, C) not in destroyed and grid[R-1][C] == 1:\n                destroyed.add((R-1, C))\n            if R < H-1 and (R+1, C) not in destroyed and grid[R+1][C] == 1:\n                destroyed.add((R+1, C))\n            if C > 0 and (R, C-1) not in destroyed and grid[R][C-1] == 1:\n                destroyed.add((R, C-1))\n            if C < W-1 and (R, C+1) not in destroyed and grid[R][C+1] == 1:\n                destroyed.add((R, C+1))\n        else:\n            # Destroy the wall at (R, C)\n            destroyed.add((R, C))\n            grid[R][C] = 0\n    \n    # Count the remaining walls\n    remaining_walls = H * W - len(destroyed)\n    print(remaining_walls)\n\n# Call the main function\nmain()\n```"]}
{"task_id": "3528", "codes": ["def maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 0\n    \n    for j in range(1, n):\n        for i in range(j):\n            if i + nums[i] >= j:\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[-1]", "def maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[-1]"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 0\n    \n    for j in range(1, n):\n        for i in range(j):\n            if i + nums[i] >= j:\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[-1]\n```", "```python\ndef maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[-1]\n```"]}
{"task_id": "arc181_a", "codes": ["import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef min_operations(permutation):\n    n = len(permutation)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                inversions += 1\n    return inversions\n\ndef main():\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        permutation = list(map(int, data[index:index + n]))\n        index += n\n        results.append(min_operations(permutation))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef count_inversions(p):\n    n = len(p)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                inversions += 1\n    return inversions\n\ndef min_operations(permutation):\n    return count_inversions(permutation)\n\n# Read input\nT = int(data[0])\nresults = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    index += 1\n    P = list(map(int, data[index:index+N]))\n    index += N\n    results.append(min_operations(P))\n\n# Print results\nfor result in results:\n    print(result)"], "passed": [false, false], "raw_code": ["```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef min_operations(permutation):\n    n = len(permutation)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                inversions += 1\n    return inversions\n\ndef main():\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        permutation = list(map(int, data[index:index + n]))\n        index += n\n        results.append(min_operations(permutation))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef count_inversions(p):\n    n = len(p)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                inversions += 1\n    return inversions\n\ndef min_operations(permutation):\n    return count_inversions(permutation)\n\n# Read input\nT = int(data[0])\nresults = []\nindex = 1\nfor _ in range(T):\n    N = int(data[index])\n    index += 1\n    P = list(map(int, data[index:index+N]))\n    index += N\n    results.append(min_operations(P))\n\n# Print results\nfor result in results:\n    print(result)\n```"]}
{"task_id": "abc368_c", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        for i in range(N):\n            if H[i] > 0:\n                if T % 3 == 0:\n                    H[i] -= 3\n                else:\n                    H[i] -= 1\n                break\n    \n    print(T)\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    \n    while any(h > 0 for h in H):\n        T += 1\n        if T % 3 == 0:\n            for i in range(N):\n                if H[i] > 0:\n                    H[i] -= 3\n                    break\n        else:\n            for i in range(N):\n                if H[i] > 0:\n                    H[i] -= 1\n                    break\n    \n    print(T)\n\nmain()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        for i in range(N):\n            if H[i] > 0:\n                if T % 3 == 0:\n                    H[i] -= 3\n                else:\n                    H[i] -= 1\n                break\n    \n    print(T)\n\nmain()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    \n    while any(h > 0 for h in H):\n        T += 1\n        if T % 3 == 0:\n            for i in range(N):\n                if H[i] > 0:\n                    H[i] -= 3\n                    break\n        else:\n            for i in range(N):\n                if H[i] > 0:\n                    H[i] -= 1\n                    break\n    \n    print(T)\n\nmain()\n```"]}
{"task_id": "abc370_c", "codes": ["def transform_string(S, T):\n    M = 0\n    X = []\n    while S != T:\n        min_change = None\n        for i in range(len(S)):\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                new_S = S[:i] + char + S[i+1:]\n                if new_S == T:\n                    min_change = new_S\n                    break\n            if min_change:\n                break\n        if min_change:\n            X.append(min_change)\n            S = min_change\n            M += 1\n    print(M)\n    for s in X:\n        print(s)\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\n\ntransform_string(S, T)", "def min_operations_and_array(S, T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    S = data[0]\n    T = data[1]\n    \n    n = len(S)\n    X = [S]\n    \n    while S != T:\n        changed = False\n        for i in range(n):\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                if char == S[i]:\n                    continue\n                new_S = S[:i] + char + S[i+1:]\n                if new_S != T and all(new_S[:j] <= X[j-1][:j] for j in range(1, len(X))):\n                    X.append(new_S)\n                    S = new_S\n                    changed = True\n                    break\n            if changed:\n                break\n    \n    print(len(X))\n    for x in X:\n        print(x)\n\nmin_operations_and_array('S', 'T')"], "passed": [false, false], "raw_code": ["```python\ndef transform_string(S, T):\n    M = 0\n    X = []\n    while S != T:\n        min_change = None\n        for i in range(len(S)):\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                new_S = S[:i] + char + S[i+1:]\n                if new_S == T:\n                    min_change = new_S\n                    break\n            if min_change:\n                break\n        if min_change:\n            X.append(min_change)\n            S = min_change\n            M += 1\n    print(M)\n    for s in X:\n        print(s)\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\n\ntransform_string(S, T)\n```", "```python\ndef min_operations_and_array(S, T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    S = data[0]\n    T = data[1]\n    \n    n = len(S)\n    X = [S]\n    \n    while S != T:\n        changed = False\n        for i in range(n):\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                if char == S[i]:\n                    continue\n                new_S = S[:i] + char + S[i+1:]\n                if new_S != T and all(new_S[:j] <= X[j-1][:j] for j in range(1, len(X))):\n                    X.append(new_S)\n                    S = new_S\n                    changed = True\n                    break\n            if changed:\n                break\n    \n    print(len(X))\n    for x in X:\n        print(x)\n\nmin_operations_and_array('S', 'T')\n```"]}
{"final_accuracy": "5.41%"}
{"difficulty": "medium", "num_threads": 32, "temperature": 0.9, "n": 2, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp09__qwen_7b_medium_n_2.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"final_accuracy": "5.41%"}
{"difficulty": "medium", "num_threads": 32, "temperature": 0.9, "n": 2, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp09__qwen_7b_medium_n_2.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"final_accuracy": "5.41%"}
