{"difficulty": "hard", "num_threads": 32, "temperature": 0.5, "n": 1, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp05_bug_trace_TPL_CODEEXECUTOR_qwen_7b_hard_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc365_e", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    total_sum = 0\n    \n    # Iterate over each element to count its contribution\n    for i in range(N):\n        # Count the number of subarrays that include A[i]\n        left_count = i\n        right_count = N - i - 1\n        \n        # Calculate the contribution of A[i]\n        total_sum += (left_count + 1) * (right_count + 1) * A[i]\n    \n    print(total_sum)\n\n# Call the main function\nmain()"]}
{"task_id": "abc366_g", "codes": ["i"], "passed": [false], "raw_code": ["```python\nimport sys\nfrom sympy import Matrix\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    edges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(M)]\n    return N, M, edges\n\ndef solve():\n    N, M, edges = read_input()\n    \n    # Create the adjacency matrix\n    adj_matrix = [[0] * N for _ in range(N)]\n    for u, v in edges:\n        adj_matrix[u][v] = 1\n        adj_matrix[v][u] = 1\n    \n    # Create the augmented matrix for the system of equations\n    augmented_matrix = []\n    for i in range(N):\n        row = adj_matrix[i][:]\n        row.append(0)  # The right-hand side of the equation is 0\n        augmented_matrix.append(row)\n    \n    # Convert to sympy Matrix and solve the system\n    M = Matrix(augmented_matrix)\n    solution = M.gauss_jordan_solve(Matrix([[0] * N]))\n    \n    if solution == Matrix([None] * N):\n        print(\"No\")\n        return\n    \n    print(\"Yes\")\n    print(\" \".join(map(str, solution)))\n\nsolve()"]}
{"task_id": "3532", "codes": ["def minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    tree = defaultdict(list)\n    \n    # Build the tree\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Initialize marking times\n    marking_times = [0] * n\n    \n    # Perform BFS to calculate marking times\n    queue = deque([0])\n    visited = set([0])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if node % 2 == 0:\n                    marking_times[neighbor] = marking_times[node] + 2\n                else:\n                    marking_times[neighbor] = marking_times[node] + 1\n                queue.append(neighbor)\n    \n    return marking_times[1:]"], "passed": [false], "raw_code": ["```python\ndef minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    tree = defaultdict(list)\n    \n    # Build the tree\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Initialize marking times\n    marking_times = [0] * n\n    \n    # Perform BFS to calculate marking times\n    queue = deque([0])\n    visited = set([0])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if node % 2 == 0:\n                    marking_times[neighbor] = marking_times[node] + 2\n                else:\n                    marking_times[neighbor] = marking_times[node] + 1\n                queue.append(neighbor)\n    \n    return marking_times[1:]\n```"]}
{"task_id": "abc367_e", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef perform_operations(N, K, X, A):\n    from collections import defaultdict, deque\n    \n    # Step 1: Decompose X into cycles\n    cycle_dict = defaultdict(list)\n    visited = [False] * N\n    for i in range(N):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = X[x] - 1\n            cycle_dict[len(cycle)].append(cycle)\n    \n    # Step 2: Apply cycles modulo length\n    for length, cycles in cycle_dict.items():\n        for cycle in cycles:\n            k_mod = K % length\n            cycle = deque(cycle)\n            cycle.rotate(-k_mod)  # Rotate left by k_mod\n            for i, idx in enumerate(cycle):\n                A[idx] = A[cycle[i - 1]]\n    \n    # Step 3: Print the final sequence\n    print(' '.join(map(str, A)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Perform the operations\nperform_operations(N, K, X, A)"]}
{"task_id": "abc367_g", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef calculate_scores():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP array\n    dp = [[0] * (1 << 20) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Process each element in the sequence\n    for i in range(1, N + 1):\n        for j in range(1 << 20):\n            dp[i][j] = dp[i - 1][j]\n            dp[i][j ^ A[i - 1]] += dp[i - 1][j]\n    \n    # Calculate the sum of scores\n    total_score = 0\n    for i in range(1, 1 << N):\n        length = bin(i).count('1')\n        if length % M == 0:\n            current_xor = 0\n            for j in range(N):\n                if i & (1 << j):\n                    current_xor ^= A[j]\n            total_score += pow(current_xor, K, MOD)\n    \n    print(total_score % MOD)\n\ncalculate_scores()"]}
{"task_id": "abc366_f", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    dp = [0] * (K + 1)\n    \n    for A, B in functions:\n        new_dp = dp[:]\n        for k in range(K, 0, -1):\n            new_dp[k] = max(new_dp[k], A * dp[k - 1] + B)\n        dp = new_dp\n    \n    print(dp[K])\n\nmax_nested_function_value()"]}
{"task_id": "abc373_f", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            for k in range(1, (j // w) + 1):\n                dp[j] = max(dp[j], dp[j - k * w] + k * v - k * k)\n    \n    print(dp[W])\n\nmax_happiness()"]}
{"task_id": "abc369_e", "codes": ["i"], "passed": [false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_time_to_travel(N, M, bridges, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    # Memoization dictionary\n    memo = {}\n\n    def dfs(current, used_bridges, time):\n        if len(used_bridges) == len(queries[0]):\n            if current == N:\n                return time\n            return float('inf')\n        \n        key = (current, frozenset(used_bridges), tuple(sorted(queries[0])))\n        if key in memo:\n            return memo[key]\n        \n        min_time = float('inf')\n        for neighbor, t in graph[current]:\n            if (neighbor, current, t) not in used_bridges:\n                new_used_bridges = list(used_bridges)\n                new_used_bridges.append((neighbor, current, t))\n                min_time = min(min_time, dfs(neighbor, new_used_bridges, time + t))\n        \n        memo[key] = min_time\n        return min_time\n\n    results = []\n    for query in queries:\n        result = dfs(1, [], 0)\n        results.append(result)\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nbridges = []\nindex = 2\nfor _ in range(M):\n    u = int(data[index])\n    v = int(data[index + 1])\n    t = int(data[index + 2])\n    bridges.append((u, v, t))\n    index += 3\n\nQ = int(data[index])\nqueries = []\nfor _ in range(Q):\n    K = int(data[index + 1])\n    query = [(int(data[index + 2 + i]), int(data[index + 3 + i]), int(data[index + 4 + i])) for i in range(K)]\n    queries.append(query)\n    index += 5 + K\n\n# Compute results\nresults = min_time_to_travel(N, M, bridges, queries)\n\n# Print results\nfor result in results:\n    print(result)"]}
{"task_id": "abc368_f", "codes": ["def determine_winner(N, A):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Check if all numbers are composite\n    all_composite = all(not is_prime(a) for a in A)\n    \n    if all_composite:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))"], "passed": [false], "raw_code": ["```python\ndef determine_winner(N, A):\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Check if all numbers are composite\n    all_composite = all(not is_prime(a) for a in A)\n    \n    if all_composite:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))\n```"]}
{"task_id": "abc367_f", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = sorted(A[l_i:r_i + 1])\n        subseq_B = sorted(B[L_i:R_i + 1])\n        \n        if subseq_A == subseq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()"]}
{"task_id": "abc370_e", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef count_partitions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            dp[i][j] = dp[i - 1][j]\n            if prefix_sum[j] - prefix_sum[i - 1] != K:\n                dp[i][j] += dp[i - 1][i - 1]\n                dp[i][j] %= MOD\n    \n    result = sum(dp[N]) % MOD\n    print(result)\n\ncount_partitions()"]}
{"task_id": "arc181_b", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        len_S = len(S)\n        len_X = len(X)\n        len_Y = len(Y)\n        \n        count_X_0 = X.count('0')\n        count_X_1 = X.count('1')\n        count_Y_0 = Y.count('0')\n        count_Y_1 = Y.count('1')\n        \n        if count_X_0 + len(T) != count_Y_1 + len(T):\n            results.append(\"No\")\n            continue\n        \n        freq_X = {}\n        freq_Y = {}\n        \n        for i in range(len_X):\n            if X[i] == '0':\n                freq_X[S[i % len_S]] = freq_X.get(S[i % len_S], 0) + 1\n            else:\n                freq_Y[T[i % len_T]] = freq_Y.get(T[i % len_T], 0) + 1\n        \n        for i in range(len_Y):\n            if Y[i] == '0':\n                freq_Y[S[i % len_S]] = freq_Y.get(S[i % len_S], 0) - 1\n            else:\n                freq_X[T[i % len_T]] = freq_X.get(T[i % len_T], 0) - 1\n        \n        if all(freq == 0 for freq in freq_X.values()) and all(freq == 0 for freq in freq_Y.values()):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nsolve()"]}
{"task_id": "arc182_d", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef min_operations_to_transform(A, B, M):\n    N = len(A)\n    \n    # Function to check if transformation is feasible\n    def is_feasible(a, b):\n        if abs(a - b) == 1 or (a == 0 and b == M - 1) or (a == M - 1 and b == 0):\n            return True\n        return False\n    \n    # Dynamic Programming table to store minimum operations\n    dp = [[float('inf')] * M for _ in range(N)]\n    \n    # Initialize the DP table for the first element\n    for j in range(M):\n        if is_feasible(A[0], j):\n            dp[0][j] = abs(j - B[0])\n    \n    # Fill the DP table\n    for i in range(1, N):\n        for j in range(M):\n            for k in range(M):\n                if is_feasible(B[i], k) and is_feasible(j, k):\n                    dp[i][k] = min(dp[i][k], dp[i-1][j] + abs(k - B[i]))\n    \n    # Find the minimum operations required to transform A to B\n    min_ops = float('inf')\n    for j in range(M):\n        if is_feasible(A[-1], j):\n            min_ops = min(min_ops"]}
{"task_id": "abc372_f", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    edges = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(M)]\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    for k in range(K):\n        for v in range(1, N + 1):\n            if k == 0:\n                dp[v][k + 1] += dp[v][k]\n            else:\n                dp[v][k + 1] += dp[v][k]\n                dp[v][k + 1] %= MOD\n                for x, y in edges:\n                    if v == x:\n                        dp[y][k + 1] += dp[x][k]\n                        dp[y][k + 1] %= MOD\n    result = sum(dp[i][K] for i in range(1, N + 1)) % MOD\n    print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    edges = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(M)]\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    for k in range(K):\n        for v in range(1, N + 1):\n            if k == 0:\n                dp[v][k + 1] += dp[v][k]\n            else:\n                dp[v][k + 1] += dp[v][k]\n                dp[v][k + 1] %= MOD\n                for x, y in edges:\n                    if v == x:\n                        dp[y][k + 1] += dp[x][k]\n                        dp[y][k + 1] %= MOD\n    result = sum(dp[i][K] for i in range(1, N + 1)) % MOD\n    print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3552", "codes": ["def largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def construct_largest_palindrome(n):\n        if n == 1:\n            return '9'\n        half_length = (n + 1) // 2\n        half = ''.join(str(i) for i in range(9, 9 - half_length, -1))\n        if n % 2 == 0:\n            return half + half[::-1]\n        else:\n            return half[:-1] + str(9) + half[::-1]\n    \n    largest_palindrome = construct_largest_palindrome(n)\n    while True:\n        if int(largest_palindrome) % k == 0:\n            return largest_palindrome\n        if len(largest_palindrome) == 1:\n            break\n        # Decrement the middle part of the palindrome\n        if n % 2 == 0:\n            half_length = (n + 1) // 2\n            new_half = str(int(largest_palindrome[:half_length]) - 1).zfill(half_length)\n            largest_palindrome = new_half + new_half[::-1]\n        else:\n            half_length = n // 2\n            new_half = str(int(largest_palindrome[:half_length]) - 1).zfill(half_length)\n            largest_palindrome = new_half + '9' + new_half[::-1]\n    return \"-1\"  # No valid k-palindrome found\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\""], "passed": [false], "raw_code": ["```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def construct_largest_palindrome(n):\n        if n == 1:\n            return '9'\n        half_length = (n + 1) // 2\n        half = ''.join(str(i) for i in range(9, 9 - half_length, -1))\n        if n % 2 == 0:\n            return half + half[::-1]\n        else:\n            return half[:-1] + str(9) + half[::-1]\n    \n    largest_palindrome = construct_largest_palindrome(n)\n    while True:\n        if int(largest_palindrome) % k == 0:\n            return largest_palindrome\n        if len(largest_palindrome) == 1:\n            break\n        # Decrement the middle part of the palindrome\n        if n % 2 == 0:\n            half_length = (n + 1) // 2\n            new_half = str(int(largest_palindrome[:half_length]) - 1).zfill(half_length)\n            largest_palindrome = new_half + new_half[::-1]\n        else:\n            half_length = n // 2\n            new_half = str(int(largest_palindrome[:half_length]) - 1).zfill(half_length)\n            largest_palindrome = new_half + '9' + new_half[::-1]\n    return \"-1\"  # No valid k-palindrome found\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```"]}
{"task_id": "abc373_g", "codes": ["def find_permutation(N, points):\n    # Separate points into P and Q\n    P = points[:N]\n    Q = points[N:]\n    \n    # Sort P based on x-coordinates, and by y-coordinates if x-coordinates are the same\n    P.sort(key=lambda p: (p[0], p[1]))\n    \n    # Sort Q based on x-coordinates, and by y-coordinates if x-coordinates are the same\n    Q.sort(key=lambda q: (q[0], q[1]))\n    \n    # Create a mapping from P to Q\n    mapping = {}\n    for i in range(N):\n        for j in range(N):\n            if Q[j] == P[i]:\n                mapping[i] = j\n                break\n    \n    # Generate the permutation R\n    R = [mapping[i] + 1 for i in range(N)]\n    \n    return \" \".join(map(str, R))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)] + [(int(data[2*N+2*i+1]), int(data[2*N+2*i+2])) for i in range(N)]\n\n# Find the permutation\nresult = find_permutation(N, points)\n\n# Print the result\nprint(result)"], "passed": [false], "raw_code": ["```python\ndef find_permutation(N, points):\n    # Separate points into P and Q\n    P = points[:N]\n    Q = points[N:]\n    \n    # Sort P based on x-coordinates, and by y-coordinates if x-coordinates are the same\n    P.sort(key=lambda p: (p[0], p[1]))\n    \n    # Sort Q based on x-coordinates, and by y-coordinates if x-coordinates are the same\n    Q.sort(key=lambda q: (q[0], q[1]))\n    \n    # Create a mapping from P to Q\n    mapping = {}\n    for i in range(N):\n        for j in range(N):\n            if Q[j] == P[i]:\n                mapping[i] = j\n                break\n    \n    # Generate the permutation R\n    R = [mapping[i] + 1 for i in range(N)]\n    \n    return \" \".join(map(str, R))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)] + [(int(data[2*N+2*i+1]), int(data[2*N+2*i+2])) for i in range(N)]\n\n# Find the permutation\nresult = find_permutation(N, points)\n\n# Print the result\nprint(result)\n```"]}
{"task_id": "abc371_f", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef min_movements(N, X, Q, T, G):\n    # Sort the initial positions of the persons\n    X.sort()\n    \n    # Function to find the minimum number of movements for a given task\n    def min_moves_for_task(T_i, G_i):\n        left, right = 0, N - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if X[mid] == G_i:\n                return 0\n            elif X[mid] < G_i:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        # Calculate the minimum distance to the nearest person\n        if left < N:\n            min_dist = abs(X[left] - G_i)\n        else:\n            min_dist = float('inf')\n        \n        if right >= 0:\n            min_dist = min(min_dist, abs(X[right] - G_i))\n        \n        return min_dist\n    \n    # Calculate the total number of movements required for all tasks\n    total_moves = sum(min_moves_for_task(T[i] - 1, G[i]) for i in range(Q))\n    \n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\nT = [int(data[N+2+i*2]) for i in range(Q)]\nG = [int(data[N+3+i*2]) for i in range(Q)]\n\n# Print the result\nprint(min_movements(N, X, Q, T, G))"]}
{"task_id": "abc372_e", "codes": ["import heapq\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = defaultdict(list)\n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            graph[u].append(-v)\n            graph[v].append(-u)\n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            if not graph[v]:\n                results.append(-1)\n            else:\n                # Get the k-th largest element\n                heap = [-x for x in graph[v]]\n                heapq.heapify(heap)\n                for _ in range(k - 1):\n                    heapq.heappop(heap)\n                results.append(-heap[0])\n    \n    for result in results:\n        print(result)\n\nmain()"], "passed": [false], "raw_code": ["```python\nimport heapq\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = defaultdict(list)\n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            graph[u].append(-v)\n            graph[v].append(-u)\n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            if not graph[v]:\n                results.append(-1)\n            else:\n                # Get the k-th largest element\n                heap = [-x for x in graph[v]]\n                heapq.heapify(heap)\n                for _ in range(k - 1):\n                    heapq.heappop(heap)\n                results.append(-heap[0])\n    \n    for result in results:\n        print(result)\n\nmain()\n```"]}
{"task_id": "arc182_c", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    MAXP = 100  # Maximum possible prime factor\n    MAXM = 17   # Maximum possible value of M\n\n    # Prime factorization of numbers from 1 to M\n    prime_factors = [[] for _ in range(MAXM + 1)]\n    for i in range(2, MAXM + 1):\n        for j in range(i, MAXM + 1, i):\n            prime_factors[j].append(i)\n\n    # DP table: dp[i][j] -> number of sequences of length i with product factorization j\n    dp = [[0] * (1 << MAXP) for _ in range(N + 1)]\n    dp[0][0] = 1  # Base case: empty sequence has product factorization 1\n\n    for m in range(1, M + 1):\n        new_dp = [[0] * (1 << MAXP) for _ in range(N + 1)]\n        for i in range(N + 1):\n            for factorization in range(1 << MAXP):\n                if dp[i][factorization] == 0:\n                    continue\n                for prime in prime_factors[m]:\n                    new_factorization = factorization\n                    while new_factorization & (1 << prime):\n                        new_factorization ^= (1 << prime)\n                    new_dp[i + 1][new_factorization] = (new_dp[i + 1][new_factorization] + dp[i][factorization]) % MOD\n        dp = new_dp\n\n    total_score = 0\n    for i in range(1, N + 1):\n        for factorization in range(1 << MAXP):\n            count = dp[i][factorization]\n            num_divisors = 1\n            for prime in range(MAXP):\n                if factorization & (1 << prime):\n                    num_divisors *= (factorization.bit_count() + 1)\n            total_score = (total_score + count * num_divisors) % MOD\n\n    return total_score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Output the result\nprint(sum_of_scores(N, M))"]}
{"task_id": "abc368_g", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    A = list(map(int, data[index:index + N]))\n    index += N\n    \n    B = list(map(int, data[index:index + N]))\n    index += N\n    \n    Q = int(data[index])\n    index += 1\n    \n    def get_value(A, B, l, r):\n        v = 0\n        for i in range(l, r + 1):\n            v = max(v + A[i], v * B[i])\n        return v\n    \n    results = []\n    while index < len(data):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            A[i] = x\n        elif query_type == 2:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            B[i] = x\n        elif query_type == 3:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            index += 2\n            result = get_value(A, B, l, r)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    A = list(map(int, data[index:index + N]))\n    index += N\n    \n    B = list(map(int, data[index:index + N]))\n    index += N\n    \n    Q = int(data[index])\n    index += 1\n    \n    def get_value(A, B, l, r):\n        v = 0\n        for i in range(l, r + 1):\n            v = max(v + A[i], v * B[i])\n        return v\n    \n    results = []\n    while index < len(data):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            A[i] = x\n        elif query_type == 2:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            B[i] = x\n        elif query_type == 3:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            index += 2\n            result = get_value(A, B, l, r)\n            results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc371_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        unique_elements = set()\n        for j in range(i, N):\n            unique_elements.add(A[j])\n            total_sum += len(unique_elements)\n    \n    print(total_sum)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        unique_elements = set()\n        for j in range(i, N):\n            unique_elements.add(A[j])\n            total_sum += len(unique_elements)\n    \n    print(total_sum)\n\nmain()\n```"]}
{"task_id": "3551", "codes": ["class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_xor = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n            node.max_xor = max(node.max_xor, num)\n\n    def getMaxXor(self, num):\n        node = self.root\n        maxXor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if alt_bit in node.children:\n                maxXor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return maxXor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * n\n    prefix_xor[0] = nums[0]\n    for i in range(1, n):\n        prefix_xor[i] = prefix_xor[i-1] ^ nums[i]\n    \n    trie = Trie()\n    for xor in prefix_xor:\n        trie.insert(xor)\n    \n    result = []\n    for l, r in queries:\n        if l == 0:\n            result.append(trie.getMaxXor(prefix_xor[r]))\n        else:\n            result.append(trie.getMaxXor(prefix_xor[r]) ^ trie.getMaxXor(prefix_xor[l-1]))\n    \n    return result"], "passed": [false], "raw_code": ["```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_xor = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n            node.max_xor = max(node.max_xor, num)\n\n    def getMaxXor(self, num):\n        node = self.root\n        maxXor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if alt_bit in node.children:\n                maxXor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return maxXor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * n\n    prefix_xor[0] = nums[0]\n    for i in range(1, n):\n        prefix_xor[i] = prefix_xor[i-1] ^ nums[i]\n    \n    trie = Trie()\n    for xor in prefix_xor:\n        trie.insert(xor)\n    \n    result = []\n    for l, r in queries:\n        if l == 0:\n            result.append(trie.getMaxXor(prefix_xor[r]))\n        else:\n            result.append(trie.getMaxXor(prefix_xor[r]) ^ trie.getMaxXor(prefix_xor[l-1]))\n    \n    return result\n```"]}
{"task_id": "3548", "codes": ["def count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def can_form_palindrome(digits):\n        count = [0] * 10\n        for digit in digits:\n            count[digit] += 1\n        odd_count = 0\n        for c in count:\n            if c % 2 != 0:\n                odd_count += 1\n        return odd_count <= 1\n    \n    def count_combinations(digits, n):\n        from math import factorial\n        numerator = factorial(n)\n        denominator = 1\n        for count in digits:\n            denominator *= factorial(count)\n        return numerator // denominator\n    \n    def count_good_numbers(n, k):\n        if n == 1:\n            return 1 if k % 2 == 0 else 0\n        \n        digits = [0] * 10\n        for i in range(n):\n            digits[i % 10] += 1\n        \n        good_count = 0\n        for i in range(10):\n            if digits[i] > 0:\n                digits[i] -= 1\n                if can_form_palindrome(digits):\n                    good_count += count_combinations(digits, n - 1)\n                digits[i] += 1\n        \n        return good_count\n    \n    return count_good_numbers(n, k)"], "passed": [false], "raw_code": ["```python\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def can_form_palindrome(digits):\n        count = [0] * 10\n        for digit in digits:\n            count[digit] += 1\n        odd_count = 0\n        for c in count:\n            if c % 2 != 0:\n                odd_count += 1\n        return odd_count <= 1\n    \n    def count_combinations(digits, n):\n        from math import factorial\n        numerator = factorial(n)\n        denominator = 1\n        for count in digits:\n            denominator *= factorial(count)\n        return numerator // denominator\n    \n    def count_good_numbers(n, k):\n        if n == 1:\n            return 1 if k % 2 == 0 else 0\n        \n        digits = [0] * 10\n        for i in range(n):\n            digits[i % 10] += 1\n        \n        good_count = 0\n        for i in range(10):\n            if digits[i] > 0:\n                digits[i] -= 1\n                if can_form_palindrome(digits):\n                    good_count += count_combinations(digits, n - 1)\n                digits[i] += 1\n        \n        return good_count\n    \n    return count_good_numbers(n, k)\n```"]}
{"task_id": "3563", "codes": ["def maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_rows = set()\n    max_score = 0\n    \n    for row in grid:\n        if len(selected_rows) == len(grid):\n            break\n        \n        # Find the largest value in the current row that hasn't been selected yet\n        for col in range(len(row)-1, -1, -1):\n            if row[col] not in [grid[r][col] for r in selected_rows]:\n                max_score += row[col]\n                selected_rows.add(grid.index(row))\n                break\n    \n    return max_score"], "passed": [false], "raw_code": ["```python\ndef maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_rows = set()\n    max_score = 0\n    \n    for row in grid:\n        if len(selected_rows) == len(grid):\n            break\n        \n        # Find the largest value in the current row that hasn't been selected yet\n        for col in range(len(row)-1, -1, -1):\n            if row[col] not in [grid[r][col] for r in selected_rows]:\n                max_score += row[col]\n                selected_rows.add(grid.index(row))\n                break\n    \n    return max_score\n```"]}
{"task_id": "3580", "codes": ["def smallest_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count == 1:\n            return i\n    return -1"], "passed": [false], "raw_code": ["```python\ndef smallest_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count == 1:\n            return i\n    return -1\n```"]}
{"task_id": "arc182_e", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef calculate_min_mod_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    min_values = [float('inf')] * M\n    \n    # Function to compute (Ck + A[i]) % M\n    def mod_value(k, i):\n        return (C * k + A[i]) % M\n    \n    # Find the minimum values for the first few residues\n    for k in range(M):\n        for i in range(N):\n            val = mod_value(k, i)\n            if val < min_values[val]:\n                min_values[val] = val\n    \n    # Find the cycle length\n    cycle_length = None\n    for k in range(M):\n        if min_values[k] != float('inf'):\n            cycle_start = k\n            break\n    \n    current_val = cycle_start\n    for k in range(1, M):\n        next_val = mod_value(cycle_start + k, 0)\n        if next_val == current_val:\n            cycle_length = k\n            break\n    \n    # Calculate the sum of minimum values within one cycle\n    cycle_sum = sum(min_values[:cycle_length])\n    \n    # Number of complete cycles\n    num_complete_cycles = K // cycle_length\n    \n    # Remaining elements in the partial cycle\n    partial_cycle_size = K % cycle_length\n    \n    # Sum for the partial cycle\n    partial_cycle_sum = sum(min_values[:partial_cycle_size])\n    \n    # Total sum\n    total_sum = num_complete_cycles * cycle_sum + partial_cycle_sum\n    \n    print(total_sum)\n\ncalculate_min_mod_sum()"]}
{"task_id": "3550", "codes": ["def maxRooksSum(board):\n    m, n = len(board), len(board[0])\n    row_max_values = [-float('inf')] * m\n    col_max_values = [-float('inf')] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if board[i][j] > row_max_values[i]:\n                row_max_values[i] = board[i][j]\n    \n    for j in range(n):\n        for i in range(m):\n            if board[i][j] > col_max_values[j]:\n                col_max_values[j] = board[i][j]\n    \n    row_indices = set()\n    col_indices = set()\n    \n    for i in range(m):\n        max_val = row_max_values[i]\n        for j in range(n):\n            if board[i][j] == max_val and j not in col_indices:\n                row_indices.add(i)\n                col_indices.add(j)\n                break\n    \n    for j in range(n):\n        max_val = col_max_values[j]\n        for i in range(m):\n            if board[i][j] == max_val and i not in row_indices:\n                row_indices.add(i)\n                col_indices.add(j)\n                break\n    \n    if len(row_indices) != 3 or len(col_indices) != 3:\n        raise ValueError(\"Failed to find 3 unique rows and 3 unique columns\")\n    \n    result = 0\n    for i in row_indices:\n        for j in col_indices:\n            result += board[i][j]\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef maxRooksSum(board):\n    m, n = len(board), len(board[0])\n    row_max_values = [-float('inf')] * m\n    col_max_values = [-float('inf')] * n\n    \n    for i in range(m):\n        for j in range(n):\n            if board[i][j] > row_max_values[i]:\n                row_max_values[i] = board[i][j]\n    \n    for j in range(n):\n        for i in range(m):\n            if board[i][j] > col_max_values[j]:\n                col_max_values[j] = board[i][j]\n    \n    row_indices = set()\n    col_indices = set()\n    \n    for i in range(m):\n        max_val = row_max_values[i]\n        for j in range(n):\n            if board[i][j] == max_val and j not in col_indices:\n                row_indices.add(i)\n                col_indices.add(j)\n                break\n    \n    for j in range(n):\n        max_val = col_max_values[j]\n        for i in range(m):\n            if board[i][j] == max_val and i not in row_indices:\n                row_indices.add(i)\n                col_indices.add(j)\n                break\n    \n    if len(row_indices) != 3 or len(col_indices) != 3:\n        raise ValueError(\"Failed to find 3 unique rows and 3 unique columns\")\n    \n    result = 0\n    for i in row_indices:\n        for j in col_indices:\n            result += board[i][j]\n    \n    return result\n```"]}
{"task_id": "abc366_e", "codes": ["import sys\nfrom bisect import bisect_left, bisect_right\n\ndef count_valid_points(N, D, points):\n    def count_x_for_fixed_y(y):\n        x_values = [point[0] for point in points if abs(point[1] - y) <= D]\n        x_values.sort()\n        left = bisect_left(x_values, y - D)\n        right = bisect_right(x_values, y + D)\n        return right - left\n    \n    def count_y_for_fixed_x(x):\n        y_values = [point[1] for point in points if abs(point[0] - x) <= D]\n        y_values.sort()\n        left = bisect_left(y_values, x - D)\n        right = bisect_right(y_values, x + D)\n        return right - left\n    \n    total_count = 0\n    for y in set(point[1] for point in points):\n        total_count += count_x_for_fixed_y(y)\n    \n    for x in set(point[0] for point in points):\n        total_count += count_y_for_fixed_x(x)\n    \n    return total_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    result = count_valid_points(N, D, points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\nimport sys\nfrom bisect import bisect_left, bisect_right\n\ndef count_valid_points(N, D, points):\n    def count_x_for_fixed_y(y):\n        x_values = [point[0] for point in points if abs(point[1] - y) <= D]\n        x_values.sort()\n        left = bisect_left(x_values, y - D)\n        right = bisect_right(x_values, y + D)\n        return right - left\n    \n    def count_y_for_fixed_x(x):\n        y_values = [point[1] for point in points if abs(point[0] - x) <= D]\n        y_values.sort()\n        left = bisect_left(y_values, x - D)\n        right = bisect_right(y_values, x + D)\n        return right - left\n    \n    total_count = 0\n    for y in set(point[1] for point in points):\n        total_count += count_x_for_fixed_y(y)\n    \n    for x in set(point[0] for point in points):\n        total_count += count_y_for_fixed_x(x)\n    \n    return total_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    result = count_valid_points(N, D, points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_non_decr[0][i] = 1\n        dp_non_incr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_non_decr[i][j] = dp_non_decr[i-1][j]\n            if j > 0:\n                dp_non_decr[i][j] += dp_non_decr[i-1][j-1]\n            dp_non_incr[i][j] = dp_non_incr[i-1][j]\n            if j < 50:\n                dp_non_incr[i][j] += dp_non_incr[i-1][j+1]\n    \n    # Calculate the total number of valid pairs\n    total_pairs = 0\n    for i in range(n):\n        total_pairs += dp_non_decr[i][nums[i]] * dp_non_incr[i][nums[i]]\n        total_pairs %= MOD\n    \n    return total_pairs"], "passed": [false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_non_decr[0][i] = 1\n        dp_non_incr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_non_decr[i][j] = dp_non_decr[i-1][j]\n            if j > 0:\n                dp_non_decr[i][j] += dp_non_decr[i-1][j-1]\n            dp_non_incr[i][j] = dp_non_incr[i-1][j]\n            if j < 50:\n                dp_non_incr[i][j] += dp_non_incr[i-1][j+1]\n    \n    # Calculate the total number of valid pairs\n    total_pairs = 0\n    for i in range(n):\n        total_pairs += dp_non_decr[i][nums[i]] * dp_non_incr[i][nums[i]]\n        total_pairs %= MOD\n    \n    return total_pairs\n```"]}
{"task_id": "arc181_d", "codes": ["def count_inversions(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n\ndef apply_operations(N, P, M, A):\n    results = []\n    for a in A:\n        while P[a-1] != a:\n            if P[a-1] > P[a]:\n                P[a-1], P[a] = P[a], P[a-1]\n            a -= 1\n        results.append(count_inversions(P))\n    return results\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nM = int(input())\nA = list(map(int, input().split()))\n\n# Get results\nresults = apply_operations(N, P, M, A)\n\n# Print results\nfor result in results:\n    print(result)"], "passed": [false], "raw_code": ["```python\ndef count_inversions(arr):\n    inv_count = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n\ndef apply_operations(N, P, M, A):\n    results = []\n    for a in A:\n        while P[a-1] != a:\n            if P[a-1] > P[a]:\n                P[a-1], P[a] = P[a], P[a-1]\n            a -= 1\n        results.append(count_inversions(P))\n    return results\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nM = int(input())\nA = list(map(int, input().split()))\n\n# Get results\nresults = apply_operations(N, P, M, A)\n\n# Print results\nfor result in results:\n    print(result)\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(health[i] / damage[i], i) for i in range(len(damage))]\n    \n    # Sort enemies by their death times in descending order\n    times_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    # Simulate the attacks in reverse order of the sorted list\n    for time, index in times_to_die:\n        if health[index] > 0:\n            # Calculate the number of full attacks Bob can make before the enemy dies\n            full_attacks = int(time // power)\n            remaining_health = health[index] - full_attacks * power\n            \n            # Add the damage from full attacks to the total damage\n            total_damage += full_attacks * power\n            \n            # If there is remaining health, add the partial attack damage\n            if remaining_health > 0:\n                total_damage += remaining_health\n                \n            # Update the health of the enemy\n            health[index] -= full_attacks * power + remaining_health\n    \n    return total_damage"], "passed": [false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(health[i] / damage[i], i) for i in range(len(damage))]\n    \n    # Sort enemies by their death times in descending order\n    times_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    # Simulate the attacks in reverse order of the sorted list\n    for time, index in times_to_die:\n        if health[index] > 0:\n            # Calculate the number of full attacks Bob can make before the enemy dies\n            full_attacks = int(time // power)\n            remaining_health = health[index] - full_attacks * power\n            \n            # Add the damage from full attacks to the total damage\n            total_damage += full_attacks * power\n            \n            # If there is remaining health, add the partial attack damage\n            if remaining_health > 0:\n                total_damage += remaining_health\n                \n            # Update the health of the enemy\n            health[index] -= full_attacks * power + remaining_health\n    \n    return total_damage\n```"]}
{"task_id": "arc183_d", "codes": ["d"], "passed": [false], "raw_code": ["```python\ndef find_leaves(graph):\n    leaves = []\n    for node in graph:\n        if len(graph[node]) == 1:\n            leaves.append(node)\n    return leaves\n\ndef remove_leaf(graph, leaf):\n    neighbor = graph[leaf][0]\n    del graph[leaf]\n    graph[neighbor].remove(leaf)\n    return neighbor\n\ndef max_score_operations(N, edges):\n    graph = {i: [] for i in range(1, N+1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    operations = []\n    while len(graph) > 1:\n        leaves = find_leaves(graph)\n        leaf1 = leaves.pop()\n        leaf2 = leaves.pop()\n        operations.append((leaf1, leaf2))\n        \n        # Remove the leaves from the graph\n        leaf1_parent = remove_leaf(graph, leaf1)\n        leaf2_parent = remove_leaf(graph, leaf2)\n        \n        # If the parent of one leaf becomes a leaf, add it back to the list\n        if len(graph[leaf1_parent]) == 1:\n            leaves.append(leaf1_parent)\n        if len(graph[leaf2_parent]) == 1:\n            leaves.append(leaf2_parent)\n    \n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[i*2+1]), int(data[i*2+2])) for i in range((N-1)//2)]\n\n# Find the operations\noperations = max_score_operations(N, edges)\n\n# Print the result\nfor op in operations:\n    print(op[0], op[1])"]}
{"task_id": "abc370_f", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]));\n    A.sort(reverse=True)\n    groups = [0] * K\n    cuts_used = [False] * N\n    for i in range(N):\n        min_group_index = groups.index(min(groups))\n        groups[min_group_index] += A[i]\n        if i > 0:\n            cuts_used[i - 1] = True\n    unused_cuts = sum(not cu for cu in cuts_used)\n    print(min(groups), unused_cuts)\nmain()"], "passed": [false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]));\n    A.sort(reverse=True)\n    groups = [0] * K\n    cuts_used = [False] * N\n    for i in range(N):\n        min_group_index = groups.index(min(groups))\n        groups[min_group_index] += A[i]\n        if i > 0:\n            cuts_used[i - 1] = True\n    unused_cuts = sum(not cu for cu in cuts_used)\n    print(min(groups), unused_cuts)\nmain()"]}
{"task_id": "arc182_a", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    P = []\n    V = []\n    index = 2\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # dp[i][0]: Number of valid sequences ending at position i with the last operation on the left part\n    # dp[i][1]: Number of valid sequences ending at position i with the last operation on the right part\n    dp = [[0, 0] for _ in range(N + 1)]\n    \n    dp[0][0] = 1\n    dp[0][1] = 1\n    \n    for i in range(Q):\n        p = P[i]\n        v = V[i]\n        \n        new_dp = [[0, 0] for _ in range(N + 1)]\n        \n        for j in range(p):\n            if v <= dp[j][0]:\n                new_dp[j][0] = (new_dp[j][0] + dp[j][0]) % MOD\n        \n        for j in range(p, N):\n            if v <= dp[j][1]:\n                new_dp[j][1] = (new_dp[j][1] + dp[j][1]) % MOD\n        \n        dp = new_dp\n    \n    result = sum(dp[N]) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    P = []\n    V = []\n    index = 2\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # dp[i][0]: Number of valid sequences ending at position i with the last operation on the left part\n    # dp[i][1]: Number of valid sequences ending at position i with the last operation on the right part\n    dp = [[0, 0] for _ in range(N + 1)]\n    \n    dp[0][0] = 1\n    dp[0][1] = 1\n    \n    for i in range(Q):\n        p = P[i]\n        v = V[i]\n        \n        new_dp = [[0, 0] for _ in range(N + 1)]\n        \n        for j in range(p):\n            if v <= dp[j][0]:\n                new_dp[j][0] = (new_dp[j][0] + dp[j][0]) % MOD\n        \n        for j in range(p, N):\n            if v <= dp[j][1]:\n                new_dp[j][1] = (new_dp[j][1] + dp[j][1]) % MOD\n        \n        dp = new_dp\n    \n    result = sum(dp[N]) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc372_g", "codes": ["def count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    \n    # Iterate over possible values of y\n    for y in range(1, max(C)):\n        max_x = 0\n        for i in range(N):\n            if A[i] * y >= C[i]:\n                break\n            max_x = max(max_x, (C[i] - B[i] * y - 1) // A[i])\n        \n        if max_x > 0:\n            count += max_x\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        \n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        results.append(count_valid_pairs(A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    \n    # Iterate over possible values of y\n    for y in range(1, max(C)):\n        max_x = 0\n        for i in range(N):\n            if A[i] * y >= C[i]:\n                break\n            max_x = max(max_x, (C[i] - B[i] * y - 1) // A[i])\n        \n        if max_x > 0:\n            count += max_x\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        \n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        results.append(count_valid_pairs(A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3575", "codes": ["def max_xor_subsequence(nums, k):\n    n = len(nums)\n    dp = {}\n    \n    for num in nums:\n        new_dp = {}\n        for key, val in dp.items():\n            new_key = key | num\n            if new_key not in new_dp or new_dp[new_key] < val ^ num:\n                new_dp[new_key] = val ^ num\n        if num not in new_dp or new_dp[num] < num:\n            new_dp[num] = num\n        dp = new_dp\n    \n    return dp.get(2 * k, 0)"], "passed": [false], "raw_code": ["```python\ndef max_xor_subsequence(nums, k):\n    n = len(nums)\n    dp = {}\n    \n    for num in nums:\n        new_dp = {}\n        for key, val in dp.items():\n            new_key = key | num\n            if new_key not in new_dp or new_dp[new_key] < val ^ num:\n                new_dp[new_key] = val ^ num\n        if num not in new_dp or new_dp[num] < num:\n            new_dp[num] = num\n        dp = new_dp\n    \n    return dp.get(2 * k, 0)\n```"]}
{"task_id": "arc181_c", "codes": ["def generate_grid(N, P, Q):\n    # Step 1: Initialize an empty N-by-N grid\n    grid = [['' for _ in range(N)] for _ in range(N)]\n    \n    # Step 2: Fill the grid row by row based on the permutation P\n    for i in range(N):\n        row = list(range(1, N + 1))\n        row.sort()\n        for j in range(N):\n            grid[i][j] = str(row[j - 1])\n    \n    # Step 3: Adjust the columns to ensure they are sorted according to the permutation Q\n    for j in range(N):\n        col = [grid[i][j] for i in range(N)]\n        col.sort()\n        for i in range(N):\n            grid[i][j] = col[Q[i] - 1]\n    \n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\ngenerate_grid(N, P, Q)"], "passed": [false], "raw_code": ["```python\ndef generate_grid(N, P, Q):\n    # Step 1: Initialize an empty N-by-N grid\n    grid = [['' for _ in range(N)] for _ in range(N)]\n    \n    # Step 2: Fill the grid row by row based on the permutation P\n    for i in range(N):\n        row = list(range(1, N + 1))\n        row.sort()\n        for j in range(N):\n            grid[i][j] = str(row[j - 1])\n    \n    # Step 3: Adjust the columns to ensure they are sorted according to the permutation Q\n    for j in range(N):\n        col = [grid[i][j] for i in range(N)]\n        col.sort()\n        for i in range(N):\n            grid[i][j] = col[Q[i] - 1]\n    \n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\ngenerate_grid(N, P, Q)\n```"]}
{"task_id": "3583", "codes": ["def minOperations(nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    max_val = max(nums)\n    freq = [0] * (max_val + 1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            freq[gcd(nums[i], nums[j])] += 1\n    \n    prefix_sum = [0] * (max_val + 1)\n    for i in range(1, max_val + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + freq[i]\n    \n    def get_index(val):\n        return prefix_sum[val]\n    \n    return get_index"], "passed": [false], "raw_code": ["```python\ndef minOperations(nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    max_val = max(nums)\n    freq = [0] * (max_val + 1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            freq[gcd(nums[i], nums[j])] += 1\n    \n    prefix_sum = [0] * (max_val + 1)\n    for i in range(1, max_val + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + freq[i]\n    \n    def get_index(val):\n        return prefix_sum[val]\n    \n    return get_index\n```"]}
{"task_id": "abc368_d", "codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef min_vertices_to_include_all(N, K, edges, V):\n    # Build the adjacency list for the tree\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Function to perform DFS and return the distance to the farthest vertex\n    def dfs(start, visited):\n        stack = [(start, 0)]\n        max_dist = 0\n        while stack:\n            node, dist = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                max_dist = max(max_dist, dist)\n                for neighbor in adj[node]:\n                    stack.append((neighbor, dist + 1))\n        return max_dist\n\n    # Calculate the maximum distance from each of the K vertices to their farthest descendant\n    max_dists = [dfs(v, set()) for v in V]\n\n    # The minimum number of vertices needed is the maximum distance plus one\n    return max(max_dists) + 1\n\n# Read input from standard input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    edges.append((u, v))\nV = list(map(int, data[2 * N + 1:]))\n\n# Calculate and print the result\nprint(min_vertices_to_include_all(N, K, edges, V))"], "passed": [false], "raw_code": ["import sys\nfrom collections import defaultdict, deque\n\ndef min_vertices_to_include_all(N, K, edges, V):\n    # Build the adjacency list for the tree\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # Function to perform DFS and return the distance to the farthest vertex\n    def dfs(start, visited):\n        stack = [(start, 0)]\n        max_dist = 0\n        while stack:\n            node, dist = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                max_dist = max(max_dist, dist)\n                for neighbor in adj[node]:\n                    stack.append((neighbor, dist + 1))\n        return max_dist\n\n    # Calculate the maximum distance from each of the K vertices to their farthest descendant\n    max_dists = [dfs(v, set()) for v in V]\n\n    # The minimum number of vertices needed is the maximum distance plus one\n    return max(max_dists) + 1\n\n# Read input from standard input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    edges.append((u, v))\nV = list(map(int, data[2 * N + 1:]))\n\n# Calculate and print the result\nprint(min_vertices_to_include_all(N, K, edges, V))"]}
{"task_id": "3527", "codes": ["def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend the list to handle circular nature\n    prefix_sum = [0] * (n + 2)\n    for i in range(n + 1):\n        prefix_sum[i + 1] = prefix_sum[i] + (colors[i] != colors[i + 1])\n\n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if prefix_sum[i + size] - prefix_sum[i] == size - 1:\n                count += 1\n        return count\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            old_color = colors[query[1]]\n            colors[query[1]] = query[2]\n            if old_color != query[2]:\n                for size in range(3, n + 1):\n                    if prefix_sum[query[1] + size] - prefix_sum[query[1]] == size - 1:\n                        result[-1] -= 1\n                    if prefix_sum[query[1] + size] - prefix_sum[(query[1] + size) % n] == size - 1:\n                        result[-1] += 1\n    return result"], "passed": [false], "raw_code": ["def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend the list to handle circular nature\n    prefix_sum = [0] * (n + 2)\n    for i in range(n + 1):\n        prefix_sum[i + 1] = prefix_sum[i] + (colors[i] != colors[i + 1])\n\n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if prefix_sum[i + size] - prefix_sum[i] == size - 1:\n                count += 1\n        return count\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            old_color = colors[query[1]]\n            colors[query[1]] = query[2]\n            if old_color != query[2]:\n                for size in range(3, n + 1):\n                    if prefix_sum[query[1] + size] - prefix_sum[query[1]] == size - 1:\n                        result[-1] -= 1\n                    if prefix_sum[query[1] + size] - prefix_sum[(query[1] + size) % n] == size - 1:\n                        result[-1] += 1\n    return result"]}
{"task_id": "abc370_g", "codes": ["def sum_of_divisors(n):\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    return result\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\nMOD = 998244353\n\ndef count_sequences(N, M):\n    dp = [[[0] * 3 for _ in range(N + 1)] for _ in range(M + 1)]\n    dp[0][1][0] = 1\n\n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            for k in range(3):\n                for d in range(1, j + 1):\n                    if j % d == 0:\n                        if is_good_integer(d):\n                            dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j // d][(k + sum_of_divisors(d)) % 3]) % MOD\n\n    result = 0\n    for j in range(1, N + 1):\n        for k in range(3):\n            result = (result + dp[M][j][k]) % MOD\n\n    return result\n\n# Read input\nN, M = map(int, input().split())\n\n# Print the result\nprint(count_sequences(N, M))"], "passed": [false], "raw_code": ["```python\ndef sum_of_divisors(n):\n    result = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    return result\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\nMOD = 998244353\n\ndef count_sequences(N, M):\n    dp = [[[0] * 3 for _ in range(N + 1)] for _ in range(M + 1)]\n    dp[0][1][0] = 1\n\n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            for k in range(3):\n                for d in range(1, j + 1):\n                    if j % d == 0:\n                        if is_good_integer(d):\n                            dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j // d][(k + sum_of_divisors(d)) % 3]) % MOD\n\n    result = 0\n    for j in range(1, N + 1):\n        for k in range(3):\n            result = (result + dp[M][j][k]) % MOD\n\n    return result\n\n# Read input\nN, M = map(int, input().split())\n\n# Print the result\nprint(count_sequences(N, M))\n```"]}
{"task_id": "3560", "codes": ["def min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, dist = queue.pop(0)\n        if cx == px and cy == py:\n            return dist\n        for dx, dy in moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, dist + 1))\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n    \n    def dfs(mask):\n        if dp[mask] != -1:\n            return dp[mask]\n        \n        alice_turn = bin(mask).count('1') % 2 == 1\n        max_moves = float('-inf')\n        \n        for i in range(n):\n            if mask & (1 << i):\n                px, py = positions[i]\n                moves = min_moves_to_capture(kx, ky, px, py)\n                new_mask = mask ^ (1 << i)\n                if alice_turn:\n                    max_moves = max(max_moves, moves + dfs(new_mask))\n                else:\n                    max_moves = min(max_moves, moves + dfs(new_mask))\n        \n        dp[mask] = max_moves\n        return dp[mask]\n    \n    return dfs((1 << n) - 1)\n\n# Example usage:\nprint(max_moves_alice(1, 1, [[0, 0]]))  # Output: 4\nprint(max_moves_alice(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_moves_alice(0, 0, [[1, 2], [2, 4]]))  # Output: 3"], "passed": [false], "raw_code": ["```python\ndef min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, dist = queue.pop(0)\n        if cx == px and cy == py:\n            return dist\n        for dx, dy in moves:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, dist + 1))\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n    \n    def dfs(mask):\n        if dp[mask] != -1:\n            return dp[mask]\n        \n        alice_turn = bin(mask).count('1') % 2 == 1\n        max_moves = float('-inf')\n        \n        for i in range(n):\n            if mask & (1 << i):\n                px, py = positions[i]\n                moves = min_moves_to_capture(kx, ky, px, py)\n                new_mask = mask ^ (1 << i)\n                if alice_turn:\n                    max_moves = max(max_moves, moves + dfs(new_mask))\n                else:\n                    max_moves = min(max_moves, moves + dfs(new_mask))\n        \n        dp[mask] = max_moves\n        return dp[mask]\n    \n    return dfs((1 << n) - 1)\n\n# Example usage:\nprint(max_moves_alice(1, 1, [[0, 0]]))  # Output: 4\nprint(max_moves_alice(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_moves_alice(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```"]}
{"task_id": "arc183_c", "codes": ["def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for l, r, x in conditions:\n        new_dp = [0] * (N + 1)\n        for i in range(N + 1):\n            if i >= l - 1 and i <= r - 1:\n                if i == x - 1:\n                    new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n                else:\n                    new_dp[i] = (new_dp[i] + dp[i - 1] * (i - l + 1)) % MOD\n            else:\n                new_dp[i] = dp[i]\n        dp = new_dp\n    return dp[N]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = [(int(data[2 + 3 * i]), int(data[3 + 3 * i]), int(data[4 + 3 * i])) for i in range(M)]\nprint(count_valid_permutations(N, M, conditions))"], "passed": [false], "raw_code": ["def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for l, r, x in conditions:\n        new_dp = [0] * (N + 1)\n        for i in range(N + 1):\n            if i >= l - 1 and i <= r - 1:\n                if i == x - 1:\n                    new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n                else:\n                    new_dp[i] = (new_dp[i] + dp[i - 1] * (i - l + 1)) % MOD\n            else:\n                new_dp[i] = dp[i]\n        dp = new_dp\n    return dp[N]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = [(int(data[2 + 3 * i]), int(data[3 + 3 * i]), int(data[4 + 3 * i])) for i in range(M)]\nprint(count_valid_permutations(N, M, conditions))"]}
{"task_id": "abc373_e", "codes": ["def min_additional_votes(N, M, K, A):\n    # Calculate the total number of votes currently counted\n    total_counted = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_counted\n    # Initialize the result list\n    results = []\n    # Iterate through each candidate\n    for i in range(N):\n        # Calculate the maximum votes the current candidate could get\n        max_votes_current = A[i] + remaining_votes\n        # Calculate the number of candidates with more votes than the current candidate\n        count_more_votes = sum(1 for j in range(N) if A[j] > A[i])\n        # Check if the current candidate can guarantee victory\n        if count_more_votes < M:\n            # Calculate the minimum additional votes needed\n            min_additional = 0\n        elif remaining_votes == 0:\n            min_additional = -1\n        else:\n            # Binary search to find the minimum additional votes needed\n            low, high = 0, remaining_votes\n            while low < high:\n                mid = (low + high) // 2\n                max_votes_current = A[i] + mid\n                count_more_votes = sum(1 for j in range(N) if A[j] > max_votes_current)\n                if count_more_votes >= M:\n                    low = mid + 1\n                else:\n                    high = mid\n            min_additional = low\n        # Append the result for the current candidate\n        results.append(min_additional)\n    # Return the results as a space-separated string\n    return ' '.join(map(str, results))\n\n# Example usage\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    print(min_additional_votes(N, M, K, A))"], "passed": [false], "raw_code": ["def min_additional_votes(N, M, K, A):\n    # Calculate the total number of votes currently counted\n    total_counted = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_counted\n    # Initialize the result list\n    results = []\n    # Iterate through each candidate\n    for i in range(N):\n        # Calculate the maximum votes the current candidate could get\n        max_votes_current = A[i] + remaining_votes\n        # Calculate the number of candidates with more votes than the current candidate\n        count_more_votes = sum(1 for j in range(N) if A[j] > A[i])\n        # Check if the current candidate can guarantee victory\n        if count_more_votes < M:\n            # Calculate the minimum additional votes needed\n            min_additional = 0\n        elif remaining_votes == 0:\n            min_additional = -1\n        else:\n            # Binary search to find the minimum additional votes needed\n            low, high = 0, remaining_votes\n            while low < high:\n                mid = (low + high) // 2\n                max_votes_current = A[i] + mid\n                count_more_votes = sum(1 for j in range(N) if A[j] > max_votes_current)\n                if count_more_votes >= M:\n                    low = mid + 1\n                else:\n                    high = mid\n            min_additional = low\n        # Append the result for the current candidate\n        results.append(min_additional)\n    # Return the results as a space-separated string\n    return ' '.join(map(str, results))\n\n# Example usage\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    print(min_additional_votes(N, M, K, A))"]}
{"task_id": "abc369_g", "codes": ["import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    # Precompute distances using Floyd-Warshall algorithm\n    dist = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        dist[i][i] = 0\n    \n    for _ in range(N - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        l = int(data[index + 2])\n        index += 3\n        dist[u][v] = l\n        dist[v][u] = l\n    \n    for k in range(1, N + 1):\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # DP table to store the minimum cost to visit all subsets of vertices ending at each vertex\n    dp = [[float('inf')] * (N + 1) for _ in range(1 << N)]\n    for v in range(1, N + 1):\n        dp[1 << (v - 1)][v] = 0\n    \n    for mask in range(1, 1 << N):\n        for v in range(1, N + 1):\n            if mask & (1 << (v - 1)):\n                for u in range(1, N + 1):\n                    if u != v and mask & (1 << (u - 1)):\n                        new_mask = mask ^ (1 << (v - 1))\n                        dp[new_mask][u] = min(dp[new_mask][u], dp[mask][v] + dist[v][u])\n    \n    # Print the results\n    for K in range(1, N + 1):\n        result = float('inf')\n        for v in range(1, N + 1):\n            if (1 << (v - 1)) & ((1 << K) - 1):\n                result = min(result, dp[(1 << K) - 1][v] + dist[v][1])\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    # Precompute distances using Floyd-Warshall algorithm\n    dist = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        dist[i][i] = 0\n    \n    for _ in range(N - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        l = int(data[index + 2])\n        index += 3\n        dist[u][v] = l\n        dist[v][u] = l\n    \n    for k in range(1, N + 1):\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # DP table to store the minimum cost to visit all subsets of vertices ending at each vertex\n    dp = [[float('inf')] * (N + 1) for _ in range(1 << N)]\n    for v in range(1, N + 1):\n        dp[1 << (v - 1)][v] = 0\n    \n    for mask in range(1, 1 << N):\n        for v in range(1, N + 1):\n            if mask & (1 << (v - 1)):\n                for u in range(1, N + 1):\n                    if u != v and mask & (1 << (u - 1)):\n                        new_mask = mask ^ (1 << (v - 1))\n                        dp[new_mask][u] = min(dp[new_mask][u], dp[mask][v] + dist[v][u])\n    \n    # Print the results\n    for K in range(1, N + 1):\n        result = float('inf')\n        for v in range(1, N + 1):\n            if (1 << (v - 1)) & ((1 << K) - 1):\n                result = min(result, dp[(1 << K) - 1][v] + dist[v][1])\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc371_g", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n\n    # Create a mapping of each element to its index in A\n    index_map = {a: i for i, a in enumerate(A)}\n\n    # Initialize the result array with zeros\n    result = [0] * N\n\n    # Process each element in A based on the permutation cycle it belongs to\n    visited = set()\n    for i in range(N):\n        if i not in visited:\n            cycle = []\n            x = i\n            while x not in visited:\n                cycle.append(x)\n                visited.add(x)\n                x = P[x] - 1\n\n            # Sort the elements in the current cycle\n            sorted_cycle = sorted(cycle, key=lambda x: A[x])\n\n            # Place the sorted elements back into the result array\n            for j, idx in enumerate(sorted_cycle):\n                result[idx] = A[cycle[j]]\n\n    # Print the result array\n    print(' '.join(map(str, result)))\n\nmain()"], "passed": [false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n\n    # Create a mapping of each element to its index in A\n    index_map = {a: i for i, a in enumerate(A)}\n\n    # Initialize the result array with zeros\n    result = [0] * N\n\n    # Process each element in A based on the permutation cycle it belongs to\n    visited = set()\n    for i in range(N):\n        if i not in visited:\n            cycle = []\n            x = i\n            while x not in visited:\n                cycle.append(x)\n                visited.add(x)\n                x = P[x] - 1\n\n            # Sort the elements in the current cycle\n            sorted_cycle = sorted(cycle, key=lambda x: A[x])\n\n            # Place the sorted elements back into the result array\n            for j, idx in enumerate(sorted_cycle):\n                result[idx] = A[cycle[j]]\n\n    # Print the result array\n    print(' '.join(map(str, result)))\n\nmain()"]}
{"task_id": "3571", "codes": ["def maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    coordinates.sort()\n    \n    # Create adjacency list and in-degree array\n    adj = [[] for _ in range(n)]\n    indegree = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                adj[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sorting using Kahn's algorithm\n    queue = [i for i in range(n) if indegree[i] == 0]\n    dp = [1] * n\n    \n    while queue:\n        u = queue.pop(0)\n        for v in adj[u]:\n            dp[v] = max(dp[v], dp[u] + 1)\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    return dp[k]"], "passed": [false], "raw_code": ["```python\ndef maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    coordinates.sort()\n    \n    # Create adjacency list and in-degree array\n    adj = [[] for _ in range(n)]\n    indegree = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                adj[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sorting using Kahn's algorithm\n    queue = [i for i in range(n) if indegree[i] == 0]\n    dp = [1] * n\n    \n    while queue:\n        u = queue.pop(0)\n        for v in adj[u]:\n            dp[v] = max(dp[v], dp[u] + 1)\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    return dp[k]\n```"]}
{"task_id": "arc183_b", "codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef is_possible_to_transform(T):\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        \n        index += 2 + 2 * N\n        \n        # Create adjacency list for the graph\n        adj_list = defaultdict(list)\n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[i] != A[j]:\n                    adj_list[A[i]].append(A[j])\n                    adj_list[A[j]].append(A[i])\n        \n        # Check if the graph is connected\n        visited = set()\n        queue = deque([A[0]])\n        \n        while queue:\n            node = queue.popleft()\n            if node not in visited:\n                visited.add(node)\n                for neighbor in adj_list[node]:\n                    queue.append(neighbor)\n        \n        if len(visited) == len(set(A)):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return \"\\n\".join(results)\n\n# Call the function and print the result\nprint(is_possible_to_transform(int(input())))"], "passed": [false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef is_possible_to_transform(T):\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        \n        index += 2 + 2 * N\n        \n        # Create adjacency list for the graph\n        adj_list = defaultdict(list)\n        for i in range(N):\n            for j in range(max(0, i - K), min(N, i + K + 1)):\n                if A[i] != A[j]:\n                    adj_list[A[i]].append(A[j])\n                    adj_list[A[j]].append(A[i])\n        \n        # Check if the graph is connected\n        visited = set()\n        queue = deque([A[0]])\n        \n        while queue:\n            node = queue.popleft()\n            if node not in visited:\n                visited.add(node)\n                for neighbor in adj_list[node]:\n                    queue.append(neighbor)\n        \n        if len(visited) == len(set(A)):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return \"\\n\".join(results)\n\n# Call the function and print the result\nprint(is_possible_to_transform(int(input())))\n```"]}
{"task_id": "abc368_e", "codes": ["def min_transfer_delays(N, M, X1, trains):\n    # Sort trains by their arrival times\n    trains.sort(key=lambda x: x[3])\n    # Initialize the list of delays\n    delays = [0] * M\n    # Set the first delay to X1\n    delays[0] = X1\n    # Iterate over the remaining trains\n    for i in range(1, M):\n        # Get the current train and the previous train\n        current_train = trains[i]\n        prev_train = trains[i - 1]\n        # Check if the current train can transfer from the previous train\n        if current_train[0] == prev_train[1] and current_train[2] <= prev_train[3]:\n            # Calculate the required delay to maintain the transfer condition\n            delays[i] = max(0, prev_train[3] + delays[i - 1] - current_train[2])\n    # Return the list of delays\n    return ' '.join(map(str, delays))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = []\nfor i in range(M):\n    A = int(data[3 + 4 * i])\n    B = int(data[4 + 4 * i])\n    S = int(data[5 + 4 * i])\n    T = int(data[6 + 4 * i])\n    trains.append((A, B, S, T))\n\n# Call the function and print the result\nprint(min_transfer_delays(N, M, X1, trains))"], "passed": [false], "raw_code": ["def min_transfer_delays(N, M, X1, trains):\n    # Sort trains by their arrival times\n    trains.sort(key=lambda x: x[3])\n    # Initialize the list of delays\n    delays = [0] * M\n    # Set the first delay to X1\n    delays[0] = X1\n    # Iterate over the remaining trains\n    for i in range(1, M):\n        # Get the current train and the previous train\n        current_train = trains[i]\n        prev_train = trains[i - 1]\n        # Check if the current train can transfer from the previous train\n        if current_train[0] == prev_train[1] and current_train[2] <= prev_train[3]:\n            # Calculate the required delay to maintain the transfer condition\n            delays[i] = max(0, prev_train[3] + delays[i - 1] - current_train[2])\n    # Return the list of delays\n    return ' '.join(map(str, delays))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = []\nfor i in range(M):\n    A = int(data[3 + 4 * i])\n    B = int(data[4 + 4 * i])\n    S = int(data[5 + 4 * i])\n    T = int(data[6 + 4 * i])\n    trains.append((A, B, S, T))\n\n# Call the function and print the result\nprint(min_transfer_delays(N, M, X1, trains))"]}
{"final_accuracy": "0.00%"}
