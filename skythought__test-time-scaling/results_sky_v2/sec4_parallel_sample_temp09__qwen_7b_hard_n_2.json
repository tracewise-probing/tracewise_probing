{"difficulty": "hard", "num_threads": 32, "temperature": 0.9, "n": 2, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp09__qwen_7b_hard_n_2.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    odd_count = sum(a % 2 == 1 for a in A)\n\n    if odd_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count how many elements are greater than 1\n    count_greater_than_one = sum(1 for x in A if x > 1)\n    \n    # If the count is odd, Anna wins; otherwise, Bruno wins\n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function\ndetermine_winner()"]}
{"task_id": "abc365_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Step 1: Compute the prefix XOR array\n    prefix_xor = [0] * N\n    prefix_xor[0] = A[0]\n    for i in range(1, N):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i]\n\n    # Step 2: Count the contributions of each element\n    total_sum = 0\n    for i in range(N):\n        total_sum += (prefix_xor[i] ^ prefix_xor[N - 1]) * (N - i)\n\n    print(total_sum)\n\n# Call the function\nmain()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize prefix XOR and frequency dictionary\n    prefix_xor = 0\n    freq = {0: 1}\n    total_sum = 0\n    \n    for i in range(N):\n        prefix_xor ^= A[i]\n        total_sum += freq.get(prefix_xor, 0)\n        freq[prefix_xor] = freq.get(prefix_xor, 0) + 1\n    \n    print(total_sum)\n\n# Call the function to execute\nsolve()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Step 1: Compute the prefix XOR array\n    prefix_xor = [0] * N\n    prefix_xor[0] = A[0]\n    for i in range(1, N):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i]\n\n    # Step 2: Count the contributions of each element\n    total_sum = 0\n    for i in range(N):\n        total_sum += (prefix_xor[i] ^ prefix_xor[N - 1]) * (N - i)\n\n    print(total_sum)\n\n# Call the function\nmain()\n```", "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize prefix XOR and frequency dictionary\n    prefix_xor = 0\n    freq = {0: 1}\n    total_sum = 0\n    \n    for i in range(N):\n        prefix_xor ^= A[i]\n        total_sum += freq.get(prefix_xor, 0)\n        freq[prefix_xor] = freq.get(prefix_xor, 0) + 1\n    \n    print(total_sum)\n\n# Call the function to execute\nsolve()\n```"]}
{"task_id": "abc366_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    # Sort points by x-coordinate, then by y-coordinate\n    points.sort(key=lambda p: (p[0], p[1]))\n    \n    # Function to calculate the Manhattan distance between two points\n    def manhattan(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    # Initialize variables for sliding window\n    left_x = 0\n    right_x = 0\n    left_y = 0\n    right_y = 0\n    count = 0\n    \n    for x in range(-10**6, 10**6 + 1):\n        # Move the right_y boundary to maintain the Manhattan distance constraint\n        while right_y < len(points) and manhattan((x, 0), points[right_y]) <= D:\n            right_y += 1\n        \n        # Move the left_y boundary to maintain the Manhattan distance constraint\n        while left_y < right_y and manhattan((x, 0), points[left_y]) > D:\n            left_y += 1\n        \n        # Count the valid (x, y) pairs for the current x\n        if right_y > left_y:\n            count += (right_y - left_y)\n    \n    print(count)\n\n# Call the main function\nmain()", "d"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    # Sort points by x-coordinate, then by y-coordinate\n    points.sort(key=lambda p: (p[0], p[1]))\n    \n    # Function to calculate the Manhattan distance between two points\n    def manhattan(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    # Initialize variables for sliding window\n    left_x = 0\n    right_x = 0\n    left_y = 0\n    right_y = 0\n    count = 0\n    \n    for x in range(-10**6, 10**6 + 1):\n        # Move the right_y boundary to maintain the Manhattan distance constraint\n        while right_y < len(points) and manhattan((x, 0), points[right_y]) <= D:\n            right_y += 1\n        \n        # Move the left_y boundary to maintain the Manhattan distance constraint\n        while left_y < right_y and manhattan((x, 0), points[left_y]) > D:\n            left_y += 1\n        \n        # Count the valid (x, y) pairs for the current x\n        if right_y > left_y:\n            count += (right_y - left_y)\n    \n    print(count)\n\n# Call the main function\nmain()\n```", "```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    D = int(data[1])\n    \n    points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\n    \n    # Initialize counters\n    count = 0\n    \n    # Iterate over all possible x and y values within the bounds of the points\n    for x in range(-10**6, 10**6 + 1):\n        for y in range(-10**6, 10**6 + 1):\n            if sum(abs(x - px) + abs(y - py) for px, py in points) <= D:\n                count += 1\n                \n    print(count)\n\ncount_valid_pairs()"]}
{"task_id": "arc181_c", "codes": ["def generate_grid(N, P, Q):\n    # Initialize the grid with zeros\n    grid = [[0] * N for _ in range(N)]\n    \n    # Helper function to check if placing 'num' at (row, col) is valid\n    def is_valid(row, col, num):\n        for i in range(col):\n            if grid[row][i] >= num:\n                return False\n        for i in range(row):\n            if grid[i][col] >= num:\n                return False\n        return True\n    \n    # Fill the grid using a greedy approach\n    numbers = list(range(1, N + 1))\n    for num in numbers:\n        placed = False\n        for i in range(N):\n            for j in range(N):\n                if is_valid(i, j, num):\n                    grid[i][j] = num\n                    placed = True\n                    break\n            if placed:\n                break\n    \n    # Convert the grid to the required format\n    result = []\n    for row in grid:\n        result.append(''.join(map(str, row)))\n    \n    return '\\n'.join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))", "def generate_grid(N, P, Q):\n    # Create a list to store the binary strings for rows and columns\n    rows = [''] * N\n    cols = [''] * N\n    \n    # Fill the rows and columns based on the permutations P and Q\n    for i in range(N):\n        rows[P[i] - 1] += str(i % 2)\n        cols[Q[i] - 1] += str(i % 2)\n    \n    # Construct the grid\n    grid = []\n    for r in rows:\n        grid.append(r + '\\n')\n    \n    return ''.join(grid)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))"], "passed": [false, false], "raw_code": ["```python\ndef generate_grid(N, P, Q):\n    # Initialize the grid with zeros\n    grid = [[0] * N for _ in range(N)]\n    \n    # Helper function to check if placing 'num' at (row, col) is valid\n    def is_valid(row, col, num):\n        for i in range(col):\n            if grid[row][i] >= num:\n                return False\n        for i in range(row):\n            if grid[i][col] >= num:\n                return False\n        return True\n    \n    # Fill the grid using a greedy approach\n    numbers = list(range(1, N + 1))\n    for num in numbers:\n        placed = False\n        for i in range(N):\n            for j in range(N):\n                if is_valid(i, j, num):\n                    grid[i][j] = num\n                    placed = True\n                    break\n            if placed:\n                break\n    \n    # Convert the grid to the required format\n    result = []\n    for row in grid:\n        result.append(''.join(map(str, row)))\n    \n    return '\\n'.join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))\n```", "```python\ndef generate_grid(N, P, Q):\n    # Create a list to store the binary strings for rows and columns\n    rows = [''] * N\n    cols = [''] * N\n    \n    # Fill the rows and columns based on the permutations P and Q\n    for i in range(N):\n        rows[P[i] - 1] += str(i % 2)\n        cols[Q[i] - 1] += str(i % 2)\n    \n    # Construct the grid\n    grid = []\n    for r in rows:\n        grid.append(r + '\\n')\n    \n    return ''.join(grid)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums: List[int]) -> int:\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(1, 51):\n        for j in range(1, 51):\n            if i + j == nums[0]:\n                if (i == n and j == n) or (i == n and j == n - 1) or (i == n - 1 and j == n):\n                    count += 1\n                elif (i == n - 1 and j == n - 1) and nums[1] == nums[0] - i + j:\n                    count += 1\n                elif (i == n - 1 and j == n - 1) and nums[1] == nums[0] - i + j + 1:\n                    count += 1\n                elif (i == n - 1 and j == n - 1) and nums[1] == nums[0] - i + j - 1:\n                    count += 1\n    \n    return count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # DP table for arr1\n    dp1 = [[0] * (n + 1) for _ in range(n + 1)]\n    dp1[0][0] = 1\n    \n    # DP table for arr2\n    dp2 = [[0] * (n + 1) for _ in range(n + 1)]\n    dp2[n][0] = 1\n    \n    for num in nums:\n        new_dp1 = [[0] * (n + 1) for _ in range(n + 1)]\n        new_dp2 = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(num + 1):\n                if j <= i:\n                    new_dp1[i][j] = (new_dp1[i][j] + dp1[i - 1][j]) % MOD\n                if j >= i:\n                    new_dp2[i][num - j] = (new_dp2[i][num - j] + dp2[i - 1][num - j]) % MOD\n        \n        dp1 = new_dp1\n        dp2 = new_dp2\n    \n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            count = (count + dp1[i][j] * dp2[i][j]) % MOD\n    \n    return count"], "passed": [false, false], "raw_code": ["```python\ndef countMonotonicPairs(nums: List[int]) -> int:\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(1, 51):\n        for j in range(1, 51):\n            if i + j == nums[0]:\n                if (i == n and j == n) or (i == n and j == n - 1) or (i == n - 1 and j == n):\n                    count += 1\n                elif (i == n - 1 and j == n - 1) and nums[1] == nums[0] - i + j:\n                    count += 1\n                elif (i == n - 1 and j == n - 1) and nums[1] == nums[0] - i + j + 1:\n                    count += 1\n                elif (i == n - 1 and j == n - 1) and nums[1] == nums[0] - i + j - 1:\n                    count += 1\n    \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # DP table for arr1\n    dp1 = [[0] * (n + 1) for _ in range(n + 1)]\n    dp1[0][0] = 1\n    \n    # DP table for arr2\n    dp2 = [[0] * (n + 1) for _ in range(n + 1)]\n    dp2[n][0] = 1\n    \n    for num in nums:\n        new_dp1 = [[0] * (n + 1) for _ in range(n + 1)]\n        new_dp2 = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(num + 1):\n                if j <= i:\n                    new_dp1[i][j] = (new_dp1[i][j] + dp1[i - 1][j]) % MOD\n                if j >= i:\n                    new_dp2[i][num - j] = (new_dp2[i][num - j] + dp2[i - 1][num - j]) % MOD\n        \n        dp1 = new_dp1\n        dp2 = new_dp2\n    \n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            count = (count + dp1[i][j] * dp2[i][j]) % MOD\n    \n    return count\n```"]}
{"task_id": "arc181_b", "codes": ["def f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef check_frequencies(X, Y):\n    from collections import Counter\n    \n    count_X = Counter()\n    count_Y = Counter()\n    \n    current = ''\n    for char in X:\n        current += char\n        count_X[current] += 1\n        current = ''\n    \n    current = ''\n    for char in Y:\n        current += char\n        count_Y[current] += 1\n        current = ''\n    \n    return count_X == count_Y\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        \n        if check_frequencies(X, Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n        \n        index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "d"], "passed": [false, false], "raw_code": ["```python\ndef f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef check_frequencies(X, Y):\n    from collections import Counter\n    \n    count_X = Counter()\n    count_Y = Counter()\n    \n    current = ''\n    for char in X:\n        current += char\n        count_X[current] += 1\n        current = ''\n    \n    current = ''\n    for char in Y:\n        current += char\n        count_Y[current] += 1\n        current = ''\n    \n    return count_X == count_Y\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        \n        if check_frequencies(X, Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n        \n        index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef f(S, T, X):\n    return ''.join([S if x == '0' else T for x in X])\n\ndef check_cases():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        # Construct the strings based on X and Y\n        result_X = f(S, '', X)\n        result_Y = f(S, '', Y)\n        \n        # Check if the results are equal\n        if result_X == result_Y:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncheck_cases()"]}
{"task_id": "abc367_e", "codes": ["d", "def process_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    X = list(map(int, data[2:N+2]))\n    A = list(map(int, data[N+2:]))\n    \n    return N, K, X, A\n\ndef find_cycle_positions(X, A):\n    N = len(X)\n    visited = [False] * N\n    cycle_positions = []\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = X[x] - 1\n            \n            cycle_positions.append((cycle, len(cycle)))\n    \n    return cycle_positions\n\ndef apply_operation(K, cycle_positions, A):\n    N = len(cycle_positions)\n    result = A[:]\n    \n    for cycle, length in cycle_positions:\n        K %= length\n        if K == 0:\n            K = length\n        \n        for i in range(K):\n            result[cycle[i]] = A[cycle[(i - K + length) % length]]\n    \n    return result\n\ndef main():\n    N, K, X, A = process_input()\n    cycle_positions = find_cycle_positions(X, A)\n    result = apply_operation(K, cycle_positions, A)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef transform_sequence(N, K, X, A):\n    # Reduce K modulo N to find the effective number of replacements needed\n    K %= N\n    \n    # Perform the replacements K times\n    for _ in range(K):\n        new_A = [A[X[i] - 1] for i in range(N)]\n        A = new_A\n    \n    # Print the resulting sequence\n    print(\" \".join(map(str, A)))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input values\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Call the function with the parsed input\ntransform_sequence(N, K, X, A)", "```python\ndef process_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    X = list(map(int, data[2:N+2]))\n    A = list(map(int, data[N+2:]))\n    \n    return N, K, X, A\n\ndef find_cycle_positions(X, A):\n    N = len(X)\n    visited = [False] * N\n    cycle_positions = []\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = X[x] - 1\n            \n            cycle_positions.append((cycle, len(cycle)))\n    \n    return cycle_positions\n\ndef apply_operation(K, cycle_positions, A):\n    N = len(cycle_positions)\n    result = A[:]\n    \n    for cycle, length in cycle_positions:\n        K %= length\n        if K == 0:\n            K = length\n        \n        for i in range(K):\n            result[cycle[i]] = A[cycle[(i - K + length) % length]]\n    \n    return result\n\ndef main():\n    N, K, X, A = process_input()\n    cycle_positions = find_cycle_positions(X, A)\n    result = apply_operation(K, cycle_positions, A)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3532", "codes": ["def minTimeToMarkTree(edges):\n    from collections import defaultdict, deque\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def bfs(start_node):\n        queue = deque([start_node])\n        visited = set([start_node])\n        times = [float('inf')] * n\n        times[start_node] = 0\n        level = 0\n\n        while queue:\n            for _ in range(len(queue)):\n                current = queue.popleft()\n                for neighbor in adj_list[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        times[neighbor] = level + 2 if current % 2 == 0 else level + 1\n                        queue.append(neighbor)\n            level += 1\n\n        return max(times)\n\n    return [bfs(i) for i in range(n)]", "def minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            node, time = queue.popleft()\n            times[node] = time\n            \n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    if node % 2 == 0:\n                        queue.append((neighbor, time + 2))\n                    else:\n                        queue.append((neighbor, time + 1))\n    \n    times = [0] * n\n    for i in range(n):\n        bfs(i)\n    \n    return times"], "passed": [false, false], "raw_code": ["def minTimeToMarkTree(edges):\n    from collections import defaultdict, deque\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def bfs(start_node):\n        queue = deque([start_node])\n        visited = set([start_node])\n        times = [float('inf')] * n\n        times[start_node] = 0\n        level = 0\n\n        while queue:\n            for _ in range(len(queue)):\n                current = queue.popleft()\n                for neighbor in adj_list[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        times[neighbor] = level + 2 if current % 2 == 0 else level + 1\n                        queue.append(neighbor)\n            level += 1\n\n        return max(times)\n\n    return [bfs(i) for i in range(n)]", "```python\ndef minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            node, time = queue.popleft()\n            times[node] = time\n            \n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    if node % 2 == 0:\n                        queue.append((neighbor, time + 2))\n                    else:\n                        queue.append((neighbor, time + 1))\n    \n    times = [0] * n\n    for i in range(n):\n        bfs(i)\n    \n    return times\n```"]}
{"task_id": "abc371_g", "codes": ["def smallest_permutation(N, P, A):\n    # Create a mapping from value to index\n    index_map = {A[i]: i for i in range(N)}\n    \n    # Track visited elements\n    visited = [False] * N\n    \n    for i in range(N):\n        if not visited[i]:\n            # Find the cycle starting at i\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = P[x] - 1\n            \n            # Sort the cycle\n            cycle_values = [A[j] for j in cycle]\n            cycle_values.sort()\n            \n            # Place the sorted values back into the array\n            for j, value in zip(cycle, cycle_values):\n                A[j] = value\n    \n    return ' '.join(map(str, A))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the result\nresult = smallest_permutation(N, P, A)\n\n# Print the result\nprint(result)", "d"], "passed": [false, false], "raw_code": ["```python\ndef smallest_permutation(N, P, A):\n    # Create a mapping from value to index\n    index_map = {A[i]: i for i in range(N)}\n    \n    # Track visited elements\n    visited = [False] * N\n    \n    for i in range(N):\n        if not visited[i]:\n            # Find the cycle starting at i\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = P[x] - 1\n            \n            # Sort the cycle\n            cycle_values = [A[j] for j in cycle]\n            cycle_values.sort()\n            \n            # Place the sorted values back into the array\n            for j, value in zip(cycle, cycle_values):\n                A[j] = value\n    \n    return ' '.join(map(str, A))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the result\nresult = smallest_permutation(N, P, A)\n\n# Print the result\nprint(result)\n```", "```python\ndef get_smallest_permutation():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:2*N+1]))\n    \n    seen = set()\n    current_perm = tuple(A)\n    \n    while current_perm not in seen:\n        seen.add(current_perm)\n        \n        next_perm = [A[P[i] - 1] for i in range(N)]\n        current_perm = tuple(next_perm)\n    \n    min_perm = min(seen, key=lambda x: ''.join(map(str, x)))\n    print(' '.join(map(str, min_perm)))\n\nget_smallest_permutation()"]}
{"task_id": "abc371_f", "codes": ["def min_total_movements(N, X, Q, T, G):\n    # Sort the initial positions\n    X.sort()\n    \n    # Function to calculate the minimum movements to reach the target G from position pos\n    def min_moves(pos, target):\n        left = pos\n        right = len(X) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if X[mid] >= target:\n                return abs(X[mid] - target)\n            elif X[mid] < target:\n                left = mid + 1\n        return float('inf')\n    \n    total_moves = 0\n    \n    # Process each task\n    for t, g in zip(T, G):\n        pos = t - 1\n        total_moves += min_moves(pos, g)\n    \n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\nT = list(map(int, data[N+2:N+2+Q]))\nG = list(map(int, data[N+2+Q:]))\n\n# Print the result\nprint(min_total_movements(N, X, Q, T, G))", "d"], "passed": [false, false], "raw_code": ["```python\ndef min_total_movements(N, X, Q, T, G):\n    # Sort the initial positions\n    X.sort()\n    \n    # Function to calculate the minimum movements to reach the target G from position pos\n    def min_moves(pos, target):\n        left = pos\n        right = len(X) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if X[mid] >= target:\n                return abs(X[mid] - target)\n            elif X[mid] < target:\n                left = mid + 1\n        return float('inf')\n    \n    total_moves = 0\n    \n    # Process each task\n    for t, g in zip(T, G):\n        pos = t - 1\n        total_moves += min_moves(pos, g)\n    \n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\nT = list(map(int, data[N+2:N+2+Q]))\nG = list(map(int, data[N+2+Q:]))\n\n# Print the result\nprint(min_total_movements(N, X, Q, T, G))\n```", "```python\ndef min_movements():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    X = list(map(int, data[index:index + N]))\n    index += N\n    \n    Q = int(data[index])\n    index += 1\n    \n    tasks = []\n    for _ in range(Q):\n        T = int(data[index]) - 1\n        G = int(data[index + 1])\n        tasks.append((T, G))\n        index += 2\n    \n    # Sort initial positions to manage relative distances efficiently\n    X.sort()\n    \n    total_moves = 0\n    \n    for T, G in tasks:\n        if X[T] != G:\n            if X[T] < G:\n                # Move east\n                moves = G - X[T]\n                X[T] = G\n            else:\n                # Move west\n                moves = X[T] - G\n                X[T] = G\n            total_moves += moves\n    \n    print(total_moves)\n\nmin_movements()"]}
{"task_id": "abc366_g", "codes": ["d", "from sympy import symbols, Eq, Matrix, mod_inverse\n\ndef read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    adjacency_list = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n        index += 2\n    \n    return N, M, adjacency_list\n\ndef find_solution(N, M, adjacency_list):\n    # Create a matrix of variables\n    variables = symbols('x0:%d' % N)\n    \n    # Create a system of equations\n    equations = []\n    for v in range(1, N + 1):\n        if len(adjacency_list[v]) > 0:\n            eq = sum(variables[neighbor] for neighbor in adjacency_list[v]) - variables[v]\n            equations.append(Eq(eq % 2, 0))\n    \n    # Convert the system of equations to a matrix form\n    matrix = Matrix([[1 if (i == j or (j + 1 in adjacency_list[i + 1])) else 0 for j in range(N)] for i in range(N)])\n    b = Matrix([0] * N)\n    \n    # Try to solve the system of equations\n    try:\n        solution = matrix.LUsolve(b)\n        return 'Yes\\n' + ' '.join(map(str, [int(sol.evalf()) for sol in solution]))\n    except:\n        return 'No'\n\ndef main():\n    N, M, adjacency_list = read_input()\n    result = find_solution(N, M, adjacency_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        graph[u].append(v)\n        graph[v].append(u)\n        index += 2\n    \n    def backtrack(vertex, assignment):\n        if vertex > N:\n            return True\n        \n        if len(graph[vertex]) == 0:\n            assignment[vertex] = 1\n            return True\n        \n        used = [False] * (2**60)\n        for neighbor in graph[vertex]:\n            if assignment[neighbor] != 0:\n                used[assignment[neighbor]] = True\n        \n        for value in range(1, 2**60):\n            if not used[value]:\n                assignment[vertex] = value\n                if backtrack(vertex + 1, assignment):\n                    return True\n                assignment[vertex] = 0\n        \n        return False\n    \n    assignment = [0] * (N + 1)\n    if backtrack(1, assignment):\n        print(\"Yes\")\n        for i in range(1, N + 1):\n            print(assignment[i], end=' ')\n        print()\n    else:\n        print(\"No\")\n\nsolve()", "```python\nfrom sympy import symbols, Eq, Matrix, mod_inverse\n\ndef read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    adjacency_list = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n        index += 2\n    \n    return N, M, adjacency_list\n\ndef find_solution(N, M, adjacency_list):\n    # Create a matrix of variables\n    variables = symbols('x0:%d' % N)\n    \n    # Create a system of equations\n    equations = []\n    for v in range(1, N + 1):\n        if len(adjacency_list[v]) > 0:\n            eq = sum(variables[neighbor] for neighbor in adjacency_list[v]) - variables[v]\n            equations.append(Eq(eq % 2, 0))\n    \n    # Convert the system of equations to a matrix form\n    matrix = Matrix([[1 if (i == j or (j + 1 in adjacency_list[i + 1])) else 0 for j in range(N)] for i in range(N)])\n    b = Matrix([0] * N)\n    \n    # Try to solve the system of equations\n    try:\n        solution = matrix.LUsolve(b)\n        return 'Yes\\n' + ' '.join(map(str, [int(sol.evalf()) for sol in solution]))\n    except:\n        return 'No'\n\ndef main():\n    N, M, adjacency_list = read_input()\n    result = find_solution(N, M, adjacency_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc373_f", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        items.append((w, v))\n    \n    # Calculate happiness per unit weight and sort items in descending order\n    items.sort(key=lambda x: x[1] / x[0], reverse=True)\n    \n    # Initialize DP array\n    dp = [0] * (W + 1)\n    \n    # Fill DP array\n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            for k in range(min(10**10, j // w) + 1):\n                dp[j] = max(dp[j], dp[j - k * w] + k * v - k**2)\n    \n    # The maximum happiness achievable\n    print(max(dp))\n\n# Call the function\nmax_happiness()", "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    W = int(data[0])\n    N = int(data[1])\n    items = []\n    \n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [-1000 * W] * (W + 1)\n    dp[0] = 0\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            max_k = min(10**10, (j + 1) // w)\n            for k in range(1, max_k + 1):\n                dp[j] = max(dp[j], dp[j - k * w] + k * v - k**2)\n    \n    print(max(dp))\n\nmax_happiness()"]}
{"task_id": "abc372_e", "codes": ["i", "import sys\nfrom typing import List, Tuple\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    # Initialize adjacency list\n    graph = [[] for _ in range(N + 1)]\n    \n    # Process each query\n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            \n            # Add edge to both vertices\n            graph[u].append(v)\n            graph[v].append(u)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            \n            # Find k-th largest vertex number connected to v\n            if len(graph[v]) < k:\n                results.append(-1)\n            else:\n                # Use a min-heap to keep the k largest elements\n                min_heap = []\n                for neighbor in graph[v]:\n                    heapq.heappush(min_heap, neighbor)\n                    if len(min_heap) > k:\n                        heapq.heappop(min_heap)\n                results.append(min_heap[0])\n    \n    # Output results for all Type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nimport heapq\n\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adjacency_list = [[] for _ in range(N + 1)]\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            heapq.heappush(adjacency_list[u], v)\n            heapq.heappush(adjacency_list[v], u)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            \n            if len(adjacency_list[v]) < k:\n                results.append(-1)\n            else:\n                top_k = heapq.nlargest(k, adjacency_list[v])\n                results.append(top_k[-1])\n    \n    for result in results:\n        print(result)\n\n# Call the function to process queries\nprocess_queries()", "```python\nimport sys\nfrom typing import List, Tuple\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    # Initialize adjacency list\n    graph = [[] for _ in range(N + 1)]\n    \n    # Process each query\n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            \n            # Add edge to both vertices\n            graph[u].append(v)\n            graph[v].append(u)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            \n            # Find k-th largest vertex number connected to v\n            if len(graph[v]) < k:\n                results.append(-1)\n            else:\n                # Use a min-heap to keep the k largest elements\n                min_heap = []\n                for neighbor in graph[v]:\n                    heapq.heappush(min_heap, neighbor)\n                    if len(min_heap) > k:\n                        heapq.heappop(min_heap)\n                results.append(min_heap[0])\n    \n    # Output results for all Type 2 queries\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc372_g", "codes": ["import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef count_valid_pairs(N, A, B, C):\n    def binary_search(max_x):\n        min_y = max(1, (C[0] - A[0] * max_x) // B[0])\n        for i in range(1, N):\n            if (C[i] - A[i] * max_x) % B[i] == 0:\n                new_min_y = (C[i] - A[i] * max_x) // B[i] + 1\n            else:\n                new_min_y = (C[i] - A[i] * max_x) // B[i]\n            if new_min_y > min_y:\n                return False\n        return True\n    \n    left, right = 1, max(C[i] // A[i] for i in range(N))\n    while left <= right:\n        mid = (left + right) // 2\n        if binary_search(mid):\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left - 1\n\ndef main():\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index + i]) for i in range(N)]\n        B = [int(data[index + N + i]) for i in range(N)]\n        C = [int(data[index + 2 * N + i]) for i in range(N)]\n        index += 3 * N\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "import sys\n\ndef solve_case(N, A, B, C):\n    count = 0\n    x_max = 10**6\n    for x in range(1, x_max + 1):\n        for i in range(N):\n            if A[i] * x + B[i] * y < C[i]:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            index += 1\n            B.append(int(data[index]))\n            index += 1\n            C.append(int(data[index]))\n            index += 1\n        \n        result = solve_case(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef count_valid_pairs(N, A, B, C):\n    def binary_search(max_x):\n        min_y = max(1, (C[0] - A[0] * max_x) // B[0])\n        for i in range(1, N):\n            if (C[i] - A[i] * max_x) % B[i] == 0:\n                new_min_y = (C[i] - A[i] * max_x) // B[i] + 1\n            else:\n                new_min_y = (C[i] - A[i] * max_x) // B[i]\n            if new_min_y > min_y:\n                return False\n        return True\n    \n    left, right = 1, max(C[i] // A[i] for i in range(N))\n    while left <= right:\n        mid = (left + right) // 2\n        if binary_search(mid):\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left - 1\n\ndef main():\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index + i]) for i in range(N)]\n        B = [int(data[index + N + i]) for i in range(N)]\n        C = [int(data[index + 2 * N + i]) for i in range(N)]\n        index += 3 * N\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport sys\n\ndef solve_case(N, A, B, C):\n    count = 0\n    x_max = 10**6\n    for x in range(1, x_max + 1):\n        for i in range(N):\n            if A[i] * x + B[i] * y < C[i]:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            index += 1\n            B.append(int(data[index]))\n            index += 1\n            C.append(int(data[index]))\n            index += 1\n        \n        result = solve_case(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc369_e", "codes": ["i", "i"], "passed": [false, false], "raw_code": ["```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef solve():\n    index = 0\n    \n    # Parse input\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        t = int(data[index + 2])\n        edges.append((u, v, t))\n        edges.append((v, u, t))  # Since the graph is undirected\n        index += 3\n    \n    Q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        B = list(map(int, data[index:index + K]))\n        queries.append(B)\n        index += K\n    \n    # Precompute all pairs shortest paths using Floyd-Warshall algorithm\n    INF = float('inf')\n    dist = [[INF] * N for _ in range(N)]\n    for u in range(N):\n        dist[u][u] = 0\n    for u, v, t in edges:\n        dist[u][v] = min(dist[u][v], t)\n        dist[v][u] = min(dist[v][u], t)\n    \n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i][k] != INF and dist[k][j] != INF:\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    # DP table initialization\n    dp = [[INF] * N for _ in range(1 << M)]\n    dp[0][0] = 0\n    \n    # Fill the DP table\n    for mask in range(1 << M):\n        for e in range(M):\n            if mask & (1 << e):\n                u, v, t = edges[e]\n                for node in range(N):\n                    if dp[mask ^ (1 << e)][node] != INF:\n                        dp[mask][node] = min(dp[mask][node], dp[mask ^ (1 << e)][node] + dist[node][u] + dist[node][v])\n    \n    # Process each query\n    results = []\n    for B in queries:\n        B_mask = sum(1 << (b - 1) for b in B)\n        min_time = INF\n        for node in range(N):\n            min_time = min(min_time, dp[B_mask][node] + dist[node][N - 1])\n        results.append(min_time)\n    \n    # Print results\n    for result in results:\n        print(result)\n\nsolve()", "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_time_to_reach(N, M, bridges, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def bellman_ford(start, mask):\n        dist = [float('inf')] * (N + 1)\n        dist[start] = 0\n        for _ in range(M):\n            new_dist = dist[:]\n            for u in range(1, N + 1):\n                if dist[u] == float('inf'):\n                    continue\n                for v, t in graph[u]:\n                    if (mask & (1 << (bridges.index((min(u, v), max(u, v)), t)))) != 0:\n                        new_dist[v] = min(new_dist[v], dist[u] + t)\n                        new_dist[u] = min(new_dist[u], dist[v] + t)\n            dist = new_dist\n        return dist[N]\n\n    results = []\n    for k, bridges_used in queries:\n        mask = 0\n        for bridge in bridges_used:\n            mask |= (1 << bridges.index(bridge))\n        min_time = float('inf')\n        for start in range(1, N + 1):\n            for end in range(1, N + 1):\n                if start != end:\n                    min_time = min(min_time, bellman_ford(start, mask) + bellman_ford(end, mask))\n        results.append(min_time)\n\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nbridges = []\nindex = 2\nfor _ in range(M):\n    u = int(data[index])\n    v = int(data[index + 1])\n    t = int(data[index + 2])\n    bridges.append(((u, v), t))\n    index += 3\n\nQ = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(Q):\n    k = int(data[index])\n    bridges_used = []\n    for j in range(index + 1, index + k + 1):\n        b = (int(data[j]), int(data[j + 1]))\n        bridges_used.append(b)\n    queries.append((k, bridges_used))\n    index += k + 2\n\n# Solve and output results\nresults = min_time_to_reach(N, M, bridges, queries)\nfor result in results:\n    print(result)"]}
{"task_id": "abc370_f", "codes": ["def can_divide(N, K, A, mid):\n    current_sum = 0\n    last_cut_used = False\n    cuts_not_used = set()\n    \n    for i in range(N):\n        current_sum += A[i]\n        \n        if current_sum > mid:\n            if i == 0:\n                return False, cuts_not_used\n            \n            cuts_not_used.add(i)\n            current_sum = A[i]\n            last_cut_used = True\n    \n    if last_cut_used:\n        cuts_not_used.remove(N)\n    \n    return True, cuts_not_used\n\ndef min_weight_and_unused_cuts(N, K, A):\n    low = max(A)\n    high = sum(A) // K\n    best_min_weight = float('inf')\n    unused_cuts = set(range(1, N))\n    \n    while low <= high:\n        mid = (low + high) // 2\n        feasible, cuts_not_used = can_divide(N, K, A, mid)\n        \n        if feasible:\n            best_min_weight = mid\n            unused_cuts = cuts_not_used\n            high = mid - 1\n        else:\n            low = mid + 1\n    \n    return best_min_weight, len(unused_cuts)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Get result\nresult = min", "d"], "passed": [false, false], "raw_code": ["def can_divide(N, K, A, mid):\n    current_sum = 0\n    last_cut_used = False\n    cuts_not_used = set()\n    \n    for i in range(N):\n        current_sum += A[i]\n        \n        if current_sum > mid:\n            if i == 0:\n                return False, cuts_not_used\n            \n            cuts_not_used.add(i)\n            current_sum = A[i]\n            last_cut_used = True\n    \n    if last_cut_used:\n        cuts_not_used.remove(N)\n    \n    return True, cuts_not_used\n\ndef min_weight_and_unused_cuts(N, K, A):\n    low = max(A)\n    high = sum(A) // K\n    best_min_weight = float('inf')\n    unused_cuts = set(range(1, N))\n    \n    while low <= high:\n        mid = (low + high) // 2\n        feasible, cuts_not_used = can_divide(N, K, A, mid)\n        \n        if feasible:\n            best_min_weight = mid\n            unused_cuts = cuts_not_used\n            high = mid - 1\n        else:\n            low = mid + 1\n    \n    return best_min_weight, len(unused_cuts)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Get result\nresult = min", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    dp = [A[0]] * K\n    pre = [A[0]]\n    for i in range(1, N):\n        t = A[i]\n        new_dp = [float('inf')] * K\n        for j in range(K):\n            new_dp[j] = min(new_dp[j], dp[j] + t)\n            if j > 0:\n                new_dp[j] = min(new_dp[j], dp[j-1] - pre[j-1] + t)\n            if j + 1 < K:\n                new_dp[j] = min(new_dp[j], pre[j] - dp[j] + t)\n        dp = new_dp\n        pre.append(dp[-1])\n    \n    never_cut = 0\n    for i in range(K - 1):\n        if dp[i] != dp[i + 1]:\n            never_cut += 1\n    \n    print(dp[-1], never_cut)\n\nmain()"]}
{"task_id": "3563", "codes": ["def maxScore(grid):\n    def backtrack(row, selected_values, current_sum):\n        if row == len(grid):\n            nonlocal max_sum\n            max_sum = max(max_sum, current_sum)\n            return\n        \n        for col in range(len(grid[row])):\n            if grid[row][col] not in selected_values:\n                backtrack(row + 1, selected_values | {grid[row][col]}, current_sum + grid[row][col])\n    \n    max_sum = 0\n    for i in range(len(grid)):\n        sorted_row = sorted(grid[i])\n        backtrack(1, {sorted_row[-1]}, sorted_row[-1])\n    \n    return max_sum", "def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Initialize variables\n    n, m = len(grid), len(grid[0])\n    visited = [False] * n\n    max_score = 0\n    \n    # Iterate over columns\n    for col in range(m):\n        max_value = 0\n        selected_row = -1\n        \n        # Find the maximum unique value in this column\n        for row in range(n):\n            if not visited[row]:\n                if grid[row][col] > max_value:\n                    max_value = grid[row][col]\n                    selected_row = row\n        \n        # If a valid cell was found, add its value to the score and mark the row as visited\n        if selected_row != -1:\n            max_score += max_value\n            visited[selected_row] = True\n    \n    return max_score"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(grid):\n    def backtrack(row, selected_values, current_sum):\n        if row == len(grid):\n            nonlocal max_sum\n            max_sum = max(max_sum, current_sum)\n            return\n        \n        for col in range(len(grid[row])):\n            if grid[row][col] not in selected_values:\n                backtrack(row + 1, selected_values | {grid[row][col]}, current_sum + grid[row][col])\n    \n    max_sum = 0\n    for i in range(len(grid)):\n        sorted_row = sorted(grid[i])\n        backtrack(1, {sorted_row[-1]}, sorted_row[-1])\n    \n    return max_sum\n```", "```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Initialize variables\n    n, m = len(grid), len(grid[0])\n    visited = [False] * n\n    max_score = 0\n    \n    # Iterate over columns\n    for col in range(m):\n        max_value = 0\n        selected_row = -1\n        \n        # Find the maximum unique value in this column\n        for row in range(n):\n            if not visited[row]:\n                if grid[row][col] > max_value:\n                    max_value = grid[row][col]\n                    selected_row = row\n        \n        # If a valid cell was found, add its value to the score and mark the row as visited\n        if selected_row != -1:\n            max_score += max_value\n            visited[selected_row] = True\n    \n    return max_score\n```"]}
{"task_id": "abc368_e", "codes": ["d", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    X1 = int(data[2])\n    trains = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        trains.append((A, B, S, T))\n        index += 4\n    trains.sort(key=lambda x: x[2])\n    delays = [0] * M\n    max_delay = 0\n    for i in range(1, M):\n        if trains[i][0] == trains[i - 1][1] and trains[i][2] <= trains[i - 1][3]:\n            delays[i] = max(max_delay - trains[i - 1][3] + trains[i][2], 0)\n            max_delay = max(max_delay, delays[i] + trains[i][2])\n    print(' '.join(map(str, delays[1:])))\nsolve()"], "passed": [false, false], "raw_code": ["```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X1 = int(data[index + 2])\n    \n    trains = []\n    for i in range(M):\n        A = int(data[index + 3 + 4 * i])\n        B = int(data[index + 4 + 4 * i])\n        S = int(data[index + 5 + 4 * i])\n        T = int(data[index + 6 + 4 * i])\n        trains.append((A, B, S, T))\n    \n    # Sort trains by departure time\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize delays\n    delays = [X1] + [0] * (M - 1)\n    \n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        max_delay = 0\n        for j in range(i):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                max_delay = max(max_delay, S_j - T_i + delays[j])\n        delays[i] += max_delay\n    \n    # Print the result\n    for delay in delays[1:]:\n        print(delay, end=' ')\n    print()\n\n# Call the function\nsolve()", "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    X1 = int(data[2])\n    trains = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        trains.append((A, B, S, T))\n        index += 4\n    trains.sort(key=lambda x: x[2])\n    delays = [0] * M\n    max_delay = 0\n    for i in range(1, M):\n        if trains[i][0] == trains[i - 1][1] and trains[i][2] <= trains[i - 1][3]:\n            delays[i] = max(max_delay - trains[i - 1][3] + trains[i][2], 0)\n            max_delay = max(max_delay, delays[i] + trains[i][2])\n    print(' '.join(map(str, delays[1:])))\nsolve()"]}
{"task_id": "3550", "codes": ["def max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate the sum of each row and column\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort rows by their sums in descending order\n    sorted_rows = sorted(range(m), key=lambda i: row_sums[i], reverse=True)\n    \n    # Initialize variables to store the best configuration\n    best_sum = float('-inf')\n    used_cols = set()\n    \n    # Iterate through the top 3 rows\n    for i in range(3):\n        row_idx = sorted_rows[i]\n        for col_idx in range(n):\n            if col_idx not in used_cols:\n                best_sum = max(best_sum, row_sums[row_idx] + col_sums[col_idx])\n                used_cols.add(col_idx)\n                break\n    \n    return best_sum", "def maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    columns_used = set()\n    selected_cells = []\n    \n    for i in range(m):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(n):\n            if j not in columns_used and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        selected_cells.append((i, max_col))\n        columns_used.add(max_col)\n    \n    return sum(board[i][j] for i, j in selected_cells)"], "passed": [false, false], "raw_code": ["```python\ndef max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate the sum of each row and column\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort rows by their sums in descending order\n    sorted_rows = sorted(range(m), key=lambda i: row_sums[i], reverse=True)\n    \n    # Initialize variables to store the best configuration\n    best_sum = float('-inf')\n    used_cols = set()\n    \n    # Iterate through the top 3 rows\n    for i in range(3):\n        row_idx = sorted_rows[i]\n        for col_idx in range(n):\n            if col_idx not in used_cols:\n                best_sum = max(best_sum, row_sums[row_idx] + col_sums[col_idx])\n                used_cols.add(col_idx)\n                break\n    \n    return best_sum\n```", "```python\ndef maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    columns_used = set()\n    selected_cells = []\n    \n    for i in range(m):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(n):\n            if j not in columns_used and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        selected_cells.append((i, max_col))\n        columns_used.add(max_col)\n    \n    return sum(board[i][j] for i, j in selected_cells)\n```"]}
{"task_id": "abc373_g", "codes": ["d", "i"], "passed": [false, false], "raw_code": ["```python\ndef can_form_non_intersecting_segments(N, P, Q):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n        \n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        \n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        \n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        \n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        \n        return False\n    \n    def on_segment(p, q, r):\n        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n            return True\n        return False\n    \n    sorted_P = sorted(P, key=lambda x: x[0])\n    \n    def find_next_q(i, used_Q):\n        for j in range(N):\n            if j not in used_Q:\n                return j\n        return None\n    \n    def backtrack(i, used_Q):\n        if i == N:\n            return []\n        \n        next_q = find_next_q(i, used_Q)\n        if next_q is None:\n            return None\n        \n        result = backtrack(i + 1, used_Q | {next_q})\n        if result is not None:\n            return [next_q] + result\n        \n        for j in range(N):\n            if j not in used_Q and i != j:\n                if not do_intersect(sorted_P[i], Q[next_q], sorted_P[j], Q[j]):\n                    result = backtrack(i + 1, used_Q | {j})\n                    if result is not None:\n                        return [j] + result\n        \n        return None\n    \n    result = backtrack(0, set())\n    return \" \".join(map(str, result)) if result is not None else \"-1\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\nQ = [(int(data[2*(i+N)+1]), int(data[2*(i+N)+2])) for i in range(N)]\n\n# Get the result\nresult = can_form_non_intersecting_segments(N, P, Q)\n\n# Print the result\nprint(result)", "```python\nimport sys\nfrom typing import List\n\ndef read_input() -> List[List[int]]:\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    N = int(data[index])\n    index += 1\n    P = [[int(data[index + 2 * i]), int(data[index + 2 * i + 1])] for i in range(N)]\n    Q = [[int(data[index + 2 * N + 2 * i]), int(data[index + 2 * N + 2 * i + 1])] for i in range(N)]\n    return N, P, Q\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # collinear\n    elif val > 0:\n        return 1  # clockwise\n    else:\n        return 2  # counterclockwise\n\ndef convex_hull(points: List[List[int]]) -> List[List[int]]:\n    n = len(points)\n    if n <= 1:\n        return points\n    \n    def compare(p, q):\n        o = orientation(P[0], p, q)\n        if o == 0:\n            return (p[0] - P[0][0]) ** 2 + (p[1] - P[0][1]) ** 2 < (q[0] - P[0][0]) ** 2 + (q[1] - P[0][1]) ** 2\n        return o == 1\n    \n    L = sorted(points, key=lambda x: (x[0], x[1]))\n    \n    lower = []\n    upper = []\n    \n    for p in L:\n        while len(lower) >= 2 and orientation(lower[-2], lower[-1], p) != 2:\n            lower.pop()\n        lower.append(p)\n        \n        while len(upper) >= 2 and orientation(upper[-2], upper[-1], p) != 1:\n            upper.pop()\n        upper.append(p)\n    \n    hull = lower[:-1] + upper[:-1]\n    return hull\n\ndef is_valid_permutation(R: List[int]) -> bool:\n    stack = []\n    for i in range(len(R)):\n        while stack and orientation(P[stack[-1]], P[i], Q[R[i]]) == 2:\n            stack.pop()\n        stack.append(i)\n    return len(stack) == 1\n\ndef find_permutation(N: int, P: List[List[int]], Q: List[List[int]]) -> List[int]:\n    hull_P = convex_hull(P)\n    hull_Q = convex_hull(Q)\n    \n    if len(hull_P) != len(hull_Q):\n        return [-1]\n    \n    M = len(hull_P)\n    dp = [[False] * M for _ in range(M)]\n    for i in range(M):\n        dp[i][i] = True\n    \n    for length in range(2, M + 1):\n        for i in range(M - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                if dp[i][k] and dp[k + 1][j] and orientation(P[hull_P[i]], P[j], Q[hull_Q[k]]) != 2:\n                    dp[i][j] = True\n                    break\n    \n    if not dp[0][M -"]}
{"task_id": "3552", "codes": ["def largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(k * (k // 1))\n    \n    half_length = (n + 1) // 2\n    half_number = '9' * half_length\n    \n    while True:\n        full_number = half_number + half_number[-(half_length - 1):][::-1]\n        \n        if int(full_number) % k == 0:\n            return full_number\n        \n        # Decrease the middle digit if n is odd\n        if n % 2 == 1:\n            mid_index = half_length - 1\n            half_number = half_number[:mid_index] + str(int(half_number[mid_index]) - 1) + half_number[mid_index+1:]\n        else:\n            # Adjust the last digit if n is even\n            half_number = half_number[:-1] + str(int(half_number[-1]) - 1)\n        \n        # Ensure the first digit is not zero\n        if half_number[0] == '0':\n            break\n    \n    return \"0\" if half_number == \"\" else str(k * (k // 1))", "def largest_k_palindrome(n: int, k: int) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    def adjust_to_divisible(num_str: str, divisor: int) -> str:\n        num = int(num_str)\n        while num % divisor != 0:\n            num -= 1\n        return str(num)\n    \n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n        return \"\"\n    \n    half_length = (n + 1) // 2\n    mid_digit = '9' * (n % 2)\n    left_half = ''.join(str(i) for i in range(half_length - 1, -1, -1))\n    full_number = left_half + mid_digit + left_half[::-1]\n    \n    while not is_palindrome(full_number):\n        mid_digit = adjust_to_divisible(mid_digit, k)\n        left_half = ''.join(str(i) for i in range(int(mid_digit[0]) - 1, -1, -1))\n        full_number = left_half + mid_digit + left_half[::-1]\n    \n    return full_number"], "passed": [false, false], "raw_code": ["```python\ndef largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(k * (k // 1))\n    \n    half_length = (n + 1) // 2\n    half_number = '9' * half_length\n    \n    while True:\n        full_number = half_number + half_number[-(half_length - 1):][::-1]\n        \n        if int(full_number) % k == 0:\n            return full_number\n        \n        # Decrease the middle digit if n is odd\n        if n % 2 == 1:\n            mid_index = half_length - 1\n            half_number = half_number[:mid_index] + str(int(half_number[mid_index]) - 1) + half_number[mid_index+1:]\n        else:\n            # Adjust the last digit if n is even\n            half_number = half_number[:-1] + str(int(half_number[-1]) - 1)\n        \n        # Ensure the first digit is not zero\n        if half_number[0] == '0':\n            break\n    \n    return \"0\" if half_number == \"\" else str(k * (k // 1))\n\n```", "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    def adjust_to_divisible(num_str: str, divisor: int) -> str:\n        num = int(num_str)\n        while num % divisor != 0:\n            num -= 1\n        return str(num)\n    \n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n        return \"\"\n    \n    half_length = (n + 1) // 2\n    mid_digit = '9' * (n % 2)\n    left_half = ''.join(str(i) for i in range(half_length - 1, -1, -1))\n    full_number = left_half + mid_digit + left_half[::-1]\n    \n    while not is_palindrome(full_number):\n        mid_digit = adjust_to_divisible(mid_digit, k)\n        left_half = ''.join(str(i) for i in range(int(mid_digit[0]) - 1, -1, -1))\n        full_number = left_half + mid_digit + left_half[::-1]\n    \n    return full_number\n```"]}
{"task_id": "arc182_a", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (Q + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for q in range(1, Q + 1):\n        for i in range(N, 0, -1):\n            if P[q - 1] <= i:\n                dp[i][q] = dp[P[q - 1] - 1][q - 1]\n            if i < N:\n                dp[i][q] += dp[i + 1][q - 1]\n            dp[i][q] %= MOD\n    \n    result = 0\n    for i in range(1, N + 1):\n        result += dp[i][Q]\n        result %= MOD\n    \n    print(result)\n\nmain()", "d"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (Q + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for q in range(1, Q + 1):\n        for i in range(N, 0, -1):\n            if P[q - 1] <= i:\n                dp[i][q] = dp[P[q - 1] - 1][q - 1]\n            if i < N:\n                dp[i][q] += dp[i + 1][q - 1]\n            dp[i][q] %= MOD\n    \n    result = 0\n    for i in range(1, N + 1):\n        result += dp[i][Q]\n        result %= MOD\n    \n    print(result)\n\nmain()\n```", "```python\ndef count_valid_sequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    P = []\n    V = []\n    for i in range(Q):\n        P.append(int(data[2 + 2 * i]) - 1)\n        V.append(int(data[3 + 2 * i]))\n    \n    MOD = 998244353\n    \n    dp = [0] * N\n    dp[0] = 1\n    \n    for i in range(Q):\n        p = P[i]\n        v = V[i]\n        \n        # Update dp array from right to left\n        for j in range(N - 1, p - 1, -1):\n            if S[j] <= v:\n                dp[j] += dp[j - 1]\n                dp[j] %= MOD\n    \n    print(dp[-1])\n\ncount_valid_sequences()"]}
{"task_id": "arc182_e", "codes": ["def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    # Initialize a dictionary to store the minimum remainders for each A[i]\n    min_remainders = [float('inf')] * N\n    \n    # Iterate over each A[i]\n    for i in range(N):\n        # Calculate the first remainder for A[i]\n        remainder = (C * 0 + A[i]) % M\n        min_remainders[i] = min(min_remainders[i], remainder)\n        \n        # Iterate over the next possible remainders\n        for k in range(1, K):\n            remainder = (C * k + A[i]) % M\n            if remainder < min_remainders[i]:\n                min_remainders[i] = remainder\n        \n        # Since K can be very large, we need to consider the periodicity\n        # The remainders will repeat every M steps\n        for j in range(M):\n            remainder = (C * (j * K // M) + A[i]) % M\n            if remainder < min_remainders[i]:\n                min_remainders[i] = remainder\n    \n    # Sum up the minimum remainders\n    result = sum(min_remainders)\n    print(result)\n\n# Call the function\nsolve()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    # Create a list to store the minimum values for each possible remainder\n    min_values = [float('inf')] * M\n    \n    # Dictionary to map remainders to their corresponding indices\n    remainder_indices = {}\n    \n    for i in range(N):\n        remainder = (C * i + A[i]) % M\n        if remainder not in remainder_indices:\n            remainder_indices[remainder] = []\n        remainder_indices[remainder].append(i)\n    \n    # Sliding window to find the minimum values\n    current_min = float('inf')\n    window_start = 0\n    result = 0\n    \n    for k in range(K):\n        while window_start <= k - len(A):\n            current_min = float('inf')\n            for i in remainder_indices[(C * window_start + A[i]) % M]:\n                if i <= k:\n                    current_min = min(current_min, (C * window_start + A[i]) % M)\n            window_start += 1\n        \n        current_min = float('inf')\n        for i in remainder_indices[(C * k + A[i]) % M]:\n            if i <= k:\n                current_min = min(current_min, (C * k + A[i]) % M)\n        \n        result += current_min\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    # Initialize a dictionary to store the minimum remainders for each A[i]\n    min_remainders = [float('inf')] * N\n    \n    # Iterate over each A[i]\n    for i in range(N):\n        # Calculate the first remainder for A[i]\n        remainder = (C * 0 + A[i]) % M\n        min_remainders[i] = min(min_remainders[i], remainder)\n        \n        # Iterate over the next possible remainders\n        for k in range(1, K):\n            remainder = (C * k + A[i]) % M\n            if remainder < min_remainders[i]:\n                min_remainders[i] = remainder\n        \n        # Since K can be very large, we need to consider the periodicity\n        # The remainders will repeat every M steps\n        for j in range(M):\n            remainder = (C * (j * K // M) + A[i]) % M\n            if remainder < min_remainders[i]:\n                min_remainders[i] = remainder\n    \n    # Sum up the minimum remainders\n    result = sum(min_remainders)\n    print(result)\n\n# Call the function\nsolve()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    # Create a list to store the minimum values for each possible remainder\n    min_values = [float('inf')] * M\n    \n    # Dictionary to map remainders to their corresponding indices\n    remainder_indices = {}\n    \n    for i in range(N):\n        remainder = (C * i + A[i]) % M\n        if remainder not in remainder_indices:\n            remainder_indices[remainder] = []\n        remainder_indices[remainder].append(i)\n    \n    # Sliding window to find the minimum values\n    current_min = float('inf')\n    window_start = 0\n    result = 0\n    \n    for k in range(K):\n        while window_start <= k - len(A):\n            current_min = float('inf')\n            for i in remainder_indices[(C * window_start + A[i]) % M]:\n                if i <= k:\n                    current_min = min(current_min, (C * window_start + A[i]) % M)\n            window_start += 1\n        \n        current_min = float('inf')\n        for i in remainder_indices[(C * k + A[i]) % M]:\n            if i <= k:\n                current_min = min(current_min, (C * k + A[i]) % M)\n        \n        result += current_min\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    # Calculate damage per second for each enemy\n    damage_per_second = [(d / h) for d, h in zip(damage, health)]\n    \n    # Create a list of tuples (damage per second, damage, health)\n    enemies = list(zip(damage_per_second, damage, health))\n    \n    # Sort enemies by damage per second in descending order\n    enemies.sort(reverse=True)\n    \n    total_damage_to_bob = 0\n    current_time = 0\n    \n    while enemies:\n        _, d, h = enemies.pop(0)\n        \n        # Calculate the time needed to defeat the enemy\n        if h % power == 0:\n            time_to_defeat = h // power\n        else:\n            time_to_defeat = (h // power) + 1\n        \n        # Add the damage dealt during this time to the total\n        total_damage_to_bob += time_to_defeat * d\n        \n        # Move forward in time\n        current_time += time_to_defeat\n    \n    return total_damage_to_bob", "def min_damage(power, damage, health):\n    n = len(damage)\n    enemies = [(d, h) for d, h in zip(damage, health)]\n    enemies.sort(key=lambda x: -x[1] // x[0])\n    \n    total_damage = 0\n    time = 0\n    \n    for d, h in enemies:\n        if h <= 0:\n            continue\n        attacks = (h + power - 1) // power\n        total_damage += attacks * d\n        time += attacks\n    \n    return total_damage"], "passed": [false, false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    # Calculate damage per second for each enemy\n    damage_per_second = [(d / h) for d, h in zip(damage, health)]\n    \n    # Create a list of tuples (damage per second, damage, health)\n    enemies = list(zip(damage_per_second, damage, health))\n    \n    # Sort enemies by damage per second in descending order\n    enemies.sort(reverse=True)\n    \n    total_damage_to_bob = 0\n    current_time = 0\n    \n    while enemies:\n        _, d, h = enemies.pop(0)\n        \n        # Calculate the time needed to defeat the enemy\n        if h % power == 0:\n            time_to_defeat = h // power\n        else:\n            time_to_defeat = (h // power) + 1\n        \n        # Add the damage dealt during this time to the total\n        total_damage_to_bob += time_to_defeat * d\n        \n        # Move forward in time\n        current_time += time_to_defeat\n    \n    return total_damage_to_bob\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    enemies = [(d, h) for d, h in zip(damage, health)]\n    enemies.sort(key=lambda x: -x[1] // x[0])\n    \n    total_damage = 0\n    time = 0\n    \n    for d, h in enemies:\n        if h <= 0:\n            continue\n        attacks = (h + power - 1) // power\n        total_damage += attacks * d\n        time += attacks\n    \n    return total_damage\n```"]}
{"task_id": "arc182_d", "codes": ["def min_operations_to_transform(N, M, A, B):\n    def count_operations(a, b):\n        diff = abs(b - a)\n        # Direct transition\n        if diff == 1:\n            return 1\n        elif diff == 0:\n            return 0\n        else:\n            # Intermediate step needed to avoid bad transitions\n            if abs((a + 1) % M - b) < diff and abs((a - 1) % M - b) < diff:\n                return 2\n            else:\n                return float('inf')\n\n    total_operations = 0\n    for i in range(N):\n        if A[i] != B[i]:\n            ops = count_operations(A[i], B[i])\n            if ops == float('inf'):\n                return -1\n            total_operations += ops\n\n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Calculate and print result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)\n", "def min_operations(N, M, A, B):\n    def count_operations(a, b):\n        diff = abs(b - a)\n        return min(diff, M - diff)\n\n    total_operations = 0\n    for i in range(N):\n        if A[i] == B[i]:\n            continue\n        current_a = A[i]\n        target_b = B[i]\n        operations = float('inf')\n        for j in range(N):\n            if i != j and A[j] != B[j] and A[j] != (A[j] + 1) % M != B[j] and A[j] != (A[j] - 1) % M != B[j]:\n                temp_A = A[:]\n                temp_A[i], temp_A[j] = temp_A[j], temp_A[i]\n                temp_operations = count_operations(current_a, target_b)\n                if temp_operations < operations:\n                    operations = temp_operations\n        if operations == float('inf'):\n            return -1\n        total_operations += operations\n        A[i] = B[i]\n    return total_operations\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:2*N+2]))\n    result = min_operations(N, M, A, B)\n    print(result)"], "passed": [false, false], "raw_code": ["def min_operations_to_transform(N, M, A, B):\n    def count_operations(a, b):\n        diff = abs(b - a)\n        # Direct transition\n        if diff == 1:\n            return 1\n        elif diff == 0:\n            return 0\n        else:\n            # Intermediate step needed to avoid bad transitions\n            if abs((a + 1) % M - b) < diff and abs((a - 1) % M - b) < diff:\n                return 2\n            else:\n                return float('inf')\n\n    total_operations = 0\n    for i in range(N):\n        if A[i] != B[i]:\n            ops = count_operations(A[i], B[i])\n            if ops == float('inf'):\n                return -1\n            total_operations += ops\n\n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Calculate and print result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)\n", "def min_operations(N, M, A, B):\n    def count_operations(a, b):\n        diff = abs(b - a)\n        return min(diff, M - diff)\n\n    total_operations = 0\n    for i in range(N):\n        if A[i] == B[i]:\n            continue\n        current_a = A[i]\n        target_b = B[i]\n        operations = float('inf')\n        for j in range(N):\n            if i != j and A[j] != B[j] and A[j] != (A[j] + 1) % M != B[j] and A[j] != (A[j] - 1) % M != B[j]:\n                temp_A = A[:]\n                temp_A[i], temp_A[j] = temp_A[j], temp_A[i]\n                temp_operations = count_operations(current_a, target_b)\n                if temp_operations < operations:\n                    operations = temp_operations\n        if operations == float('inf'):\n            return -1\n        total_operations += operations\n        A[i] = B[i]\n    return total_operations\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:2*N+2]))\n    result = min_operations(N, M, A, B)\n    print(result)"]}
{"task_id": "arc181_d", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    # Initialize Fenwick Tree\n    tree = [0] * (N + 1)\n\n    def update(index, value):\n        while index <= N:\n            tree[index] += value\n            index += index & -index\n\n    def query(index):\n        result = 0\n        while index > 0:\n            result += tree[index]\n            index -= index & -index\n        return result\n\n    def get_inversion_count(perm):\n        inversions = 0\n        for i, x in enumerate(perm):\n            inversions += i - query(x)\n            update(x, 1)\n        return inversions\n\n    # Initial inversion count\n    current_perm = P[:]\n    initial_inv = get_inversion_count(current_perm)\n    print(initial_inv)\n\n    for a in A:\n        for i in range(a - 1, N):\n            if current_perm[i] > current_perm[i + 1]:\n                current_perm[i], current_perm[i + 1] = current_perm[i + 1], current_perm[i]\n                update(current_perm[i], -1)\n                update(current_perm[i + 1], 1)\n        print(get_inversion_count(current_perm))\n\nif __name__ == '__main__':\n    main()", "def build_bit(n):\n    bit = [0] * (n + 1)\n    return bit\n\ndef update(bit, idx, val):\n    while idx <= len(bit):\n        bit[idx] += val\n        idx += idx & -idx\n\ndef query(bit, idx):\n    result = 0\n    while idx > 0:\n        result += bit[idx]\n        idx -= idx & -idx\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    bit = build_bit(N)\n    inv_count = 0\n    \n    for i in range(1, N+1):\n        update(bit, P[i], 1)\n        inv_count += i - query(bit, P[i])\n    \n    results = []\n    for a in A:\n        for _ in range(a - len(results)):\n            for i in range(len(P)):\n                if P[i] == a:\n                    P.pop(i)\n                    break\n            \n            new_inv_count = 0\n            bit = build_bit(N)\n            for p in P:\n                update(bit, p, 1)\n                new_inv_count += len(P) - i - query(bit, p)\n            \n            inv_count = new_inv_count\n        \n        results.append(inv_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    # Initialize Fenwick Tree\n    tree = [0] * (N + 1)\n\n    def update(index, value):\n        while index <= N:\n            tree[index] += value\n            index += index & -index\n\n    def query(index):\n        result = 0\n        while index > 0:\n            result += tree[index]\n            index -= index & -index\n        return result\n\n    def get_inversion_count(perm):\n        inversions = 0\n        for i, x in enumerate(perm):\n            inversions += i - query(x)\n            update(x, 1)\n        return inversions\n\n    # Initial inversion count\n    current_perm = P[:]\n    initial_inv = get_inversion_count(current_perm)\n    print(initial_inv)\n\n    for a in A:\n        for i in range(a - 1, N):\n            if current_perm[i] > current_perm[i + 1]:\n                current_perm[i], current_perm[i + 1] = current_perm[i + 1], current_perm[i]\n                update(current_perm[i], -1)\n                update(current_perm[i + 1], 1)\n        print(get_inversion_count(current_perm))\n\nif __name__ == '__main__':\n    main()", "```python\ndef build_bit(n):\n    bit = [0] * (n + 1)\n    return bit\n\ndef update(bit, idx, val):\n    while idx <= len(bit):\n        bit[idx] += val\n        idx += idx & -idx\n\ndef query(bit, idx):\n    result = 0\n    while idx > 0:\n        result += bit[idx]\n        idx -= idx & -idx\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    bit = build_bit(N)\n    inv_count = 0\n    \n    for i in range(1, N+1):\n        update(bit, P[i], 1)\n        inv_count += i - query(bit, P[i])\n    \n    results = []\n    for a in A:\n        for _ in range(a - len(results)):\n            for i in range(len(P)):\n                if P[i] == a:\n                    P.pop(i)\n                    break\n            \n            new_inv_count = 0\n            bit = build_bit(N)\n            for p in P:\n                update(bit, p, 1)\n                new_inv_count += len(P) - i - query(bit, p)\n            \n            inv_count = new_inv_count\n        \n        results.append(inv_count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3551", "codes": ["class TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\ndef insert(trie, num):\n    node = trie\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        if not node.children[bit]:\n            node.children[bit] = TrieNode()\n        node = node.children[bit]\n\ndef find_max_xor(trie, num):\n    max_xor = 0\n    node = trie\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        max_xor <<= 1\n        if node.children[1 - bit]:\n            node = node.children[1 - bit]\n            max_xor |= 1\n        else:\n            node = node.children[bit]\n    return max_xor\n\ndef max_xor_queries(nums, queries):\n    trie = TrieNode()\n    for num in nums:\n        insert(trie, num)\n    \n    result = []\n    for l, r in queries:\n        max_xor = 0\n        for i in range(l, r + 1):\n            max_xor |= nums[i]\n            result.append(max_xor)\n    \n    return result", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n    \n    def query(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if alt_bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    for l, r in queries:\n        current_xor = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(trie.query(current_xor))\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\nclass TrieNode:\n    def __init__(self):\n        self.children = [None, None]\n\ndef insert(trie, num):\n    node = trie\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        if not node.children[bit]:\n            node.children[bit] = TrieNode()\n        node = node.children[bit]\n\ndef find_max_xor(trie, num):\n    max_xor = 0\n    node = trie\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        max_xor <<= 1\n        if node.children[1 - bit]:\n            node = node.children[1 - bit]\n            max_xor |= 1\n        else:\n            node = node.children[bit]\n    return max_xor\n\ndef max_xor_queries(nums, queries):\n    trie = TrieNode()\n    for num in nums:\n        insert(trie, num)\n    \n    result = []\n    for l, r in queries:\n        max_xor = 0\n        for i in range(l, r + 1):\n            max_xor |= nums[i]\n            result.append(max_xor)\n    \n    return result\n```", "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, num):\n        node = self.root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n    \n    def query(self, num):\n        node = self.root\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            alt_bit = 1 - bit\n            if alt_bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[alt_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    trie = Trie()\n    result = []\n    \n    for l, r in queries:\n        current_xor = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(trie.query(current_xor))\n    \n    return result\n```"]}
{"task_id": "3548", "codes": ["def count_good_integers(n, k):\n    from itertools import permutations\n    \n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def is_valid_number(digits):\n        num_str = ''.join(map(str, digits))\n        if num_str[0] == '0':\n            return False\n        num = int(num_str)\n        return num % k == 0\n    \n    count = 0\n    digits_sum = [i for i in range(1, 10) if i * (n // 2 + 1) >= k and i * (n // 2) < k]\n    \n    for digit_sum in digits_sum:\n        for perm in set(permutations([digit_sum] * n)):\n            if is_palindrome(''.join(map(str, perm))) and is_valid_number(perm):\n                count += 1\n                \n    return count", "def count_good_integers(n, k):\n    def is_k_palindrome(num):\n        return str(num) == str(num)[::-1] and num % k == 0\n    \n    def generate_numbers(digits, length):\n        if length == 0:\n            yield \"\"\n            return\n        for i in range(len(digits)):\n            for suffix in generate_numbers(digits[:i] + digits[i+1:], length - 1):\n                yield digits[i] + suffix\n    \n    def has_valid_permutation(digits):\n        for perm in itertools.permutations(digits):\n            num = int(''.join(perm))\n            if is_k_palindrome(num):\n                return True\n        return False\n    \n    count = 0\n    for i in range(10**(n-1), 10**n):\n        digits = str(i)\n        if has_valid_permutation(digits):\n            count += 1\n    \n    return count"], "passed": [false, false], "raw_code": ["```python\ndef count_good_integers(n, k):\n    from itertools import permutations\n    \n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def is_valid_number(digits):\n        num_str = ''.join(map(str, digits))\n        if num_str[0] == '0':\n            return False\n        num = int(num_str)\n        return num % k == 0\n    \n    count = 0\n    digits_sum = [i for i in range(1, 10) if i * (n // 2 + 1) >= k and i * (n // 2) < k]\n    \n    for digit_sum in digits_sum:\n        for perm in set(permutations([digit_sum] * n)):\n            if is_palindrome(''.join(map(str, perm))) and is_valid_number(perm):\n                count += 1\n                \n    return count\n```", "```python\ndef count_good_integers(n, k):\n    def is_k_palindrome(num):\n        return str(num) == str(num)[::-1] and num % k == 0\n    \n    def generate_numbers(digits, length):\n        if length == 0:\n            yield \"\"\n            return\n        for i in range(len(digits)):\n            for suffix in generate_numbers(digits[:i] + digits[i+1:], length - 1):\n                yield digits[i] + suffix\n    \n    def has_valid_permutation(digits):\n        for perm in itertools.permutations(digits):\n            num = int(''.join(perm))\n            if is_k_palindrome(num):\n                return True\n        return False\n    \n    count = 0\n    for i in range(10**(n-1), 10**n):\n        digits = str(i)\n        if has_valid_permutation(digits):\n            count += 1\n    \n    return count\n```"]}
{"task_id": "abc369_g", "codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef min_max_score(N, edges):\n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v, l in edges:\n        adj_list[u].append((v, l))\n        adj_list[v].append((u, l))\n\n    def bfs(start):\n        dist = [-1] * (N + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor, weight in adj_list[node]:\n                if dist[neighbor] == -1:\n                    dist[neighbor] = dist[node] + weight\n                    queue.append(neighbor)\n        return dist\n\n    def find_min_cycle(vertices):\n        # Use Floyd-Warshall to find the shortest paths between all pairs of vertices\n        dp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n        for u, v, l in edges:\n            dp[u][v] = dp[v][u] = l\n        for k in range(1, N + 1):\n            for i in range(1, N + 1):\n                for j in range(1, N + 1):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\n        # Find the minimum cycle passing through all vertices\n        min_cycle = float('inf')\n        for subset in range(1 << len(vertices)):\n            current_length = 0\n            last_vertex = None\n            for vertex in vertices:\n                if subset & (1 << vertex) != 0:\n                    if last_vertex is not None:\n                        current_length += dp[last_vertex][vertex]\n                    last_vertex = vertex\n            if last_vertex is not None:\n                current_length += dp[last_vertex][vertices[0]]\n            min_cycle = min(min_cycle, current_length)\n        return min_cycle\n\n    results = []\n    for K in range(1, N + 1):\n        # Generate all combinations of K vertices\n        from itertools import combinations\n        min_score = float('inf')\n        for vertices in combinations(range(1, N + 1), K):\n            min_score = min(min_score, find_min_cycle(vertices))\n        results.append(min_score)\n\n    return results\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    edges = [(int(data[3*i+1]), int(data[3*i+2]), int(data[3*i+3])) for i in range(N-1)]\n    result = min_max_score(N, edges)\n    for r in result:\n        print(r)", "i"], "passed": [false, false], "raw_code": ["import sys\nfrom collections import defaultdict, deque\n\ndef min_max_score(N, edges):\n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v, l in edges:\n        adj_list[u].append((v, l))\n        adj_list[v].append((u, l))\n\n    def bfs(start):\n        dist = [-1] * (N + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor, weight in adj_list[node]:\n                if dist[neighbor] == -1:\n                    dist[neighbor] = dist[node] + weight\n                    queue.append(neighbor)\n        return dist\n\n    def find_min_cycle(vertices):\n        # Use Floyd-Warshall to find the shortest paths between all pairs of vertices\n        dp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\n        for u, v, l in edges:\n            dp[u][v] = dp[v][u] = l\n        for k in range(1, N + 1):\n            for i in range(1, N + 1):\n                for j in range(1, N + 1):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\n        # Find the minimum cycle passing through all vertices\n        min_cycle = float('inf')\n        for subset in range(1 << len(vertices)):\n            current_length = 0\n            last_vertex = None\n            for vertex in vertices:\n                if subset & (1 << vertex) != 0:\n                    if last_vertex is not None:\n                        current_length += dp[last_vertex][vertex]\n                    last_vertex = vertex\n            if last_vertex is not None:\n                current_length += dp[last_vertex][vertices[0]]\n            min_cycle = min(min_cycle, current_length)\n        return min_cycle\n\n    results = []\n    for K in range(1, N + 1):\n        # Generate all combinations of K vertices\n        from itertools import combinations\n        min_score = float('inf')\n        for vertices in combinations(range(1, N + 1), K):\n            min_score = min(min_score, find_min_cycle(vertices))\n        results.append(min_score)\n\n    return results\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    edges = [(int(data[3*i+1]), int(data[3*i+2]), int(data[3*i+3])) for i in range(N-1)]\n    result = min_max_score(N, edges)\n    for r in result:\n        print(r)", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = []\nindex = 1\n\nfor _ in range(N - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    l = int(data[index + 2])\n    edges.append((l, u, v))\n    index += 3\n\n# Sort edges by weight\nedges.sort()\n\n# Union-Find data structure\nclass UF:\n    def __init__(self, n):\n        self.parent = list(range(n))\n    \n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n    \n    def union(self, u, v):\n        pu, pv = self.find(u), self.find(v)\n        if pu != pv:\n            self.parent[pu] = pv\n\nuf = UF(N)\nmst_weight = 0\nmst_edges = []\n\nfor l, u, v in edges:\n    if uf.find(u) != uf.find(v):\n        uf.union(u, v)\n        mst_weight += l\n        mst_edges.append((u, v))\n\ntotal_weight = sum(l for l, _, _ in edges)\n\nresults = []\nfor K in range(1, N + 1):\n    if K == 1:\n        result = 2 * min(total_weight - mst_weight + edges[i][0] for i in range(len(edges)))\n    elif K == 2:\n        result = 2 * min(total_weight - mst_weight + edges[i][0] + edges[j][0] for i in range(len(edges)) for j in range(i + 1, len(edges)) if edges[i][1] != edges[j][1] and edges[i][2] != edges[j][2])\n    else:\n        result = 2 * (total_weight - mst_weight)\n    results.append(result)\n\nfor result in results:\n    print(result)"]}
{"task_id": "3575", "codes": ["def max_subsequence_value(nums, k):\n    n = len(nums)\n    dp = [[0] * 2 for _ in range(n)]\n    \n    # Initialize the first element\n    dp[0][0] = nums[0]\n    if n > 1:\n        dp[1][1] = nums[1]\n    \n    # Fill the DP table\n    for i in range(2, n):\n        for j in range(2):\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j^1] | nums[i])\n    \n    # Find the maximum value of the subsequence\n    max_val = 0\n    for i in range(k, n-k+1):\n        max_val = max(max_val, dp[i-1][0] ^ dp[n-i][1])\n    \n    return max_val", "def max_xor(nums, k):\n    def xor(a, b):\n        return a ^ b\n    \n    def dfs(nums, k):\n        if k == 0:\n            return 0\n        mid = len(nums) // 2\n        left_max = dfs(nums[:mid], k // 2)\n        right_max = dfs(nums[mid:], k // 2)\n        return max(left_max, right_max, xor(left_max, right_max))\n    \n    return dfs(nums, k)\n\ndef max_sequence_value(nums, k):\n    subsequence = []\n    for i in range(2 * k):\n        subsequence.append(max(nums))\n        nums.remove(max(nums))\n    return xor(subsequence[:k], subsequence[k:])"], "passed": [false, false], "raw_code": ["```python\ndef max_subsequence_value(nums, k):\n    n = len(nums)\n    dp = [[0] * 2 for _ in range(n)]\n    \n    # Initialize the first element\n    dp[0][0] = nums[0]\n    if n > 1:\n        dp[1][1] = nums[1]\n    \n    # Fill the DP table\n    for i in range(2, n):\n        for j in range(2):\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j^1] | nums[i])\n    \n    # Find the maximum value of the subsequence\n    max_val = 0\n    for i in range(k, n-k+1):\n        max_val = max(max_val, dp[i-1][0] ^ dp[n-i][1])\n    \n    return max_val\n```", "```python\ndef max_xor(nums, k):\n    def xor(a, b):\n        return a ^ b\n    \n    def dfs(nums, k):\n        if k == 0:\n            return 0\n        mid = len(nums) // 2\n        left_max = dfs(nums[:mid], k // 2)\n        right_max = dfs(nums[mid:], k // 2)\n        return max(left_max, right_max, xor(left_max, right_max))\n    \n    return dfs(nums, k)\n\ndef max_sequence_value(nums, k):\n    subsequence = []\n    for i in range(2 * k):\n        subsequence.append(max(nums))\n        nums.remove(max(nums))\n    return xor(subsequence[:k], subsequence[k:])\n```"]}
{"task_id": "3583", "codes": ["from collections import defaultdict\nimport bisect\n\ndef getGCD(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\ndef answerQueries(nums, queries):\n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count occurrences of each GCD\n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_count[d] += 1\n    \n    # Prefix sum array to count elements less than or equal to a given value\n    prefix_sum = [0] * (max_val + 1)\n    for gcd, count in gcd_count.items():\n        prefix_sum[gcd] = count\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for query in queries:\n        idx = bisect.bisect_right(prefix_sum, query)\n        result.append(idx)\n    \n    return result", "from collections import defaultdict\nfrom typing import List\n\ndef getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count occurrences of each GCD\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    # Create a sorted list of unique GCDs\n    gcd_list = sorted(gcd_count.keys())\n    \n    # Create a prefix sum array to store cumulative frequencies\n    prefix_sum = [0]\n    current_sum = 0\n    for gcd_val in gcd_list:\n        current_sum += gcd_count[gcd_val]\n        prefix_sum.append(current_sum)\n    \n    # Answer each query\n    result = []\n    for query in queries:\n        idx = query + 1  # Convert 0-based index to 1-based for binary search\n        idx = bisect.bisect_left(prefix_sum, idx)\n        if idx > 0:\n            result.append(gcd_list[idx - 1])\n        else:\n            result.append(0)\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\nfrom collections import defaultdict\nimport bisect\n\ndef getGCD(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\ndef answerQueries(nums, queries):\n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count occurrences of each GCD\n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_count[d] += 1\n    \n    # Prefix sum array to count elements less than or equal to a given value\n    prefix_sum = [0] * (max_val + 1)\n    for gcd, count in gcd_count.items():\n        prefix_sum[gcd] = count\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for query in queries:\n        idx = bisect.bisect_right(prefix_sum, query)\n        result.append(idx)\n    \n    return result\n```", "```python\nfrom collections import defaultdict\nfrom typing import List\n\ndef getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count occurrences of each GCD\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    # Create a sorted list of unique GCDs\n    gcd_list = sorted(gcd_count.keys())\n    \n    # Create a prefix sum array to store cumulative frequencies\n    prefix_sum = [0]\n    current_sum = 0\n    for gcd_val in gcd_list:\n        current_sum += gcd_count[gcd_val]\n        prefix_sum.append(current_sum)\n    \n    # Answer each query\n    result = []\n    for query in queries:\n        idx = query + 1  # Convert 0-based index to 1-based for binary search\n        idx = bisect.bisect_left(prefix_sum, idx)\n        if idx > 0:\n            result.append(gcd_list[idx - 1])\n        else:\n            result.append(0)\n    \n    return result\n```"]}
{"task_id": "arc183_c", "codes": ["import sys\nfrom functools import lru_cache\n\n# Function to calculate binomial coefficient\n@lru_cache(None)\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n\ndef count_permutations(N, M, conditions):\n    MOD = 998244353\n    # Precompute binomial coefficients for later use\n    binomials = [0] * (N + 1)\n    for i in range(N + 1):\n        for j in range(min(i, M) + 1):\n            binomials[i] += binomial_coefficient(i, j)\n            binomials[i] %= MOD\n\n    @lru_cache(None)\n    def dp(i, mask):\n        if i == N + 1:\n            return mask == 0\n        count = 0\n        for j in range(1, N + 1):\n            if mask & (1 << j):\n                continue\n            if any(max(P[L-1:R]) == j for L, R, _ in conditions if L <= i <= R):\n                continue\n            count += dp(i + 1, mask | (1 << j))\n        return count % MOD\n\n    return dp(1, 0)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    conditions = [[int(data[2 + 3 * i]), int(data[3 + 3 * i]), int(data[4 + 3 * i])] for i in range(M)]\n    result = count_permutations(N, M, conditions)\n    print(result)\n\nif __name__ == '__main__':\n    main()", "from sys import stdin, stdout\nimport math\n\ndef read_ints():\n    return map(int, stdin.readline().split())\n\ndef mod_inv(a, m):\n    return pow(a, m - 2, m)\n\ndef nCr(n, r, p):\n    if r > n:\n        return 0\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * mod_inv(den, p) % p\n\ndef main():\n    N, M = read_ints()\n    MOD = 998244353\n    \n    # Read conditions\n    conditions = []\n    for _ in range(M):\n        L, R, X = read_ints()\n        conditions.append((L - 1, R - 1, X - 1))\n    \n    # Initialize DP table\n    dp = [[0] * N for _ in range(N)]\n    for i in range(N):\n        dp[0][i] = 1\n    \n    # Process each condition\n    for L, R, X in conditions:\n        new_dp = [[0] * N for _ in range(N)]\n        for i in range(L, R + 1):\n            for j in range(N):\n                if j != X:\n                    new_dp[i - L][j] += dp[i - L - 1][k] for k in range(j + 1) if k != X\n                    new_dp[i - L][j] %= MOD\n        dp = new_dp\n    \n    # Sum up the results\n    result = sum(dp[-1]) % MOD\n    stdout.write(f\"{result}\\n\")\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["import sys\nfrom functools import lru_cache\n\n# Function to calculate binomial coefficient\n@lru_cache(None)\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n\ndef count_permutations(N, M, conditions):\n    MOD = 998244353\n    # Precompute binomial coefficients for later use\n    binomials = [0] * (N + 1)\n    for i in range(N + 1):\n        for j in range(min(i, M) + 1):\n            binomials[i] += binomial_coefficient(i, j)\n            binomials[i] %= MOD\n\n    @lru_cache(None)\n    def dp(i, mask):\n        if i == N + 1:\n            return mask == 0\n        count = 0\n        for j in range(1, N + 1):\n            if mask & (1 << j):\n                continue\n            if any(max(P[L-1:R]) == j for L, R, _ in conditions if L <= i <= R):\n                continue\n            count += dp(i + 1, mask | (1 << j))\n        return count % MOD\n\n    return dp(1, 0)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    conditions = [[int(data[2 + 3 * i]), int(data[3 + 3 * i]), int(data[4 + 3 * i])] for i in range(M)]\n    result = count_permutations(N, M, conditions)\n    print(result)\n\nif __name__ == '__main__':\n    main()", "```python\nfrom sys import stdin, stdout\nimport math\n\ndef read_ints():\n    return map(int, stdin.readline().split())\n\ndef mod_inv(a, m):\n    return pow(a, m - 2, m)\n\ndef nCr(n, r, p):\n    if r > n:\n        return 0\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n    return num * mod_inv(den, p) % p\n\ndef main():\n    N, M = read_ints()\n    MOD = 998244353\n    \n    # Read conditions\n    conditions = []\n    for _ in range(M):\n        L, R, X = read_ints()\n        conditions.append((L - 1, R - 1, X - 1))\n    \n    # Initialize DP table\n    dp = [[0] * N for _ in range(N)]\n    for i in range(N):\n        dp[0][i] = 1\n    \n    # Process each condition\n    for L, R, X in conditions:\n        new_dp = [[0] * N for _ in range(N)]\n        for i in range(L, R + 1):\n            for j in range(N):\n                if j != X:\n                    new_dp[i - L][j] += dp[i - L - 1][k] for k in range(j + 1) if k != X\n                    new_dp[i - L][j] %= MOD\n        dp = new_dp\n    \n    # Sum up the results\n    result = sum(dp[-1]) % MOD\n    stdout.write(f\"{result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "arc182_c", "codes": ["def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    dp = [0] * (M + 1)\n    dp[1] = 1\n    for i in range(2, M + 1):\n        dp[i] = dp[i - 1] + count_divisors(i)\n        dp[i] %= MOD\n    result = 0\n    for k in range(1, N + 1):\n        result += pow(M, k, MOD) * dp[M]\n        result %= MOD\n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nprint(sum_of_scores(N, M))\n", "def calculate_score(N, M):\n    MOD = 998244353\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % MOD\n        return result\n\n    def power(base, exp):\n        result = 1\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % MOD\n            base = (base * base) % MOD\n            exp //= 2\n        return result\n\n    def divisors_count(n):\n        count = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                power_count = 0\n                while n % i == 0:\n                    n //= i\n                    power_count += 1\n                count *= (power_count + 1)\n                count %= MOD\n        if n > 1:\n            count *= 2\n            count %= MOD\n        return count\n\n    total_divisors = 1\n    for _ in range(N):\n        total_divisors = (total_divisors * (M + 1)) % MOD\n\n    total_score = 0\n    for m in range(1, M + 1):\n        total_score = (total_score + divisors_count(m)) % MOD\n\n    final_score = (total_divisors * total_score) % MOD\n    return final_score\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    print(calculate_score(N, M))"], "passed": [false, false], "raw_code": ["def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    dp = [0] * (M + 1)\n    dp[1] = 1\n    for i in range(2, M + 1):\n        dp[i] = dp[i - 1] + count_divisors(i)\n        dp[i] %= MOD\n    result = 0\n    for k in range(1, N + 1):\n        result += pow(M, k, MOD) * dp[M]\n        result %= MOD\n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nprint(sum_of_scores(N, M))\n", "def calculate_score(N, M):\n    MOD = 998244353\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % MOD\n        return result\n\n    def power(base, exp):\n        result = 1\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % MOD\n            base = (base * base) % MOD\n            exp //= 2\n        return result\n\n    def divisors_count(n):\n        count = 1\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                power_count = 0\n                while n % i == 0:\n                    n //= i\n                    power_count += 1\n                count *= (power_count + 1)\n                count %= MOD\n        if n > 1:\n            count *= 2\n            count %= MOD\n        return count\n\n    total_divisors = 1\n    for _ in range(N):\n        total_divisors = (total_divisors * (M + 1)) % MOD\n\n    total_score = 0\n    for m in range(1, M + 1):\n        total_score = (total_score + divisors_count(m)) % MOD\n\n    final_score = (total_divisors * total_score) % MOD\n    return final_score\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    print(calculate_score(N, M))"]}
{"task_id": "3560", "codes": ["def min_moves_to_capture(kx, ky, px, py):\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [[[float('-inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    def dfs(i, j, mask):\n        if mask == 0:\n            return 0\n        if dp[i][j][mask] != float('-inf'):\n            return dp[i][j][mask]\n        min_moves = float('inf')\n        for k in range(n):\n            if (mask & (1 << k)) > 0:\n                px, py = positions[k]\n                moves = min_moves_to_capture(kx, ky, px, py)\n                remaining_mask = mask ^ (1 << k)\n                min_moves = min(min_moves, moves + dfs(px, py, remaining_mask))\n        dp[i][j][mask] = min_moves\n        return dp[i][j][mask]\n    return dfs(kx, ky, (1 << n) - 1)", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the minimum moves using the L-shape movement of the knight\n    return min(abs(kx - px) + abs(ky - py), abs(kx - py) + abs(ky - px))\n\ndef max_moves_alice(kx, ky, positions, memo=None):\n    if memo is None:\n        memo = {}\n    if not positions:\n        return 0\n    if (kx, ky, tuple(sorted(positions))) in memo:\n        return memo[(kx, ky, tuple(sorted(positions)))]\n\n    max_moves = float('-inf')\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        opponent_max_moves = max_moves_bob(px, py, remaining_positions, memo)\n        total_moves = moves + opponent_max_moves\n        max_moves = max(max_moves, total_moves)\n\n    memo[(kx, ky, tuple(sorted(positions)))] = max_moves\n    return max_moves\n\ndef max_moves_bob(px, py, positions, memo=None):\n    if memo is None:\n        memo = {}\n    if not positions:\n        return 0\n    if (px, py, tuple(sorted(positions))) in memo:\n        return memo[(px, py, tuple(sorted(positions)))]\n\n    min_moves = float('inf')\n    for i, (qx, qy) in enumerate(positions):\n        moves = min_moves_to_capture(px, py, qx, qy)\n        remaining_positions = positions[:i] + positions[i+1:]\n        alice_max_moves = max_moves_alice(qx, qy, remaining_positions, memo)\n        min_moves = min(min_moves, alice_max_moves)\n\n    memo[(px, py, tuple(sorted(positions)))] = min_moves\n    return min_moves\n\ndef max_total_moves(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)"], "passed": [false, false], "raw_code": ["def min_moves_to_capture(kx, ky, px, py):\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [[[float('-inf')] * (1 << n) for _ in range(n)] for _ in range(n)]\n    def dfs(i, j, mask):\n        if mask == 0:\n            return 0\n        if dp[i][j][mask] != float('-inf'):\n            return dp[i][j][mask]\n        min_moves = float('inf')\n        for k in range(n):\n            if (mask & (1 << k)) > 0:\n                px, py = positions[k]\n                moves = min_moves_to_capture(kx, ky, px, py)\n                remaining_mask = mask ^ (1 << k)\n                min_moves = min(min_moves, moves + dfs(px, py, remaining_mask))\n        dp[i][j][mask] = min_moves\n        return dp[i][j][mask]\n    return dfs(kx, ky, (1 << n) - 1)", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the minimum moves using the L-shape movement of the knight\n    return min(abs(kx - px) + abs(ky - py), abs(kx - py) + abs(ky - px))\n\ndef max_moves_alice(kx, ky, positions, memo=None):\n    if memo is None:\n        memo = {}\n    if not positions:\n        return 0\n    if (kx, ky, tuple(sorted(positions))) in memo:\n        return memo[(kx, ky, tuple(sorted(positions)))]\n\n    max_moves = float('-inf')\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        opponent_max_moves = max_moves_bob(px, py, remaining_positions, memo)\n        total_moves = moves + opponent_max_moves\n        max_moves = max(max_moves, total_moves)\n\n    memo[(kx, ky, tuple(sorted(positions)))] = max_moves\n    return max_moves\n\ndef max_moves_bob(px, py, positions, memo=None):\n    if memo is None:\n        memo = {}\n    if not positions:\n        return 0\n    if (px, py, tuple(sorted(positions))) in memo:\n        return memo[(px, py, tuple(sorted(positions)))]\n\n    min_moves = float('inf')\n    for i, (qx, qy) in enumerate(positions):\n        moves = min_moves_to_capture(px, py, qx, qy)\n        remaining_positions = positions[:i] + positions[i+1:]\n        alice_max_moves = max_moves_alice(qx, qy, remaining_positions, memo)\n        min_moves = min(min_moves, alice_max_moves)\n\n    memo[(px, py, tuple(sorted(positions)))] = min_moves\n    return min_moves\n\ndef max_total_moves(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)"]}
{"task_id": "abc366_f", "codes": ["def max_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    functions = []\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Precompute the effect of applying each function multiple times\n    max_values = [[0] * K for _ in range(N)]\n    for i in range(N):\n        current_value = 1\n        for k in range(K):\n            current_value = functions[i][0] * current_value + functions[i][1]\n            max_values[i][k] = current_value\n    \n    # Dynamic programming to find the maximum value\n    dp = [0] * N\n    for i in range(N):\n        dp[i] = max_values[i][K-1]\n    \n    for k in range(K-2, -1, -1):\n        new_dp = [0] * N\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    new_dp[i] = max(new_dp[i], dp[j] + max_values[i][k])\n        dp = new_dp\n    \n    print(dp[0])\n\nmax_function_value()", "i"], "passed": [false, false], "raw_code": ["```python\ndef max_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    functions = []\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Precompute the effect of applying each function multiple times\n    max_values = [[0] * K for _ in range(N)]\n    for i in range(N):\n        current_value = 1\n        for k in range(K):\n            current_value = functions[i][0] * current_value + functions[i][1]\n            max_values[i][k] = current_value\n    \n    # Dynamic programming to find the maximum value\n    dp = [0] * N\n    for i in range(N):\n        dp[i] = max_values[i][K-1]\n    \n    for k in range(K-2, -1, -1):\n        new_dp = [0] * N\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    new_dp[i] = max(new_dp[i], dp[j] + max_values[i][k])\n        dp = new_dp\n    \n    print(dp[0])\n\nmax_function_value()\n```", "```python\nimport numpy as np\n\ndef max_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    # Initialize the identity matrix for the combined transformation\n    combined_matrix = np.eye(2, dtype=int)\n    \n    # Process each function to update the combined transformation matrix\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        \n        # Create the transformation matrix for the current function\n        transform_matrix = np.array([[A, B], [0, 1]], dtype=int)\n        \n        # Update the combined transformation matrix\n        combined_matrix = np.dot(combined_matrix, transform_matrix)\n    \n    # Compute the final value by applying the combined transformation to x=1 and adding the constant terms\n    result = 0\n    for _ in range(K):\n        result = combined_matrix[0, 0] * result + combined_matrix[0, 1]\n    \n    print(result)\n\nmax_function_value()"]}
{"task_id": "3527", "codes": ["def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Extend the list to simulate the circular nature\n    counts = {i: 0 for i in range(3, n + 1)}\n    \n    def is_alternating(start, end):\n        for i in range(start, end):\n            if colors[i] == colors[i + 1]:\n                return False\n        return True\n    \n    def update_counts(size, diff):\n        nonlocal counts\n        counts[size] += diff\n    \n    def process_query(query):\n        nonlocal colors\n        if query[0] == 1:\n            size = query[1]\n            result = counts[size]\n            return result\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            old_color = colors[index]\n            colors[index] = color\n            \n            start = max(index - size, 0)\n            end = min(index + size, 2 * n)\n            \n            if is_alternating(start, end):\n                if old_color != colors[start]:\n                    update_counts(size, -1)\n                if colors[end - 1] != colors[end % n]:\n                    update_counts(size, 1)\n            else:\n                update_counts(size, -1)\n                update_counts(size, -1)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            result = process_query(query)\n            results.append(result)\n        elif query[0] == 2:\n            process_query(query)\n    \n    return results", "def alternatingGroups(colors, queries):\n    n = len(colors)\n    color_count = [0] * n\n    \n    def count_alternating_groups():\n        count = {}\n        for size in range(3, n + 1):\n            for i in range(n):\n                if colors[i] != colors[(i + size) % n]:\n                    count[size] = count.get(size, 0) + 1\n        return count\n    \n    def update_color(index, new_color):\n        nonlocal color_count\n        old_color = colors[index]\n        colors[index] = new_color\n        \n        # Remove old alternating groups\n        for size in range(3, n + 1):\n            if (index - size + 1) % n >= 0 and colors[(index - size + 1) % n] != colors[index]:\n                count_alternating_groups()[size] -= 1\n            if (index + size) % n < n and colors[(index + size) % n] != colors[(index + size - 1) % n]:\n                count_alternating_groups()[size] -= 1\n        \n        # Add new alternating groups\n        for size in range(3, n + 1):\n            if (index - size + 1) % n >= 0 and colors[(index - size + 1) % n] != colors[index]:\n                count_alternating_groups()[size] += 1\n            if (index + size) % n < n and colors[(index + size) % n] != colors[(index + size - 1) % n]:\n                count_alternating_groups()[size] += 1\n    \n    result = []\n    current_counts = count_alternating_groups()\n    \n    for query in queries:\n        if query[0] == 1:\n            result.append(current_counts.get(query[1], 0))\n        elif query[0] == 2:\n            update_color(query[1], query[2])\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Extend the list to simulate the circular nature\n    counts = {i: 0 for i in range(3, n + 1)}\n    \n    def is_alternating(start, end):\n        for i in range(start, end):\n            if colors[i] == colors[i + 1]:\n                return False\n        return True\n    \n    def update_counts(size, diff):\n        nonlocal counts\n        counts[size] += diff\n    \n    def process_query(query):\n        nonlocal colors\n        if query[0] == 1:\n            size = query[1]\n            result = counts[size]\n            return result\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            old_color = colors[index]\n            colors[index] = color\n            \n            start = max(index - size, 0)\n            end = min(index + size, 2 * n)\n            \n            if is_alternating(start, end):\n                if old_color != colors[start]:\n                    update_counts(size, -1)\n                if colors[end - 1] != colors[end % n]:\n                    update_counts(size, 1)\n            else:\n                update_counts(size, -1)\n                update_counts(size, -1)\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            result = process_query(query)\n            results.append(result)\n        elif query[0] == 2:\n            process_query(query)\n    \n    return results\n```", "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    color_count = [0] * n\n    \n    def count_alternating_groups():\n        count = {}\n        for size in range(3, n + 1):\n            for i in range(n):\n                if colors[i] != colors[(i + size) % n]:\n                    count[size] = count.get(size, 0) + 1\n        return count\n    \n    def update_color(index, new_color):\n        nonlocal color_count\n        old_color = colors[index]\n        colors[index] = new_color\n        \n        # Remove old alternating groups\n        for size in range(3, n + 1):\n            if (index - size + 1) % n >= 0 and colors[(index - size + 1) % n] != colors[index]:\n                count_alternating_groups()[size] -= 1\n            if (index + size) % n < n and colors[(index + size) % n] != colors[(index + size - 1) % n]:\n                count_alternating_groups()[size] -= 1\n        \n        # Add new alternating groups\n        for size in range(3, n + 1):\n            if (index - size + 1) % n >= 0 and colors[(index - size + 1) % n] != colors[index]:\n                count_alternating_groups()[size] += 1\n            if (index + size) % n < n and colors[(index + size) % n] != colors[(index + size - 1) % n]:\n                count_alternating_groups()[size] += 1\n    \n    result = []\n    current_counts = count_alternating_groups()\n    \n    for query in queries:\n        if query[0] == 1:\n            result.append(current_counts.get(query[1], 0))\n        elif query[0] == 2:\n            update_color(query[1], query[2])\n    \n    return result\n```"]}
{"task_id": "abc367_f", "codes": ["f", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n\n    results = []\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n\n        subseq_A = sorted(A[l_i:r_i + 1])\n        subseq_B = sorted(B[L_i:R_i + 1])\n\n        if subseq_A == subseq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nfrom collections import Counter\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nN = int(data[index])\nQ = int(data[index + 1])\nindex += 2\n\nA = list(map(int, data[index:index + N]))\nindex += N\n\nB = list(map(int, data[index:index + N]))\nindex += N\n\nqueries = []\nfor _ in range(Q):\n    li = int(data[index]) - 1\n    ri = int(data[index + 1]) - 1\n    Li = int(data[index + 2]) - 1\n    Ri = int(data[index + 3]) - 1\n    index += 4\n    queries.append((li, ri, Li, Ri))\n\n# Process queries\nresults = []\nfor li, ri, Li, Ri in queries:\n    subseq_A = A[li:ri + 1]\n    subseq_B = B[Li:Ri + 1]\n    \n    if Counter(subseq_A) == Counter(subseq_B):\n        results.append(\"Yes\")\n    else:\n        results.append(\"No\")\n\n# Output results\nfor result in results:\n    print(result)", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n\n    results = []\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n\n        subseq_A = sorted(A[l_i:r_i + 1])\n        subseq_B = sorted(B[L_i:R_i + 1])\n\n        if subseq_A == subseq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc368_g", "codes": ["def update_array(arr, i, x):\n    arr[i - 1] = x\n\ndef max_value(A, B, l, r):\n    v = 0\n    for i in range(l - 1, r):\n        if v + A[i] > v * B[i]:\n            v += A[i]\n        else:\n            v *= B[i]\n    return v\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    \n    queries = []\n    for i in range(Q):\n        queries.append(list(map(int, data[2*N+2+i*3:2*N+5+(i*3)])))\n    \n    results = []\n    idx = 0\n    \n    while idx < len(queries):\n        query_type = queries[idx][0]\n        if query_type == 1:\n            update_array(A, queries[idx][1], queries[idx][2])\n        elif query_type == 2:\n            update_array(B, queries[idx][1], queries[idx][2])\n        elif query_type == 3:\n            result = max_value(A, B, queries[idx][1], queries[idx][2])\n            results.append(result)\n        idx += 1\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "i"], "passed": [false, false], "raw_code": ["```python\ndef update_array(arr, i, x):\n    arr[i - 1] = x\n\ndef max_value(A, B, l, r):\n    v = 0\n    for i in range(l - 1, r):\n        if v + A[i] > v * B[i]:\n            v += A[i]\n        else:\n            v *= B[i]\n    return v\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    \n    queries = []\n    for i in range(Q):\n        queries.append(list(map(int, data[2*N+2+i*3:2*N+5+(i*3)])))\n    \n    results = []\n    idx = 0\n    \n    while idx < len(queries):\n        query_type = queries[idx][0]\n        if query_type == 1:\n            update_array(A, queries[idx][1], queries[idx][2])\n        elif query_type == 2:\n            update_array(B, queries[idx][1], queries[idx][2])\n        elif query_type == 3:\n            result = max_value(A, B, queries[idx][1], queries[idx][2])\n            results.append(result)\n        idx += 1\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport sys\n\ndef process_queries(N, A, B, Q, queries):\n    def preprocess(A, B):\n        n = len(A)\n        prefix_sum_A = [0] * (n + 1)\n        prefix_product_A = [1] * (n + 1)\n        prefix_sum_B = [0] * (n + 1)\n        prefix_product_B = [1] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix_sum_A[i] = prefix_sum_A[i - 1] + A[i - 1]\n            prefix_product_A[i] = prefix_product_A[i - 1] * A[i - 1]\n            prefix_sum_B[i] = prefix_sum_B[i - 1] + B[i - 1]\n            prefix_product_B[i] = prefix_product_B[i - 1] * B[i - 1]\n        \n        return prefix_sum_A, prefix_product_A, prefix_sum_B, prefix_product_B\n    \n    prefix_sum_A, prefix_product_A, prefix_sum_B, prefix_product_B = preprocess(A, B)\n    \n    results = []\n    \n    for query in queries:\n        if query[0] == 1:\n            _, i, x = query\n            A[i - 1] = x\n            prefix_sum_A[i] = prefix_sum_A[i - 1] + x\n            prefix_product_A[i] = prefix_product_A[i - 1] * x\n        elif query[0] == 2:\n            _, i, x = query\n            B[i - 1] = x\n            prefix_sum_B[i] = prefix_sum_B[i - 1] + x\n            prefix_product_B[i] = prefix_product_B[i - 1] * x\n        elif query[0] == 3:\n            l, r = query[1], query[2]\n            v = 0\n            max_v = 0\n            \n            for i in range(l, r + 1):\n                v += A[i - 1]\n                max_v = max(max_v, v)\n            \n            for i in range(l, r + 1):\n                v *= B[i - 1]\n                max_v = max(max_v, v)\n            \n            results.append(max_v)\n    \n    for result in results:\n        print(result)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:N + 1]))\nB = list(map(int, data[N + 1:2 * N + 1]))\nQ = int(data[2 * N + 1])\n\nqueries = []\nfor i in range(Q):\n    query_type = int(data[2 * N + 2 + i * 2])\n    if query_type == 1 or query_type == 2:\n        i_val = int(data[2 * N + 3 + i * 2])\n        x_val = int(data[2 * N + 4 + i * 2])\n        queries.append((query_type, i_val, x_val))\n    elif query_type == 3:\n        l_val = int(data[2 * N + 3 + i * 2])\n        r_val = int(data[2 * N + 4 + i * 2])\n        queries.append((query_type, l_val, r"]}
{"task_id": "arc183_b", "codes": ["def can_transform(A, B, K):\n    if len(set(A)) != len(set(B)):\n        return \"No\"\n    \n    count_A = [A.count(x) for x in set(A)]\n    count_B = [B.count(x) for x in set(B)]\n    \n    if sorted(count_A) != sorted(count_B):\n        return \"No\"\n    \n    n = len(A)\n    visited = [False] * n\n    \n    def dfs(i):\n        stack = [i]\n        while stack:\n            current = stack.pop()\n            if not visited[current]:\n                visited[current] = True\n                for j in range(max(0, current - K), min(n, current + K + 1)):\n                    if not visited[j] and A[current] == A[j]:\n                        stack.append(j)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n    \n    for i in range(n):\n        if not visited[i]:\n            return \"No\"\n    \n    return \"Yes\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nresults = []\n\nT = int(data[index])\nindex += 1\n\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    result = can_transform(A, B, K)\n    results.append(result)\n\nfor result in results:\n    print(result)", "def can_make_equal(A, B, K):\n    for i in range(len(A)):\n        if A[i] != B[i]:\n            found = False\n            for j in range(max(0, i-K), min(len(A), i+K+1)):\n                if A[j] == B[i]:\n                    found = True\n                    break\n            if not found:\n                return 'No'\n    return 'Yes'\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index+N]))\n        index += N\n        B = list(map(int, data[index:index+N]))\n        index += N\n        result = can_make_equal(A, B, K)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef can_transform(A, B, K):\n    if len(set(A)) != len(set(B)):\n        return \"No\"\n    \n    count_A = [A.count(x) for x in set(A)]\n    count_B = [B.count(x) for x in set(B)]\n    \n    if sorted(count_A) != sorted(count_B):\n        return \"No\"\n    \n    n = len(A)\n    visited = [False] * n\n    \n    def dfs(i):\n        stack = [i]\n        while stack:\n            current = stack.pop()\n            if not visited[current]:\n                visited[current] = True\n                for j in range(max(0, current - K), min(n, current + K + 1)):\n                    if not visited[j] and A[current] == A[j]:\n                        stack.append(j)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n    \n    for i in range(n):\n        if not visited[i]:\n            return \"No\"\n    \n    return \"Yes\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\nresults = []\n\nT = int(data[index])\nindex += 1\n\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    result = can_transform(A, B, K)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```", "def can_make_equal(A, B, K):\n    for i in range(len(A)):\n        if A[i] != B[i]:\n            found = False\n            for j in range(max(0, i-K), min(len(A), i+K+1)):\n                if A[j] == B[i]:\n                    found = True\n                    break\n            if not found:\n                return 'No'\n    return 'Yes'\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index+N]))\n        index += N\n        B = list(map(int, data[index:index+N]))\n        index += N\n        result = can_make_equal(A, B, K)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3571", "codes": ["def max_increasing_path(coordinates, k):\n    # Sort coordinates based on x and then y\n    coordinates.sort()\n    \n    n = len(coordinates)\n    dp = [1] * n\n    \n    def dfs(i):\n        if dp[i] != 1:\n            return dp[i]\n        \n        x, y = coordinates[i]\n        for j in range(i):\n            x_prev, y_prev = coordinates[j]\n            if x > x_prev and y > y_prev:\n                dp[i] = max(dp[i], dfs(j) + 1)\n        \n        return dp[i]\n    \n    max_length = 0\n    for i in range(n):\n        if i == k:\n            max_length = max(max_length, dfs(i))\n    \n    return max_length", "def maxIncreasingPath(coordinates, k):\n    from functools import lru_cache\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Create a dictionary to map coordinates to indices\n    index_map = {coord: i for i, coord in enumerate(coordinates)}\n    \n    # Step 3: Define the recursive function with memoization\n    @lru_cache(None)\n    def dfs(i):\n        x, y = coordinates[i]\n        max_path = 1\n        # Check right neighbor\n        if i + 1 < len(coordinates) and coordinates[i + 1][0] > x and coordinates[i + 1][1] > y:\n            max_path = max(max_path, 1 + dfs(i + 1))\n        # Check down neighbor\n        if i + len(coordinates) // len(coordinates[0]) < len(coordinates) and coordinates[i + len(coordinates) // len(coordinates[0])][0] > x and coordinates[i + len(coordinates) // len(coordinates[0])][1] > y:\n            max_path = max(max_path, 1 + dfs(i + len(coordinates) // len(coordinates[0])))\n        return max_path\n    \n    # Step 4: Compute the maximum increasing path for each point and get the result for the k-th point\n    result = dfs(index_map[coordinates[k]])\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\ndef max_increasing_path(coordinates, k):\n    # Sort coordinates based on x and then y\n    coordinates.sort()\n    \n    n = len(coordinates)\n    dp = [1] * n\n    \n    def dfs(i):\n        if dp[i] != 1:\n            return dp[i]\n        \n        x, y = coordinates[i]\n        for j in range(i):\n            x_prev, y_prev = coordinates[j]\n            if x > x_prev and y > y_prev:\n                dp[i] = max(dp[i], dfs(j) + 1)\n        \n        return dp[i]\n    \n    max_length = 0\n    for i in range(n):\n        if i == k:\n            max_length = max(max_length, dfs(i))\n    \n    return max_length\n```", "```python\ndef maxIncreasingPath(coordinates, k):\n    from functools import lru_cache\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Create a dictionary to map coordinates to indices\n    index_map = {coord: i for i, coord in enumerate(coordinates)}\n    \n    # Step 3: Define the recursive function with memoization\n    @lru_cache(None)\n    def dfs(i):\n        x, y = coordinates[i]\n        max_path = 1\n        # Check right neighbor\n        if i + 1 < len(coordinates) and coordinates[i + 1][0] > x and coordinates[i + 1][1] > y:\n            max_path = max(max_path, 1 + dfs(i + 1))\n        # Check down neighbor\n        if i + len(coordinates) // len(coordinates[0]) < len(coordinates) and coordinates[i + len(coordinates) // len(coordinates[0])][0] > x and coordinates[i + len(coordinates) // len(coordinates[0])][1] > y:\n            max_path = max(max_path, 1 + dfs(i + len(coordinates) // len(coordinates[0])))\n        return max_path\n    \n    # Step 4: Compute the maximum increasing path for each point and get the result for the k-th point\n    result = dfs(index_map[coordinates[k]])\n    \n    return result\n```"]}
{"task_id": "abc370_e", "codes": ["def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    \n    # Base case: one way to partition an empty array\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            if prefix_sum == K:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][prefix_sum]) % MOD\n            prefix_sum += A[i - 1]\n    \n    # Sum up all valid partitions\n    result = 0\n    for j in range(K + 1):\n        result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))", "def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * N for _ in range(N)]\n    dp[0][0] = 1\n    \n    for i in range(1, N):\n        prefix_sum = [0] * (i + 1)\n        prefix_sum[1] = A[0]\n        for j in range(2, i + 1):\n            prefix_sum[j] = prefix_sum[j - 1] + A[j - 1]\n        \n        dp[i][i] = 1\n        total_sum = prefix_sum[i]\n        \n        for j in range(i):\n            if prefix_sum[j + 1] == K:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n            if total_sum - prefix_sum[j] != K:\n                dp[i][i] = (dp[i][i] + dp[i - 1][j]) % MOD\n    \n    result = 0\n    for j in range(N):\n        if prefix_sum[j + 1] != K:\n            result = (result + dp[N - 1][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))"], "passed": [false, false], "raw_code": ["```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    \n    # Base case: one way to partition an empty array\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            if prefix_sum == K:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][prefix_sum]) % MOD\n            prefix_sum += A[i - 1]\n    \n    # Sum up all valid partitions\n    result = 0\n    for j in range(K + 1):\n        result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))\n```", "```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * N for _ in range(N)]\n    dp[0][0] = 1\n    \n    for i in range(1, N):\n        prefix_sum = [0] * (i + 1)\n        prefix_sum[1] = A[0]\n        for j in range(2, i + 1):\n            prefix_sum[j] = prefix_sum[j - 1] + A[j - 1]\n        \n        dp[i][i] = 1\n        total_sum = prefix_sum[i]\n        \n        for j in range(i):\n            if prefix_sum[j + 1] == K:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n            if total_sum - prefix_sum[j] != K:\n                dp[i][i] = (dp[i][i] + dp[i - 1][j]) % MOD\n    \n    result = 0\n    for j in range(N):\n        if prefix_sum[j + 1] != K:\n            result = (result + dp[N - 1][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))\n```"]}
{"task_id": "abc367_g", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n\n    MOD = 998244353\n    \n    # DP table to store the sum of scores for subsequences of length i ending with element j\n    dp = [[0] * (1 << 20) for _ in range(N + 1)]\n    \n    total_score = 0\n    \n    for i in range(1, N + 1):\n        x = A[i - 1]\n        for j in range(1 << 20):\n            new_xor = j ^ x\n            dp[i][new_xor] += dp[i - 1][j]\n            dp[i][new_xor] %= MOD\n        \n        # Calculate the score for subsequences of length i\n        if i % M == 0:\n            xor_sum = sum(dp[i][:])\n            total_score += pow(xor_sum, K, MOD)\n            total_score %= MOD\n    \n    print(total_score)\n\nmain()", "d"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n\n    MOD = 998244353\n    \n    # DP table to store the sum of scores for subsequences of length i ending with element j\n    dp = [[0] * (1 << 20) for _ in range(N + 1)]\n    \n    total_score = 0\n    \n    for i in range(1, N + 1):\n        x = A[i - 1]\n        for j in range(1 << 20):\n            new_xor = j ^ x\n            dp[i][new_xor] += dp[i - 1][j]\n            dp[i][new_xor] %= MOD\n        \n        # Calculate the score for subsequences of length i\n        if i % M == 0:\n            xor_sum = sum(dp[i][:])\n            total_score += pow(xor_sum, K, MOD)\n            total_score %= MOD\n    \n    print(total_score)\n\nmain()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Precompute powers of 2 modulo MOD\n    pow2 = [1] * (N + 1)\n    for i in range(1, N + 1):\n        pow2[i] = (pow2[i - 1] * 2) % MOD\n    \n    # Precompute powers of K modulo MOD\n    powK = [1] * (N + 1)\n    for i in range(1, N + 1):\n        powK[i] = pow(powK[i - 1], K, MOD)\n    \n    # Initialize DP array\n    dp = [0] * (1 << N)\n    dp[0] = 1\n    \n    # Process each bit position\n    for bit in range(N):\n        new_dp = [0] * (1 << N)\n        for mask in range(1 << N):\n            if dp[mask] == 0:\n                continue\n            \n            new_mask = mask | (1 << bit)\n            if bin(new_mask).count('1') % M == 0:\n                new_dp[new_mask] = (new_dp[new_mask] + dp[mask]) % MOD\n            else:\n                new_dp[new_mask] = (new_dp[new_mask] + pow2[len(bin(mask)) - 2] * dp[mask]) % MOD\n        \n        dp = new_dp\n    \n    # Calculate the final sum\n    total_sum = 0\n    for mask in range(1, 1 << N):\n        total_sum = (total_sum + dp[mask]) % MOD\n    \n    print(total_sum)\n\nmain()"]}
{"task_id": "abc370_g", "codes": ["def sum_of_divisors(n):\n    div_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            div_sum[j] += i\n    return div_sum\n\ndef is_good_integer(n, div_sum):\n    return div_sum[n] % 3 == 0\n\ndef count_sequences(N, M):\n    MOD = 998244353\n    div_sum = sum_of_divisors(N)\n    \n    dp = [[0] * 3 for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for num in range(1, N + 1):\n        if is_good_integer(num, div_sum):\n            for i in range(M, 0, -1):\n                for j in range(3):\n                    dp[i][(j * num) % 3] += dp[i - 1][j]\n                    dp[i][(j * num) % 3] %= MOD\n    \n    return dp[M][0]\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Calculate and print the result\nresult = count_sequences(N, M)\nprint(result)", "d"], "passed": [false, false], "raw_code": ["```python\ndef sum_of_divisors(n):\n    div_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            div_sum[j] += i\n    return div_sum\n\ndef is_good_integer(n, div_sum):\n    return div_sum[n] % 3 == 0\n\ndef count_sequences(N, M):\n    MOD = 998244353\n    div_sum = sum_of_divisors(N)\n    \n    dp = [[0] * 3 for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for num in range(1, N + 1):\n        if is_good_integer(num, div_sum):\n            for i in range(M, 0, -1):\n                for j in range(3):\n                    dp[i][(j * num) % 3] += dp[i - 1][j]\n                    dp[i][(j * num) % 3] %= MOD\n    \n    return dp[M][0]\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Calculate and print the result\nresult = count_sequences(N, M)\nprint(result)\n```", "```python\ndef count_good_sequences(N, M):\n    MOD = 998244353\n    \n    # Function to calculate sum of divisors modulo 3 for a number\n    def sum_of_divisors_mod_3(n):\n        total = 0\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                total += (i % 3) * ((n // i) % 3)\n                if i != n // i:\n                    total += ((n // i) % 3) * (i % 3)\n        return total % 3\n    \n    # Precompute sum of divisors modulo 3 for all numbers up to N\n    sum_div_mod_3 = [sum_of_divisors_mod_3"]}
{"task_id": "arc183_d", "codes": ["import sys\nfrom collections import deque\n\ndef bfs(n, edges):\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    distances = [-1] * (n + 1)\n    def find_farthest(start):\n        queue = deque([start])\n        distances[start] = 0\n        farthest_node = start\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj_list[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n                    farthest_node = neighbor\n        return farthest_node\n    \n    first_farthest = find_farthest(1)\n    second_farthest = find_farthest(first_farthest)\n    return second_farthest\n\ndef solve():\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    results = []\n    for _ in range(n // 2):\n        farthest_leaf = bfs(n, edges)\n        # Find the other leaf connected to the same node\n        for u, v in edges:\n            if u == farthest_leaf or v == farthest_leaf:\n                other_leaf = v if u == farthest_leaf else u\n                results.append((farthest_leaf, other_leaf))\n                edges.remove((u, v))\n                break\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    solve()", "import heapq\nfrom collections import defaultdict, deque\n\ndef read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        A = int(data[index]) - 1\n        B = int(data[index + 1]) - 1\n        edges.append((A, B))\n        index += 2\n    \n    return N, edges\n\ndef build_tree(edges, N):\n    tree = defaultdict(list)\n    for A, B in edges:\n        tree[A].append(B)\n        tree[B].append(A)\n    \n    return tree\n\ndef get_leaves(tree, N):\n    leaves = [i for i in range(N) if len(tree[i]) == 1]\n    return leaves\n\ndef find_farthest_pair(leaves, tree):\n    n = len(leaves)\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        q = deque([leaves[i]])\n        visited = {leaves[i]}\n        while q:\n            node = q.popleft()\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    dist[i][get_leaves(tree, N).index(neighbor)] = dist[i][get_leaves(tree, N).index(node)] + 1\n                    q.append(neighbor)\n    \n    max_dist = float('-inf')\n    max_pair = (-1, -1)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i][j] > max_dist:\n                max_dist = dist[i][j]\n                max_pair = (leaves[i], leaves[j])\n    \n    return max_pair\n\ndef main():\n    N, edges = read_input()\n    tree = build_tree(edges, N)\n    leaves = get_leaves(tree, N)\n    \n    result = []\n    while leaves:\n        A, B = find_farthest_pair(leaves, tree)\n        result.append((A + 1, B + 1))\n        leaves.remove(A)\n        leaves.remove(B)\n    \n    for x, y in result:\n        print(x, y)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nimport sys\nfrom collections import deque\n\ndef bfs(n, edges):\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    distances = [-1] * (n + 1)\n    def find_farthest(start):\n        queue = deque([start])\n        distances[start] = 0\n        farthest_node = start\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj_list[node]:\n                if distances[neighbor] == -1:\n                    distances[neighbor] = distances[node] + 1\n                    queue.append(neighbor)\n                    farthest_node = neighbor\n        return farthest_node\n    \n    first_farthest = find_farthest(1)\n    second_farthest = find_farthest(first_farthest)\n    return second_farthest\n\ndef solve():\n    n = int(input())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    results = []\n    for _ in range(n // 2):\n        farthest_leaf = bfs(n, edges)\n        # Find the other leaf connected to the same node\n        for u, v in edges:\n            if u == farthest_leaf or v == farthest_leaf:\n                other_leaf = v if u == farthest_leaf else u\n                results.append((farthest_leaf, other_leaf))\n                edges.remove((u, v))\n                break\n    \n    for result in results:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    solve()\n```", "```python\nimport heapq\nfrom collections import defaultdict, deque\n\ndef read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        A = int(data[index]) - 1\n        B = int(data[index + 1]) - 1\n        edges.append((A, B))\n        index += 2\n    \n    return N, edges\n\ndef build_tree(edges, N):\n    tree = defaultdict(list)\n    for A, B in edges:\n        tree[A].append(B)\n        tree[B].append(A)\n    \n    return tree\n\ndef get_leaves(tree, N):\n    leaves = [i for i in range(N) if len(tree[i]) == 1]\n    return leaves\n\ndef find_farthest_pair(leaves, tree):\n    n = len(leaves)\n    dist = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        q = deque([leaves[i]])\n        visited = {leaves[i]}\n        while q:\n            node = q.popleft()\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    dist[i][get_leaves(tree, N).index(neighbor)] = dist[i][get_leaves(tree, N).index(node)] + 1\n                    q.append(neighbor)\n    \n    max_dist = float('-inf')\n    max_pair = (-1, -1)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dist[i][j] > max_dist:\n                max_dist = dist[i][j]\n                max_pair = (leaves[i], leaves[j])\n    \n    return max_pair\n\ndef main():\n    N, edges = read_input()\n    tree = build_tree(edges, N)\n    leaves = get_leaves(tree, N)\n    \n    result = []\n    while leaves:\n        A, B = find_farthest_pair(leaves, tree)\n        result.append((A + 1, B + 1))\n        leaves.remove(A)\n        leaves.remove(B)\n    \n    for x, y in result:\n        print(x, y)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3580", "codes": ["def find_almost_equal_substring(s: str, pattern: str) -> int:\n    n = len(s)\n    m = len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1", "def findAlmostEqualSubstring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1"], "passed": [true, false], "raw_code": ["```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    n = len(s)\n    m = len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```", "```python\ndef findAlmostEqualSubstring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"]}
{"task_id": "abc371_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    total_sum = 0\n    \n    for i in range(N):\n        distinct_elements = set()\n        for j in range(i, N):\n            distinct_elements.add(A[j])\n            total_sum += len(distinct_elements)\n    \n    print(total_sum)\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize prefix sum array with empty sets\n    prefix_sum = [set()]\n    \n    # Fill the prefix sum array with unique elements up to each index\n    for num in A:\n        new_set = prefix_sum[-1].copy()\n        new_set.add(num)\n        prefix_sum.append(new_set)\n    \n    total_count = 0\n    \n    # Iterate over all pairs (i, j)\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            # Number of unique elements in the subarray A[i-1:j]\n            unique_count = len(prefix_sum[j]) - len(prefix_sum[i-1])\n            total_count += unique_count\n    \n    print(total_count)\n\nmain()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    total_sum = 0\n    \n    for i in range(N):\n        distinct_elements = set()\n        for j in range(i, N):\n            distinct_elements.add(A[j])\n            total_sum += len(distinct_elements)\n    \n    print(total_sum)\n\nmain()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize prefix sum array with empty sets\n    prefix_sum = [set()]\n    \n    # Fill the prefix sum array with unique elements up to each index\n    for num in A:\n        new_set = prefix_sum[-1].copy()\n        new_set.add(num)\n        prefix_sum.append(new_set)\n    \n    total_count = 0\n    \n    # Iterate over all pairs (i, j)\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            # Number of unique elements in the subarray A[i-1:j]\n            unique_count = len(prefix_sum[j]) - len(prefix_sum[i-1])\n            total_count += unique_count\n    \n    print(total_count)\n\nmain()\n```"]}
{"task_id": "abc368_d", "codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef dfs(node, parent, graph, depth, subtree_size, ancestors):\n    depth[node] = depth[parent] + 1\n    ancestors[node][0] = parent\n    subtree_size[node] = 1\n    \n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, graph, depth, subtree_size, ancestors)\n            subtree_size[node] += subtree_size[neighbor]\n    \n    return depth, subtree_size, ancestors\n\ndef get_lca(u, v, depth, ancestors):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    \n    # Make u and v at the same depth\n    for i in range(17):\n        if (depth[u] - (1 << i)) >= depth[v]:\n            u = ancestors[u][i]\n    \n    if u == v:\n        return u\n    \n    # Move both u and v up until they meet\n    for i in range(16, -1, -1):\n        if ancestors[u][i] != ancestors[v][i]:\n            u = ancestors[u][i]\n            v = ancestors[v][i]\n    \n    return ancestors[u][0]\n\ndef minimum_vertex_set(n, edges, vertices):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    depth = [0] * (n + 1)\n    subtree_size = [0] * (n + 1)\n    ancestors = [[0] * 20 for _ in range(n + 1)]\n    \n    dfs(1, 0, graph, depth, subtree_size, ancestors)\n    \n    count = 0\n    covered = set()\n    \n    for v in vertices:\n        if v not in covered:\n            count += 1\n            lca = get_lca(1, v, depth, ancestors)\n            covered |= set(range(lca, v + 1))\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(N - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    \n    vertices = list(map(int, data[index:index + K]))\n    \n    result = minimum_vertex_set(N, edges, vertices)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        edges.append((u, v))\n        index += 2\n    \n    vertices = [int(data[index]) - 1 for _ in range(k)]\n    \n    return n, k, edges, vertices\n\ndef build_tree(edges, n):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    return tree\n\ndef dfs(tree, root, parent, depth, depths, ancestors):\n    depths[root] = depth\n    ancestors[root][0] = parent\n    for i in range(1, 18):  # Assuming log(N) <= 17\n        if ancestors[root][i - 1] != -1:\n            ancestors[root][i] = ancestors[ancestors[root][i - 1]][i - 1]\n    \n    for neighbor in tree[root]:\n        if neighbor != parent:\n            dfs(tree, neighbor, root, depth + 1, depths, ancestors)\n\ndef lca(depths, ancestors, u, v):\n    if depths[u] > depths[v]:\n        u, v = v, u\n    \n    diff = depths[v] - depths[u]\n    for i in range(17, -1, -1):\n        if (diff >> i) & 1:\n            v = ancestors[v][i]\n    \n    if u == v:\n        return u\n    \n    for i in range(17, -1, -1):\n        if ancestors[u][i] != ancestors[v][i]:\n            u = ancestors[u][i]\n            v = ancestors[v][i]\n    \n    return ancestors[u][0]\n\ndef min_vertices_in_subtree(n, edges, vertices):\n    tree = build_tree(edges, n)\n    depths = [-1] * n\n    ancestors = [[-1] * 18 for _ in range(n)]  # Log(N) <= 17\n    \n    dfs(tree, 0, -1, 0, depths, ancestors)\n    \n    max_path_length = 0\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            lca_node = lca(depths, ancestors, vertices[i], vertices[j])\n            path_length = depths[vertices[i]] + depths[vertices[j]] - 2 * depths[lca_node]\n            max_path_length = max(max_path_length, path_length)\n    \n    return max_path_length // 2 + 1\n\ndef main():\n    n, k, edges, vertices = read_input()\n    result = min_vertices_in_subtree(n, edges, vertices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef dfs(node, parent, graph, depth, subtree_size, ancestors):\n    depth[node] = depth[parent] + 1\n    ancestors[node][0] = parent\n    subtree_size[node] = 1\n    \n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, graph, depth, subtree_size, ancestors)\n            subtree_size[node] += subtree_size[neighbor]\n    \n    return depth, subtree_size, ancestors\n\ndef get_lca(u, v, depth, ancestors):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    \n    # Make u and v at the same depth\n    for i in range(17):\n        if (depth[u] - (1 << i)) >= depth[v]:\n            u = ancestors[u][i]\n    \n    if u == v:\n        return u\n    \n    # Move both u and v up until they meet\n    for i in range(16, -1, -1):\n        if ancestors[u][i] != ancestors[v][i]:\n            u = ancestors[u][i]\n            v = ancestors[v][i]\n    \n    return ancestors[u][0]\n\ndef minimum_vertex_set(n, edges, vertices):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    depth = [0] * (n + 1)\n    subtree_size = [0] * (n + 1)\n    ancestors = [[0] * 20 for _ in range(n + 1)]\n    \n    dfs(1, 0, graph, depth, subtree_size, ancestors)\n    \n    count = 0\n    covered = set()\n    \n    for v in vertices:\n        if v not in covered:\n            count += 1\n            lca = get_lca(1, v, depth, ancestors)\n            covered |= set(range(lca, v + 1))\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(N - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    \n    vertices = list(map(int, data[index:index + K]))\n    \n    result = minimum_vertex_set(N, edges, vertices)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    \n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        edges.append((u, v))\n        index += 2\n    \n    vertices = [int(data[index]) - 1 for _ in range(k)]\n    \n    return n, k, edges, vertices\n\ndef build_tree(edges, n):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    return tree\n\ndef dfs(tree, root, parent, depth, depths, ancestors):\n    depths[root] = depth\n    ancestors[root][0] = parent\n    for i in range(1, 18):  # Assuming log(N) <= 17\n        if ancestors[root][i - 1] != -1:\n            ancestors[root][i] = ancestors[ancestors[root][i - 1]][i - 1]\n    \n    for neighbor in tree[root]:\n        if neighbor != parent:\n            dfs(tree, neighbor, root, depth + 1, depths, ancestors)\n\ndef lca(depths, ancestors, u, v):\n    if depths[u] > depths[v]:\n        u, v = v, u\n    \n    diff = depths[v] - depths[u]\n    for i in range(17, -1, -1):\n        if (diff >> i) & 1:\n            v = ancestors[v][i]\n    \n    if u == v:\n        return u\n    \n    for i in range(17, -1, -1):\n        if ancestors[u][i] != ancestors[v][i]:\n            u = ancestors[u][i]\n            v = ancestors[v][i]\n    \n    return ancestors[u][0]\n\ndef min_vertices_in_subtree(n, edges, vertices):\n    tree = build_tree(edges, n)\n    depths = [-1] * n\n    ancestors = [[-1] * 18 for _ in range(n)]  # Log(N) <= 17\n    \n    dfs(tree, 0, -1, 0, depths, ancestors)\n    \n    max_path_length = 0\n    for i in range(len(vertices)):\n        for j in range(i + 1, len(vertices)):\n            lca_node = lca(depths, ancestors, vertices[i], vertices[j])\n            path_length = depths[vertices[i]] + depths[vertices[j]] - 2 * depths[lca_node]\n            max_path_length = max(max_path_length, path_length)\n    \n    return max_path_length // 2 + 1\n\ndef main():\n    n, k, edges, vertices = read_input()\n    result = min_vertices_in_subtree(n, edges, vertices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc373_e", "codes": ["def min_additional_votes(N, M, K, A):\n    # Calculate the total number of votes counted so far\n    current_total_votes = sum(A)\n    \n    # Calculate the number of remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Sort candidates based on their current votes\n    sorted_candidates = sorted(range(N), key=lambda x: A[x], reverse=True)\n    \n    # Initialize an array to store the result\n    C = [-1] * N\n    \n    # Iterate over each candidate\n    for i in range(N):\n        # Check if the candidate already has enough votes to win\n        if A[sorted_candidates[i]] > remaining_votes + A[sorted_candidates[i]]:\n            C[sorted_candidates[i]] = 0\n            continue\n        \n        # Determine the minimum additional votes needed\n        max_possible_votes = remaining_votes + A[sorted_candidates[i]]\n        min_additional = float('inf')\n        \n        for j in range(M - 1):\n            if j < N:\n                if sorted_candidates[j] != sorted_candidates[i]:\n                    max_possible_votes -= A[sorted_candidates[j]]\n            \n            min_additional = min(min_additional, max_possible_votes - A[sorted_candidates[i]])\n        \n        if min_additional == float('inf'):\n            min_additional = -1\n        \n        C[sorted_candidates[i]] = min_additional\n    \n    return ' '.join(map(str, C))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Call the function and print the result\nprint(min_additional_votes(N, M, K, A))", "def min_additional_votes(N, M, K, A):\n    def can_win(i, additional_votes):\n        # Calculate the maximum votes another candidate can get\n        max_other_votes = sum(A[j] + additional_votes for j in range(N) if j != i)\n        return (max_other_votes <= A[i])\n\n    C = []\n    for i in range(N):\n        if A[i] >= K:\n            C.append(0)\n            continue\n        \n        left, right = 0, K - sum(A)\n        while left < right:\n            mid = (left + right) // 2\n            if can_win(i, mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        if can_win(i, left):\n            C.append(left)\n        else:\n            C.append(-1)\n    \n    print(' '.join(map(str, C)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\nmin_additional_votes(N, M, K, A)"], "passed": [false, false], "raw_code": ["```python\ndef min_additional_votes(N, M, K, A):\n    # Calculate the total number of votes counted so far\n    current_total_votes = sum(A)\n    \n    # Calculate the number of remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Sort candidates based on their current votes\n    sorted_candidates = sorted(range(N), key=lambda x: A[x], reverse=True)\n    \n    # Initialize an array to store the result\n    C = [-1] * N\n    \n    # Iterate over each candidate\n    for i in range(N):\n        # Check if the candidate already has enough votes to win\n        if A[sorted_candidates[i]] > remaining_votes + A[sorted_candidates[i]]:\n            C[sorted_candidates[i]] = 0\n            continue\n        \n        # Determine the minimum additional votes needed\n        max_possible_votes = remaining_votes + A[sorted_candidates[i]]\n        min_additional = float('inf')\n        \n        for j in range(M - 1):\n            if j < N:\n                if sorted_candidates[j] != sorted_candidates[i]:\n                    max_possible_votes -= A[sorted_candidates[j]]\n            \n            min_additional = min(min_additional, max_possible_votes - A[sorted_candidates[i]])\n        \n        if min_additional == float('inf'):\n            min_additional = -1\n        \n        C[sorted_candidates[i]] = min_additional\n    \n    return ' '.join(map(str, C))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Call the function and print the result\nprint(min_additional_votes(N, M, K, A))\n```", "```python\ndef min_additional_votes(N, M, K, A):\n    def can_win(i, additional_votes):\n        # Calculate the maximum votes another candidate can get\n        max_other_votes = sum(A[j] + additional_votes for j in range(N) if j != i)\n        return (max_other_votes <= A[i])\n\n    C = []\n    for i in range(N):\n        if A[i] >= K:\n            C.append(0)\n            continue\n        \n        left, right = 0, K - sum(A)\n        while left < right:\n            mid = (left + right) // 2\n            if can_win(i, mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        if can_win(i, left):\n            C.append(left)\n        else:\n            C.append(-1)\n    \n    print(' '.join(map(str, C)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\nmin_additional_votes(N, M, K, A)\n```"]}
{"task_id": "abc372_f", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n\n    edges = []\n    index = 3\n    for _ in range(M):\n        x = int(data[index])\n        y = int(data[index + 1])\n        edges.append((x - 1, y - 1))\n        index += 2\n\n    MOD = 998244353\n\n    dp = [[0] * N for _ in range(K + 1)]\n    dp[0][0] = 1\n\n    for k in range(K):\n        new_dp = [0] * N\n        for j in range(N):\n            if dp[k][j] == 0:\n                continue\n            # Move along the cyclic edge\n            new_dp[(j + 1) % N] = (new_dp[(j + 1) % N] + dp[k][j]) % MOD\n            # Move along the additional edges\n            for x, y in edges:\n                if j == x:\n                    new_dp[y] = (new_dp[y] + dp[k][j]) % MOD\n        dp[k + 1] = new_dp\n\n    result = sum(dp[K]) % MOD\n    print(result)\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        x = int(data[index]) - 1\n        y = int(data[index + 1]) - 1\n        edges[x].append(y)\n        index += 2\n    \n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N)]\n    dp[0][0] = 1\n    \n    for k in range(K):\n        new_dp = [0] * (K + 1)\n        for v in range(N):\n            if dp[v][k] > 0:\n                # Move along the cyclic edge\n                next_v = (v + 1) % N\n                new_dp[next_v] = (new_dp[next_v] + dp[v][k]) % MOD\n                \n                # Move along the additional edges\n                for next_v in edges[v]:\n                    new_dp[next_v] = (new_dp[next_v] + dp[v][k]) % MOD\n        \n        dp = new_dp\n    \n    result = sum(dp[v][K] for v in range(N)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n\n    edges = []\n    index = 3\n    for _ in range(M):\n        x = int(data[index])\n        y = int(data[index + 1])\n        edges.append((x - 1, y - 1))\n        index += 2\n\n    MOD = 998244353\n\n    dp = [[0] * N for _ in range(K + 1)]\n    dp[0][0] = 1\n\n    for k in range(K):\n        new_dp = [0] * N\n        for j in range(N):\n            if dp[k][j] == 0:\n                continue\n            # Move along the cyclic edge\n            new_dp[(j + 1) % N] = (new_dp[(j + 1) % N] + dp[k][j]) % MOD\n            # Move along the additional edges\n            for x, y in edges:\n                if j == x:\n                    new_dp[y] = (new_dp[y] + dp[k][j]) % MOD\n        dp[k + 1] = new_dp\n\n    result = sum(dp[K]) % MOD\n    print(result)\n\nmain()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        x = int(data[index]) - 1\n        y = int(data[index + 1]) - 1\n        edges[x].append(y)\n        index += 2\n    \n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N)]\n    dp[0][0] = 1\n    \n    for k in range(K):\n        new_dp = [0] * (K + 1)\n        for v in range(N):\n            if dp[v][k] > 0:\n                # Move along the cyclic edge\n                next_v = (v + 1) % N\n                new_dp[next_v] = (new_dp[next_v] + dp[v][k]) % MOD\n                \n                # Move along the additional edges\n                for next_v in edges[v]:\n                    new_dp[next_v] = (new_dp[next_v] + dp[v][k]) % MOD\n        \n        dp = new_dp\n    \n    result = sum(dp[v][K] for v in range(N)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"final_accuracy": "0.00%"}
