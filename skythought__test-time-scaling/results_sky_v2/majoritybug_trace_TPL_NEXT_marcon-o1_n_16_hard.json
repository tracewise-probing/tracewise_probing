"{\"difficulty\": \"hard\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"AIDC-AI/Marco-o1\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majoritybug_trace_TPL_NEXT_marcon-o1_n_16_hard.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"AIDC-AI/Marco-o1\", \"api_base\": \"http://10.96.183.224:63019/8002/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3551", "code": "def max_xor_subarray(nums, queries):\n    def get_max_xor(l, r):\n        if l > r:\n            return 0\n        max_xor = 0\n        current_xor = 0\n        xor_set = set()\n        for i in range(l, r + 1):\n            current_xor ^= nums[i]\n            if current_xor > max_xor:\n                max_xor = current_xor\n            # Explore all possible subarrays ending at i\n            for xor_val in xor_set:\n                new_xor = current_xor ^ xor_val\n                if new_xor > max_xor:\n                    max_xor = new_xor\n            xor_set.add(current_xor)\n        return max_xor\n\n    result = []\n    for query in queries:\n        l, r = query\n        result.append(get_max_xor(l, r))\n    return result\n", "passed": false, "raw_code": "def max_xor_subarray(nums, queries):\n    def get_max_xor(l, r):\n        if l > r:\n            return 0\n        max_xor = 0\n        current_xor = 0\n        xor_set = set()\n        for i in range(l, r + 1):\n            current_xor ^= nums[i]\n            if current_xor > max_xor:\n                max_xor = current_xor\n            # Explore all possible subarrays ending at i\n            for xor_val in xor_set:\n                new_xor = current_xor ^ xor_val\n                if new_xor > max_xor:\n                    max_xor = new_xor\n            xor_set.add(current_xor)\n        return max_xor\n\n    result = []\n    for query in queries:\n        l, r = query\n        result.append(get_max_xor(l, r))\n    return result\n"}
{"task_id": "3532", "code": "def find_marking_times(edges):\n    from collections import defaultdict\n\n    # Build the adjacency list\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(node, parent, time):\n        marking_time = time\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                marking_time = max(marking_time, dfs(neighbor, node, time + 1))\n        return marking_time\n\n    result = []\n    for i in range(len(adj)):\n        result.append(dfs(i, -1, 0))\n\n    return result\n", "passed": false, "raw_code": "def find_marking_times(edges):\n    from collections import defaultdict\n\n    # Build the adjacency list\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(node, parent, time):\n        marking_time = time\n        for neighbor in adj[node]:\n            if neighbor != parent:\n                marking_time = max(marking_time, dfs(neighbor, node, time + 1))\n        return marking_time\n\n    result = []\n    for i in range(len(adj)):\n        result.append(dfs(i, -1, 0))\n\n    return result\n"}
{"task_id": "3531", "code": "def minimum_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time each enemy takes to kill Bob if Bob does not attack\n    time_to_kill = [float('inf')] * n\n    for i in range(n):\n        if health[i] % power == 0:\n            time_to_kill[i] = health[i] // power\n        else:\n            time_to_kill[i] = health[i] // power + 1\n    # Sort enemies based on the time they take to kill Bob in descending order\n    sorted_enemies = sorted(range(n), key=lambda x: time_to_kill[x], reverse=True)\n    total_damage = 0\n    for i in range(n):\n        enemy = sorted_enemies[i]\n        if time_to_kill[enemy] == float('inf'):\n            continue\n        # Calculate the damage Bob receives in each second\n        damage_per_second = damage[enemy]\n        seconds = time_to_kill[enemy]\n        total_damage += damage_per_second * seconds\n        # Reduce the remaining health after Bob's attacks\n        remaining_health = health[enemy] - (seconds * power)\n        if remaining_health > 0:\n            # If there's still health left, calculate additional damage\n            additional_seconds = remaining_health // damage[enemy]\n            if remaining_health % damage[enemy] != 0:\n                additional_seconds += 1\n            total_damage += damage[enemy] * additional_seconds\n            # Update time_to_kill for other enemies if necessary\n            for j in range(n):\n                if j != enemy:\n                    if health[j] > 0:\n                        time_to_kill[j] = max(time_to_kill[j], time_to_kill[enemy] + 1)\n    return total_damage\n", "passed": false, "raw_code": "def minimum_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time each enemy takes to kill Bob if Bob does not attack\n    time_to_kill = [float('inf')] * n\n    for i in range(n):\n        if health[i] % power == 0:\n            time_to_kill[i] = health[i] // power\n        else:\n            time_to_kill[i] = health[i] // power + 1\n    # Sort enemies based on the time they take to kill Bob in descending order\n    sorted_enemies = sorted(range(n), key=lambda x: time_to_kill[x], reverse=True)\n    total_damage = 0\n    for i in range(n):\n        enemy = sorted_enemies[i]\n        if time_to_kill[enemy] == float('inf'):\n            continue\n        # Calculate the damage Bob receives in each second\n        damage_per_second = damage[enemy]\n        seconds = time_to_kill[enemy]\n        total_damage += damage_per_second * seconds\n        # Reduce the remaining health after Bob's attacks\n        remaining_health = health[enemy] - (seconds * power)\n        if remaining_health > 0:\n            # If there's still health left, calculate additional damage\n            additional_seconds = remaining_health // damage[enemy]\n            if remaining_health % damage[enemy] != 0:\n                additional_seconds += 1\n            total_damage += damage[enemy] * additional_seconds\n            # Update time_to_kill for other enemies if necessary\n            for j in range(n):\n                if j != enemy:\n                    if health[j] > 0:\n                        time_to_kill[j] = max(time_to_kill[j], time_to_kill[enemy] + 1)\n    return total_damage\n"}
{"task_id": "3563", "code": "def max_score(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Create a list to store the maximum score for each column\n    max_scores = [0] * cols\n    \n    for col in range(cols):\n        current_score = 0\n        seen = set()\n        for row in range(rows):\n            if grid[row][col] not in seen:\n                current_score += grid[row][col]\n                seen.add(grid[row][col])\n        max_scores[col] = current_score\n    \n    # Find the maximum score among all columns\n    return max(max_scores)\n", "passed": false, "raw_code": "def max_score(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Create a list to store the maximum score for each column\n    max_scores = [0] * cols\n    \n    for col in range(cols):\n        current_score = 0\n        seen = set()\n        for row in range(rows):\n            if grid[row][col] not in seen:\n                current_score += grid[row][col]\n                seen.add(grid[row][col])\n        max_scores[col] = current_score\n    \n    # Find the maximum score among all columns\n    return max(max_scores)\n"}
{"task_id": "3535", "code": "def count_monotonic_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def count_non_decreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] <= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n        return dp[-1]\n    \n    def count_non_increasing(arr):\n        dp = [1] * n\n        for i in range(n-2, -1, -1):\n            for j in range(n-1, i, -1):\n                if arr[j] >= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n        return dp[0]\n    \n    total = 0\n    for i in range(n):\n        arr1 = [nums[j] - nums[i] for j in range(n)]\n        arr2 = [nums[j] - nums[i] for j in range(n)]\n        \n        # Ensure arr1 is non-decreasing and arr2 is non-increasing\n        arr1.sort()\n        arr2.sort(reverse=True)\n        \n        total += count_non_decreasing(arr1) * count_non_increasing(arr2)\n        total %= MOD\n    \n    return total\n", "passed": false, "raw_code": "def count_monotonic_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def count_non_decreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] <= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n        return dp[-1]\n    \n    def count_non_increasing(arr):\n        dp = [1] * n\n        for i in range(n-2, -1, -1):\n            for j in range(n-1, i, -1):\n                if arr[j] >= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n        return dp[0]\n    \n    total = 0\n    for i in range(n):\n        arr1 = [nums[j] - nums[i] for j in range(n)]\n        arr2 = [nums[j] - nums[i] for j in range(n)]\n        \n        # Ensure arr1 is non-decreasing and arr2 is non-increasing\n        arr1.sort()\n        arr2.sort(reverse=True)\n        \n        total += count_non_decreasing(arr1) * count_non_increasing(arr2)\n        total %= MOD\n    \n    return total\n"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    \"\"\"\n    Returns the smallest starting index of a substring in 's' that is almost equal to 'pattern'.\n    A substring is considered almost equal if at most one character can be changed to make it identical to 'pattern'.\n    If no such substring exists, returns -1.\n    \n    Parameters:\n    s (str): The main string to search within.\n    pattern (str): The target pattern to match.\n    \n    Returns:\n    int: The starting index of the first almost equal substring or -1 if none exists.\n    \"\"\"\n    len_s = len(s)\n    len_p = len(pattern)\n    if len_p > len_s:\n        return -1\n\n    for i in range(len_s - len_p + 1):\n        mismatch = 0\n        for j in range(len_p):\n            if s[i + j] != pattern[j]:\n                mismatch += 1\n                if mismatch > 1:\n                    break\n        if mismatch <= 1:\n            return i\n    return -1\n", "passed": false, "raw_code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    \"\"\"\n    Returns the smallest starting index of a substring in 's' that is almost equal to 'pattern'.\n    A substring is considered almost equal if at most one character can be changed to make it identical to 'pattern'.\n    If no such substring exists, returns -1.\n    \n    Parameters:\n    s (str): The main string to search within.\n    pattern (str): The target pattern to match.\n    \n    Returns:\n    int: The starting index of the first almost equal substring or -1 if none exists.\n    \"\"\"\n    len_s = len(s)\n    len_p = len(pattern)\n    if len_p > len_s:\n        return -1\n\n    for i in range(len_s - len_p + 1):\n        mismatch = 0\n        for j in range(len_p):\n            if s[i + j] != pattern[j]:\n                mismatch += 1\n                if mismatch > 1:\n                    break\n        if mismatch <= 1:\n            return i\n    return -1\n"}
{"task_id": "3550", "code": "def max_rook_sum(board):\n    m = len(board)\n    n = len(board[0])\n    \n    # Initialize dictionaries to store the sum of positive and negative values in each row and column\n    row_sums_pos = {i: 0 for i in range(m)}\n    row_sums_neg = {i: 0 for i in range(m)}\n    col_sums_pos = {j: 0 for j in range(n)}\n    col_sums_neg = {j: 0 for j in range(n)}\n    \n    # Calculate the sums for positive and negative values in rows and columns\n    for i in range(m):\n        for j in range(n):\n            val = board[i][j]\n            if val > 0:\n                row_sums_pos[i] += val\n                col_sums_pos[j] += val\n            else:\n                row_sums_neg[i] += val\n                col_sums_neg[j] += val\n    \n    # Function to calculate the maximum sum by placing rooks in the current row and column\n    def dfs(row, col, used_rows, used_cols, current_sum):\n        if len(used_rows) == 3:\n            return current_sum\n        max_sum = float('-inf')\n        for r in range(m):\n            if r in used_rows:\n                continue\n            for c in range(n):\n                if c in used_cols:\n                    continue\n                # Check if placing a rook here doesn't conflict with existing rooks\n                # Since we're using DFS, we assume that previous placements are valid\n                new_sum = current_sum + board[r][c]\n                # Update used rows and columns\n                new_used_rows = used_rows.union({r})\n                new_used_cols = used_cols.union({c})\n                # Recurse\n                max_sum = max(max_sum, dfs(r, c, new_used_rows, new_used_cols, new_sum))\n        return max_sum\n    \n    # Start DFS from the first row and column\n    initial_sum = 0\n    return dfs(0, 0, set(), set(), initial_sum)\n", "passed": false, "raw_code": "def max_rook_sum(board):\n    m = len(board)\n    n = len(board[0])\n    \n    # Initialize dictionaries to store the sum of positive and negative values in each row and column\n    row_sums_pos = {i: 0 for i in range(m)}\n    row_sums_neg = {i: 0 for i in range(m)}\n    col_sums_pos = {j: 0 for j in range(n)}\n    col_sums_neg = {j: 0 for j in range(n)}\n    \n    # Calculate the sums for positive and negative values in rows and columns\n    for i in range(m):\n        for j in range(n):\n            val = board[i][j]\n            if val > 0:\n                row_sums_pos[i] += val\n                col_sums_pos[j] += val\n            else:\n                row_sums_neg[i] += val\n                col_sums_neg[j] += val\n    \n    # Function to calculate the maximum sum by placing rooks in the current row and column\n    def dfs(row, col, used_rows, used_cols, current_sum):\n        if len(used_rows) == 3:\n            return current_sum\n        max_sum = float('-inf')\n        for r in range(m):\n            if r in used_rows:\n                continue\n            for c in range(n):\n                if c in used_cols:\n                    continue\n                # Check if placing a rook here doesn't conflict with existing rooks\n                # Since we're using DFS, we assume that previous placements are valid\n                new_sum = current_sum + board[r][c]\n                # Update used rows and columns\n                new_used_rows = used_rows.union({r})\n                new_used_cols = used_cols.union({c})\n                # Recurse\n                max_sum = max(max_sum, dfs(r, c, new_used_rows, new_used_cols, new_sum))\n        return max_sum\n    \n    # Start DFS from the first row and column\n    initial_sum = 0\n    return dfs(0, 0, set(), set(), initial_sum)\n"}
{"task_id": "3571", "code": "def max_increasing_path(coordinates, k):\n    n = len(coordinates)\n    # Sort the coordinates based on x-coordinate, then y-coordinate\n    sorted_coords = sorted(range(n), key=lambda i: (coordinates[i][0], coordinates[i][1]))\n    \n    # Initialize memoization dictionary to store the maximum path length ending at each coordinate\n    memo = {}\n    \n    def dfs(index):\n        if index in memo:\n            return memo[index]\n        x, y = coordinates[index]\n        max_len = 1  # The path at least includes the current coordinate\n        # Explore all possible next coordinates\n        for i in range(n):\n            if i == index:\n                continue\n            x_next, y_next = coordinates[i]\n            if x_next > x and y_next > y:\n                if i in memo:\n                    max_len = max(max_len, memo[i] + 1)\n                else:\n                    max_len = max(max_len, dfs(i) + 1)\n        memo[index] = max_len\n        return max_len\n    \n    # Since we need to include coordinates[k], start the DFS from the sorted position of coordinates[k]\n    k_index = sorted_coords[k]\n    return dfs(k_index)\n", "passed": false, "raw_code": "def max_increasing_path(coordinates, k):\n    n = len(coordinates)\n    # Sort the coordinates based on x-coordinate, then y-coordinate\n    sorted_coords = sorted(range(n), key=lambda i: (coordinates[i][0], coordinates[i][1]))\n    \n    # Initialize memoization dictionary to store the maximum path length ending at each coordinate\n    memo = {}\n    \n    def dfs(index):\n        if index in memo:\n            return memo[index]\n        x, y = coordinates[index]\n        max_len = 1  # The path at least includes the current coordinate\n        # Explore all possible next coordinates\n        for i in range(n):\n            if i == index:\n                continue\n            x_next, y_next = coordinates[i]\n            if x_next > x and y_next > y:\n                if i in memo:\n                    max_len = max(max_len, memo[i] + 1)\n                else:\n                    max_len = max(max_len, dfs(i) + 1)\n        memo[index] = max_len\n        return max_len\n    \n    # Since we need to include coordinates[k], start the DFS from the sorted position of coordinates[k]\n    k_index = sorted_coords[k]\n    return dfs(k_index)\n"}
{"task_id": "3552", "code": "def largest_k_palindromic(n, k):\n    if k == 1:\n        return '9' * n\n    if k == 2:\n        if n % 2 == 0:\n            return '8' + '0' * (n - 2) + '8'\n        else:\n            return '8' + '0' * (n - 3) + '8'\n    if k == 3:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 4:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 5:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 6:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 7:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 8:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 9:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n", "passed": false, "raw_code": "def largest_k_palindromic(n, k):\n    if k == 1:\n        return '9' * n\n    if k == 2:\n        if n % 2 == 0:\n            return '8' + '0' * (n - 2) + '8'\n        else:\n            return '8' + '0' * (n - 3) + '8'\n    if k == 3:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 4:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 5:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 6:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 7:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 8:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n    if k == 9:\n        if n % 2 == 0:\n            return '9' + '0' * (n - 2) + '9'\n        else:\n            return '9' + '0' * (n - 3) + '9'\n"}
{"task_id": "3583", "code": "def findGCD(nums, queries):\n    from math import gcd\n    from itertools import combinations\n\n    # Generate all possible pairs and their GCDs\n    gcd_pairs = sorted([gcd(a, b) for a, b in combinations(nums, 2)])\n    \n    # Retrieve elements based on queries\n    answer = [gcd_pairs[q] for q in queries]\n    return answer\n", "passed": false, "raw_code": "def findGCD(nums, queries):\n    from math import gcd\n    from itertools import combinations\n\n    # Generate all possible pairs and their GCDs\n    gcd_pairs = sorted([gcd(a, b) for a, b in combinations(nums, 2)])\n    \n    # Retrieve elements based on queries\n    answer = [gcd_pairs[q] for q in queries]\n    return answer\n"}
{"task_id": "3575", "code": "def max_subsequence_value(nums, k):\n    n = len(nums)\n    if n == 0 or k == 0:\n        return 0\n\n    # Generate all possible subsequences of size 2k\n    from itertools import combinations\n    all_subsequences = list(combinations(nums, 2 * k))\n\n    max_value = float('-inf')\n    for subseq in all_subsequences:\n        first_half = subseq[:k]\n        second_half = subseq[k:]\n        first_or = 0\n        second_or = 0\n        for num in first_half:\n            first_or |= num\n        for num in second_half:\n            second_or |= num\n        current_value = first_or ^ second_or\n        if current_value > max_value:\n            max_value = current_value\n\n    return max_value\n", "passed": false, "raw_code": "def max_subsequence_value(nums, k):\n    n = len(nums)\n    if n == 0 or k == 0:\n        return 0\n\n    # Generate all possible subsequences of size 2k\n    from itertools import combinations\n    all_subsequences = list(combinations(nums, 2 * k))\n\n    max_value = float('-inf')\n    for subseq in all_subsequences:\n        first_half = subseq[:k]\n        second_half = subseq[k:]\n        first_or = 0\n        second_or = 0\n        for num in first_half:\n            first_or |= num\n        for num in second_half:\n            second_or |= num\n        current_value = first_or ^ second_or\n        if current_value > max_value:\n            max_value = current_value\n\n    return max_value\n"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    def is_k_palindromic(x, k):\n        s = str(x)\n        return s == s[::-1] and x % k == 0\n\n    def can_form_k_palindrome(s, k):\n        count = [0] * 10\n        for digit in s:\n            count[int(digit)] += 1\n        # Check for single odd digit\n        odd = 0\n        for cnt in count:\n            if cnt % 2 != 0:\n                odd += 1\n                if odd > 1:\n                    return False\n        # If number of digits is even, all counts must be even\n        if len(s) % 2 == 0:\n            for cnt in count:\n                if cnt % 2 != 0:\n                    return False\n        # If number of digits is odd, one count can be odd (for middle digit)\n        else:\n            if odd == 0:\n                return False\n        # Check divisibility by k\n        num = int(''.join(sorted(s)))\n        return is_k_palindromic(num, k)\n\n    total = 0\n    for i in range(1, 10**n):\n        s = str(i).zfill(n)\n        if can_form_k_palindrome(s, k):\n            total += 1\n    return total\n", "passed": false, "raw_code": "def count_good_integers(n, k):\n    def is_k_palindromic(x, k):\n        s = str(x)\n        return s == s[::-1] and x % k == 0\n\n    def can_form_k_palindrome(s, k):\n        count = [0] * 10\n        for digit in s:\n            count[int(digit)] += 1\n        # Check for single odd digit\n        odd = 0\n        for cnt in count:\n            if cnt % 2 != 0:\n                odd += 1\n                if odd > 1:\n                    return False\n        # If number of digits is even, all counts must be even\n        if len(s) % 2 == 0:\n            for cnt in count:\n                if cnt % 2 != 0:\n                    return False\n        # If number of digits is odd, one count can be odd (for middle digit)\n        else:\n            if odd == 0:\n                return False\n        # Check divisibility by k\n        num = int(''.join(sorted(s)))\n        return is_k_palindromic(num, k)\n\n    total = 0\n    for i in range(1, 10**n):\n        s = str(i).zfill(n)\n        if can_form_k_palindrome(s, k):\n            total += 1\n    return total\n"}
{"task_id": "3527", "code": "def solve(colors, queries):\n    def count_alternating_groups(size):\n        n = len(colors)\n        if size < 3:\n            return 0\n        count = 0\n        for i in range(n):\n            current_size = 1\n            prev_color = colors[i]\n            is_alternating = True\n            for j in range(1, size):\n                next_index = (i + j) % n\n                next_color = colors[next_index]\n                if next_color != prev_color:\n                    current_size += 1\n                    prev_color = next_color\n                else:\n                    is_alternating = False\n                    break\n            if is_alternating:\n                count += 1\n        return count\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index = query[1]\n            new_color = query[2]\n            colors[index] = new_color\n    return result\n", "passed": false, "raw_code": "def solve(colors, queries):\n    def count_alternating_groups(size):\n        n = len(colors)\n        if size < 3:\n            return 0\n        count = 0\n        for i in range(n):\n            current_size = 1\n            prev_color = colors[i]\n            is_alternating = True\n            for j in range(1, size):\n                next_index = (i + j) % n\n                next_color = colors[next_index]\n                if next_color != prev_color:\n                    current_size += 1\n                    prev_color = next_color\n                else:\n                    is_alternating = False\n                    break\n            if is_alternating:\n                count += 1\n        return count\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index = query[1]\n            new_color = query[2]\n            colors[index] = new_color\n    return result\n"}
{"task_id": "3560", "code": "def max_total_moves(kx, ky, positions):\n    # Convert positions to a set for faster lookup\n    pawns = set(tuple(pos) for pos in positions)\n    \n    def dfs(current, remaining_pawns, depth, memo):\n        if not remaining_pawns:\n            return depth\n        if current in memo:\n            return memo[current]\n        \n        min_moves = float('inf')\n        for dx, dy in [(-2, -1), (-1, -2), (1, -2), (2, -1),\n                       (2, 1), (1, 2), (-1, 2), (-2, 1)]:\n            new_x, new_y = current[0] + dx, current[1] + dy\n            if 0 <= new_x < 50 and 0 <= new_y < 50:\n                for pawn in remaining_pawns.copy():\n                    if (new_x, new_y) == pawn:\n                        new_remaining = remaining_pawns - {pawn}\n                        move = dfs((new_x, new_y), new_remaining, depth + 1, memo)\n                        min_moves = min(min_moves, move)\n        memo[current] = min_moves\n        return min_moves\n    \n    memo = {}\n    max_moves = 0\n    for pawn in positions:\n        remaining = set(positions) - {tuple(pawn)}\n        moves = dfs((kx, ky), remaining, 0, memo)\n        max_moves += moves\n    return max_moves\n", "passed": false, "raw_code": "def max_total_moves(kx, ky, positions):\n    # Convert positions to a set for faster lookup\n    pawns = set(tuple(pos) for pos in positions)\n    \n    def dfs(current, remaining_pawns, depth, memo):\n        if not remaining_pawns:\n            return depth\n        if current in memo:\n            return memo[current]\n        \n        min_moves = float('inf')\n        for dx, dy in [(-2, -1), (-1, -2), (1, -2), (2, -1),\n                       (2, 1), (1, 2), (-1, 2), (-2, 1)]:\n            new_x, new_y = current[0] + dx, current[1] + dy\n            if 0 <= new_x < 50 and 0 <= new_y < 50:\n                for pawn in remaining_pawns.copy():\n                    if (new_x, new_y) == pawn:\n                        new_remaining = remaining_pawns - {pawn}\n                        move = dfs((new_x, new_y), new_remaining, depth + 1, memo)\n                        min_moves = min(min_moves, move)\n        memo[current] = min_moves\n        return min_moves\n    \n    memo = {}\n    max_moves = 0\n    for pawn in positions:\n        remaining = set(positions) - {tuple(pawn)}\n        moves = dfs((kx, ky), remaining, 0, memo)\n        max_moves += moves\n    return max_moves\n"}
{"final_accuracy": "0.00%"}
