{"difficulty": "hard", "num_threads": 32, "temperature": 0.9, "n": 16, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp09_bug_trace_TPL_CODEEXECUTOR_qwen_7b_hard_n_16.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def has_more_than_one_prime_factor(n):\n        factors = set()\n        # Check divisibility by 2\n        while n % 2 == 0:\n            factors.add(2)\n            n //= 2\n        # Check for other primes\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n //= i\n        if n > 2:\n            factors.add(n)\n        return len(factors) > 1\n    \n    count = sum(has_more_than_one_prime_factor(x) for x in A)\n    \n    if count % 2 == 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "passed": false, "raw_code": "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def has_more_than_one_prime_factor(n):\n        factors = set()\n        # Check divisibility by 2\n        while n % 2 == 0:\n            factors.add(2)\n            n //= 2\n        # Check for other primes\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n //= i\n        if n > 2:\n            factors.add(n)\n        return len(factors) > 1\n    \n    count = sum(has_more_than_one_prime_factor(x) for x in A)\n    \n    if count % 2 == 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def countNonDecreasing(arr):\n        dp = [1] * (max(arr) + 1)\n        for num in arr:\n            dp[num] += dp[num - 1]\n        return sum(dp) % MOD\n    \n    def countNonIncreasing(arr):\n        dp = [1] * (min(arr) + 1)\n        for num in reversed(arr):\n            dp[num] += dp[num + 1]\n        return sum(dp) % MOD\n    \n    result = 0\n    for i in range(n):\n        left_nums = nums[:i]\n        right_nums = nums[i:]\n        \n        left_non_decreasing_count = countNonDecreasing(left_nums)\n        right_non_increasing_count = countNonIncreasing(right_nums)\n        \n        result = (result + left_non_decreasing_count * right_non_increasing_count) % MOD\n    \n    return result", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def countNonDecreasing(arr):\n        dp = [1] * (max(arr) + 1)\n        for num in arr:\n            dp[num] += dp[num - 1]\n        return sum(dp) % MOD\n    \n    def countNonIncreasing(arr):\n        dp = [1] * (min(arr) + 1)\n        for num in reversed(arr):\n            dp[num] += dp[num + 1]\n        return sum(dp) % MOD\n    \n    result = 0\n    for i in range(n):\n        left_nums = nums[:i]\n        right_nums = nums[i:]\n        \n        left_non_decreasing_count = countNonDecreasing(left_nums)\n        right_non_increasing_count = countNonIncreasing(right_nums)\n        \n        result = (result + left_non_decreasing_count * right_non_increasing_count) % MOD\n    \n    return result\n```"}
{"task_id": "3532", "code": "def get_marking_times(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    from collections import deque\n    marked = [0] * n\n    times = [float('inf')] * n\n\n    def bfs(start, time):\n        queue = deque([start])\n        marked[start] = time\n        times[start] = time + start % 2\n\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not marked[neighbor]:\n                    marked[neighbor] = time\n                    times[neighbor] = times[current] + (neighbor % 2) * 2\n                    queue.append(neighbor)\n\n    # Identify the initial and terminal nodes\n    initial_nodes = [i for i in range(n) if len(graph[i]) == 1]\n    terminal_nodes = [i for i in range(n) if len(graph[i]) == 1 and i not in initial_nodes]\n\n    # Mark the initial nodes\n    for node in initial_nodes:\n        bfs(node, 1)\n\n    return times", "passed": false, "raw_code": "def get_marking_times(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    from collections import deque\n    marked = [0] * n\n    times = [float('inf')] * n\n\n    def bfs(start, time):\n        queue = deque([start])\n        marked[start] = time\n        times[start] = time + start % 2\n\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not marked[neighbor]:\n                    marked[neighbor] = time\n                    times[neighbor] = times[current] + (neighbor % 2) * 2\n                    queue.append(neighbor)\n\n    # Identify the initial and terminal nodes\n    initial_nodes = [i for i in range(n) if len(graph[i]) == 1]\n    terminal_nodes = [i for i in range(n) if len(graph[i]) == 1 and i not in initial_nodes]\n\n    # Mark the initial nodes\n    for node in initial_nodes:\n        bfs(node, 1)\n\n    return times"}
{"task_id": "abc367_f", "code": "import sys\nfrom collections import Counter\n\ndef can_rearrange_subsequences(N, Q, A, B, queries):\n    results = []\n    for l_i, r_i, L_i, R_i in queries:\n        # Extract the subsequences\n        subseq_A = A[l_i - 1:r_i]\n        subseq_B = B[L_i - 1:R_i]\n        # Check if the frequency counts of elements are the same\n        if Counter(subseq_A) == Counter(subseq_B):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results\n\n# Read input from standard input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\nqueries = [(int(data[2*N+2 + 4*i]), int(data[2*N+2 + 4*i+1]), int(data[2*N+2 + 4*i+2]), int(data[2*N+2 + 4*i+3])) for i in range(Q)]\n\n# Process the queries and print the results\nresults = can_rearrange_subsequences(N, Q, A, B, queries)\nfor result in results:\n    print(result)\ncan_rearrange_subsequences(N, Q, A, B, queries)", "passed": false, "raw_code": "import sys\nfrom collections import Counter\n\ndef can_rearrange_subsequences(N, Q, A, B, queries):\n    results = []\n    for l_i, r_i, L_i, R_i in queries:\n        # Extract the subsequences\n        subseq_A = A[l_i - 1:r_i]\n        subseq_B = B[L_i - 1:R_i]\n        # Check if the frequency counts of elements are the same\n        if Counter(subseq_A) == Counter(subseq_B):\n            results.append('Yes')\n        else:\n            results.append('No')\n    return results\n\n# Read input from standard input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\nqueries = [(int(data[2*N+2 + 4*i]), int(data[2*N+2 + 4*i+1]), int(data[2*N+2 + 4*i+2]), int(data[2*N+2 + 4*i+3])) for i in range(Q)]\n\n# Process the queries and print the results\nresults = can_rearrange_subsequences(N, Q, A, B, queries)\nfor result in results:\n    print(result)\ncan_rearrange_subsequences(N, Q, A, B, queries)"}
{"task_id": "abc365_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    P = [0]\n    current_xor = 0\n    for num in A:\n        current_xor ^= num\n        P.append(current_xor)\n    \n    # Initialize result\n    result = 0\n    \n    # Calculate the sum of XORs for all subarrays\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            result += P[j] ^ P[i - 1]\n    \n    print(result)\n\n# Call the main function\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    P = [0]\n    current_xor = 0\n    for num in A:\n        current_xor ^= num\n        P.append(current_xor)\n    \n    # Initialize result\n    result = 0\n    \n    # Calculate the sum of XORs for all subarrays\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            result += P[j] ^ P[i - 1]\n    \n    print(result)\n\n# Call the main function\nmain()\n```"}
{"task_id": "abc373_e", "code": "def calculate_additional_votes(N, M, K, A):\n    # Calculate the total votes already counted\n    total_counted_votes = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_counted_votes\n    # Initialize the result array with -1\n    result = [-1] * N\n    # Iterate over each candidate\n    for i in range(N):\n        # If candidate i has already won or lost, skip them\n        if A[i] >= (K - total_counted_votes + 1) / (M + 1) or A[i] < (K - total_counted_votes) / (M + 1):\n            continue\n        # Calculate the maximum number of votes another candidate could have without winning\n        max_votes_others_can_have = sorted(A)[::-1][M]\n        # Calculate the minimum additional votes needed for candidate i to win\n        additional_votes_needed = max(0, max_votes_others_can_have - A[i] + 1)\n        # Ensure the additional votes do not exceed the remaining votes\n        if additional_votes_needed <= remaining_votes:\n            result[i] = additional_votes_needed\n    return ' '.join(map(str, result))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    print(calculate_additional_votes(N, M, K, A))\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "def calculate_additional_votes(N, M, K, A):\n    # Calculate the total votes already counted\n    total_counted_votes = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_counted_votes\n    # Initialize the result array with -1\n    result = [-1] * N\n    # Iterate over each candidate\n    for i in range(N):\n        # If candidate i has already won or lost, skip them\n        if A[i] >= (K - total_counted_votes + 1) / (M + 1) or A[i] < (K - total_counted_votes) / (M + 1):\n            continue\n        # Calculate the maximum number of votes another candidate could have without winning\n        max_votes_others_can_have = sorted(A)[::-1][M]\n        # Calculate the minimum additional votes needed for candidate i to win\n        additional_votes_needed = max(0, max_votes_others_can_have - A[i] + 1)\n        # Ensure the additional votes do not exceed the remaining votes\n        if additional_votes_needed <= remaining_votes:\n            result[i] = additional_votes_needed\n    return ' '.join(map(str, result))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    print(calculate_additional_votes(N, M, K, A))\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "abc371_f", "code": "def min_movements(N, X, Q, T, G):\n    # Sort the positions of the people\n    X.sort()\n    \n    # Calculate the prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + X[i]\n    \n    # Function to calculate the number of movements for a single task\n    def movements_for_task(t, g):\n        x_t = X[t - 1]\n        if g >= x_t:\n            return g - x_t + prefix_sum[N] - prefix_sum[bisect_right(X, g)]\n        else:\n            return x_t - g + prefix_sum[bisect_left(X, g)] - prefix_sum[0]\n    \n    import bisect\n    \n    # Calculate total movements for all tasks\n    total_moves = sum(movements_for_task(t, g) for t, g in zip(T, G))\n    \n    print(total_moves)\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\nT = []\nG = []\nfor i in range(Q):\n    T.append(int(data[N+2+2*i]))\n    G.append(int(data[N+3+2*i]))\n\nmin_movements(N, X, Q, T, G)", "passed": false, "raw_code": "```python\ndef min_movements(N, X, Q, T, G):\n    # Sort the positions of the people\n    X.sort()\n    \n    # Calculate the prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + X[i]\n    \n    # Function to calculate the number of movements for a single task\n    def movements_for_task(t, g):\n        x_t = X[t - 1]\n        if g >= x_t:\n            return g - x_t + prefix_sum[N] - prefix_sum[bisect_right(X, g)]\n        else:\n            return x_t - g + prefix_sum[bisect_left(X, g)] - prefix_sum[0]\n    \n    import bisect\n    \n    # Calculate total movements for all tasks\n    total_moves = sum(movements_for_task(t, g) for t, g in zip(T, G))\n    \n    print(total_moves)\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\nT = []\nG = []\nfor i in range(Q):\n    T.append(int(data[N+2+2*i]))\n    G.append(int(data[N+3+2*i]))\n\nmin_movements(N, X, Q, T, G)\n```"}
{"task_id": "abc368_e", "code": "def min_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X1 = int(data[index + 2])\n    index += 3\n    \n    trains = []\n    for _ in range(M):\n        Ai = int(data[index])\n        Bi = int(data[index + 1])\n        Si = int(data[index + 2])\n        Ti = int(data[index + 3])\n        trains.append((Ai, Bi, Si, Ti))\n        index += 4\n    \n    # Sort trains by arrival time\n    trains.sort(key=lambda x: x[2])\n    \n    delays = [X1] * M\n    for i in range(1, M):\n        Ai, Bi, Si, Ti = trains[i]\n        prev_Ai, prev_Bi, prev_Si, prev_Ti = trains[i - 1]\n        \n        if Bi == prev_Bi and Ti <= prev_Si:\n            required_delay = max(0, prev_Si + delays[i - 1] - Ti)\n            delays[i] += required_delay\n    \n    # Print the delays excluding the first one\n    for delay in delays[1:]:\n        print(delay, end=' ')\n    print()\n\nmin_delays()", "passed": false, "raw_code": "```python\ndef min_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X1 = int(data[index + 2])\n    index += 3\n    \n    trains = []\n    for _ in range(M):\n        Ai = int(data[index])\n        Bi = int(data[index + 1])\n        Si = int(data[index + 2])\n        Ti = int(data[index + 3])\n        trains.append((Ai, Bi, Si, Ti))\n        index += 4\n    \n    # Sort trains by arrival time\n    trains.sort(key=lambda x: x[2])\n    \n    delays = [X1] * M\n    for i in range(1, M):\n        Ai, Bi, Si, Ti = trains[i]\n        prev_Ai, prev_Bi, prev_Si, prev_Ti = trains[i - 1]\n        \n        if Bi == prev_Bi and Ti <= prev_Si:\n            required_delay = max(0, prev_Si + delays[i - 1] - Ti)\n            delays[i] += required_delay\n    \n    # Print the delays excluding the first one\n    for delay in delays[1:]:\n        print(delay, end=' ')\n    print()\n\nmin_delays()\n```"}
{"task_id": "abc367_e", "code": "def process_sequence(N, K, X, A):\n    for _ in range(K % (N * N)):\n        A = [A[X[i] - 1] for i in range(N)]\n    print(' '.join(map(str, A)))\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nx = list(map(int, data[2:n+2]))\na = list(map(int, data[n+2:]))\nprocess_sequence(n, k, x, a)", "passed": false, "raw_code": "def process_sequence(N, K, X, A):\n    for _ in range(K % (N * N)):\n        A = [A[X[i] - 1] for i in range(N)]\n    print(' '.join(map(str, A)))\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nx = list(map(int, data[2:n+2]))\na = list(map(int, data[n+2:]))\nprocess_sequence(n, k, x, a)"}
{"task_id": "abc373_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    \n    items = []\n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            for k in range(min(10**10, (j // w) + 1)):\n                dp[j] = max(dp[j], dp[j - k * w] + k * v - k**2)\n    \n    print(dp[W])\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    \n    items = []\n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            for k in range(min(10**10, (j // w) + 1)):\n                dp[j] = max(dp[j], dp[j - k * w] + k * v - k**2)\n    \n    print(dp[W])\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    result = 0\n    \n    for i in range(N):\n        distinct_count = set()\n        for j in range(i, N):\n            distinct_count.add(A[j])\n            result += len(distinct_count)\n    \n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    result = 0\n    \n    for i in range(N):\n        distinct_count = set()\n        for j in range(i, N):\n            distinct_count.add(A[j])\n            result += len(distinct_count)\n    \n    print(result)\n\nmain()\n```"}
{"task_id": "arc181_c", "code": "def fill_grid(N, P, Q):\n    # Generate all binary numbers from 0 to 2^N - 1\n    binary_numbers = [format(i, f'0{N}b') for i in range(2**N)]\n    \n    # Sort the binary numbers according to the permutations P and Q\n    sorted_numbers = []\n    for p in P:\n        sorted_numbers.append(binary_numbers[p-1])\n    for q in Q:\n        sorted_numbers.append(binary_numbers[q-1])\n    \n    # Print the grid\n    for num in sorted_numbers:\n        print(num)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Call the function with the input data\nfill_grid(N, P, Q)", "passed": false, "raw_code": "```python\ndef fill_grid(N, P, Q):\n    # Generate all binary numbers from 0 to 2^N - 1\n    binary_numbers = [format(i, f'0{N}b') for i in range(2**N)]\n    \n    # Sort the binary numbers according to the permutations P and Q\n    sorted_numbers = []\n    for p in P:\n        sorted_numbers.append(binary_numbers[p-1])\n    for q in Q:\n        sorted_numbers.append(binary_numbers[q-1])\n    \n    # Print the grid\n    for num in sorted_numbers:\n        print(num)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Call the function with the input data\nfill_grid(N, P, Q)\n```"}
{"task_id": "abc366_f", "code": "import sys\nfrom itertools import permutations\n\ndef max_nested_function_value(N, K, functions):\n    max_value = -sys.maxsize\n    # Generate all possible sequences of K distinct integers between 1 and N\n    for seq in permutations(range(1, N+1), K):\n        current_value = 1\n        # Apply each function in the sequence\n        for func_index in seq:\n            A, B = functions[func_index-1]\n            current_value = A * current_value + B\n        # Update the maximum value found\n        if current_value > max_value:\n            max_value = current_value\n    return max_value\n\n# Read input from standard input\ninput = sys.stdin.read()\ndata = input.splitlines()\nN, K = map(int, data[0].split())\nfunctions = [tuple(map(int, line.split())) for line in data[1:N+1]]\n\n# Calculate and print the result\nresult = max_nested_function_value(N, K, functions)\nprint(result)", "passed": false, "raw_code": "import sys\nfrom itertools import permutations\n\ndef max_nested_function_value(N, K, functions):\n    max_value = -sys.maxsize\n    # Generate all possible sequences of K distinct integers between 1 and N\n    for seq in permutations(range(1, N+1), K):\n        current_value = 1\n        # Apply each function in the sequence\n        for func_index in seq:\n            A, B = functions[func_index-1]\n            current_value = A * current_value + B\n        # Update the maximum value found\n        if current_value > max_value:\n            max_value = current_value\n    return max_value\n\n# Read input from standard input\ninput = sys.stdin.read()\ndata = input.splitlines()\nN, K = map(int, data[0].split())\nfunctions = [tuple(map(int, line.split())) for line in data[1:N+1]]\n\n# Calculate and print the result\nresult = max_nested_function_value(N, K, functions)\nprint(result)"}
{"task_id": "abc370_e", "code": "def count_partitions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, N + 1):\n        prefix_sum = [0]\n        for j in range(i):\n            prefix_sum.append(prefix_sum[-1] + A[j])\n        \n        for j in range(i):\n            if prefix_sum[j + 1] == K:\n                dp[i][j] += dp[j][j] % MOD\n            dp[i][i - 1] += dp[j][j] % MOD\n        \n        for j in range(i):\n            dp[i][j] = (dp[i][j] + dp[i][j + 1]) % MOD\n    \n    # The result is the sum of all valid partitions\n    result = sum(dp[N][:N]) % MOD\n    print(result)\n\ncount_partitions()", "passed": false, "raw_code": "```python\ndef count_partitions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, N + 1):\n        prefix_sum = [0]\n        for j in range(i):\n            prefix_sum.append(prefix_sum[-1] + A[j])\n        \n        for j in range(i):\n            if prefix_sum[j + 1] == K:\n                dp[i][j] += dp[j][j] % MOD\n            dp[i][i - 1] += dp[j][j] % MOD\n        \n        for j in range(i):\n            dp[i][j] = (dp[i][j] + dp[i][j + 1]) % MOD\n    \n    # The result is the sum of all valid partitions\n    result = sum(dp[N][:N]) % MOD\n    print(result)\n\ncount_partitions()\n```"}
{"task_id": "abc372_f", "code": "def main():\\n    import sys\\n    input = sys.stdin.read\\n    data = input().split()\\n\\n    index = 0\\n    N = int(data[index])\\n    M = int(data[index + 1])\\n    K = int(data[index + 2])\\n    index += 3\\n\\n    edges = [[] for _ in range(N)]\\n    for _ in range(M):\\n        x = int(data[index]) - 1\\n        y = int(data[index + 1]) - 1\\n        edges[x].append(y)\\n        index += 2\\n\\n    MOD = 998244353\\n    dp = [[0] * (K + 1) for _ in range(N)]\\n    dp[0][0] = 1\\n\\n    for k in range(K):\\n        new_dp = [[0] * (K + 1) for _ in range(N)]\\n        for i in range(N):\\n            if dp[i][k] > 0:\\n                # Move along the circular edge\\n                new_dp[(i + 1) % N][k + 1] = (new_dp[(i + 1) % N][k + 1] + dp[i][k]) % MOD\\n                # Move along additional edges\\n                for j in edges[i]:\\n                    new_dp[j][k + 1] = (new_dp[j][k + 1] + dp[i][k]) % MOD\\n        dp = new_dp\\n\\n    result = sum(dp[i][K] for i in range(N)) % MOD\\n    print(result)\\n\\nif __name__ == '__main__':\\n    main()", "passed": false, "raw_code": "def main():\\n    import sys\\n    input = sys.stdin.read\\n    data = input().split()\\n\\n    index = 0\\n    N = int(data[index])\\n    M = int(data[index + 1])\\n    K = int(data[index + 2])\\n    index += 3\\n\\n    edges = [[] for _ in range(N)]\\n    for _ in range(M):\\n        x = int(data[index]) - 1\\n        y = int(data[index + 1]) - 1\\n        edges[x].append(y)\\n        index += 2\\n\\n    MOD = 998244353\\n    dp = [[0] * (K + 1) for _ in range(N)]\\n    dp[0][0] = 1\\n\\n    for k in range(K):\\n        new_dp = [[0] * (K + 1) for _ in range(N)]\\n        for i in range(N):\\n            if dp[i][k] > 0:\\n                # Move along the circular edge\\n                new_dp[(i + 1) % N][k + 1] = (new_dp[(i + 1) % N][k + 1] + dp[i][k]) % MOD\\n                # Move along additional edges\\n                for j in edges[i]:\\n                    new_dp[j][k + 1] = (new_dp[j][k + 1] + dp[i][k]) % MOD\\n        dp = new_dp\\n\\n    result = sum(dp[i][K] for i in range(N)) % MOD\\n    print(result)\\n\\nif __name__ == '__main__':\\n    main()"}
{"task_id": "abc366_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n\n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n\n    def count_valid_pairs(points, D):\n        count = 0\n        for x in range(-D, D + 1):\n            for y in range(-D, D + 1):\n                if all(abs(x - px) + abs(y - py) <= D for px, py in points):\n                    count += 1\n        return count\n\n    result = count_valid_pairs(points, D)\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n\n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n\n    def count_valid_pairs(points, D):\n        count = 0\n        for x in range(-D, D + 1):\n            for y in range(-D, D + 1):\n                if all(abs(x - px) + abs(y - py) <= D for px, py in points):\n                    count += 1\n        return count\n\n    result = count_valid_pairs(points, D)\n    print(result)\n\nmain()\n```"}
{"task_id": "arc181_b", "code": "def f(S, T, X):\n    return ''.join([S if x == '0' else T for x in X])\n\ndef solve_case(S, X, Y):\n    len_X = len(X)\n    len_Y = len(Y)\n    \n    # If X and Y are already equal, any T works\n    if X == Y:\n        return \"Yes\"\n    \n    # Otherwise, we need to check if we can find a T that makes the sequences equal\n    # This involves checking if the sequences can be made equal by adjusting T\n    # We can use the concept of periodicity and suffixes to determine this\n    \n    # Construct the sequences\n    seq_X = f(S, '', X)\n    seq_Y = f(S, '', Y)\n    \n    # Find the common prefix and suffix lengths\n    common_prefix_length = 0\n    common_suffix_length = 0\n    \n    while common_prefix_length < min(len(seq_X), len(seq_Y)) and seq_X[common_prefix_length] == seq_Y[common_prefix_length]:\n        common_prefix_length += 1\n    \n    while common_suffix_length < min(len(seq_X), len(seq_Y)) and seq_X[-(common_suffix_length + 1)] == seq_Y[-(common_suffix_length + 1)]:\n        common_suffix_length += 1\n    \n    # If the sequences can be made equal by adjusting T, return \"Yes\"\n    if common_prefix_length + common_suffix_length >= max(len(seq_X), len(seq_Y)):\n        return \"Yes\"\n    \n    return \"No\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        index += 1\n        X = data[index]\n        index += 1\n        Y = data[index]\n        index += 1\n        \n        result = solve_case(S, X, Y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    return ''.join([S if x == '0' else T for x in X])\n\ndef solve_case(S, X, Y):\n    len_X = len(X)\n    len_Y = len(Y)\n    \n    # If X and Y are already equal, any T works\n    if X == Y:\n        return \"Yes\"\n    \n    # Otherwise, we need to check if we can find a T that makes the sequences equal\n    # This involves checking if the sequences can be made equal by adjusting T\n    # We can use the concept of periodicity and suffixes to determine this\n    \n    # Construct the sequences\n    seq_X = f(S, '', X)\n    seq_Y = f(S, '', Y)\n    \n    # Find the common prefix and suffix lengths\n    common_prefix_length = 0\n    common_suffix_length = 0\n    \n    while common_prefix_length < min(len(seq_X), len(seq_Y)) and seq_X[common_prefix_length] == seq_Y[common_prefix_length]:\n        common_prefix_length += 1\n    \n    while common_suffix_length < min(len(seq_X), len(seq_Y)) and seq_X[-(common_suffix_length + 1)] == seq_Y[-(common_suffix_length + 1)]:\n        common_suffix_length += 1\n    \n    # If the sequences can be made equal by adjusting T, return \"Yes\"\n    if common_prefix_length + common_suffix_length >= max(len(seq_X), len(seq_Y)):\n        return \"Yes\"\n    \n    return \"No\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        index += 1\n        X = data[index]\n        index += 1\n        Y = data[index]\n        index += 1\n        \n        result = solve_case(S, X, Y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc366_g", "code": "def dfs(graph, node, visited, colors):\n    stack = [node]\n    while stack:\n        current = stack.pop()\n        if not visited[current]:\n            visited[current] = True\n            color = 0\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n                elif colors[neighbor] != 0:\n                    color ^= colors[neighbor]\n            colors[current] = color\n\ndef can_assign_values(n, m, edges):\n    if m == 0:\n        return \"Yes\\n1\"\n    \n    # Build the graph\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the graph is connected\n    visited = [False] * (n + 1)\n    dfs(graph, 1, visited, [0] * (n + 1))\n    \n    if not all(visited[1:]):\n        return \"No\"\n    \n    # Assign values using DFS\n    colors = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited, colors)\n    \n    # Print the result\n    result = []\n    for i in range(1, n + 1):\n        result.append(str(colors[i]))\n    \n    return f\"Yes\\n{' '.join(result)}\"\n\n# Example usage:\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(M):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\n\nprint(can_assign_values(N, M, edges))", "passed": false, "raw_code": "```python\ndef dfs(graph, node, visited, colors):\n    stack = [node]\n    while stack:\n        current = stack.pop()\n        if not visited[current]:\n            visited[current] = True\n            color = 0\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n                elif colors[neighbor] != 0:\n                    color ^= colors[neighbor]\n            colors[current] = color\n\ndef can_assign_values(n, m, edges):\n    if m == 0:\n        return \"Yes\\n1\"\n    \n    # Build the graph\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the graph is connected\n    visited = [False] * (n + 1)\n    dfs(graph, 1, visited, [0] * (n + 1))\n    \n    if not all(visited[1:]):\n        return \"No\"\n    \n    # Assign values using DFS\n    colors = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited, colors)\n    \n    # Print the result\n    result = []\n    for i in range(1, n + 1):\n        result.append(str(colors[i]))\n    \n    return f\"Yes\\n{' '.join(result)}\"\n\n# Example usage:\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(M):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\n\nprint(can_assign_values(N, M, edges))\n```"}
{"task_id": "abc369_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    # Calculate total length of all edges\n    total_length = sum(l for _, _, l in edges)\n    \n    # Function to calculate minimum path length for given K\n    def min_path_length(K):\n        if K == 1:\n            return total_length\n        else:\n            return 2 * total_length // K\n    \n    # Print results for each K\n    for K in range(1, N + 1):\n        print(min_path_length(K))\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    # Calculate total length of all edges\n    total_length = sum(l for _, _, l in edges)\n    \n    # Function to calculate minimum path length for given K\n    def min_path_length(K):\n        if K == 1:\n            return total_length\n        else:\n            return 2 * total_length // K\n    \n    # Print results for each K\n    for K in range(1, N + 1):\n        print(min_path_length(K))\n\nmain()\n```"}
{"task_id": "abc372_g", "code": "def count_valid_pairs(N, A, B, C):\n    total_count = 0\n    for i in range(1, N + 1):\n        if A[i - 1] == 0:\n            # Special case when A_i is zero, only y < C_i / B_i is valid\n            if C[i - 1] % B[i - 1] == 0:\n                max_y = (C[i - 1] // B[i - 1]) - 1\n            else:\n                max_y = C[i - 1] // B[i - 1]\n        else:\n            # General case\n            low, high = 1, C[i - 1] // A[i - 1]\n            while low <= high:\n                mid = (low + high) // 2\n                if A[i - 1] * mid + B[i - 1] * mid < C[i - 1]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            total_count += high\n    return total_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index + i]) for i in range(N)]\n        B = [int(data[index + N + i]) for i in range(N)]\n        C = [int(data[index + 2 * N + i]) for i in range(N)]\n        index += 3 * N\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef count_valid_pairs(N, A, B, C):\n    total_count = 0\n    for i in range(1, N + 1):\n        if A[i - 1] == 0:\n            # Special case when A_i is zero, only y < C_i / B_i is valid\n            if C[i - 1] % B[i - 1] == 0:\n                max_y = (C[i - 1] // B[i - 1]) - 1\n            else:\n                max_y = C[i - 1] // B[i - 1]\n        else:\n            # General case\n            low, high = 1, C[i - 1] // A[i - 1]\n            while low <= high:\n                mid = (low + high) // 2\n                if A[i - 1] * mid + B[i - 1] * mid < C[i - 1]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            total_count += high\n    return total_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index + i]) for i in range(N)]\n        B = [int(data[index + N + i]) for i in range(N)]\n        C = [int(data[index + 2 * N + i]) for i in range(N)]\n        index += 3 * N\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc373_g", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    lines = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        lines.append((x, y))\n        index += 2\n    \n    return N, points, lines\n\ndef build_graph(points, lines):\n    graph = defaultdict(list)\n    indegree = [0] * len(points)\n    \n    for i in range(len(points)):\n        for j in range(len(lines)):\n            # Check if the line segment between P[i] and Q[j] intersects with any previous segment\n            if not does_intersect(points[i], lines[j]):\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    return graph, indegree\n\ndef does_intersect(P1, Q1):\n    # Simplified method to check intersection using slopes and cross products\n    (x1, y1) = P1\n    (x2, y2) = Q1\n    if x1 == x2:\n        return False  # Vertical lines do not intersect with other vertical lines\n    slope = (y2 - y1) / (x2 - x1)\n    intercept = y1 - slope * x1\n    return True  # Placeholder, actual implementation needed\n\ndef topological_sort(graph, indegree):\n    queue = deque([i for i in range(len(indegree)) if indegree[i] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        \n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\ndef main():\n    N, points, lines = read_input()\n    graph, indegree = build_graph(points, lines)\n    \n    order = topological_sort(graph, indegree)\n    \n    if len(order) != N:\n        print(-1)\n    else:\n        print(' '.join(map(str, order + 1)))\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    lines = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        lines.append((x, y))\n        index += 2\n    \n    return N, points, lines\n\ndef build_graph(points, lines):\n    graph = defaultdict(list)\n    indegree = [0] * len(points)\n    \n    for i in range(len(points)):\n        for j in range(len(lines)):\n            # Check if the line segment between P[i] and Q[j] intersects with any previous segment\n            if not does_intersect(points[i], lines[j]):\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    return graph, indegree\n\ndef does_intersect(P1, Q1):\n    # Simplified method to check intersection using slopes and cross products\n    (x1, y1) = P1\n    (x2, y2) = Q1\n    if x1 == x2:\n        return False  # Vertical lines do not intersect with other vertical lines\n    slope = (y2 - y1) / (x2 - x1)\n    intercept = y1 - slope * x1\n    return True  # Placeholder, actual implementation needed\n\ndef topological_sort(graph, indegree):\n    queue = deque([i for i in range(len(indegree)) if indegree[i] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        \n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\ndef main():\n    N, points, lines = read_input()\n    graph, indegree = build_graph(points, lines)\n    \n    order = topological_sort(graph, indegree)\n    \n    if len(order) != N:\n        print(-1)\n    else:\n        print(' '.join(map(str, order + 1)))\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_d", "code": "def min_operations_to_transform(N, M, A, B):\n    # Convert lists to tuples for faster access\n    A = tuple(A)\n    B = tuple(B)\n    \n    # Initialize total operations counter\n    total_operations = 0\n    \n    # Iterate through each position in the sequence\n    for i in range(N):\n        if A[i] != B[i]:\n            # Calculate direct and circular differences\n            diff = abs(A[i] - B[i])\n            circ_diff = min(diff, M - diff)\n            \n            # Check if the current change maintains the good sequence property\n            if i > 0 and (A[i-1] == A[i] or B[i-1] == B[i]):\n                return -1\n            if i < N-1 and (A[i+1] == A[i] or B[i+1] == B[i]):\n                return -1\n            \n            # Add the operations needed for this position\n            total_operations += circ_diff\n    \n    return total_operations\n\n# Example usage:\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)", "passed": false, "raw_code": "```python\ndef min_operations_to_transform(N, M, A, B):\n    # Convert lists to tuples for faster access\n    A = tuple(A)\n    B = tuple(B)\n    \n    # Initialize total operations counter\n    total_operations = 0\n    \n    # Iterate through each position in the sequence\n    for i in range(N):\n        if A[i] != B[i]:\n            # Calculate direct and circular differences\n            diff = abs(A[i] - B[i])\n            circ_diff = min(diff, M - diff)\n            \n            # Check if the current change maintains the good sequence property\n            if i > 0 and (A[i-1] == A[i] or B[i-1] == B[i]):\n                return -1\n            if i < N-1 and (A[i+1] == A[i] or B[i+1] == B[i]):\n                return -1\n            \n            # Add the operations needed for this position\n            total_operations += circ_diff\n    \n    return total_operations\n\n# Example usage:\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)\n```"}
{"task_id": "3527", "code": "def countAlternatingGroups(colors, queries):\n    n = len(colors)\n    count = [0] * (n + 1)\n    \n    def check(i, j):\n        if (colors[i] != colors[j]) and ((i + 1) % n != j):\n            return True\n        return False\n    \n    for size in range(3, n + 1):\n        for start in range(n):\n            if check(start, (start + size - 1) % n):\n                count[size] += 1\n    \n    result = []\n    for q in queries:\n        if q[0] == 1:\n            result.append(count[q[1]])\n        else:\n            old_color = colors[q[1]]\n            colors[q[1]] = q[2]\n            for size in range(3, n + 1):\n                if q[1] >= size - 1:\n                    if check((q[1] - size + 1) % n, q[1]):\n                        count[size] -= 1\n                    if check(q[1], (q[1] + size) % n):\n                        count[size] -= 1\n                if q[1] < size - 1:\n                    if check((q[1] - size + 1) % n, q[1]):\n                        count[size] += 1\n                    if check(q[1], (q[1] + size) % n):\n                        count[size] += 1\n    return result", "passed": false, "raw_code": "```python\ndef countAlternatingGroups(colors, queries):\n    n = len(colors)\n    count = [0] * (n + 1)\n    \n    def check(i, j):\n        if (colors[i] != colors[j]) and ((i + 1) % n != j):\n            return True\n        return False\n    \n    for size in range(3, n + 1):\n        for start in range(n):\n            if check(start, (start + size - 1) % n):\n                count[size] += 1\n    \n    result = []\n    for q in queries:\n        if q[0] == 1:\n            result.append(count[q[1]])\n        else:\n            old_color = colors[q[1]]\n            colors[q[1]] = q[2]\n            for size in range(3, n + 1):\n                if q[1] >= size - 1:\n                    if check((q[1] - size + 1) % n, q[1]):\n                        count[size] -= 1\n                    if check(q[1], (q[1] + size) % n):\n                        count[size] -= 1\n                if q[1] < size - 1:\n                    if check((q[1] - size + 1) % n, q[1]):\n                        count[size] += 1\n                    if check(q[1], (q[1] + size) % n):\n                        count[size] += 1\n    return result\n```"}
{"task_id": "arc181_d", "code": "import sys\nfrom bisect import bisect_left, insort_right\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    # Initialize Fenwick Tree\n    fenwick_tree = [0] * (N + 1)\n\n    def update(index, value):\n        while index <= N:\n            fenwick_tree[index] += value\n            index += index & -index\n\n    def query(index):\n        result = 0\n        while index > 0:\n            result += fenwick_tree[index]\n            index -= index & -index\n        return result\n\n    # Calculate initial inversion number\n    inversions = sum(query(P[i]) for i in range(N))\n\n    results = []\n\n    for k in A:\n        # Find position of k in P\n        pos = bisect_left(P, k)\n\n        # Add k to Fenwick Tree\n        update(pos + 1, 1)\n\n        # Update inversion number\n        inversions -= pos - query(pos + 1)\n        inversions += N - pos - (pos - query(pos + 1))\n\n        results.append(inversions)\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "import sys\nfrom bisect import bisect_left, insort_right\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    # Initialize Fenwick Tree\n    fenwick_tree = [0] * (N + 1)\n\n    def update(index, value):\n        while index <= N:\n            fenwick_tree[index] += value\n            index += index & -index\n\n    def query(index):\n        result = 0\n        while index > 0:\n            result += fenwick_tree[index]\n            index -= index & -index\n        return result\n\n    # Calculate initial inversion number\n    inversions = sum(query(P[i]) for i in range(N))\n\n    results = []\n\n    for k in A:\n        # Find position of k in P\n        pos = bisect_left(P, k)\n\n        # Add k to Fenwick Tree\n        update(pos + 1, 1)\n\n        # Update inversion number\n        inversions -= pos - query(pos + 1)\n        inversions += N - pos - (pos - query(pos + 1))\n\n        results.append(inversions)\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "abc372_e", "code": "import heapq\nfrom collections import defaultdict\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = defaultdict(list)\n    \n    answers = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            \n            # Add edge\n            heapq.heappush(adj_list[u], v)\n            heapq.heappush(adj_list[v], u)\n            \n            # Ensure only the smallest k elements are kept\n            while len(adj_list[u]) > 1:\n                heapq.heappop(adj_list[u])\n            while len(adj_list[v]) > 1:\n                heapq.heappop(adj_list[v])\n        \n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            # Get k-th largest vertex\n            if k > len(adj_list[v]):\n                answers.append(-1)\n            else:\n                # Extract the smallest k elements to get the k-th largest\n                top_k = [-heapq.heappop(adj_list[v]) for _ in range(k)]\n                answers.append(top_k[-1])\n                # Push the extracted elements back into the heap\n                for x in reversed(top_k):\n                    heapq.heappush(adj_list[v], -x)\n    \n    for ans in answers:\n        print(ans)\n\nmain()", "passed": false, "raw_code": "```python\nimport heapq\nfrom collections import defaultdict\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = defaultdict(list)\n    \n    answers = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            \n            # Add edge\n            heapq.heappush(adj_list[u], v)\n            heapq.heappush(adj_list[v], u)\n            \n            # Ensure only the smallest k elements are kept\n            while len(adj_list[u]) > 1:\n                heapq.heappop(adj_list[u])\n            while len(adj_list[v]) > 1:\n                heapq.heappop(adj_list[v])\n        \n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            # Get k-th largest vertex\n            if k > len(adj_list[v]):\n                answers.append(-1)\n            else:\n                # Extract the smallest k elements to get the k-th largest\n                top_k = [-heapq.heappop(adj_list[v]) for _ in range(k)]\n                answers.append(top_k[-1])\n                # Push the extracted elements back into the heap\n                for x in reversed(top_k):\n                    heapq.heappush(adj_list[v], -x)\n    \n    for ans in answers:\n        print(ans)\n\nmain()\n```"}
{"task_id": "abc367_g", "code": "def xor_sum_of_subsequences(N, M, K, A):\n    MOD = 998244353\n    \n    def mod_pow(x, y):\n        if y == 0:\n            return 1\n        elif y % 2 == 0:\n            half_pow = mod_pow(x, y // 2)\n            return (half_pow * half_pow) % MOD\n        else:\n            return (x * mod_pow(x, y - 1)) % MOD\n    \n    total_score = 0\n    \n    for mask in range(1, 1 << N):\n        subseq = [A[i] for i in range(N) if mask & (1 << i)]\n        subseq_length = len(subseq)\n        \n        if subseq_length % M == 0:\n            subseq_xor = 0\n            for num in subseq:\n                subseq_xor ^= num\n            total_score += mod_pow(subseq_xor, K)\n    \n    return total_score % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Print the result\nprint(xor_sum_of_subsequences(N, M, K, A))", "passed": false, "raw_code": "```python\ndef xor_sum_of_subsequences(N, M, K, A):\n    MOD = 998244353\n    \n    def mod_pow(x, y):\n        if y == 0:\n            return 1\n        elif y % 2 == 0:\n            half_pow = mod_pow(x, y // 2)\n            return (half_pow * half_pow) % MOD\n        else:\n            return (x * mod_pow(x, y - 1)) % MOD\n    \n    total_score = 0\n    \n    for mask in range(1, 1 << N):\n        subseq = [A[i] for i in range(N) if mask & (1 << i)]\n        subseq_length = len(subseq)\n        \n        if subseq_length % M == 0:\n            subseq_xor = 0\n            for num in subseq:\n                subseq_xor ^= num\n            total_score += mod_pow(subseq_xor, K)\n    \n    return total_score % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Print the result\nprint(xor_sum_of_subsequences(N, M, K, A))\n```"}
{"task_id": "abc371_g", "code": "def min_lexicographic_array(N, P, A):\n    # Initialize visited array\n    visited = [False] * N\n    \n    for start in range(N):\n        if not visited[start]:\n            # Start a new cycle\n            cycle = []\n            current = start\n            while not visited[current]:\n                visited[current] = True\n                cycle.append(current)\n                current = P[current] - 1\n            \n            # Sort the cycle\n            cycle_values = [A[i] for i in cycle]\n            cycle_values.sort()\n            \n            # Place the sorted values back into the array\n            for i, value in zip(cycle, cycle_values):\n                A[i] = value\n    \n    # Print the result\n    print(' '.join(map(str, A)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\nmin_lexicographic_array(N, P, A)", "passed": false, "raw_code": "```python\ndef min_lexicographic_array(N, P, A):\n    # Initialize visited array\n    visited = [False] * N\n    \n    for start in range(N):\n        if not visited[start]:\n            # Start a new cycle\n            cycle = []\n            current = start\n            while not visited[current]:\n                visited[current] = True\n                cycle.append(current)\n                current = P[current] - 1\n            \n            # Sort the cycle\n            cycle_values = [A[i] for i in cycle]\n            cycle_values.sort()\n            \n            # Place the sorted values back into the array\n            for i, value in zip(cycle, cycle_values):\n                A[i] = value\n    \n    # Print the result\n    print(' '.join(map(str, A)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\nmin_lexicographic_array(N, P, A)\n```"}
{"task_id": "abc368_d", "code": "def min_vertices_in_subtree(N, K, edges, vertices):\n    # Build the adjacency list for the tree\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Function to perform DFS and find the LCA\n    def dfs(node, parent, path):\n        if node in vertices:\n            path.append(node)\n            if len(path) == K:\n                return True\n        found = False\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                found |= dfs(neighbor, node, path)\n        if found:\n            path.append(node)\n        return found\n\n    # Perform DFS to find the LCA\n    lca_path = []\n    dfs(vertices[0], -1, lca_path)\n\n    # Function to get the level of each vertex\n    levels = [float('inf')] * (N + 1)\n    queue = [(lca_path[-1], 0)]\n    while queue:\n        node, level = queue.pop(0)\n        levels[node] = level\n        for neighbor in adj_list[node]:\n            if levels[neighbor] == float('inf'):\n                queue.append((neighbor, level + 1))\n\n    # Calculate the minimum number of vertices in the subtree\n    min_vertices = float('inf')\n    for node in lca_path:\n        if levels[node] + 1 < min_vertices:\n            min_vertices = levels[node] + 1\n\n    return min_vertices\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N - 1)]\nvertices = list(map(int, data[N + 2:N + 2 + K]))\n\n# Print the result\nprint(min_vertices_in_subtree(N, K, edges, vertices))", "passed": false, "raw_code": "def min_vertices_in_subtree(N, K, edges, vertices):\n    # Build the adjacency list for the tree\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Function to perform DFS and find the LCA\n    def dfs(node, parent, path):\n        if node in vertices:\n            path.append(node)\n            if len(path) == K:\n                return True\n        found = False\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                found |= dfs(neighbor, node, path)\n        if found:\n            path.append(node)\n        return found\n\n    # Perform DFS to find the LCA\n    lca_path = []\n    dfs(vertices[0], -1, lca_path)\n\n    # Function to get the level of each vertex\n    levels = [float('inf')] * (N + 1)\n    queue = [(lca_path[-1], 0)]\n    while queue:\n        node, level = queue.pop(0)\n        levels[node] = level\n        for neighbor in adj_list[node]:\n            if levels[neighbor] == float('inf'):\n                queue.append((neighbor, level + 1))\n\n    # Calculate the minimum number of vertices in the subtree\n    min_vertices = float('inf')\n    for node in lca_path:\n        if levels[node] + 1 < min_vertices:\n            min_vertices = levels[node] + 1\n\n    return min_vertices\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N - 1)]\nvertices = list(map(int, data[N + 2:N + 2 + K]))\n\n# Print the result\nprint(min_vertices_in_subtree(N, K, edges, vertices))"}
{"task_id": "abc368_g", "code": "import sys\nfrom typing import List\n\ndef build_segment_tree(arr: List[int]) -> List[int]:\n    n = len(arr)\n    tree = [0] * (2 * n)\n    for i in range(n):\n        tree[n + i] = arr[i]\n    for i in range(n - 1, 0, -1):\n        tree[i] = max(tree[2 * i], tree[2 * i + 1])\n    return tree\n\ndef update_segment_tree(tree: List[int], index: int, value: int, n: int) -> None:\n    index += n\n    tree[index] = value\n    while index > 1:\n        index //= 2\n        tree[index] = max(tree[2 * index], tree[2 * index + 1])\n\ndef query_segment_tree(tree: List[int], left: int, right: int, n: int) -> int:\n    result = float('-inf')\n    left += n\n    right += n\n    while left < right:\n        if left % 2 == 1:\n            result = max(result, tree[left])\n            left += 1\n        if right % 2 == 1:\n            right -= 1\n            result = max(result, tree[right])\n        left //= 2\n        right //= 2\n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    A = list(map(int, data[1:n+1]))\n    B = list(map(int, data[n+1:2*n+1]))\n    Q = int(data[2*n+1])\n\n    tree_A = build_segment_tree(A)\n    tree_B = build_segment_tree(B)\n\n    index = 2 * n\n\n    results = []\n    for i in range(Q):\n        query_type = int(data[index])\n        index += 1\n\n        if query_type == 1:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            A[i] = x\n            update_segment_tree(tree_A, i, x, n)\n        elif query_type == 2:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            B[i] = x\n            update_segment_tree(tree_B, i, x, n)\n        elif query_type == 3:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            index += 2\n            v = 0\n            for j in range(l, r + 1):\n                v = max(v + A[j], v * B[j])\n            results.append(str(v))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "import sys\nfrom typing import List\n\ndef build_segment_tree(arr: List[int]) -> List[int]:\n    n = len(arr)\n    tree = [0] * (2 * n)\n    for i in range(n):\n        tree[n + i] = arr[i]\n    for i in range(n - 1, 0, -1):\n        tree[i] = max(tree[2 * i], tree[2 * i + 1])\n    return tree\n\ndef update_segment_tree(tree: List[int], index: int, value: int, n: int) -> None:\n    index += n\n    tree[index] = value\n    while index > 1:\n        index //= 2\n        tree[index] = max(tree[2 * index], tree[2 * index + 1])\n\ndef query_segment_tree(tree: List[int], left: int, right: int, n: int) -> int:\n    result = float('-inf')\n    left += n\n    right += n\n    while left < right:\n        if left % 2 == 1:\n            result = max(result, tree[left])\n            left += 1\n        if right % 2 == 1:\n            right -= 1\n            result = max(result, tree[right])\n        left //= 2\n        right //= 2\n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    A = list(map(int, data[1:n+1]))\n    B = list(map(int, data[n+1:2*n+1]))\n    Q = int(data[2*n+1])\n\n    tree_A = build_segment_tree(A)\n    tree_B = build_segment_tree(B)\n\n    index = 2 * n\n\n    results = []\n    for i in range(Q):\n        query_type = int(data[index])\n        index += 1\n\n        if query_type == 1:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            A[i] = x\n            update_segment_tree(tree_A, i, x, n)\n        elif query_type == 2:\n            i = int(data[index]) - 1\n            x = int(data[index + 1])\n            index += 2\n            B[i] = x\n            update_segment_tree(tree_B, i, x, n)\n        elif query_type == 3:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            index += 2\n            v = 0\n            for j in range(l, r + 1):\n                v = max(v + A[j], v * B[j])\n            results.append(str(v))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "abc370_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]));\n    prefix_sums = [0] * (N + 1)\n    for i in range(N):\n        prefix_sums[i+1] = prefix_sums[i] + A[i]\n    def can_distribute(x):\n        dp = [-float('inf')] * (K + 1)\n        dp[0] = 0\n        for i in range(1, N + 1):\n            new_dp = [-float('inf')] * (K + 1)\n            for j in range(K):\n                if dp[j] >= prefix_sums[i] - prefix_sums[i - 1]:\n                    new_dp[j] = max(new_dp[j], dp[j])\n                if dp[j] >= prefix_sums[i] - prefix_sums[i - 2]:\n                    new_dp[j] = max(new_dp[j], dp[j] + prefix_sums[i] - prefix_sums[i - 2])\n            dp = new_dp\n        return dp[K - 1] >= prefix_sums[N]\n    left, right = 0, prefix_sums[-1]\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_distribute(mid):\n            left = mid\n        else:\n            right = mid - 1\n    x = left\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            dp[j][i] = dp[j][i - 1]\n            if i >= 2 and dp[j][i - 2] + prefix_sums[i] - prefix_sums[i - 2] >= prefix_sums[i - 1]:\n                dp[j][i] = max(dp[j][i], dp[j][i - 2] + prefix_sums[i] - prefix_sums[i - 2])\n    cuts = set()\n    for i in range(1, N):\n        if dp[K - 1][i + 1] > dp[K - 1][i]:\n            cuts.add(i)\n    y = len(cuts)\n    print(x, y)\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]));\n    prefix_sums = [0] * (N + 1)\n    for i in range(N):\n        prefix_sums[i+1] = prefix_sums[i] + A[i]\n    def can_distribute(x):\n        dp = [-float('inf')] * (K + 1)\n        dp[0] = 0\n        for i in range(1, N + 1):\n            new_dp = [-float('inf')] * (K + 1)\n            for j in range(K):\n                if dp[j] >= prefix_sums[i] - prefix_sums[i - 1]:\n                    new_dp[j] = max(new_dp[j], dp[j])\n                if dp[j] >= prefix_sums[i] - prefix_sums[i - 2]:\n                    new_dp[j] = max(new_dp[j], dp[j] + prefix_sums[i] - prefix_sums[i - 2])\n            dp = new_dp\n        return dp[K - 1] >= prefix_sums[N]\n    left, right = 0, prefix_sums[-1]\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_distribute(mid):\n            left = mid\n        else:\n            right = mid - 1\n    x = left\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            dp[j][i] = dp[j][i - 1]\n            if i >= 2 and dp[j][i - 2] + prefix_sums[i] - prefix_sums[i - 2] >= prefix_sums[i - 1]:\n                dp[j][i] = max(dp[j][i], dp[j][i - 2] + prefix_sums[i] - prefix_sums[i - 2])\n    cuts = set()\n    for i in range(1, N):\n        if dp[K - 1][i + 1] > dp[K - 1][i]:\n            cuts.add(i)\n    y = len(cuts)\n    print(x, y)\nmain()"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    # Create a list of tuples (health, damage) and sort it by health\n    enemies = sorted(zip(health, damage))\n    \n    total_damage = 0\n    current_time = 0\n    \n    while enemies:\n        # Find the enemy with the maximum remaining health\n        max_health_enemy = max(enemies, key=lambda x: x[0])\n        \n        # Calculate how many attacks are needed to defeat this enemy\n        attacks_needed = -(-max_health_enemy[0] // power)  # Ceiling division\n        \n        # Update total damage Bob takes\n        total_damage += attacks_needed * max_health_enemy[1]\n        \n        # Remove the defeated enemy from the list\n        enemies.remove(max_health_enemy)\n    \n    return total_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    # Create a list of tuples (health, damage) and sort it by health\n    enemies = sorted(zip(health, damage))\n    \n    total_damage = 0\n    current_time = 0\n    \n    while enemies:\n        # Find the enemy with the maximum remaining health\n        max_health_enemy = max(enemies, key=lambda x: x[0])\n        \n        # Calculate how many attacks are needed to defeat this enemy\n        attacks_needed = -(-max_health_enemy[0] // power)  # Ceiling division\n        \n        # Update total damage Bob takes\n        total_damage += attacks_needed * max_health_enemy[1]\n        \n        # Remove the defeated enemy from the list\n        enemies.remove(max_health_enemy)\n    \n    return total_damage\n```"}
{"task_id": "3550", "code": "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(board[i]) for i in range(m)]\n    col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    selected_rows = set()\n    selected_cols = set()\n    selected_sum = 0\n    \n    for i in range(3):\n        for j in range(3):\n            if i not in selected_rows and j not in selected_cols:\n                selected_rows.add(i)\n                selected_cols.add(j)\n                selected_sum += row_sums[i] + col_sums[j]\n                break\n    \n    for i in selected_rows:\n        selected_sum -= board[i][i]\n    \n    return selected_sum", "passed": false, "raw_code": "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(board[i]) for i in range(m)]\n    col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    selected_rows = set()\n    selected_cols = set()\n    selected_sum = 0\n    \n    for i in range(3):\n        for j in range(3):\n            if i not in selected_rows and j not in selected_cols:\n                selected_rows.add(i)\n                selected_cols.add(j)\n                selected_sum += row_sums[i] + col_sums[j]\n                break\n    \n    for i in selected_rows:\n        selected_sum -= board[i][i]\n    \n    return selected_sum\n```"}
{"task_id": "3563", "code": "def maxScore(grid):\n    def backtrack(row, used_values, current_score):\n        if row == len(grid):\n            return current_score\n        \n        max_score = 0\n        for col in range(len(grid[0])):\n            if grid[row][col] not in used_values:\n                new_used_values = used_values | {grid[row][col]}\n                max_score = max(max_score, backtrack(row + 1, new_used_values, current_score + grid[row][col]))\n        \n        return max_score\n    \n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    # Start backtracking from the first row with an empty set of used values and zero score\n    return backtrack(0, set(), 0)", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    def backtrack(row, used_values, current_score):\n        if row == len(grid):\n            return current_score\n        \n        max_score = 0\n        for col in range(len(grid[0])):\n            if grid[row][col] not in used_values:\n                new_used_values = used_values | {grid[row][col]}\n                max_score = max(max_score, backtrack(row + 1, new_used_values, current_score + grid[row][col]))\n        \n        return max_score\n    \n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    # Start backtracking from the first row with an empty set of used values and zero score\n    return backtrack(0, set(), 0)\n```"}
{"task_id": "arc183_d", "code": "d", "passed": false, "raw_code": "```python\ndef find_leaves(tree):\n    leaves = []\n    for node, neighbors in tree.items():\n        if len(neighbors) == 1:\n            leaves.append(node)\n    return leaves\n\ndef get_distance(tree, start, end):\n    visited = set()\n    queue = [(start, 0)]\n    while queue:\n        node, dist = queue.pop(0)\n        if node == end:\n            return dist\n        visited.add(node)\n        for neighbor in tree[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, dist + 1))\n    return float('inf')\n\ndef solve_tree_operations(N, edges):\n    tree = {i: [] for i in range(1, N+1)}\n    for A, B in edges:\n        tree[A].append(B)\n        tree[B].append(A)\n    \n    result = []\n    leaves = find_leaves(tree)\n    leaves_set = set(leaves)\n    \n    while leaves_set:\n        farthest_leaf = max(leaves_set, key=lambda x: min(get_distance(tree, x, y) for y in leaves_set if x != y))\n        second_farthest_leaf = None\n        max_dist = 0\n        for leaf in leaves_set:\n            if leaf != farthest_leaf:\n                dist = get_distance(tree, farthest_leaf, leaf)\n                if dist > max_dist:\n                    max_dist = dist\n                    second_farthest_leaf = leaf\n        \n        result.append((farthest_leaf, second_farthest_leaf))\n        \n        # Remove leaves from the tree\n        tree[farthest_leaf] = [x for x in tree[farthest_leaf] if x != second_farthest_leaf]\n        tree[second_farthest_leaf] = [x for x in tree[second_farthest_leaf] if x != farthest_leaf]\n        \n        leaves_set.remove(farthest_leaf)\n        leaves_set.remove(second_farthest_leaf)\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[i*2+1]), int(data[i*2+2])) for i in range((N-1)//2)]\n\n# Solve and print the result\nresult = solve_tree_operations(N, edges)\nfor op in result:\n    print(op[0], op[1])"}
{"task_id": "abc369_e", "code": "import sys\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\ndef read_int():\n    global index\n    result = int(data[index])\n    index += 1\n    return result\ndef read_str():\n    global index\n    result = data[index]\n    index += 1\n    return result\n\ndef solve():\n    N = read_int()\n    M = read_int()\n    graph = defaultdict(list)\n    for _ in range(M):\n        u = read_int() - 1\n        v = read_int() - 1\n        t = read_int()\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    Q = read_int()\n    queries = []\n    for _ in range(Q):\n        K = read_int()\n        bridges = [read_int() - 1 for _ in range(K)]\n        queries.append(bridges)\n\n    def dp(start, end, mask, dist):\n        if (start, end, mask) in memo:\n            return memo[(start, end, mask)]\n        if mask == (1 << len(queries[0])) - 1:\n            return dist[end]\n        min_time = float('inf')\n        for next_node, next_dist in graph[start]:\n            new_mask = mask | (1 << next_node)\n            if new_mask != mask:\n                min_time = min(min_time, dp(next_node, end, new_mask, dist[next_node] + next_dist))\n        memo[(start, end, mask)] = min_time\n        return min_time\n\n    memo = {}\n    results = []\n    for q in queries:\n        start = 0\n        end = N - 1\n        mask = (1 << len(q)) - 1\n        results.append(dp(start, end, mask, {i: float('inf') for i in range(N)}))\n\n    for result in results:\n        print(result)\n\nsolve()", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\n\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\ndef read_int():\n    global index\n    result = int(data[index])\n    index += 1\n    return result\ndef read_str():\n    global index\n    result = data[index]\n    index += 1\n    return result\n\ndef solve():\n    N = read_int()\n    M = read_int()\n    graph = defaultdict(list)\n    for _ in range(M):\n        u = read_int() - 1\n        v = read_int() - 1\n        t = read_int()\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    Q = read_int()\n    queries = []\n    for _ in range(Q):\n        K = read_int()\n        bridges = [read_int() - 1 for _ in range(K)]\n        queries.append(bridges)\n\n    def dp(start, end, mask, dist):\n        if (start, end, mask) in memo:\n            return memo[(start, end, mask)]\n        if mask == (1 << len(queries[0])) - 1:\n            return dist[end]\n        min_time = float('inf')\n        for next_node, next_dist in graph[start]:\n            new_mask = mask | (1 << next_node)\n            if new_mask != mask:\n                min_time = min(min_time, dp(next_node, end, new_mask, dist[next_node] + next_dist))\n        memo[(start, end, mask)] = min_time\n        return min_time\n\n    memo = {}\n    results = []\n    for q in queries:\n        start = 0\n        end = N - 1\n        mask = (1 << len(q)) - 1\n        results.append(dp(start, end, mask, {i: float('inf') for i in range(N)}))\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    def dfs(x, y):\n        if (x, y) not in dp:\n            dp[(x, y)] = 1\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and coordinates[nx][ny] > coordinates[x][y]:\n                    dp[(x, y)] = max(dp[(x, y)], 1 + dfs(nx, ny))\n        return dp[(x, y)]\n    \n    coordinates.sort()\n    m, n = len(coordinates), len(coordinates[0])\n    dp = {}\n    max_path = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if i * n + j == k:\n                max_path = max(max_path, dfs(i, j))\n    \n    return max_path", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    def dfs(x, y):\n        if (x, y) not in dp:\n            dp[(x, y)] = 1\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and coordinates[nx][ny] > coordinates[x][y]:\n                    dp[(x, y)] = max(dp[(x, y)], 1 + dfs(nx, ny))\n        return dp[(x, y)]\n    \n    coordinates.sort()\n    m, n = len(coordinates), len(coordinates[0])\n    dp = {}\n    max_path = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if i * n + j == k:\n                max_path = max(max_path, dfs(i, j))\n    \n    return max_path\n```"}
{"task_id": "3552", "code": "def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = 10**(n-1)\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    \n    return \"-1\"  # In case no such number exists, though constraints should prevent this\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = 10**(n-1)\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    \n    return \"-1\"  # In case no such number exists, though constraints should prevent this\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n    \n    def count_palin_with_prefix(prefix):\n        if len(prefix) == n // 2:\n            palin = int(prefix + prefix[::-1])\n            if is_palindrome(palin) and palin % k == 0:\n                return 1\n            return 0\n        \n        count = 0\n        for digit in range(10):\n            if digit != 0 or len(prefix) > 0:\n                count += count_palin_with_prefix(prefix + str(digit))\n        return count\n    \n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    return count_palin_with_prefix(\"\")", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n    \n    def count_palin_with_prefix(prefix):\n        if len(prefix) == n // 2:\n            palin = int(prefix + prefix[::-1])\n            if is_palindrome(palin) and palin % k == 0:\n                return 1\n            return 0\n        \n        count = 0\n        for digit in range(10):\n            if digit != 0 or len(prefix) > 0:\n                count += count_palin_with_prefix(prefix + str(digit))\n        return count\n    \n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    return count_palin_with_prefix(\"\")\n```"}
{"task_id": "arc182_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    total_sum = 0\n    for k in range(K):\n        min_val = float('inf')\n        for i in range(N):\n            val = (C * k + A[i]) % M\n            if val < min_val:\n                min_val = val\n        total_sum += min_val\n\n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n\n    total_sum = 0\n    for k in range(K):\n        min_val = float('inf')\n        for i in range(N):\n            val = (C * k + A[i]) % M\n            if val < min_val:\n                min_val = val\n        total_sum += min_val\n\n    print(total_sum)\n\nmain()"}
{"task_id": "arc183_b", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        for num in A:\n            freq_A[num] += 1\n        for num in B:\n            freq_B[num] += 1\n        if freq_A == freq_B:\n            results.append('Yes')\n        else:\n            results.append('No')\n    for result in results:\n        print(result)\n\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        for num in A:\n            freq_A[num] += 1\n        for num in B:\n            freq_B[num] += 1\n        if freq_A == freq_B:\n            results.append('Yes')\n        else:\n            results.append('No')\n    for result in results:\n        print(result)\n\nmain()"}
{"task_id": "3560", "code": "def min_moves(kx, ky, px, py):\n    dx = abs(px - kx)\n    dy = abs(py - ky)\n    return max((dx + dy) // 3, (dx + dy + 2) // 3)\n\ndef max_alice_moves(kx, ky, positions):\n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        min_moves_for_pawn = float('inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(kx, ky, px, py)\n            new_pawns = pawns[:i] + pawns[i+1:]\n            if turn == 'Alice':\n                min_moves_for_pawn = min(min_moves_for_pawn, moves + dfs(new_pawns, 'Bob'))\n            else:\n                min_moves_for_pawn = max(min_moves_for_pawn, moves + dfs(new_pawns, 'Alice'))\n        return min_moves_for_pawn\n\n    return dfs(positions, 'Alice')", "passed": false, "raw_code": "def min_moves(kx, ky, px, py):\n    dx = abs(px - kx)\n    dy = abs(py - ky)\n    return max((dx + dy) // 3, (dx + dy + 2) // 3)\n\ndef max_alice_moves(kx, ky, positions):\n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        min_moves_for_pawn = float('inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(kx, ky, px, py)\n            new_pawns = pawns[:i] + pawns[i+1:]\n            if turn == 'Alice':\n                min_moves_for_pawn = min(min_moves_for_pawn, moves + dfs(new_pawns, 'Bob'))\n            else:\n                min_moves_for_pawn = max(min_moves_for_pawn, moves + dfs(new_pawns, 'Alice'))\n        return min_moves_for_pawn\n\n    return dfs(positions, 'Alice')"}
{"task_id": "3575", "code": "def max_value_subsequence(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    # Generate all combinations of indices for subsequences of size 2*k\n    from itertools import combinations\n    \n    for comb in combinations(range(n), 2 * k):\n        part1 = comb[:k]\n        part2 = comb[k:]\n        \n        or_part1 = 0\n        or_part2 = 0\n        \n        # Calculate OR for the first part\n        for num in part1:\n            or_part1 |= nums[num]\n        \n        # Calculate OR for the second part\n        for num in part2:\n            or_part2 |= nums[num]\n        \n        # Calculate the value of the current subsequence\n        value = or_part1 ^ or_part2\n        \n        # Update the maximum value\n        if value > max_val:\n            max_val = value\n    \n    return max_val", "passed": false, "raw_code": "```python\ndef max_value_subsequence(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    # Generate all combinations of indices for subsequences of size 2*k\n    from itertools import combinations\n    \n    for comb in combinations(range(n), 2 * k):\n        part1 = comb[:k]\n        part2 = comb[k:]\n        \n        or_part1 = 0\n        or_part2 = 0\n        \n        # Calculate OR for the first part\n        for num in part1:\n            or_part1 |= nums[num]\n        \n        # Calculate OR for the second part\n        for num in part2:\n            or_part2 |= nums[num]\n        \n        # Calculate the value of the current subsequence\n        value = or_part1 ^ or_part2\n        \n        # Update the maximum value\n        if value > max_val:\n            max_val = value\n    \n    return max_val\n```"}
{"task_id": "arc183_c", "code": "import sys\n\ndef count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    total_permutations = 0\n    \n    # Generate all permutations of [1, 2, ..., N]\n    from itertools import permutations\n    perms = permutations(range(1, N + 1))\n    \n    for perm in perms:\n        valid = True\n        for l, r, x in conditions:\n            max_val = max(perm[l - 1:r])\n            if max_val == perm[x - 1]:\n                valid = False\n                break\n        if valid:\n            total_permutations += 1\n    \n    return total_permutations % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = []\n    \n    idx = 2\n    for _ in range(M):\n        L = int(data[idx])\n        R = int(data[idx + 1])\n        X = int(data[idx + 2])\n        conditions.append((L, R, X))\n        idx += 3\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)", "passed": false, "raw_code": "```python\nimport sys\n\ndef count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    total_permutations = 0\n    \n    # Generate all permutations of [1, 2, ..., N]\n    from itertools import permutations\n    perms = permutations(range(1, N + 1))\n    \n    for perm in perms:\n        valid = True\n        for l, r, x in conditions:\n            max_val = max(perm[l - 1:r])\n            if max_val == perm[x - 1]:\n                valid = False\n                break\n        if valid:\n            total_permutations += 1\n    \n    return total_permutations % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = []\n    \n    idx = 2\n    for _ in range(M):\n        L = int(data[idx])\n        R = int(data[idx + 1])\n        X = int(data[idx + 2])\n        conditions.append((L, R, X))\n        idx += 3\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)\n```"}
{"task_id": "3583", "code": "from math import gcd\nfrom collections import defaultdict\nfrom typing import List\n\ndef getGcdPairs(nums: List[int], queries: List[int]) -> List[int]:\n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    gcd_list = []\n    for g, count in gcd_counts.items():\n        gcd_list.extend([g] * count)\n    \n    gcd_list.sort()\n    \n    result = []\n    for query in queries:\n        result.append(gcd_list[query])\n    \n    return result", "passed": false, "raw_code": "```python\nfrom math import gcd\nfrom collections import defaultdict\nfrom typing import List\n\ndef getGcdPairs(nums: List[int], queries: List[int]) -> List[int]:\n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    gcd_list = []\n    for g, count in gcd_counts.items():\n        gcd_list.extend([g] * count)\n    \n    gcd_list.sort()\n    \n    result = []\n    for query in queries:\n        result.append(gcd_list[query])\n    \n    return result\n```"}
{"task_id": "arc182_a", "code": "def count_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    for i in range(Q):\n        new_dp = [0] * (N + 1)\n        for j in range(N + 1):\n            if dp[j] == 0:\n                continue\n            if j + 1 <= P[i]:\n                new_dp[min(N, max(j, V[i] - 1))] = (new_dp[min(N, max(j, V[i] - 1))] + dp[j]) % MOD\n            if j <= P[i]:\n                new_dp[min(N, j + V[i] - 1)] = (new_dp[min(N, j + V[i] - 1)] + dp[j]) % MOD\n        dp = new_dp\n    \n    return dp[N] % MOD\n\n# Read input\nN, Q = map(int, input().split())\nP = []\nV = []\nfor _ in range(Q):\n    p, v = map(int, input().split())\n    P.append(p)\n    V.append(v)\n\n# Calculate and print the result\nresult = count_sequences(N, Q, P, V)\nprint(result)", "passed": false, "raw_code": "```python\ndef count_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    for i in range(Q):\n        new_dp = [0] * (N + 1)\n        for j in range(N + 1):\n            if dp[j] == 0:\n                continue\n            if j + 1 <= P[i]:\n                new_dp[min(N, max(j, V[i] - 1))] = (new_dp[min(N, max(j, V[i] - 1))] + dp[j]) % MOD\n            if j <= P[i]:\n                new_dp[min(N, j + V[i] - 1)] = (new_dp[min(N, j + V[i] - 1)] + dp[j]) % MOD\n        dp = new_dp\n    \n    return dp[N] % MOD\n\n# Read input\nN, Q = map(int, input().split())\nP = []\nV = []\nfor _ in range(Q):\n    p, v = map(int, input().split())\n    P.append(p)\n    V.append(v)\n\n# Calculate and print the result\nresult = count_sequences(N, Q, P, V)\nprint(result)\n```"}
{"task_id": "3551", "code": "def maxXorQueries(nums, queries):\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    root = TrieNode()\n\n    def insert(num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def getMaxXor(num):\n        max_xor = 0\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            opposite_bit = 1 - bit\n            if opposite_bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[opposite_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\n    # Sort queries by their end index to process them in order\n    sorted_queries = [(i, l, r) for i, (l, r) in enumerate(queries)]\n    sorted_queries.sort(key=lambda x: x[2])\n\n    result = [0] * len(queries)\n    i = 0\n    current_xors = set()\n\n    for j, l, r in sorted_queries:\n        while i <= r:\n            insert(nums[i])\n            current_xors.add(nums[i])\n            i += 1\n\n        while current_xors:\n            if getMinBit(current_xors) > r - l + 1:\n                break\n            current_num = current_xors.pop()\n            remove(current_num)\n\n        result[j] = getMaxXor(getMaxBit(current_xors))\n\n    return result\n\n# Helper functions for managing the Trie\n\ndef getMinBit(numbers):\n    min_bit = float('inf')\n    for num in numbers:\n        for i in range(31, -1, -1):\n            if (num >> i) & 1 == 1:\n                min_bit = min(min_bit, i)\n                break\n    return min_bit\n\n\ndef remove(num):\n    node = root\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        node.children[bit] = None\n        node = node.children[bit]\n", "passed": false, "raw_code": "def maxXorQueries(nums, queries):\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n\n    root = TrieNode()\n\n    def insert(num):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n\n    def getMaxXor(num):\n        max_xor = 0\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            opposite_bit = 1 - bit\n            if opposite_bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[opposite_bit]\n            else:\n                node = node.children[bit]\n        return max_xor\n\n    # Sort queries by their end index to process them in order\n    sorted_queries = [(i, l, r) for i, (l, r) in enumerate(queries)]\n    sorted_queries.sort(key=lambda x: x[2])\n\n    result = [0] * len(queries)\n    i = 0\n    current_xors = set()\n\n    for j, l, r in sorted_queries:\n        while i <= r:\n            insert(nums[i])\n            current_xors.add(nums[i])\n            i += 1\n\n        while current_xors:\n            if getMinBit(current_xors) > r - l + 1:\n                break\n            current_num = current_xors.pop()\n            remove(current_num)\n\n        result[j] = getMaxXor(getMaxBit(current_xors))\n\n    return result\n\n# Helper functions for managing the Trie\n\ndef getMinBit(numbers):\n    min_bit = float('inf')\n    for num in numbers:\n        for i in range(31, -1, -1):\n            if (num >> i) & 1 == 1:\n                min_bit = min(min_bit, i)\n                break\n    return min_bit\n\n\ndef remove(num):\n    node = root\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        node.children[bit] = None\n        node = node.children[bit]\n"}
{"task_id": "abc370_g", "code": "MOD = 998244353\n\ndef sum_of_divisors(n):\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef count_good_sequences(N, M):\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for i in range(1, M + 1):\n        for k in range(1, N + 1):\n            if is_good_integer(k):\n                for j in range(N, k - 1, -1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j//k]) % MOD\n    \n    return sum(dp[M][j] for j in range(1, N + 1)) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(count_good_sequences(N, M))", "passed": false, "raw_code": "```python\nMOD = 998244353\n\ndef sum_of_divisors(n):\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef count_good_sequences(N, M):\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for i in range(1, M + 1):\n        for k in range(1, N + 1):\n            if is_good_integer(k):\n                for j in range(N, k - 1, -1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j//k]) % MOD\n    \n    return sum(dp[M][j] for j in range(1, N + 1)) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(count_good_sequences(N, M))\n```"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"}
{"task_id": "arc182_c", "code": "MOD = 998244353\n\ndef count_divisors(n):\n    count = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            power = 0\n            while n % i == 0:\n                n //= i\n                power += 1\n            count *= (power + 1)\n    if n > 1:\n        count *= 2\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Precompute the number of divisors for all products\n    max_product = M**N\n    divisors = [0] * (max_product + 1)\n    for x in range(1, max_product + 1):\n        divisors[x] = count_divisors(x)\n    \n    # Calculate the total score\n    total_score = 0\n    for k in range(1, N + 1):\n        for m in range(1, M + 1):\n            total_score += divisors[m]\n            total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nMOD = 998244353\n\ndef count_divisors(n):\n    count = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            power = 0\n            while n % i == 0:\n                n //= i\n                power += 1\n            count *= (power + 1)\n    if n > 1:\n        count *= 2\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Precompute the number of divisors for all products\n    max_product = M**N\n    divisors = [0] * (max_product + 1)\n    for x in range(1, max_product + 1):\n        divisors[x] = count_divisors(x)\n    \n    # Calculate the total score\n    total_score = 0\n    for k in range(1, N + 1):\n        for m in range(1, M + 1):\n            total_score += divisors[m]\n            total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"final_accuracy": "0.00%"}
