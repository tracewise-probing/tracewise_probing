"{\"difficulty\": \"medium\", \"num_threads\": 32, \"temperature\": 0.7, \"n\": 1, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_vanilla_bug_trace_TPL_CODEEXECUTOR_qwen_7b_medium_n_1.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3518", "codes": ["def maxScore(a, b):\n    a.sort()\n    b.sort(reverse=True)\n    return sum(a[i] * b[i] for i in range(4))"], "passed": [false], "raw_code": ["```python\ndef maxScore(a, b):\n    a.sort()\n    b.sort(reverse=True)\n    return sum(a[i] * b[i] for i in range(4))\n```"]}
{"task_id": "3579", "codes": ["def max_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings based on their numerical value in descending order\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    result = int(concatenated_binary, 2)\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef max_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings based on their numerical value in descending order\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    result = int(concatenated_binary, 2)\n    \n    return result\n```"]}
{"task_id": "3534", "codes": ["def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    # Convert all numbers to strings for easy manipulation\n    num_strs = [str(num) for num in nums]\n    \n    # Iterate over all pairs of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            num1, num2 = num_strs[i], num_strs[j]\n            \n            # Try swapping all pairs of digits in num1\n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    swapped_num1 = num1[:k] + num1[l] + num1[k+1:l] + num1[k] + num1[l+1:]\n                    \n                    # Check if the swapped number matches any other number in the list\n                    if swapped_num1 in num_strs[j]:\n                        count += 1\n            \n            # Try swapping all pairs of digits in num2\n            for k in range(len(num2)):\n                for l in range(k + 1, len(num2)):\n                    swapped_num2 = num2[:k] + num2[l] + num2[k+1:l] + num2[k] + num2[l+1:]\n                    \n                    # Check if the swapped number matches any other number in the list\n                    if swapped_num2 in num_strs[i]:\n                        count += 1\n    \n    return count"], "passed": [false], "raw_code": ["```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    # Convert all numbers to strings for easy manipulation\n    num_strs = [str(num) for num in nums]\n    \n    # Iterate over all pairs of numbers\n    for i in range(n):\n        for j in range(i + 1, n):\n            num1, num2 = num_strs[i], num_strs[j]\n            \n            # Try swapping all pairs of digits in num1\n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    swapped_num1 = num1[:k] + num1[l] + num1[k+1:l] + num1[k] + num1[l+1:]\n                    \n                    # Check if the swapped number matches any other number in the list\n                    if swapped_num1 in num_strs[j]:\n                        count += 1\n            \n            # Try swapping all pairs of digits in num2\n            for k in range(len(num2)):\n                for l in range(k + 1, len(num2)):\n                    swapped_num2 = num2[:k] + num2[l] + num2[k+1:l] + num2[k] + num2[l+1:]\n                    \n                    # Check if the swapped number matches any other number in the list\n                    if swapped_num2 in num_strs[i]:\n                        count += 1\n    \n    return count\n```"]}
{"task_id": "3496", "codes": ["def min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def is_feasible(total_time):\n        remaining_height = mountainHeight\n        for worker_time in sorted(workerTimes):\n            current_time = 0\n            x = 1\n            while current_time < total_time and remaining_height > 0:\n                current_time += worker_time * x\n                if current_time <= total_time:\n                    remaining_height -= 1\n                    x += 1\n            if remaining_height == 0:\n                return True\n        return False\n\n    low = max(workerTimes)\n    high = sum(workerTimes) * mountainHeight\n    result = high\n\n    while low <= high:\n        mid = (low + high) // 2\n        if is_feasible(mid):\n            result = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return result"], "passed": [false], "raw_code": ["```python\ndef min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def is_feasible(total_time):\n        remaining_height = mountainHeight\n        for worker_time in sorted(workerTimes):\n            current_time = 0\n            x = 1\n            while current_time < total_time and remaining_height > 0:\n                current_time += worker_time * x\n                if current_time <= total_time:\n                    remaining_height -= 1\n                    x += 1\n            if remaining_height == 0:\n                return True\n        return False\n\n    low = max(workerTimes)\n    high = sum(workerTimes) * mountainHeight\n    result = high\n\n    while low <= high:\n        mid = (low + high) // 2\n        if is_feasible(mid):\n            result = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return result\n```"]}
{"task_id": "3522", "codes": ["def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        sorted_subarray = sorted(subarray)\n        \n        if all(sorted_subarray[j] + 1 == sorted_subarray[j + 1] for j in range(k - 1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results"], "passed": [false], "raw_code": ["```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        sorted_subarray = sorted(subarray)\n        \n        if all(sorted_subarray[j] + 1 == sorted_subarray[j + 1] for j in range(k - 1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```"]}
{"task_id": "3525", "codes": ["def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    max_boost_A = energyDrinkA[0]\n    max_boost_B = energyDrinkB[0]\n    \n    for i in range(1, n):\n        max_boost_A = max(max_boost_A + energyDrinkA[i], max_boost_B - 1 + energyDrinkA[i])\n        max_boost_B = max(max_boost_B + energyDrinkB[i], max_boost_A - 1 + energyDrinkB[i])\n    \n    return max(max_boost_A, max_boost_B)"], "passed": [false], "raw_code": ["```python\ndef maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    max_boost_A = energyDrinkA[0]\n    max_boost_B = energyDrinkB[0]\n    \n    for i in range(1, n):\n        max_boost_A = max(max_boost_A + energyDrinkA[i], max_boost_B - 1 + energyDrinkA[i])\n        max_boost_B = max(max_boost_B + energyDrinkB[i], max_boost_A - 1 + energyDrinkB[i])\n    \n    return max(max_boost_A, max_boost_B)\n```"]}
{"task_id": "3485", "codes": ["def maxScore(start, d):\n    start.sort()\n    max_diff = 0\n    for i in range(1, len(start)):\n        diff = start[i] - start[i-1]\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff"], "passed": [false], "raw_code": ["```python\ndef maxScore(start, d):\n    start.sort()\n    max_diff = 0\n    for i in range(1, len(start)):\n        diff = start[i] - start[i-1]\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n```"]}
{"task_id": "3528", "codes": ["def maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[n-1]"], "passed": [false], "raw_code": ["```python\ndef maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[n-1]\n```"]}
{"task_id": "3573", "codes": ["def countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    # Count character frequencies in word2\n    target_count = Counter(word2)\n    \n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    # Sliding window approach\n    for i in range(n - m + 1):\n        current_count = Counter()\n        for j in range(m):\n            current_count[word1[i + j]] += 1\n        \n        # Check if the current window's character counts meet or exceed the target counts\n        if all(current_count[char] >= target_count[char] for char in target_count):\n            count += 1\n    \n    return count"], "passed": [false], "raw_code": ["```python\ndef countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    # Count character frequencies in word2\n    target_count = Counter(word2)\n    \n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    # Sliding window approach\n    for i in range(n - m + 1):\n        current_count = Counter()\n        for j in range(m):\n            current_count[word1[i + j]] += 1\n        \n        # Check if the current window's character counts meet or exceed the target counts\n        if all(current_count[char] >= target_count[char] for char in target_count):\n            count += 1\n    \n    return count\n```"]}
{"task_id": "3558", "codes": ["def hasPath(grid, health):\n    def dfs(x, y, health):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or health <= 0:\n            return False\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return health >= 1\n        \n        temp = grid[x][y]\n        grid[x][y] = 2  # Mark the cell as visited\n        \n        if dfs(x + 1, y, health - temp) or dfs(x - 1, y, health - temp) or dfs(x, y + 1, health - temp) or dfs(x, y - 1, health - temp):\n            return True\n        \n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)"], "passed": [false], "raw_code": ["```python\ndef hasPath(grid, health):\n    def dfs(x, y, health):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or health <= 0:\n            return False\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return health >= 1\n        \n        temp = grid[x][y]\n        grid[x][y] = 2  # Mark the cell as visited\n        \n        if dfs(x + 1, y, health - temp) or dfs(x - 1, y, health - temp) or dfs(x, y + 1, health - temp) or dfs(x, y - 1, health - temp):\n            return True\n        \n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)\n```"]}
{"task_id": "3526", "codes": ["def minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_rows():\n        count = 0\n        for row in grid:\n            for i in range((n + 1) // 2):\n                if row[i] != row[n - 1 - i]:\n                    count += 1\n        return count\n    \n    def flips_for_columns():\n        count = 0\n        for j in range(n):\n            for i in range((m + 1) // 2):\n                if grid[i][j] != grid[m - 1 - i][j]:\n                    count += 1\n        return count\n    \n    return min(flips_for_rows(), flips_for_columns())"], "passed": [true], "raw_code": ["```python\ndef minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_rows():\n        count = 0\n        for row in grid:\n            for i in range((n + 1) // 2):\n                if row[i] != row[n - 1 - i]:\n                    count += 1\n        return count\n    \n    def flips_for_columns():\n        count = 0\n        for j in range(n):\n            for i in range((m + 1) // 2):\n                if grid[i][j] != grid[m - 1 - i][j]:\n                    count += 1\n        return count\n    \n    return min(flips_for_rows(), flips_for_columns())\n```"]}
{"task_id": "3540", "codes": ["def hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)"], "passed": [true], "raw_code": ["```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```"]}
{"task_id": "3584", "codes": ["def find_smallest_sequence(word1, word2):\n    n, m = len(word1), len(word2)\n    mismatch_indices = []\n\n    # Identify all mismatched indices\n    for i in range(n):\n        if i < m and word1[i] != word2[i]:\n            mismatch_indices.append(i)\n\n    # If there are no mismatches, return an empty list\n    if not mismatch_indices:\n        return []\n\n    # Construct the smallest sequence\n    result = []\n    for idx in mismatch_indices:\n        if len(result) == 0 or idx > result[-1]:\n            result.append(idx)\n        else:\n            break\n\n    # Check if the constructed sequence is valid\n    transformed_word = list(word1)\n    for idx in result:\n        transformed_word[idx] = word2[idx]\n\n    # Convert back to string and check if it is almost equal to word2\n    transformed_str = ''.join(transformed_word)\n    diff_count = sum(1 for a, b in zip(transformed_str, word2) if a != b)\n\n    if diff_count > 1:\n        return []\n\n    return result"], "passed": [false], "raw_code": ["```python\ndef find_smallest_sequence(word1, word2):\n    n, m = len(word1), len(word2)\n    mismatch_indices = []\n\n    # Identify all mismatched indices\n    for i in range(n):\n        if i < m and word1[i] != word2[i]:\n            mismatch_indices.append(i)\n\n    # If there are no mismatches, return an empty list\n    if not mismatch_indices:\n        return []\n\n    # Construct the smallest sequence\n    result = []\n    for idx in mismatch_indices:\n        if len(result) == 0 or idx > result[-1]:\n            result.append(idx)\n        else:\n            break\n\n    # Check if the constructed sequence is valid\n    transformed_word = list(word1)\n    for idx in result:\n        transformed_word[idx] = word2[idx]\n\n    # Convert back to string and check if it is almost equal to word2\n    transformed_str = ''.join(transformed_word)\n    diff_count = sum(1 for a, b in zip(transformed_str, word2) if a != b)\n\n    if diff_count > 1:\n        return []\n\n    return result\n```"]}
{"task_id": "3541", "codes": ["def is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            if word in word_count:\n                word_count[word] += 1\n                if word_count[word] >= 2:\n                    return True\n            else:\n                word_count[word] = 1\n    \n    return False"], "passed": [false], "raw_code": ["```python\ndef is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            if word in word_count:\n                word_count[word] += 1\n                if word_count[word] >= 2:\n                    return True\n            else:\n                word_count[word] = 1\n    \n    return False\n```"]}
{"task_id": "3559", "codes": ["def minValidStrings(words, target):\n    dp = [float('inf')] * (len(target) + 1)\n    dp[0] = 0\n    \n    for i in range(1, len(target) + 1):\n        for word in words:\n            if i >= len(word) and target[i - len(word):i] == word[:len(word)]:\n                dp[i] = min(dp[i], dp[i - len(word)] + 1)\n    \n    return dp[-1] if dp[-1] != float('inf') else -1"], "passed": [false], "raw_code": ["```python\ndef minValidStrings(words, target):\n    dp = [float('inf')] * (len(target) + 1)\n    dp[0] = 0\n    \n    for i in range(1, len(target) + 1):\n        for word in words:\n            if i >= len(word) and target[i - len(word):i] == word[:len(word)]:\n                dp[i] = min(dp[i], dp[i - len(word)] + 1)\n    \n    return dp[-1] if dp[-1] != float('inf') else -1\n```"]}
{"task_id": "3510", "codes": ["def maxTowerHeight(maximumHeight):\n    maximumHeight.sort(reverse=True)\n    heights = set()\n    current_height = 1\n    \n    for max_height in maximumHeight:\n        while current_height in heights or current_height > max_height:\n            current_height += 1\n        if current_height > max_height:\n            return -1\n        heights.add(current_height)\n        current_height += 1\n    \n    return sum(heights)"], "passed": [false], "raw_code": ["```python\ndef maxTowerHeight(maximumHeight):\n    maximumHeight.sort(reverse=True)\n    heights = set()\n    current_height = 1\n    \n    for max_height in maximumHeight:\n        while current_height in heights or current_height > max_height:\n            current_height += 1\n        if current_height > max_height:\n            return -1\n        heights.add(current_height)\n        current_height += 1\n    \n    return sum(heights)\n```"]}
{"task_id": "3570", "codes": ["def countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    vowel_positions = {v: [] for v in vowels}\n    \n    # Record positions of vowels\n    for i, char in enumerate(word):\n        if char in vowels:\n            vowel_positions[char].append(i)\n    \n    count = 0\n    \n    # Iterate over each vowel as the starting point of the substring\n    for v1 in vowels:\n        for v2 in vowels:\n            for v3 in vowels:\n                for v4 in vowels:\n                    for v5 in vowels:\n                        # Get positions of the current vowels\n                        pos1 = vowel_positions[v1]\n                        pos2 = vowel_positions[v2]\n                        pos3 = vowel_positions[v3]\n                        pos4 = vowel_positions[v4]\n                        pos5 = vowel_positions[v5]\n                        \n                        # Find the maximum and minimum positions of the vowels\n                        max_pos = max(pos1[-1], pos2[-1], pos3[-1], pos4[-1], pos5[-1])\n                        min_pos = min(pos1[0], pos2[0], pos3[0], pos4[0], pos5[0])\n                        \n                        # Calculate the number of consonants in the substring\n                        consonant_count = max_pos - min_pos - 4\n                        \n                        # Check if the consonant count is exactly k\n                        if consonant_count == k:\n                            count += 1\n    \n    return count"], "passed": [false], "raw_code": ["```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    vowel_positions = {v: [] for v in vowels}\n    \n    # Record positions of vowels\n    for i, char in enumerate(word):\n        if char in vowels:\n            vowel_positions[char].append(i)\n    \n    count = 0\n    \n    # Iterate over each vowel as the starting point of the substring\n    for v1 in vowels:\n        for v2 in vowels:\n            for v3 in vowels:\n                for v4 in vowels:\n                    for v5 in vowels:\n                        # Get positions of the current vowels\n                        pos1 = vowel_positions[v1]\n                        pos2 = vowel_positions[v2]\n                        pos3 = vowel_positions[v3]\n                        pos4 = vowel_positions[v4]\n                        pos5 = vowel_positions[v5]\n                        \n                        # Find the maximum and minimum positions of the vowels\n                        max_pos = max(pos1[-1], pos2[-1], pos3[-1], pos4[-1], pos5[-1])\n                        min_pos = min(pos1[0], pos2[0], pos3[0], pos4[0], pos5[0])\n                        \n                        # Calculate the number of consonants in the substring\n                        consonant_count = max_pos - min_pos - 4\n                        \n                        # Check if the consonant count is exactly k\n                        if consonant_count == k:\n                            count += 1\n    \n    return count\n```"]}
{"task_id": "3517", "codes": ["import heapq\n\ndef shortest_path(n, queries):\n    # Initialize the graph with the initial roads\n    graph = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        graph[i].append((i + 1, 1))\n    \n    def dijkstra(start, end):\n        dist = [float('inf')] * n\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, u = heapq.heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            for v, weight in graph[u]:\n                distance = current_dist + weight\n                if distance < dist[v]:\n                    dist[v] = distance\n                    heapq.heappush(pq, (distance, v))\n        \n        return dist[end]\n    \n    results = []\n    for u, v in queries:\n        graph[u].append((v, 1))\n        results.append(dijkstra(0, n - 1))\n    \n    return results"], "passed": [true], "raw_code": ["```python\nimport heapq\n\ndef shortest_path(n, queries):\n    # Initialize the graph with the initial roads\n    graph = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        graph[i].append((i + 1, 1))\n    \n    def dijkstra(start, end):\n        dist = [float('inf')] * n\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, u = heapq.heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            for v, weight in graph[u]:\n                distance = current_dist + weight\n                if distance < dist[v]:\n                    dist[v] = distance\n                    heapq.heappush(pq, (distance, v))\n        \n        return dist[end]\n    \n    results = []\n    for u, v in queries:\n        graph[u].append((v, 1))\n        results.append(dijkstra(0, n - 1))\n    \n    return results\n```"]}
{"task_id": "3495", "codes": ["import heapq\n\ndef kth_nearest_obstacle_distance(queries, k):\n    # Initialize a min-heap to store distances\n    heap = []\n    results = []\n    \n    for x, y in queries:\n        # Calculate the distance of the new obstacle\n        distance = abs(x) + abs(y)\n        \n        # Push the distance into the heap\n        heapq.heappush(heap, distance)\n        \n        # If the heap size exceeds k, remove the largest distance\n        if len(heap) > k:\n            heapq.heappop(heap)\n        \n        # If the heap size is less than k, append -1\n        if len(heap) < k:\n            results.append(-1)\n        else:\n            # Otherwise, append the k-th smallest distance (root of the heap)\n            results.append(heap[0])\n    \n    return results"], "passed": [false], "raw_code": ["```python\nimport heapq\n\ndef kth_nearest_obstacle_distance(queries, k):\n    # Initialize a min-heap to store distances\n    heap = []\n    results = []\n    \n    for x, y in queries:\n        # Calculate the distance of the new obstacle\n        distance = abs(x) + abs(y)\n        \n        # Push the distance into the heap\n        heapq.heappush(heap, distance)\n        \n        # If the heap size exceeds k, remove the largest distance\n        if len(heap) > k:\n            heapq.heappop(heap)\n        \n        # If the heap size is less than k, append -1\n        if len(heap) < k:\n            results.append(-1)\n        else:\n            # Otherwise, append the k-th smallest distance (root of the heap)\n            results.append(heap[0])\n    \n    return results\n```"]}
{"final_accuracy": "15.79%"}
