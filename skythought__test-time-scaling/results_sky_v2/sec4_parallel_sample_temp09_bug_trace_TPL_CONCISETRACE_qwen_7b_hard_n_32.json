"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.9, \"n\": 32, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_temp09_bug_trace_TPL_CONCISETRACE_qwen_7b_hard_n_32.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42, \"resume\": true}"
{"task_id": "abc368_f", "codes": ["def determine_winner(N, A):\n    # Count how many numbers are greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    # If the count is odd, Anna wins; otherwise, Bruno wins\n    if count_greater_than_one % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine the winner\nwinner = determine_winner(N, A)\nprint(winner)", "def determine_winner(N, A):\n    import math\n    for i in range(N-1, -1, -1):\n        if A[i] > 2:\n            for x in range(2, A[i]):\n                if A[i] % x == 0:\n                    A[i] = x\n                    break\n            return 'Anna'\n    return 'Bruno'\n\nimport sys\ninput = sys.stdin.read\nN, A = map(int, input().strip().split()), list(map(int, input().strip().split()))\nprint(determine_winner(N, A))", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count how many numbers are not 2\n    count_not_two = sum(1 for num in A if num != 2)\n    \n    # If there is an odd number of such numbers, Anna wins; otherwise, Bruno wins\n    if count_not_two % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # If there's any number greater than 2, Anna can always win\n    if any(a > 2 for a in A):\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner(N, A):\n    # Check if there is at least one even number in the sequence\n    has_even = any(num % 2 == 0 for num in A)\n    \n    # If there is at least one even number, Anna wins; otherwise, Bruno wins\n    if has_even:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\ndetermine_winner(N, A)", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of elements greater than 1\n    count_greater_than_1 = sum(1 for num in A if num > 1)\n    \n    # Determine the winner based on the parity of the count\n    if count_greater_than_1 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers\n    odd_count = sum(1 for num in A if num % 2 != 0)\n    \n    # Determine the winner based on the parity of the number of odd numbers\n    if odd_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    num_odd = sum(1 for x in A if x % 2 != 0)\n    \n    if num_odd % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_2 = sum(1 for num in A if num > 2)\n    \n    if count_greater_than_2 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner(N, A):\n    # Since Anna can always force Bruno to make the last move, Anna wins\n    return \"Anna\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))", "```python\ndef who_wins(n, A):\n    count = 0\n    for a in A:\n        while a % 2 == 0:\n            a //= 2\n        if a != 1:\n            count += 1\n    if count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nA = list(map(int, data[1:]))\nwho_wins(n, A)", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_2 = sum(1 for x in A if x > 2)\n    \n    if count_greater_than_2 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "import sys\n\ndef determine_winner(N, A):\n    perfect_squares = [1] * N\n    for i in range(N):\n        if int(A[i]**0.5) ** 2 == A[i]:\n            perfect_squares[i] = 0\n    if sum(perfect_squares) % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    print(determine_winner(N, A))\n\nmain()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def is_composite(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return True\n        return False\n    \n    composite_count = sum(is_composite(x) for x in A)\n    \n    if composite_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner(N, A):\n    # Check if there is at least one odd number\n    has_odd = any(x % 2 != 0 for x in A)\n    \n    if has_odd:\n        return \"Bruno\"\n    else:\n        return \"Anna\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))", "def determine_winner(N, A):\n    # Count how many numbers are even\n    even_count = sum(1 for num in A if num % 2 == 0)\n    # If there's at least one even number, Anna wins; otherwise, Bruno wins\n    if even_count > 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner(int(input()), list(map(int, input().split())))", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_2 = sum(1 for x in A if x > 2)\n    \n    if count_greater_than_2 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner(N, A):\n    def count_distinct_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n //= i\n        if n > 2:\n            factors.add(n)\n        return len(factors)\n    \n    odd_count = sum(count_distinct_prime_factors(a) % 2 for a in A)\n    \n    if odd_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\ndetermine_winner(N, A)", "def determine_winner(N, A):\n    # Check if there is any number greater than 1\n    for num in A:\n        if num > 1:\n            return \"Anna\"\n    return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers in the sequence\n    odd_count = sum(1 for num in A if num % 2 != 0)\n    \n    # If there are more odd numbers, Anna wins; otherwise, Bruno wins\n    if odd_count > 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def can_make_move(n):\n        return n > 2\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    # Since Anna goes first, we check if there's any number that is not prime\n    for num in A:\n        if not is_prime(num):\n            print(\"Anna\")\n            return\n    \n    print(\"Bruno\")\n\n# Call the function to execute the code\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner(N, A):\n    for num in A:\n        if num > 2:\n            print(\"Anna\")\n            return\n    print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\ndetermine_winner(N, A)", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def count_prime_factors(n):\n        count = 0\n        # Check for number of 2s that divide n\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                count += 1\n                n //= i\n        # This condition is to check if n is a prime number greater than 2\n        if n > 2:\n            count += 1\n        return count\n    \n    has_single_prime_factor = False\n    for num in A:\n        if count_prime_factors(num) == 1:\n            has_single_prime_factor = True\n            break\n    \n    if has_single_prime_factor:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Check if all numbers are already prime\n    all_prime = all(is_prime(a) for a in A)\n    \n    # If all numbers are prime, Bruno wins; otherwise, Anna wins\n    if all_prime:\n        print(\"Bruno\")\n    else:\n        print(\"Anna\")\n\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count how many numbers are greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers\n    odd_count = sum(1 for num in A if num % 2 != 0)\n    \n    # If the number of odd numbers is odd, Anna wins; otherwise, Bruno wins\n    if odd_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count numbers greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    # Determine the winner based on the count\n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Check if there is any perfect square in the initial list\n    has_perfect_square = any(x**0.5 == int(x**0.5) for x in A)\n    \n    if has_perfect_square:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of elements greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    # Determine the winner based on the parity of the count\n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function to execute the code\ndetermine_winner()", "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers\n    num_odds = sum(1 for x in A if x % 2 != 0)\n    \n    # Determine the winner based on the count of odd numbers\n    if num_odds % 2 == 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef determine_winner(N, A):\n    # Count how many numbers are greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    # If the count is odd, Anna wins; otherwise, Bruno wins\n    if count_greater_than_one % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine the winner\nwinner = determine_winner(N, A)\nprint(winner)\n```", "def determine_winner(N, A):\n    import math\n    for i in range(N-1, -1, -1):\n        if A[i] > 2:\n            for x in range(2, A[i]):\n                if A[i] % x == 0:\n                    A[i] = x\n                    break\n            return 'Anna'\n    return 'Bruno'\n\nimport sys\ninput = sys.stdin.read\nN, A = map(int, input().strip().split()), list(map(int, input().strip().split()))\nprint(determine_winner(N, A))", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count how many numbers are not 2\n    count_not_two = sum(1 for num in A if num != 2)\n    \n    # If there is an odd number of such numbers, Anna wins; otherwise, Bruno wins\n    if count_not_two % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # If there's any number greater than 2, Anna can always win\n    if any(a > 2 for a in A):\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner(N, A):\n    # Check if there is at least one even number in the sequence\n    has_even = any(num % 2 == 0 for num in A)\n    \n    # If there is at least one even number, Anna wins; otherwise, Bruno wins\n    if has_even:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\ndetermine_winner(N, A)\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of elements greater than 1\n    count_greater_than_1 = sum(1 for num in A if num > 1)\n    \n    # Determine the winner based on the parity of the count\n    if count_greater_than_1 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers\n    odd_count = sum(1 for num in A if num % 2 != 0)\n    \n    # Determine the winner based on the parity of the number of odd numbers\n    if odd_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    num_odd = sum(1 for x in A if x % 2 != 0)\n    \n    if num_odd % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_2 = sum(1 for num in A if num > 2)\n    \n    if count_greater_than_2 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner(N, A):\n    # Since Anna can always force Bruno to make the last move, Anna wins\n    return \"Anna\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))\n```", "```python\ndef who_wins(n, A):\n    count = 0\n    for a in A:\n        while a % 2 == 0:\n            a //= 2\n        if a != 1:\n            count += 1\n    if count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nA = list(map(int, data[1:]))\nwho_wins(n, A)", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_2 = sum(1 for x in A if x > 2)\n    \n    if count_greater_than_2 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\nimport sys\n\ndef determine_winner(N, A):\n    perfect_squares = [1] * N\n    for i in range(N):\n        if int(A[i]**0.5) ** 2 == A[i]:\n            perfect_squares[i] = 0\n    if sum(perfect_squares) % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    print(determine_winner(N, A))\n\nmain()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def is_composite(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return True\n        return False\n    \n    composite_count = sum(is_composite(x) for x in A)\n    \n    if composite_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner(N, A):\n    # Check if there is at least one odd number\n    has_odd = any(x % 2 != 0 for x in A)\n    \n    if has_odd:\n        return \"Bruno\"\n    else:\n        return \"Anna\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))\n```", "def determine_winner(N, A):\n    # Count how many numbers are even\n    even_count = sum(1 for num in A if num % 2 == 0)\n    # If there's at least one even number, Anna wins; otherwise, Bruno wins\n    if even_count > 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner(int(input()), list(map(int, input().split())))", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_2 = sum(1 for x in A if x > 2)\n    \n    if count_greater_than_2 % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner(N, A):\n    def count_distinct_prime_factors(n):\n        factors = set()\n        while n % 2 == 0:\n            factors.add(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.add(i)\n                n //= i\n        if n > 2:\n            factors.add(n)\n        return len(factors)\n    \n    odd_count = sum(count_distinct_prime_factors(a) % 2 for a in A)\n    \n    if odd_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\ndetermine_winner(N, A)\n```", "```python\ndef determine_winner(N, A):\n    # Check if there is any number greater than 1\n    for num in A:\n        if num > 1:\n            return \"Anna\"\n    return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\nprint(determine_winner(N, A))\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers in the sequence\n    odd_count = sum(1 for num in A if num % 2 != 0)\n    \n    # If there are more odd numbers, Anna wins; otherwise, Bruno wins\n    if odd_count > 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def can_make_move(n):\n        return n > 2\n    \n    def is_prime(n):\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    # Since Anna goes first, we check if there's any number that is not prime\n    for num in A:\n        if not is_prime(num):\n            print(\"Anna\")\n            return\n    \n    print(\"Bruno\")\n\n# Call the function to execute the code\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    if N % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner(N, A):\n    for num in A:\n        if num > 2:\n            print(\"Anna\")\n            return\n    print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\ndetermine_winner(N, A)\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def count_prime_factors(n):\n        count = 0\n        # Check for number of 2s that divide n\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                count += 1\n                n //= i\n        # This condition is to check if n is a prime number greater than 2\n        if n > 2:\n            count += 1\n        return count\n    \n    has_single_prime_factor = False\n    for num in A:\n        if count_prime_factors(num) == 1:\n            has_single_prime_factor = True\n            break\n    \n    if has_single_prime_factor:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    # Check if all numbers are already prime\n    all_prime = all(is_prime(a) for a in A)\n    \n    # If all numbers are prime, Bruno wins; otherwise, Anna wins\n    if all_prime:\n        print(\"Bruno\")\n    else:\n        print(\"Anna\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count how many numbers are greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers\n    odd_count = sum(1 for num in A if num % 2 != 0)\n    \n    # If the number of odd numbers is odd, Anna wins; otherwise, Bruno wins\n    if odd_count % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count numbers greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    # Determine the winner based on the count\n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Check if there is any perfect square in the initial list\n    has_perfect_square = any(x**0.5 == int(x**0.5) for x in A)\n    \n    if has_perfect_square:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of elements greater than 1\n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    # Determine the winner based on the parity of the count\n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function to execute the code\ndetermine_winner()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Count the number of odd numbers\n    num_odds = sum(1 for x in A if x % 2 != 0)\n    \n    # Determine the winner based on the count of odd numbers\n    if num_odds % 2 == 0:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    result = 0\n    \n    for i in range(n):\n        for j in range(51):\n            k = nums[i] - j\n            if 0 <= k <= 50:\n                arr1 = [j] * (i + 1)\n                arr2 = [k] * (i + 1)\n                \n                # Check if arr1 is non-decreasing\n                non_decreasing = True\n                for l in range(1, i + 1):\n                    if arr1[l] < arr1[l - 1]:\n                        non_decreasing = False\n                        break\n                \n                # Check if arr2 is non-increasing\n                non_increasing = True\n                for l in range(1, i + 1):\n                    if arr2[l] > arr2[l - 1]:\n                        non_increasing = False\n                        break\n                \n                if non_decreasing and non_increasing:\n                    result += 1\n                    \n    return result % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        dp[i][i] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if nums[j - 1] - j >= 0:\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]\n                dp[i][j] %= MOD\n    \n    total_count = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if nums[j - 1] - j >= 0:\n                total_count += dp[i][j]\n                total_count %= MOD\n    \n    return total_count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    non_decreasing = [0] * 51\n    non_increasing = [0] * 51\n    result = 0\n    \n    for v in nums:\n        result += (non_decreasing[v] + non_increasing[v]) % MOD\n        result %= MOD\n        for i in range(v + 1):\n            non_decreasing[i] += 1\n        for i in range(v, 51):\n            non_increasing[i] += 1\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp1 = [[0] * 51 for _ in range(n)]\n    dp2 = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for j in range(51):\n        dp1[0][j] = 1\n        dp2[0][j] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp1[i][j] = dp1[i-1][j]\n            if j > 0:\n                dp1[i][j] += dp1[i-1][j-1]\n                dp1[i][j] %= MOD\n            \n            dp2[i][j] = dp2[i-1][j]\n            if j < 50:\n                dp2[i][j] += dp2[i-1][j+1]\n                dp2[i][j] %= MOD\n    \n    # Count valid pairs\n    count = 0\n    for j in range(51):\n        count += dp1[n-1][j] * dp2[n-1][j]\n        count %= MOD\n    \n    return count", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def is_non_increasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i-1] < arr[i]:\n                return False\n        return True\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            arr1 = [i] * n\n            arr1[j] += nums[i] - i\n            arr2 = [nums[i] - arr1[k] for k in range(n)]\n            if is_non_increasing(arr2):\n                count += 1\n                \n    return count % MOD", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[-1][i] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            dp_inc[i][j] = dp_inc[i-1][j] + dp_inc[i-1][j-1] if j > 0 else dp_inc[i-1][j]\n            dp_dec[i][j] = dp_dec[i+1][j] + dp_dec[i+1][j+1] if j < 50 else dp_dec[i+1][j]\n    \n    result = 0\n    for i in range(n):\n        for j in range(nums[i] + 1):\n            result += dp_inc[i][j] * dp_dec[i][nums[i] - j]\n            result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    dp_inc[0][nums[0]] = 1\n    dp_dec[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        for j in range(nums[i] + 1):\n            dp_inc[i][j] = sum(dp_inc[i-1][k] for k in range(j + 1)) % MOD\n            dp_dec[i][j] = sum(dp_dec[i-1][k] for k in range(j, 51)) % MOD\n    \n    count = 0\n    for i in range(n):\n        count += dp_inc[i][nums[i]] * dp_dec[i][nums[i]]\n        count %= MOD\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [1] * n\n    dp_non_incr = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] >= nums[j]:\n                dp_non_decr[i] += dp_non_decr[j]\n                dp_non_decr[i] %= MOD\n            if nums[i] <= nums[j]:\n                dp_non_incr[i] += dp_non_incr[j]\n                dp_non_incr[i] %= MOD\n    \n    total_count = 0\n    for i in range(n):\n        total_count += dp_non_decr[i] * dp_non_incr[i]\n        total_count %= MOD\n    \n    return total_count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [0] * n\n    dp_non_incr = [0] * n\n    \n    dp_non_decr[0] = 1\n    dp_non_incr[0] = 1\n    \n    for i in range(1, n):\n        dp_non_decr[i] = dp_non_decr[i-1]\n        dp_non_incr[i] = dp_non_incr[i-1]\n        \n        for j in range(i):\n            if nums[j] <= nums[i]:\n                dp_non_decr[i] += dp_non_decr[j]\n                dp_non_decr[i] %= MOD\n            \n            if nums[j] >= nums[i]:\n                dp_non_incr[i] += dp_non_incr[j]\n                dp_non_incr[i] %= MOD\n    \n    result = 0\n    for i in range(n):\n        result += dp_non_decr[i] * dp_non_incr[i]\n        result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp = [[0] * 51 for _ in range(51)]\n    \n    for num in nums:\n        new_dp = [[0] * 51 for _ in range(51)]\n        for j in range(num + 1):\n            for k in range(num + 1):\n                if j <= k:\n                    new_dp[j][k] = (new_dp[j][k] + dp[j][k]) % MOD\n                if j >= k:\n                    new_dp[j][k] = (new_dp[j][k] + dp[j][k]) % MOD\n        dp = new_dp\n    \n    return sum(dp[i][j] for i in range(51) for j in range(i, -1, -1)) % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Calculate prefix sums for arr1\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + (nums[i] // 2)\n    \n    # Calculate suffix sums for arr2\n    suffix_sum = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + (nums[i] // 2)\n    \n    # Count valid pairs\n    count = 0\n    for i in range(n):\n        count += (prefix_sum[i] * suffix_sum[i + 1]) % MOD\n    \n    return count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def is_monotonic(arr):\n        return all(arr[i] >= arr[i+1] for i in range(n-1))\n    \n    count = 0\n    \n    for arr1 in range(1, nums[0] + 1):\n        arr2 = [nums[0] - arr1]\n        for i in range(1, n):\n            if arr2[-1] < nums[i]:\n                break\n            arr2.append(nums[i] - arr1)\n        \n        if is_monotonic(arr2):\n            count += 1\n    \n    return count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_val = max(nums)\n    total_pairs = 0\n    \n    # Initialize DP dictionaries\n    dp_arr1 = {}\n    dp_arr2 = {}\n    \n    # Iterate over each possible prefix sum\n    for i in range(n * max_val + 1):\n        dp_arr1[i] = 0\n        dp_arr2[i] = 0\n    \n    # Base cases\n    dp_arr1[0] = 1\n    dp_arr2[0] = 1\n    \n    for num in nums:\n        new_dp_arr1 = dp_arr1.copy()\n        new_dp_arr2 = dp_arr2.copy()\n        \n        for prefix_sum in range(num, n * max_val + 1):\n            new_dp_arr1[prefix_sum] += dp_arr1[prefix_sum - num]\n            new_dp_arr2[prefix_sum] += dp_arr2[prefix_sum - num]\n            \n            new_dp_arr1[prefix_sum] %= MOD\n            new_dp_arr2[prefix_sum] %= MOD\n        \n        dp_arr1 = new_dp_arr1\n        dp_arr2 = new_dp_arr2\n    \n    for prefix_sum in range(n * max_val + 1):\n        total_pairs += dp_arr1[prefix_sum] * dp_arr2[prefix_sum]\n        total_pairs %= MOD\n    \n    return total_pairs", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    inc_counts = [0] * 51\n    dec_counts = [0] * 51\n    \n    ans = 0\n    \n    for num in nums:\n        # Count valid arr1 values\n        inc_valid = sum(inc_counts[:num + 1]) % MOD\n        \n        # Count valid arr2 values\n        dec_valid = sum(dec_counts[num:]) % MOD\n        \n        # Update the answer\n        ans = (ans + inc_valid * dec_valid) % MOD\n        \n        # Update the counts for the next iteration\n        inc_counts[num] += 1\n        dec_counts[num] += 1\n    \n    return ans", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_dec = [[0] * 51 for _ in range(n)]\n    dp_non_inc = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for j in range(51):\n        dp_non_dec[0][j] = 1\n        dp_non_inc[0][j] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_non_dec[i][j] = sum(dp_non_dec[i-1][k] for k in range(j, 51)) % MOD\n            dp_non_inc[i][j] = sum(dp_non_inc[i-1][k] for k in range(0, j+1)) % MOD\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_non_dec[i][nums[i]] * dp_non_inc[i][nums[i]]\n        result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    def is_monotonic(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n    \n    for i in range(n):\n        for j in range(i, n):\n            arr1 = [0] * n\n            arr2 = [0] * n\n            for k in range(i, j + 1):\n                arr1[k] = k - i\n                arr2[k] = nums[k] - arr1[k]\n            if is_monotonic(arr1) and is_monotonic(arr2[::-1]):\n                count += 1\n    \n    return count % MOD", "from math import comb\n\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for num in nums:\n        count += comb(num + 1, 1)\n        count %= MOD\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_incr = [[0] * 51 for _ in range(n)]\n    dp_decr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_incr[0][i] = 1\n        dp_decr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_incr[i][j] += dp_incr[i-1][j-1]\n            dp_incr[i][j] += dp_incr[i-1][j]\n            dp_incr[i][j] %= MOD\n            \n            if j < 50:\n                dp_decr[i][j] += dp_decr[i-1][j+1]\n            dp_decr[i][j] += dp_decr[i-1][j]\n            dp_decr[i][j] %= MOD\n    \n    # Calculate the total number of valid pairs\n    result = 0\n    for j in range(51):\n        if 0 <= nums[0] - j <= 50:\n            result += dp_incr[-1][j] * dp_decr[-1][nums[0] - j]\n            result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp_incr = [[0] * (n + 1) for _ in range(n)]\n    dp_decr = [[0] * (n + 1) for _ in range(n)]\n    \n    for j in range(n):\n        dp_incr[j][j+1] = 1\n        dp_decr[j][j+1] = 1\n        \n        for i in range(j):\n            if nums[i] <= nums[j]:\n                dp_incr[i][j+1] += dp_incr[i][j]\n                dp_incr[i][j+1] %= MOD\n            \n            if nums[i] >= nums[j]:\n                dp_decr[i][j+1] += dp_decr[i][j]\n                dp_decr[i][j+1] %= MOD\n    \n    result = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == nums[j]:\n                result += dp_incr[i][j] * dp_decr[j][j+1]\n                result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        arr1 = [0] * n\n        arr1[i] = nums[i]\n        for j in range(i+1, n):\n            arr1[j] = nums[j] - arr1[j-1]\n            if arr1[j] < arr1[j-1]:\n                break\n        else:\n            arr2 = [nums[i]] * n\n            for k in range(i, n):\n                arr2[k] -= arr1[k]\n                if arr2[k] > arr2[k+1]:\n                    break\n            else:\n                count += 1\n    return count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(nums[i] + 1):\n            arr1 = [j] * (i + 1)\n            arr2 = [nums[i] - j] * (i + 1)\n            if all(arr2[j] >= arr2[j + 1] for j in range(i)):\n                count += 1\n    return count % MOD", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_non_decr[0][i] = 1\n        dp_non_incr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_non_decr[i][j] = dp_non_decr[i-1][j] + dp_non_decr[i-1][j+1:]\n            dp_non_incr[i][j] = dp_non_incr[i-1][j] + dp_non_incr[i-1][:j+1]\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_non_decr[i][nums[i]] * dp_non_incr[i][nums[i]]\n        result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if nums[j] < nums[i]:\n                break\n            arr1 = [nums[i]] * (j - i + 1)\n            arr2 = [nums[j]] * (j - i + 1)\n            arr1[-1] += nums[j] - nums[i]\n            if arr1[-1] > nums[j]:\n                continue\n            arr2[0] -= nums[j] - nums[i]\n            if arr2[0] < nums[j]:\n                continue\n            if all(arr1[k] <= arr1[k+1] for k in range(len(arr1)-1)) and \\\n               all(arr2[k] >= arr2[k+1] for k in range(len(arr2)-1)):\n                count = (count + 1) % MOD\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    # Iterate over all possible values for arr1\n    for arr1 in range(1 << n):\n        valid = True\n        arr2 = [0] * n\n        \n        # Calculate arr2 based on arr1\n        for i in range(n):\n            if arr1 & (1 << i):\n                arr2[i] = nums[i]\n            else:\n                arr2[i] = nums[i] - arr1 & (1 << i)\n        \n        # Check if arr2 is monotonically non-increasing\n        for i in range(1, n):\n            if arr2[i] > arr2[i - 1]:\n                valid = False\n                break\n        \n        if valid:\n            count += 1\n    \n    return count % MOD", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Fill dp_inc table\n    for i in range(n):\n        dp_inc[i][nums[i]] += 1\n        for j in range(nums[i]):\n            dp_inc[i][j] += dp_inc[i-1][j]\n        \n        for j in range(51):\n            dp_inc[i][j] %= MOD\n    \n    # Fill dp_dec table\n    for i in range(n-1, -1, -1):\n        dp_dec[i][nums[i]] += 1\n        for j in range(nums[i], 51):\n            dp_dec[i][j] += dp_dec[i+1][j]\n        \n        for j in range(51):\n            dp_dec[i][j] %= MOD\n    \n    # Count valid pairs\n    result = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == nums[i]:\n                result += dp_inc[i][nums[j]]\n            elif nums[i] + nums[j", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_inc[i][j] = dp_inc[i-1][j-1] + dp_inc[i-1][j]\n            else:\n                dp_inc[i][j] = dp_inc[i-1][j]\n            \n            if j < 50:\n                dp_dec[i][j] = dp_dec[i-1][j+1] + dp_dec[i-1][j]\n            else:\n                dp_dec[i][j] = dp_dec[i-1][j]\n    \n    # Count valid pairs\n    result = 0\n    for j in range(51):\n        result += dp_inc[n-1][j] * dp_dec[n-1][j]\n    \n    return result % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for arr1 in range(n + 1):\n        for arr2 in range(n + 1):\n            valid = True\n            for i in range(n):\n                if arr1 + arr2 != nums[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n                count %= MOD\n    return count", "def count_monotonic_pairs(nums):\n    mod = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    dp_non_decr[0][nums[0]] = 1\n    dp_non_incr[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        for j in range(nums[i] + 1):\n            dp_non_decr[i][j] = sum(dp_non_decr[i-1][k] for k in range(j, nums[i]+1)) % mod\n            dp_non_incr[i][j] = sum(dp_non_incr[i-1][k] for k in range(j, nums[i]+1)) % mod\n    \n    total_count = 0\n    for j in range(51):\n        total_count = (total_count + dp_non_decr[-1][j] * dp_non_incr[-1][j]) % mod\n    \n    return total_count", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n\n    def countNonDecreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] <= arr[i]:\n                    dp[i] += dp[j]\n        return sum(dp) % MOD\n\n    def countNonIncreasing(arr):\n        dp = [1] * n\n        for i in range(n-2, -1, -1):\n            for j in range(n-1, i, -1):\n                if arr[j] <= arr[i]:\n                    dp[i] += dp[j]\n        return sum(dp) % MOD\n\n    total_pairs = 0\n    for i in range(n):\n        for j in range(n):\n            arr1 = [min(nums[k], k - i) for k in range(n)]\n            arr2 = [min(nums[k], n - k - 1 + j) for k in range(n)]\n            if sum(x + y for x, y in zip(arr1, arr2)) == sum(nums):\n                total_pairs += 1\n    return total_pairs % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_incr = [[0] * 51 for _ in range(n)]\n    dp_decr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_incr[0][i] = 1\n        dp_decr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_incr[i][j] = dp_incr[i-1][j-1]\n            if j < 50:\n                dp_incr[i][j] += dp_incr[i-1][j+1]\n            dp_incr[i][j] %= MOD\n            \n            if j > 0:\n                dp_decr[i][j] = dp_decr[i-1][j-1]\n            dp_decr[i][j] += dp_decr[i-1][j]\n            dp_decr[i][j] %= MOD\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_incr[i][nums[i]] * dp_decr[i][nums[i]]\n        result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def countNonDecreasing(arr):\n        count = 0\n        prefix_sum = [0] * (max(arr) + 1)\n        for num in arr:\n            count += prefix_sum[num]\n            prefix_sum[num] += 1\n        return count\n    \n    def countNonIncreasing(arr):\n        count = 0\n        prefix_sum = [0] * (max(arr) + 1)\n        for num in reversed(arr):\n            count += prefix_sum[num]\n            prefix_sum[num] += 1\n        return count\n    \n    total_count = 0\n    for i in range(n):\n        target = nums[i]\n        for j in range(target + 1):\n            arr1 = [j] * (i + 1)\n            arr2 = [(target - j)] * (i + 1)\n            if arr2 == sorted(arr2, reverse=True):\n                if i > 0:\n                    total_count += countNonDecreasing(arr1[:i]) * countNonIncreasing(arr2[:i])\n                else:\n                    total_count += 1\n    \n    return total_count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Initialize base cases\n    for j in range(51):\n        dp_inc[0][j] = 1\n        dp_dec[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, 51):\n            dp_inc[i][j] = dp_inc[i-1][j]\n            if j > 0:\n                dp_inc[i][j] += dp_inc[i-1][j-1]\n        \n            dp_dec[i][j] = dp_dec[i-1][j]\n            if j < 50:\n                dp_dec[i][j] += dp_dec[i-1][j+1]\n    \n    result = 0\n    for i in range(n):\n        for j in range(1, 51):\n            result += dp_inc[i][j] * dp_dec[i][j]\n    \n    return result % MOD"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    result = 0\n    \n    for i in range(n):\n        for j in range(51):\n            k = nums[i] - j\n            if 0 <= k <= 50:\n                arr1 = [j] * (i + 1)\n                arr2 = [k] * (i + 1)\n                \n                # Check if arr1 is non-decreasing\n                non_decreasing = True\n                for l in range(1, i + 1):\n                    if arr1[l] < arr1[l - 1]:\n                        non_decreasing = False\n                        break\n                \n                # Check if arr2 is non-increasing\n                non_increasing = True\n                for l in range(1, i + 1):\n                    if arr2[l] > arr2[l - 1]:\n                        non_increasing = False\n                        break\n                \n                if non_decreasing and non_increasing:\n                    result += 1\n                    \n    return result % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        dp[i][i] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if nums[j - 1] - j >= 0:\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1]\n                dp[i][j] %= MOD\n    \n    total_count = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if nums[j - 1] - j >= 0:\n                total_count += dp[i][j]\n                total_count %= MOD\n    \n    return total_count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    non_decreasing = [0] * 51\n    non_increasing = [0] * 51\n    result = 0\n    \n    for v in nums:\n        result += (non_decreasing[v] + non_increasing[v]) % MOD\n        result %= MOD\n        for i in range(v + 1):\n            non_decreasing[i] += 1\n        for i in range(v, 51):\n            non_increasing[i] += 1\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp1 = [[0] * 51 for _ in range(n)]\n    dp2 = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for j in range(51):\n        dp1[0][j] = 1\n        dp2[0][j] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp1[i][j] = dp1[i-1][j]\n            if j > 0:\n                dp1[i][j] += dp1[i-1][j-1]\n                dp1[i][j] %= MOD\n            \n            dp2[i][j] = dp2[i-1][j]\n            if j < 50:\n                dp2[i][j] += dp2[i-1][j+1]\n                dp2[i][j] %= MOD\n    \n    # Count valid pairs\n    count = 0\n    for j in range(51):\n        count += dp1[n-1][j] * dp2[n-1][j]\n        count %= MOD\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def is_non_increasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i-1] < arr[i]:\n                return False\n        return True\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            arr1 = [i] * n\n            arr1[j] += nums[i] - i\n            arr2 = [nums[i] - arr1[k] for k in range(n)]\n            if is_non_increasing(arr2):\n                count += 1\n                \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[-1][i] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            dp_inc[i][j] = dp_inc[i-1][j] + dp_inc[i-1][j-1] if j > 0 else dp_inc[i-1][j]\n            dp_dec[i][j] = dp_dec[i+1][j] + dp_dec[i+1][j+1] if j < 50 else dp_dec[i+1][j]\n    \n    result = 0\n    for i in range(n):\n        for j in range(nums[i] + 1):\n            result += dp_inc[i][j] * dp_dec[i][nums[i] - j]\n            result %= MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    dp_inc[0][nums[0]] = 1\n    dp_dec[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        for j in range(nums[i] + 1):\n            dp_inc[i][j] = sum(dp_inc[i-1][k] for k in range(j + 1)) % MOD\n            dp_dec[i][j] = sum(dp_dec[i-1][k] for k in range(j, 51)) % MOD\n    \n    count = 0\n    for i in range(n):\n        count += dp_inc[i][nums[i]] * dp_dec[i][nums[i]]\n        count %= MOD\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [1] * n\n    dp_non_incr = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] >= nums[j]:\n                dp_non_decr[i] += dp_non_decr[j]\n                dp_non_decr[i] %= MOD\n            if nums[i] <= nums[j]:\n                dp_non_incr[i] += dp_non_incr[j]\n                dp_non_incr[i] %= MOD\n    \n    total_count = 0\n    for i in range(n):\n        total_count += dp_non_decr[i] * dp_non_incr[i]\n        total_count %= MOD\n    \n    return total_count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [0] * n\n    dp_non_incr = [0] * n\n    \n    dp_non_decr[0] = 1\n    dp_non_incr[0] = 1\n    \n    for i in range(1, n):\n        dp_non_decr[i] = dp_non_decr[i-1]\n        dp_non_incr[i] = dp_non_incr[i-1]\n        \n        for j in range(i):\n            if nums[j] <= nums[i]:\n                dp_non_decr[i] += dp_non_decr[j]\n                dp_non_decr[i] %= MOD\n            \n            if nums[j] >= nums[i]:\n                dp_non_incr[i] += dp_non_incr[j]\n                dp_non_incr[i] %= MOD\n    \n    result = 0\n    for i in range(n):\n        result += dp_non_decr[i] * dp_non_incr[i]\n        result %= MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp = [[0] * 51 for _ in range(51)]\n    \n    for num in nums:\n        new_dp = [[0] * 51 for _ in range(51)]\n        for j in range(num + 1):\n            for k in range(num + 1):\n                if j <= k:\n                    new_dp[j][k] = (new_dp[j][k] + dp[j][k]) % MOD\n                if j >= k:\n                    new_dp[j][k] = (new_dp[j][k] + dp[j][k]) % MOD\n        dp = new_dp\n    \n    return sum(dp[i][j] for i in range(51) for j in range(i, -1, -1)) % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Calculate prefix sums for arr1\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + (nums[i] // 2)\n    \n    # Calculate suffix sums for arr2\n    suffix_sum = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + (nums[i] // 2)\n    \n    # Count valid pairs\n    count = 0\n    for i in range(n):\n        count += (prefix_sum[i] * suffix_sum[i + 1]) % MOD\n    \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def is_monotonic(arr):\n        return all(arr[i] >= arr[i+1] for i in range(n-1))\n    \n    count = 0\n    \n    for arr1 in range(1, nums[0] + 1):\n        arr2 = [nums[0] - arr1]\n        for i in range(1, n):\n            if arr2[-1] < nums[i]:\n                break\n            arr2.append(nums[i] - arr1)\n        \n        if is_monotonic(arr2):\n            count += 1\n    \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    max_val = max(nums)\n    total_pairs = 0\n    \n    # Initialize DP dictionaries\n    dp_arr1 = {}\n    dp_arr2 = {}\n    \n    # Iterate over each possible prefix sum\n    for i in range(n * max_val + 1):\n        dp_arr1[i] = 0\n        dp_arr2[i] = 0\n    \n    # Base cases\n    dp_arr1[0] = 1\n    dp_arr2[0] = 1\n    \n    for num in nums:\n        new_dp_arr1 = dp_arr1.copy()\n        new_dp_arr2 = dp_arr2.copy()\n        \n        for prefix_sum in range(num, n * max_val + 1):\n            new_dp_arr1[prefix_sum] += dp_arr1[prefix_sum - num]\n            new_dp_arr2[prefix_sum] += dp_arr2[prefix_sum - num]\n            \n            new_dp_arr1[prefix_sum] %= MOD\n            new_dp_arr2[prefix_sum] %= MOD\n        \n        dp_arr1 = new_dp_arr1\n        dp_arr2 = new_dp_arr2\n    \n    for prefix_sum in range(n * max_val + 1):\n        total_pairs += dp_arr1[prefix_sum] * dp_arr2[prefix_sum]\n        total_pairs %= MOD\n    \n    return total_pairs\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    inc_counts = [0] * 51\n    dec_counts = [0] * 51\n    \n    ans = 0\n    \n    for num in nums:\n        # Count valid arr1 values\n        inc_valid = sum(inc_counts[:num + 1]) % MOD\n        \n        # Count valid arr2 values\n        dec_valid = sum(dec_counts[num:]) % MOD\n        \n        # Update the answer\n        ans = (ans + inc_valid * dec_valid) % MOD\n        \n        # Update the counts for the next iteration\n        inc_counts[num] += 1\n        dec_counts[num] += 1\n    \n    return ans\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_dec = [[0] * 51 for _ in range(n)]\n    dp_non_inc = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for j in range(51):\n        dp_non_dec[0][j] = 1\n        dp_non_inc[0][j] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_non_dec[i][j] = sum(dp_non_dec[i-1][k] for k in range(j, 51)) % MOD\n            dp_non_inc[i][j] = sum(dp_non_inc[i-1][k] for k in range(0, j+1)) % MOD\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_non_dec[i][nums[i]] * dp_non_inc[i][nums[i]]\n        result %= MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    def is_monotonic(arr):\n        return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n    \n    for i in range(n):\n        for j in range(i, n):\n            arr1 = [0] * n\n            arr2 = [0] * n\n            for k in range(i, j + 1):\n                arr1[k] = k - i\n                arr2[k] = nums[k] - arr1[k]\n            if is_monotonic(arr1) and is_monotonic(arr2[::-1]):\n                count += 1\n    \n    return count % MOD\n```", "```python\nfrom math import comb\n\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for num in nums:\n        count += comb(num + 1, 1)\n        count %= MOD\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_incr = [[0] * 51 for _ in range(n)]\n    dp_decr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_incr[0][i] = 1\n        dp_decr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_incr[i][j] += dp_incr[i-1][j-1]\n            dp_incr[i][j] += dp_incr[i-1][j]\n            dp_incr[i][j] %= MOD\n            \n            if j < 50:\n                dp_decr[i][j] += dp_decr[i-1][j+1]\n            dp_decr[i][j] += dp_decr[i-1][j]\n            dp_decr[i][j] %= MOD\n    \n    # Calculate the total number of valid pairs\n    result = 0\n    for j in range(51):\n        if 0 <= nums[0] - j <= 50:\n            result += dp_incr[-1][j] * dp_decr[-1][nums[0] - j]\n            result %= MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp_incr = [[0] * (n + 1) for _ in range(n)]\n    dp_decr = [[0] * (n + 1) for _ in range(n)]\n    \n    for j in range(n):\n        dp_incr[j][j+1] = 1\n        dp_decr[j][j+1] = 1\n        \n        for i in range(j):\n            if nums[i] <= nums[j]:\n                dp_incr[i][j+1] += dp_incr[i][j]\n                dp_incr[i][j+1] %= MOD\n            \n            if nums[i] >= nums[j]:\n                dp_decr[i][j+1] += dp_decr[i][j]\n                dp_decr[i][j+1] %= MOD\n    \n    result = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == nums[j]:\n                result += dp_incr[i][j] * dp_decr[j][j+1]\n                result %= MOD\n    \n    return result\n```", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        arr1 = [0] * n\n        arr1[i] = nums[i]\n        for j in range(i+1, n):\n            arr1[j] = nums[j] - arr1[j-1]\n            if arr1[j] < arr1[j-1]:\n                break\n        else:\n            arr2 = [nums[i]] * n\n            for k in range(i, n):\n                arr2[k] -= arr1[k]\n                if arr2[k] > arr2[k+1]:\n                    break\n            else:\n                count += 1\n    return count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(nums[i] + 1):\n            arr1 = [j] * (i + 1)\n            arr2 = [nums[i] - j] * (i + 1)\n            if all(arr2[j] >= arr2[j + 1] for j in range(i)):\n                count += 1\n    return count % MOD", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_non_decr[0][i] = 1\n        dp_non_incr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_non_decr[i][j] = dp_non_decr[i-1][j] + dp_non_decr[i-1][j+1:]\n            dp_non_incr[i][j] = dp_non_incr[i-1][j] + dp_non_incr[i-1][:j+1]\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_non_decr[i][nums[i]] * dp_non_incr[i][nums[i]]\n        result %= MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if nums[j] < nums[i]:\n                break\n            arr1 = [nums[i]] * (j - i + 1)\n            arr2 = [nums[j]] * (j - i + 1)\n            arr1[-1] += nums[j] - nums[i]\n            if arr1[-1] > nums[j]:\n                continue\n            arr2[0] -= nums[j] - nums[i]\n            if arr2[0] < nums[j]:\n                continue\n            if all(arr1[k] <= arr1[k+1] for k in range(len(arr1)-1)) and \\\n               all(arr2[k] >= arr2[k+1] for k in range(len(arr2)-1)):\n                count = (count + 1) % MOD\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    # Iterate over all possible values for arr1\n    for arr1 in range(1 << n):\n        valid = True\n        arr2 = [0] * n\n        \n        # Calculate arr2 based on arr1\n        for i in range(n):\n            if arr1 & (1 << i):\n                arr2[i] = nums[i]\n            else:\n                arr2[i] = nums[i] - arr1 & (1 << i)\n        \n        # Check if arr2 is monotonically non-increasing\n        for i in range(1, n):\n            if arr2[i] > arr2[i - 1]:\n                valid = False\n                break\n        \n        if valid:\n            count += 1\n    \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Fill dp_inc table\n    for i in range(n):\n        dp_inc[i][nums[i]] += 1\n        for j in range(nums[i]):\n            dp_inc[i][j] += dp_inc[i-1][j]\n        \n        for j in range(51):\n            dp_inc[i][j] %= MOD\n    \n    # Fill dp_dec table\n    for i in range(n-1, -1, -1):\n        dp_dec[i][nums[i]] += 1\n        for j in range(nums[i], 51):\n            dp_dec[i][j] += dp_dec[i+1][j]\n        \n        for j in range(51):\n            dp_dec[i][j] %= MOD\n    \n    # Count valid pairs\n    result = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[i] + nums[j] == nums[i]:\n                result += dp_inc[i][nums[j]]\n            elif nums[i] + nums[j", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_inc[i][j] = dp_inc[i-1][j-1] + dp_inc[i-1][j]\n            else:\n                dp_inc[i][j] = dp_inc[i-1][j]\n            \n            if j < 50:\n                dp_dec[i][j] = dp_dec[i-1][j+1] + dp_dec[i-1][j]\n            else:\n                dp_dec[i][j] = dp_dec[i-1][j]\n    \n    # Count valid pairs\n    result = 0\n    for j in range(51):\n        result += dp_inc[n-1][j] * dp_dec[n-1][j]\n    \n    return result % MOD\n```", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    for arr1 in range(n + 1):\n        for arr2 in range(n + 1):\n            valid = True\n            for i in range(n):\n                if arr1 + arr2 != nums[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n                count %= MOD\n    return count", "```python\ndef count_monotonic_pairs(nums):\n    mod = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    dp_non_decr[0][nums[0]] = 1\n    dp_non_incr[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        for j in range(nums[i] + 1):\n            dp_non_decr[i][j] = sum(dp_non_decr[i-1][k] for k in range(j, nums[i]+1)) % mod\n            dp_non_incr[i][j] = sum(dp_non_incr[i-1][k] for k in range(j, nums[i]+1)) % mod\n    \n    total_count = 0\n    for j in range(51):\n        total_count = (total_count + dp_non_decr[-1][j] * dp_non_incr[-1][j]) % mod\n    \n    return total_count\n```", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n\n    def countNonDecreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] <= arr[i]:\n                    dp[i] += dp[j]\n        return sum(dp) % MOD\n\n    def countNonIncreasing(arr):\n        dp = [1] * n\n        for i in range(n-2, -1, -1):\n            for j in range(n-1, i, -1):\n                if arr[j] <= arr[i]:\n                    dp[i] += dp[j]\n        return sum(dp) % MOD\n\n    total_pairs = 0\n    for i in range(n):\n        for j in range(n):\n            arr1 = [min(nums[k], k - i) for k in range(n)]\n            arr2 = [min(nums[k], n - k - 1 + j) for k in range(n)]\n            if sum(x + y for x, y in zip(arr1, arr2)) == sum(nums):\n                total_pairs += 1\n    return total_pairs % MOD", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_incr = [[0] * 51 for _ in range(n)]\n    dp_decr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_incr[0][i] = 1\n        dp_decr[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_incr[i][j] = dp_incr[i-1][j-1]\n            if j < 50:\n                dp_incr[i][j] += dp_incr[i-1][j+1]\n            dp_incr[i][j] %= MOD\n            \n            if j > 0:\n                dp_decr[i][j] = dp_decr[i-1][j-1]\n            dp_decr[i][j] += dp_decr[i-1][j]\n            dp_decr[i][j] %= MOD\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_incr[i][nums[i]] * dp_decr[i][nums[i]]\n        result %= MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def countNonDecreasing(arr):\n        count = 0\n        prefix_sum = [0] * (max(arr) + 1)\n        for num in arr:\n            count += prefix_sum[num]\n            prefix_sum[num] += 1\n        return count\n    \n    def countNonIncreasing(arr):\n        count = 0\n        prefix_sum = [0] * (max(arr) + 1)\n        for num in reversed(arr):\n            count += prefix_sum[num]\n            prefix_sum[num] += 1\n        return count\n    \n    total_count = 0\n    for i in range(n):\n        target = nums[i]\n        for j in range(target + 1):\n            arr1 = [j] * (i + 1)\n            arr2 = [(target - j)] * (i + 1)\n            if arr2 == sorted(arr2, reverse=True):\n                if i > 0:\n                    total_count += countNonDecreasing(arr1[:i]) * countNonIncreasing(arr2[:i])\n                else:\n                    total_count += 1\n    \n    return total_count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Initialize base cases\n    for j in range(51):\n        dp_inc[0][j] = 1\n        dp_dec[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(1, 51):\n            dp_inc[i][j] = dp_inc[i-1][j]\n            if j > 0:\n                dp_inc[i][j] += dp_inc[i-1][j-1]\n        \n            dp_dec[i][j] = dp_dec[i-1][j]\n            if j < 50:\n                dp_dec[i][j] += dp_dec[i-1][j+1]\n    \n    result = 0\n    for i in range(n):\n        for j in range(1, 51):\n            result += dp_inc[i][j] * dp_dec[i][j]\n    \n    return result % MOD\n```"]}
