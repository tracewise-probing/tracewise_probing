"{\"difficulty\": \"hard\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"deepseek-ai/deepseek-coder-6.7b-instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majority_dk7b_n_16_hard.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"deepseek-ai/deepseek-coder-6.7b-instruct\", \"api_base\": \"http://10.96.183.224:63019/8003/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3552", "code": "", "passed": false, "raw_code": ""}
{"task_id": "3550", "code": "", "passed": false, "raw_code": ""}
{"task_id": "3580", "code": "def almostEqual(s, pattern):\n    len_s, len_p = len(s), len(pattern)\n    if len_s < len_p: # if pattern is longer than s, it's impossible\n        return -1\n    diff_count = 0 # count of characters that are different\n    for i in range(len_p):\n        if s[i] != pattern[i]:\n            diff_count += 1\n    if diff_count == 0: # if there are no differences, return 0\n        return 0\n    elif diff_count > 1: # if more than one difference, return -1\n        return -1\n    # scan the rest of the string\n    for i in range(len_p, len_s):\n        if s[i] != pattern[i]:\n            if s[i-len_p] == pattern[i-len_p]: # count as other character instead of the same character\n                diff_count -= 1\n            else:\n                return -1\n        if diff_count > 1: # if more than one difference, return -1\n            return -1\n    if diff_count == 1: # if there's exactly one difference, return the last index\n        return len_s - len_p\n    return -1\n", "passed": false, "raw_code": "def almostEqual(s, pattern):\n    len_s, len_p = len(s), len(pattern)\n    if len_s < len_p: # if pattern is longer than s, it's impossible\n        return -1\n    diff_count = 0 # count of characters that are different\n    for i in range(len_p):\n        if s[i] != pattern[i]:\n            diff_count += 1\n    if diff_count == 0: # if there are no differences, return 0\n        return 0\n    elif diff_count > 1: # if more than one difference, return -1\n        return -1\n    # scan the rest of the string\n    for i in range(len_p, len_s):\n        if s[i] != pattern[i]:\n            if s[i-len_p] == pattern[i-len_p]: # count as other character instead of the same character\n                diff_count -= 1\n            else:\n                return -1\n        if diff_count > 1: # if more than one difference, return -1\n            return -1\n    if diff_count == 1: # if there's exactly one difference, return the last index\n        return len_s - len_p\n    return -1\n"}
{"task_id": "3575", "code": "def maximumXOR(nums, k):\n    if 2 * k > len(nums):\n        return -1\n\n    dp = [[0] * len(nums) for _ in range(k)]\n    for i in range(len(nums)):\n        dp[0][i] = nums[i]\n\n    for j in range(1, k):\n        for i in range(len(nums) - 2 * j):\n            dp[j][i] = max(dp[j - 1][i], dp[j - 1][i + 1])\n\n    return max(dp[-1])\n", "passed": false, "raw_code": "def maximumXOR(nums, k):\n    if 2 * k > len(nums):\n        return -1\n\n    dp = [[0] * len(nums) for _ in range(k)]\n    for i in range(len(nums)):\n        dp[0][i] = nums[i]\n\n    for j in range(1, k):\n        for i in range(len(nums) - 2 * j):\n            dp[j][i] = max(dp[j - 1][i], dp[j - 1][i + 1])\n\n    return max(dp[-1])\n"}
{"task_id": "3535", "code": "def count_monotonic_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp = [[0]*2 for _ in range(n)]\n    dp[0][0] = dp[0][1] = 1\n    for i in range(1, n):\n        dp[i][0] = dp[i][1] = 1\n        for j in range(i):\n            if nums[i] >= nums[j]:\n                dp[i][0] = (dp[i][0] + dp[j][0]) % MOD\n            if nums[i] <= nums[j]:\n                dp[i][1] = (dp[i][1] + dp[j][1]) % MOD\n    return (sum(x for x, _ in dp) + sum(x for _, x in dp)) % MOD\n", "passed": false, "raw_code": "def count_monotonic_pairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    dp = [[0]*2 for _ in range(n)]\n    dp[0][0] = dp[0][1] = 1\n    for i in range(1, n):\n        dp[i][0] = dp[i][1] = 1\n        for j in range(i):\n            if nums[i] >= nums[j]:\n                dp[i][0] = (dp[i][0] + dp[j][0]) % MOD\n            if nums[i] <= nums[j]:\n                dp[i][1] = (dp[i][1] + dp[j][1]) % MOD\n    return (sum(x for x, _ in dp) + sum(x for _, x in dp)) % MOD\n"}
{"task_id": "3548", "code": "def countGoodNumbers(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[[0]*k for _ in range(n+1)] for _ in range(n+1)]\n    dp[1][0][k-1] = k-1\n    dp[1][1][k-1] = 1\n    for i in range(2, n+1):\n        for j in range(i+1):\n            for p in range(k):\n                dp[i][j][p] = (k * dp[i-1][j][k-1]) % mod\n                if j > 0:\n                    for q in range(p):\n                        dp[i][j][p] += dp[i][j-1][q]\n                        dp[i][j][p] %= mod\n                if j < i:\n                    for q in range(k):\n                        dp[i][j][p] += dp[i-1][j-1][q]\n                        dp[i][j][p] %= mod\n    total = sum(sum(dp[n][j][p] for p in range(k)) for j in range(n+1)) % mod\n    return total\n", "passed": false, "raw_code": "def countGoodNumbers(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[[0]*k for _ in range(n+1)] for _ in range(n+1)]\n    dp[1][0][k-1] = k-1\n    dp[1][1][k-1] = 1\n    for i in range(2, n+1):\n        for j in range(i+1):\n            for p in range(k):\n                dp[i][j][p] = (k * dp[i-1][j][k-1]) % mod\n                if j > 0:\n                    for q in range(p):\n                        dp[i][j][p] += dp[i][j-1][q]\n                        dp[i][j][p] %= mod\n                if j < i:\n                    for q in range(k):\n                        dp[i][j][p] += dp[i-1][j-1][q]\n                        dp[i][j][p] %= mod\n    total = sum(sum(dp[n][j][p] for p in range(k)) for j in range(n+1)) % mod\n    return total\n"}
{"task_id": "3531", "code": "print(minimumDamage(4, [1,2,3,4], [4,5,6,8]))  # Outputs: 39\nprint(minimumDamage(1, [1,1,1,1], [1,2,3,4]))  # Outputs: 20\nprint(minimumDamage(8, [40], [59]))  # Outputs: 320\n", "passed": false, "raw_code": "print(minimumDamage(4, [1,2,3,4], [4,5,6,8]))  # Outputs: 39\nprint(minimumDamage(1, [1,1,1,1], [1,2,3,4]))  # Outputs: 20\nprint(minimumDamage(8, [40], [59]))  # Outputs: 320\n"}
{"task_id": "3527", "code": "def color_groups(colors, queries):\n    # Initialize variables\n    red_groups = []\n    blue_groups = []\n    result = []\n    # Process queries\n    for query in queries:\n        if query[0] == 1: # 1 means count alternating groups\n            size = query[1]\n            count = 0\n            previous_color = None\n            same_color_count = 0\n            for color in colors:\n                if color == previous_color:\n                    same_color_count += 1\n                else:\n                    if same_color_count >= size: \n                        count += 1\n                    same_color_count = 1\n                    previous_color = color\n            result.append(count)\n        elif query[0] == 2: # 2 means change the color\n            index = query[1]\n            new_color = query[2]\n            colors[index] = new_color\n    return result\n", "passed": false, "raw_code": "def color_groups(colors, queries):\n    # Initialize variables\n    red_groups = []\n    blue_groups = []\n    result = []\n    # Process queries\n    for query in queries:\n        if query[0] == 1: # 1 means count alternating groups\n            size = query[1]\n            count = 0\n            previous_color = None\n            same_color_count = 0\n            for color in colors:\n                if color == previous_color:\n                    same_color_count += 1\n                else:\n                    if same_color_count >= size: \n                        count += 1\n                    same_color_count = 1\n                    previous_color = color\n            result.append(count)\n        elif query[0] == 2: # 2 means change the color\n            index = query[1]\n            new_color = query[2]\n            colors[index] = new_color\n    return result\n"}
{"task_id": "3563", "code": "from typing import List\n\ndef maxScore(grid: List[List[int]]) -> int:\n    dp = [0] * (1 << len(grid[0]))\n    for row in grid:\n        row = sorted(row, reverse=True)\n        for i in range(1 << len(grid[0])):\n            n_i = bin(i).count('1')\n            if n_i < len(row) and ((i >> n_i) & 1 == 0):\n                continue\n            v = 0\n            for j in range(len(row)):\n                if ((i >> j) & 1) == 1:\n                    v ^= (1 << row[j])\n            dp[i] = max(dp[i], dp[i ^ v] + sum(row))\n    return dp[(1 << len(grid[0])) - 1]\n\n", "passed": false, "raw_code": "from typing import List\n\ndef maxScore(grid: List[List[int]]) -> int:\n    dp = [0] * (1 << len(grid[0]))\n    for row in grid:\n        row = sorted(row, reverse=True)\n        for i in range(1 << len(grid[0])):\n            n_i = bin(i).count('1')\n            if n_i < len(row) and ((i >> n_i) & 1 == 0):\n                continue\n            v = 0\n            for j in range(len(row)):\n                if ((i >> j) & 1) == 1:\n                    v ^= (1 << row[j])\n            dp[i] = max(dp[i], dp[i ^ v] + sum(row))\n    return dp[(1 << len(grid[0])) - 1]\n\n"}
{"task_id": "3583", "code": "from math import gcd\nfrom collections import defaultdict\n\ndef solve(nums, queries):\n    n = len(nums)\n    all_gcds = defaultdict(list)\n\n    # get all gcds of pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            all_gcds[gcd(nums[i], nums[j])].append((i, j))\n\n    # sort gcds in ascending order\n    all_gcds = {k: v for k, v in sorted(all_gcds.items())}\n    \n    # prepare flattened list of all gcds\n    flat_gcds = [k for k, v in all_gcds.items() for pair in v]\n\n    # query answer\n    answers = [flat_gcds[q] for q in queries]\n\n    return answers\n", "passed": false, "raw_code": "from math import gcd\nfrom collections import defaultdict\n\ndef solve(nums, queries):\n    n = len(nums)\n    all_gcds = defaultdict(list)\n\n    # get all gcds of pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            all_gcds[gcd(nums[i], nums[j])].append((i, j))\n\n    # sort gcds in ascending order\n    all_gcds = {k: v for k, v in sorted(all_gcds.items())}\n    \n    # prepare flattened list of all gcds\n    flat_gcds = [k for k, v in all_gcds.items() for pair in v]\n\n    # query answer\n    answers = [flat_gcds[q] for q in queries]\n\n    return answers\n"}
{"task_id": "3571", "code": "def longestIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    points = sorted([(x, y, i) for i, (x, y) in enumerate(coordinates)])\n    neighbors = [[] for _ in range(n)]\n    dp = [1] * n  # initialize dp[i] to 1\n\n    # Build graph\n    for i in range(n):\n        x1, y1, _ = points[i]\n        for j in range(i+1, n):\n            x2, y2, _ = points[j]\n            if x1 < x2 and y1 < y2:\n                neighbors[i].append(j)\n\n    # DFS traversal\n    def dfs(node):\n        if dp[node] != 1:  # node is visited\n            return dp[node]\n        for nei in neighbors[node]:\n            dp[node] = max(dp[node], 1 + dfs(nei))\n        return dp[node]\n\n    return max(dfs(k) for k in range(n))\n", "passed": false, "raw_code": "def longestIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    points = sorted([(x, y, i) for i, (x, y) in enumerate(coordinates)])\n    neighbors = [[] for _ in range(n)]\n    dp = [1] * n  # initialize dp[i] to 1\n\n    # Build graph\n    for i in range(n):\n        x1, y1, _ = points[i]\n        for j in range(i+1, n):\n            x2, y2, _ = points[j]\n            if x1 < x2 and y1 < y2:\n                neighbors[i].append(j)\n\n    # DFS traversal\n    def dfs(node):\n        if dp[node] != 1:  # node is visited\n            return dp[node]\n        for nei in neighbors[node]:\n            dp[node] = max(dp[node], 1 + dfs(nei))\n        return dp[node]\n\n    return max(dfs(k) for k in range(n))\n"}
{"task_id": "3551", "code": "class BinaryIndexedTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def _parent(self, idx):\n        return idx + (idx & -idx)\n\n    def _child(self, idx):\n        return idx - (idx & -idx)\n\n    def update(self, idx, value):\n        while idx <= self.size:\n            self.tree[idx] = max(self.tree[idx], value)\n            idx = self._parent(idx)\n\n    def query(self, idx):\n        max_value = 0\n        while idx > 0:\n            max_value = max(max_value, self.tree[idx])\n            idx = self._child(idx)\n        return max_value\n\ndef solve(nums, queries):\n    bit = BinaryIndexedTree(len(nums))\n    sorted_nums = sorted([(num, idx) for idx, num in enumerate(nums)])\n    sorted_queries = sorted([(l, r, idx) for idx, (l, r) in enumerate(queries)])\n    nums.sort()\n    q_idx = 0\n    res = [0] * len(queries)\n    for num, idx in sorted_nums:\n        bit.update(idx + 1, num ^ bit.query(idx))\n        while q_idx < len(queries) and sorted_queries[q_idx][0] == idx:\n            res[sorted_queries[q_idx][2]] = bit.query(sorted_queries[q_idx][1] + 1)\n            q_idx += 1\n    return res\n\nnums = [2,8,4,32,16,1]\nqueries = [[0,2],[1,4],[0,5]]\nprint(solve(nums, queries))  # [12, 60, 60]\n\nnums = [0,7,3,2,8,5,1]\nqueries = [[0,3],[1,5],[2,4],[2,6],[5,6]]\nprint(solve(nums, queries))  # [7, 14, 11, 14, 5]\n", "passed": false, "raw_code": "class BinaryIndexedTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def _parent(self, idx):\n        return idx + (idx & -idx)\n\n    def _child(self, idx):\n        return idx - (idx & -idx)\n\n    def update(self, idx, value):\n        while idx <= self.size:\n            self.tree[idx] = max(self.tree[idx], value)\n            idx = self._parent(idx)\n\n    def query(self, idx):\n        max_value = 0\n        while idx > 0:\n            max_value = max(max_value, self.tree[idx])\n            idx = self._child(idx)\n        return max_value\n\ndef solve(nums, queries):\n    bit = BinaryIndexedTree(len(nums))\n    sorted_nums = sorted([(num, idx) for idx, num in enumerate(nums)])\n    sorted_queries = sorted([(l, r, idx) for idx, (l, r) in enumerate(queries)])\n    nums.sort()\n    q_idx = 0\n    res = [0] * len(queries)\n    for num, idx in sorted_nums:\n        bit.update(idx + 1, num ^ bit.query(idx))\n        while q_idx < len(queries) and sorted_queries[q_idx][0] == idx:\n            res[sorted_queries[q_idx][2]] = bit.query(sorted_queries[q_idx][1] + 1)\n            q_idx += 1\n    return res\n\nnums = [2,8,4,32,16,1]\nqueries = [[0,2],[1,4],[0,5]]\nprint(solve(nums, queries))  # [12, 60, 60]\n\nnums = [0,7,3,2,8,5,1]\nqueries = [[0,3],[1,5],[2,4],[2,6],[5,6]]\nprint(solve(nums, queries))  # [7, 14, 11, 14, 5]\n"}
{"task_id": "3532", "code": "from collections import defaultdict, deque\n\ndef get_marked_times(n, edges):\n    adjacency_list = defaultdict(list)\n    for u, v in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    marked_times = [0] * n\n    queue = deque([(0, 0)])  # node, depth or time\n    visited = [False] * n\n    visited[0] = True\n\n    while queue:\n        node, time = queue.popleft()\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                marked_times[neighbor] = time + 1 if neighbor % 2 == 1 else time + 2\n                queue.append((neighbor, marked_times[neighbor]))\n\n    return marked_times\n", "passed": false, "raw_code": "from collections import defaultdict, deque\n\ndef get_marked_times(n, edges):\n    adjacency_list = defaultdict(list)\n    for u, v in edges:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    marked_times = [0] * n\n    queue = deque([(0, 0)])  # node, depth or time\n    visited = [False] * n\n    visited[0] = True\n\n    while queue:\n        node, time = queue.popleft()\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                marked_times[neighbor] = time + 1 if neighbor % 2 == 1 else time + 2\n                queue.append((neighbor, marked_times[neighbor]))\n\n    return marked_times\n"}
{"task_id": "3560", "code": "def max_moves(kx: int, ky: int, positions: List[List[int]]) -> int:\n    squares = [[0]*50 for _ in range(50)]\n    knight = (kx, ky)\n    pawns = [(x, y) for x, y in positions]\n    moves = [[-1]*50 for _ in range(50)]\n    bfs = [(knight, 0)]\n    for x, y in pawns:\n        squares[x][y] = 1\n    while bfs:\n        (x, y), d = bfs.pop(0)\n        if moves[x][y] == -1 or d < moves[x][y]:\n            moves[x][y] = d\n            bfs += [((x+dx, y+dy), d+1) for dx, dy in [(-2, -1),(-2, 1),(-1, -2),(-1, 2),(2, -1),(2, 1),(1, -2),(1, 2)] if 0<=x+dx<50 and 0<=y+dy<50 and moves[x+dx][y+dy]==-1 and squares[x+dx][y+dy]==0]\n    moves[knight[0]][knight[1]] = 0\n    return max(moves[x][y] for x, y in pawns)\n", "passed": false, "raw_code": "def max_moves(kx: int, ky: int, positions: List[List[int]]) -> int:\n    squares = [[0]*50 for _ in range(50)]\n    knight = (kx, ky)\n    pawns = [(x, y) for x, y in positions]\n    moves = [[-1]*50 for _ in range(50)]\n    bfs = [(knight, 0)]\n    for x, y in pawns:\n        squares[x][y] = 1\n    while bfs:\n        (x, y), d = bfs.pop(0)\n        if moves[x][y] == -1 or d < moves[x][y]:\n            moves[x][y] = d\n            bfs += [((x+dx, y+dy), d+1) for dx, dy in [(-2, -1),(-2, 1),(-1, -2),(-1, 2),(2, -1),(2, 1),(1, -2),(1, 2)] if 0<=x+dx<50 and 0<=y+dy<50 and moves[x+dx][y+dy]==-1 and squares[x+dx][y+dy]==0]\n    moves[knight[0]][knight[1]] = 0\n    return max(moves[x][y] for x, y in pawns)\n"}
{"final_accuracy": "0.00%"}
{"difficulty": "hard", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_no_public_tests", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "deepseek-ai/deepseek-coder-6.7b-instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majority_dk7b_n_16_hard.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "deepseek-ai/deepseek-coder-6.7b-instruct", "api_base": "http://10.96.183.224:63019/8003/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc365_e", "code": "def solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n    prefix_xor = [0] * (N + 1)\n    for i in range(N):\n        prefix_xor[i+1] = prefix_xor[i] ^ A[i]\n    result = 0\n    for i in range(N):\n        result += A[i] * ((prefix_xor[N] ^ prefix_xor[i+1]) - prefix_xor[i])\n    print(result)\n\nsolve()\n", "passed": false, "raw_code": "def solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n    prefix_xor = [0] * (N + 1)\n    for i in range(N):\n        prefix_xor[i+1] = prefix_xor[i] ^ A[i]\n    result = 0\n    for i in range(N):\n        result += A[i] * ((prefix_xor[N] ^ prefix_xor[i+1]) - prefix_xor[i])\n    print(result)\n\nsolve()\n"}
{"task_id": "abc366_f", "code": "def main():\n    n, k = map(int, input().split())\n    fs = [(a, b) for a, b in [map(int, input().split())] for _ in range(n)]\n    p = list(map(int, input().split()))\n\n    max_value = 0\n    while p:\n        a, b = fs[p.pop() - 1]\n        max_value = a * max_value + b\n\n    print(max_value)\n\nif __name__ == '__main__':\n    main()\n", "passed": false, "raw_code": "def main():\n    n, k = map(int, input().split())\n    fs = [(a, b) for a, b in [map(int, input().split())] for _ in range(n)]\n    p = list(map(int, input().split()))\n\n    max_value = 0\n    while p:\n        a, b = fs[p.pop() - 1]\n        max_value = a * max_value + b\n\n    print(max_value)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "abc368_f", "code": "def game_winner(n, numbers):\n    if n == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\nif __name__ == \"__main__\":\n    n = int(input())\n    numbers = list(map(int, input().split()))\n    game_winner(n, numbers)\n", "passed": false, "raw_code": "def game_winner(n, numbers):\n    if n == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\nif __name__ == \"__main__\":\n    n = int(input())\n    numbers = list(map(int, input().split()))\n    game_winner(n, numbers)\n"}
{"task_id": "abc366_e", "code": "def solve(n, points, d):\n    count = 0\n    for x in range(-10**6, 10**6+1):\n        for y in range(-10**6, 10**6+1):\n            total_distance = sum(abs(x-point[0]) + abs(y-point[1]) for point in points)\n            if total_distance <= d:\n                count += 1\n    return count\n\nif __name__ == '__main__':\n    import sys\n    N, D = map(int, sys.stdin.readline().split())\n    points = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    print(solve(N, points, D))\n", "passed": false, "raw_code": "def solve(n, points, d):\n    count = 0\n    for x in range(-10**6, 10**6+1):\n        for y in range(-10**6, 10**6+1):\n            total_distance = sum(abs(x-point[0]) + abs(y-point[1]) for point in points)\n            if total_distance <= d:\n                count += 1\n    return count\n\nif __name__ == '__main__':\n    import sys\n    N, D = map(int, sys.stdin.readline().split())\n    points = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    print(solve(N, points, D))\n"}
{"task_id": "abc368_d", "code": "", "passed": false, "raw_code": ""}
{"task_id": "abc367_g", "code": "# import time\n\nMOD = 998244353 \n\ndef solve(n, m, k, a):\n\n    a.sort()\n    f = [1] \n    for i in range(1, n + 1): \n        f.append(f[-1] * i % MOD) \n\n    fac = [1]\n    for i in range(1, 2 * n + 1):\n        fac.append(fac[-1] * i % MOD) \n\n    inv = [1]\n    for i in range(1, 2 * n + 1):\n        inv.append(inv[-1] * pow(i, MOD - 2, MOD) % MOD) \n\n    def comb(n, m):\n        if m < 0 or m > n: \n            return 0\n        return fac[n] * inv[m] % MOD * inv[n - m] % MOD \n\n    p = [0] * (n + 1) \n    q = [0] * (n + 1) \n    s = 0\n    l = 0\n    r = 0\n\n    for i in range(n):\n        while l < i and a[i] - a[l] >= m:\n            l += 1\n\n        while r < i and a[r] <= a[i] - m:\n            r += 1\n\n        p[i] = l - 1\n        q[i] = n - 1 - i + r + 1 \n        s += sum(q[p[i]+1:i]) - sum(q[i+1:]) - ((a[i] // m * comb(q[i], q[i] - a[i] // m + 1)) % MOD) \n\n    s %= MOD \n\n    return (pow(2, n, MOD) - 1 - s) % MOD if m == 1 else ((pow(2, n, MOD) - 1 - s) * pow(m - 1, k, MOD) % MOD)\n\n# N, M, K = map(int, input().split())\n# A = list(map(int, input().split()))\n\n# start = time.time()\n# result = solve(N, M, K, A)\n# print (result)\n# print (\"Time:\", time.time()-start)\n", "passed": false, "raw_code": "# import time\n\nMOD = 998244353 \n\ndef solve(n, m, k, a):\n\n    a.sort()\n    f = [1] \n    for i in range(1, n + 1): \n        f.append(f[-1] * i % MOD) \n\n    fac = [1]\n    for i in range(1, 2 * n + 1):\n        fac.append(fac[-1] * i % MOD) \n\n    inv = [1]\n    for i in range(1, 2 * n + 1):\n        inv.append(inv[-1] * pow(i, MOD - 2, MOD) % MOD) \n\n    def comb(n, m):\n        if m < 0 or m > n: \n            return 0\n        return fac[n] * inv[m] % MOD * inv[n - m] % MOD \n\n    p = [0] * (n + 1) \n    q = [0] * (n + 1) \n    s = 0\n    l = 0\n    r = 0\n\n    for i in range(n):\n        while l < i and a[i] - a[l] >= m:\n            l += 1\n\n        while r < i and a[r] <= a[i] - m:\n            r += 1\n\n        p[i] = l - 1\n        q[i] = n - 1 - i + r + 1 \n        s += sum(q[p[i]+1:i]) - sum(q[i+1:]) - ((a[i] // m * comb(q[i], q[i] - a[i] // m + 1)) % MOD) \n\n    s %= MOD \n\n    return (pow(2, n, MOD) - 1 - s) % MOD if m == 1 else ((pow(2, n, MOD) - 1 - s) * pow(m - 1, k, MOD) % MOD)\n\n# N, M, K = map(int, input().split())\n# A = list(map(int, input().split()))\n\n# start = time.time()\n# result = solve(N, M, K, A)\n# print (result)\n# print (\"Time:\", time.time()-start)\n"}
{"task_id": "abc369_e", "code": "import sys\n\ndef get_answer(N, M, bridges, Q, query):\n    INF = float('inf')\n    graph = [[INF] * (N + 1) for _ in range(N + 1)]\n\n    for u, v, t in bridges:\n        graph[u][v] = graph[v][u] = min(graph[u][v], t)\n    \n    for i in range(1, N + 1):\n        graph[i][i] = 0\n\n    for k in range(1, N + 1):\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n\n    for q in range(Q):\n        answer = INF\n        for perm in query[q]:\n            time = sum(graph[u][v] for u, v in zip(perm, perm[1:]))\n            answer = min(answer, time)\n        print(answer)\n\n\ndef read_input():\n    N, M = map(int, sys.stdin.readline().split())\n    bridges = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n    Q = int(sys.stdin.readline())\n    query = [list(map(int, sys.stdin.readline().split())) for _ in range(Q)]\n    query = [[(u-1, v-1, t-1) for u, v, t in q[2:]] for q in query] # Adjust to 0-indexed\n    return N, M, bridges, Q, query\n\n\nif __name__ == '__main__':\n    N, M, bridges, Q, query = read_input()\n    get_answer(N, M, bridges, Q, query)\n", "passed": false, "raw_code": "import sys\n\ndef get_answer(N, M, bridges, Q, query):\n    INF = float('inf')\n    graph = [[INF] * (N + 1) for _ in range(N + 1)]\n\n    for u, v, t in bridges:\n        graph[u][v] = graph[v][u] = min(graph[u][v], t)\n    \n    for i in range(1, N + 1):\n        graph[i][i] = 0\n\n    for k in range(1, N + 1):\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n\n    for q in range(Q):\n        answer = INF\n        for perm in query[q]:\n            time = sum(graph[u][v] for u, v in zip(perm, perm[1:]))\n            answer = min(answer, time)\n        print(answer)\n\n\ndef read_input():\n    N, M = map(int, sys.stdin.readline().split())\n    bridges = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n    Q = int(sys.stdin.readline())\n    query = [list(map(int, sys.stdin.readline().split())) for _ in range(Q)]\n    query = [[(u-1, v-1, t-1) for u, v, t in q[2:]] for q in query] # Adjust to 0-indexed\n    return N, M, bridges, Q, query\n\n\nif __name__ == '__main__':\n    N, M, bridges, Q, query = read_input()\n    get_answer(N, M, bridges, Q, query)\n"}
{"task_id": "abc370_e", "code": "MOD = 998244353\nN_MAX = 2 * 10**5 + 10\nK_MAX = 10**15\nA_MAX = 10**9\n\nfac = [0] * N_MAX\nfinv = [0] * N_MAX\ninv = [0] * N_MAX\n\ndef com_init():\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1\n    for i in range(2, N_MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\ndef com(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\ndef solve():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    S = [0] * (N + 1)\n    for i in range(N):\n        S[i + 1] = (S[i] + A[i]) % MOD\n\n    cnt = [0] * (N + 1)\n    for i in range(1, N + 1):\n        cnt[i] = (cnt[i - 1] + A[i - 1]) % MOD\n\n    f = [0] * (N + 1)\n    f[0] = 1\n    for i in range(1, N + 1):\n        f[i] = f[i - 1] * 2 % MOD\n        if f[i] < 0:\n            f[i] += MOD\n\n    ans = 0\n    for i in range(0, N):\n        if A[i] > K:\n            break\n        j = min(i, N - (K - S[N] + MOD) // A[i] - 1)\n        ans = (ans + com(cnt[j + 1], j + 1) * f[j + 1] % MOD * 2 % MOD -\n               com(cnt[i + 1], i + 1) * f[i + 1] % MOD - \n               com(cnt[j + 1], j + 1) % MOD) % MOD\n        if ans < 0:\n            ans += MOD\n\n    print(ans if ans >= 0 else ans + MOD)\n\nif __name__ == '__main__':\n    com_init()\n    solve()\n", "passed": false, "raw_code": "MOD = 998244353\nN_MAX = 2 * 10**5 + 10\nK_MAX = 10**15\nA_MAX = 10**9\n\nfac = [0] * N_MAX\nfinv = [0] * N_MAX\ninv = [0] * N_MAX\n\ndef com_init():\n    fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1\n    for i in range(2, N_MAX):\n        fac[i] = fac[i - 1] * i % MOD\n        inv[i] = MOD - inv[MOD%i] * (MOD // i) % MOD\n        finv[i] = finv[i - 1] * inv[i] % MOD\n\ndef com(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD\n\ndef solve():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    S = [0] * (N + 1)\n    for i in range(N):\n        S[i + 1] = (S[i] + A[i]) % MOD\n\n    cnt = [0] * (N + 1)\n    for i in range(1, N + 1):\n        cnt[i] = (cnt[i - 1] + A[i - 1]) % MOD\n\n    f = [0] * (N + 1)\n    f[0] = 1\n    for i in range(1, N + 1):\n        f[i] = f[i - 1] * 2 % MOD\n        if f[i] < 0:\n            f[i] += MOD\n\n    ans = 0\n    for i in range(0, N):\n        if A[i] > K:\n            break\n        j = min(i, N - (K - S[N] + MOD) // A[i] - 1)\n        ans = (ans + com(cnt[j + 1], j + 1) * f[j + 1] % MOD * 2 % MOD -\n               com(cnt[i + 1], i + 1) * f[i + 1] % MOD - \n               com(cnt[j + 1], j + 1) % MOD) % MOD\n        if ans < 0:\n            ans += MOD\n\n    print(ans if ans >= 0 else ans + MOD)\n\nif __name__ == '__main__':\n    com_init()\n    solve()\n"}
{"task_id": "abc367_f", "code": "def process_queries():\n    n, q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    queries = [list(map(int, input().split())) for _ in range(q)]\n\n    for l, r, L, R in queries:\n        subseqA = A[l-1:r]\n        subseqB = B[L-1:R]\n        subseqA.sort()\n        subseqB.sort()\n        \n        if subseqA == subseqB:\n            print('Yes')\n        else:\n            print('No')\n\nprocess_queries()\n", "passed": false, "raw_code": "def process_queries():\n    n, q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    queries = [list(map(int, input().split())) for _ in range(q)]\n\n    for l, r, L, R in queries:\n        subseqA = A[l-1:r]\n        subseqB = B[L-1:R]\n        subseqA.sort()\n        subseqB.sort()\n        \n        if subseqA == subseqB:\n            print('Yes')\n        else:\n            print('No')\n\nprocess_queries()\n"}
{"task_id": "abc371_g", "code": "def solve():\n    N = int(input().strip())\n    P = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    # Use permutation to map the permutation to the original array\n    B = [0] * (N + 1)\n    for i in range(1, N+1):\n        B[P[i-1]] = A[i-1]\n    \n    # Print the result\n    print(' '.join(map(str, B[1:N+1])))\n\nsolve()\n", "passed": false, "raw_code": "def solve():\n    N = int(input().strip())\n    P = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    # Use permutation to map the permutation to the original array\n    B = [0] * (N + 1)\n    for i in range(1, N+1):\n        B[P[i-1]] = A[i-1]\n    \n    # Print the result\n    print(' '.join(map(str, B[1:N+1])))\n\nsolve()\n"}
{"task_id": "abc366_g", "code": "from collections import defaultdict\nfrom itertools import product\n\ndef solve_graph(N, M, edges):\n    adj = defaultdict(list)\n    degrees = [0] * (N+1)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n\n    for x in range(1, 2**60):\n        if all((x ^ y) in adj[z] for z, y in product(range(1, N+1), repeat=2) if degrees[z] >= 1):\n            return x\n    return -1\n", "passed": false, "raw_code": "from collections import defaultdict\nfrom itertools import product\n\ndef solve_graph(N, M, edges):\n    adj = defaultdict(list)\n    degrees = [0] * (N+1)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n\n    for x in range(1, 2**60):\n        if all((x ^ y) in adj[z] for z, y in product(range(1, N+1), repeat=2) if degrees[z] >= 1):\n            return x\n    return -1\n"}
{"task_id": "abc368_g", "code": "def solve(n, A, B, Q, queries):\n    ans = []\n    v = 0\n    for q in queries:\n        if q[0] == 3:\n            l = q[1]\n            r = q[2]\n            sumA = 0\n            sumB = 0\n            for i in range(n):\n                if i >= l-1 and i <= r-1:\n                    sumA += A[i]\n                    sumB += B[i]\n            v = (sumA * sumB) % (10**9)\n            ans.append(v)\n        elif q[0] == 1:\n            A[q[1]-1] = q[2]\n        elif q[0] == 2:\n            B[q[1]-1] = q[2]\n    return ans\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nQ = int(input())\nqueries = []\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    queries.append(query)\nres = solve(N, A, B, Q, queries)\nfor r in res:\n    print(r)\n", "passed": false, "raw_code": "def solve(n, A, B, Q, queries):\n    ans = []\n    v = 0\n    for q in queries:\n        if q[0] == 3:\n            l = q[1]\n            r = q[2]\n            sumA = 0\n            sumB = 0\n            for i in range(n):\n                if i >= l-1 and i <= r-1:\n                    sumA += A[i]\n                    sumB += B[i]\n            v = (sumA * sumB) % (10**9)\n            ans.append(v)\n        elif q[0] == 1:\n            A[q[1]-1] = q[2]\n        elif q[0] == 2:\n            B[q[1]-1] = q[2]\n    return ans\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nQ = int(input())\nqueries = []\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    queries.append(query)\nres = solve(N, A, B, Q, queries)\nfor r in res:\n    print(r)\n"}
{"task_id": "abc368_e", "code": "import sys\nfrom operator import itemgetter\n\nn, m, x1 = map(int, sys.stdin.readline().split())\ntrains = [None] * m\nfor i in range(m):\n    a, b, s, t = map(int, sys.stdin.readline().split())\n    trains[i] = (a, b, -s, t, i)\n\n# sort trains by the departure time of A_i and B_i.\ntrains.sort(key=itemgetter(0, 1))\n\n# sort trains by the original order (i)\ntrains.sort(key=itemgetter(4))\n\n# initial X_i\nx = [0] * m\n\n# find the X_i\nfor i in range(m-1, -1, -1):\n    a, b, _, t, _ = trains[i]\n    # find a delay time that makes the condition hold\n    for j in range(x1, -1, -1):\n        if i + j >= m:\n            continue\n        _, _, s2, t2, _ = trains[i+j]\n        if t + j <= s2:\n            x[i] = j\n            x1 = j\n            break\n\nprint(' '.join(map(str, x)))\n", "passed": false, "raw_code": "import sys\nfrom operator import itemgetter\n\nn, m, x1 = map(int, sys.stdin.readline().split())\ntrains = [None] * m\nfor i in range(m):\n    a, b, s, t = map(int, sys.stdin.readline().split())\n    trains[i] = (a, b, -s, t, i)\n\n# sort trains by the departure time of A_i and B_i.\ntrains.sort(key=itemgetter(0, 1))\n\n# sort trains by the original order (i)\ntrains.sort(key=itemgetter(4))\n\n# initial X_i\nx = [0] * m\n\n# find the X_i\nfor i in range(m-1, -1, -1):\n    a, b, _, t, _ = trains[i]\n    # find a delay time that makes the condition hold\n    for j in range(x1, -1, -1):\n        if i + j >= m:\n            continue\n        _, _, s2, t2, _ = trains[i+j]\n        if t + j <= s2:\n            x[i] = j\n            x1 = j\n            break\n\nprint(' '.join(map(str, x)))\n"}
{"task_id": "abc369_g", "code": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef build_graph(edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    return graph\n\ndef dijkstra(graph, start, k):\n    dist = [float('inf')] * (N+1)\n    dist[start] = 0\n    pq = [(0, start)]\n    dp = [[float('inf')] * (k+1) for _ in range(N+1)]\n    dp[start][0] = 0\n\n    while pq:\n        d, node = heapq.heappop(pq)\n        if dist[node] < d:\n            continue\n        for neighbor, w in graph[node]:\n            if d + w < dist[neighbor]:\n                dist[neighbor] = d + w\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            for j in range(min(k, len(graph[start]) - 1)):\n                if dp[node][j] < float('inf'):\n                    dp[neighbor][j+1] = min(dp[neighbor][j+1], dp[node][j] + w)\n    return min(dp[1])\n\nN = int(sys.stdin.readline())\nedges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N-1)]\ngraph = build_graph(edges)\n\nfor k in range(1, N+1):\n    print(dijkstra(graph, 1, k))\n", "passed": false, "raw_code": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef build_graph(edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    return graph\n\ndef dijkstra(graph, start, k):\n    dist = [float('inf')] * (N+1)\n    dist[start] = 0\n    pq = [(0, start)]\n    dp = [[float('inf')] * (k+1) for _ in range(N+1)]\n    dp[start][0] = 0\n\n    while pq:\n        d, node = heapq.heappop(pq)\n        if dist[node] < d:\n            continue\n        for neighbor, w in graph[node]:\n            if d + w < dist[neighbor]:\n                dist[neighbor] = d + w\n                heapq.heappush(pq, (dist[neighbor], neighbor))\n            for j in range(min(k, len(graph[start]) - 1)):\n                if dp[node][j] < float('inf'):\n                    dp[neighbor][j+1] = min(dp[neighbor][j+1], dp[node][j] + w)\n    return min(dp[1])\n\nN = int(sys.stdin.readline())\nedges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N-1)]\ngraph = build_graph(edges)\n\nfor k in range(1, N+1):\n    print(dijkstra(graph, 1, k))\n"}
{"task_id": "abc371_e", "code": "from collections import defaultdict\n\ndef solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    prefix_count = defaultdict(int)\n    distinct_count = [0] * (N + 1)\n    total = 0\n\n    for i in range(N - 1, -1, -1):\n        if prefix_count[A[i]] == 0:\n            total += len(prefix_count)\n            distinct_count[i] = len(prefix_count)\n        prefix_count[A[i]] += 1\n\n    print(total)\n\nsolve()\n", "passed": false, "raw_code": "from collections import defaultdict\n\ndef solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n\n    prefix_count = defaultdict(int)\n    distinct_count = [0] * (N + 1)\n    total = 0\n\n    for i in range(N - 1, -1, -1):\n        if prefix_count[A[i]] == 0:\n            total += len(prefix_count)\n            distinct_count[i] = len(prefix_count)\n        prefix_count[A[i]] += 1\n\n    print(total)\n\nsolve()\n"}
{"task_id": "abc367_e", "code": "import sys\n\ndef perform_operations():\n    N, K = map(int, sys.stdin.readline().split())\n    X = list(map(int, sys.stdin.readline().split()))\n    A = list(map(int, sys.stdin.readline().split()))\n\n    for k in range(K):\n        B = [0] * N\n        for i in range(N):\n            B[i] = A[X[i] - 1]\n        A = B\n\n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    perform_operations()\n", "passed": false, "raw_code": "import sys\n\ndef perform_operations():\n    N, K = map(int, sys.stdin.readline().split())\n    X = list(map(int, sys.stdin.readline().split()))\n    A = list(map(int, sys.stdin.readline().split()))\n\n    for k in range(K):\n        B = [0] * N\n        for i in range(N):\n            B[i] = A[X[i] - 1]\n        A = B\n\n    print(' '.join(map(str, A)))\n\nif __name__ == \"__main__\":\n    perform_operations()\n"}
{"task_id": "abc370_f", "code": "import sys\n\ndef min_weight(n, k, masses):\n    min_cut = 1e9\n    for start in range(k):\n        cut = start\n        group = [0]*k\n        group_masses = [0]*k\n        for i in range(start, start+n):\n            group[i%k] += 1\n            group_masses[i%k] += masses[i%n]\n        weight = max(group_masses)\n        min_weight = min(group_masses)\n        if weight - min_weight < min_cut:\n            min_cut = weight - min_weight\n            min_range = group\n            min_start = start\n    uncut_cut = 0\n    for i in range(min_start, min_start+n):\n        if min_range[i%k] == 1 and masses[i%n] == min_weight:\n            uncut_cut += 1\n    return min_weight, uncut_cut\n\n\nn, k = map(int, sys.stdin.readline().split())\nmasses = list(map(int, sys.stdin.readline().split()))\nmin_weight, uncut_cut = min_weight(n, k, masses)\nprint(min_weight, uncut_cut)\n", "passed": false, "raw_code": "import sys\n\ndef min_weight(n, k, masses):\n    min_cut = 1e9\n    for start in range(k):\n        cut = start\n        group = [0]*k\n        group_masses = [0]*k\n        for i in range(start, start+n):\n            group[i%k] += 1\n            group_masses[i%k] += masses[i%n]\n        weight = max(group_masses)\n        min_weight = min(group_masses)\n        if weight - min_weight < min_cut:\n            min_cut = weight - min_weight\n            min_range = group\n            min_start = start\n    uncut_cut = 0\n    for i in range(min_start, min_start+n):\n        if min_range[i%k] == 1 and masses[i%n] == min_weight:\n            uncut_cut += 1\n    return min_weight, uncut_cut\n\n\nn, k = map(int, sys.stdin.readline().split())\nmasses = list(map(int, sys.stdin.readline().split()))\nmin_weight, uncut_cut = min_weight(n, k, masses)\nprint(min_weight, uncut_cut)\n"}
{"task_id": "abc372_g", "code": "from bisect import bisect_right\nfrom heapq import merge\n\ndef solve(A, B, C):\n    n = len(A)\n    AB = sorted((a/b, a, b) for a, b, c in zip(A, B, C) if b != 0)\n    order = sorted(range(n), key=lambda i: -C[i]/A[i])\n    result = 0\n    h = []\n    for i in order:\n        while AB and AB[-1][0] >= C[i]/A[i]:\n            _, a, b = AB.pop()\n            h.append((a, b))\n        h.sort(reverse=True)\n        j = bisect_right(h, (C[i], 0))\n        result += len(h) - j\n        h = h[:j]\n    return result\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        AB = [list(map(int, input().strip().split())) for _ in range(n)]\n        print(solve(*zip(*AB)))\n    \nif __name__ == '__main__':\n    main()\n", "passed": false, "raw_code": "from bisect import bisect_right\nfrom heapq import merge\n\ndef solve(A, B, C):\n    n = len(A)\n    AB = sorted((a/b, a, b) for a, b, c in zip(A, B, C) if b != 0)\n    order = sorted(range(n), key=lambda i: -C[i]/A[i])\n    result = 0\n    h = []\n    for i in order:\n        while AB and AB[-1][0] >= C[i]/A[i]:\n            _, a, b = AB.pop()\n            h.append((a, b))\n        h.sort(reverse=True)\n        j = bisect_right(h, (C[i], 0))\n        result += len(h) - j\n        h = h[:j]\n    return result\n\ndef main():\n    t = int(input().strip())\n    for _ in range(t):\n        n = int(input().strip())\n        AB = [list(map(int, input().strip().split())) for _ in range(n)]\n        print(solve(*zip(*AB)))\n    \nif __name__ == '__main__':\n    main()\n"}
{"task_id": "abc371_f", "code": "import sys\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef min_movements():\n    n = get_int()\n    x = get_ints()\n    q = get_int()\n    persons = [0] * (n + 1)\n    movements = 0\n    for i in range(1, n + 1):\n        persons[i] = x[i - 1]\n    for _ in range(q):\n        t, g = get_ints()\n        if t < persons[1] or t > persons[n]:\n            movements += abs(persons[1] - g) if abs(persons[1] - g) > abs(persons[n] - g) else abs(persons[n] - g)\n            if persons[1] > g:\n                for i in range(1, n + 1):\n                    persons[i] -= abs(persons[1] - g)\n                persons[1] = g\n            else:\n                for i in range(n, 0, -1):\n                    persons[i] += abs(persons[n] - g)\n                persons[n] = g\n        else:\n            for i in range(1, n + 1):\n                if persons[i] > persons[i - 1] and persons[i] > g and persons[i - 1] <= g:\n                    movements += persons[i] - g\n                    for j in range(i, n + 1):\n                        persons[j] -= persons[i] - g\n                    persons[i - 1] += persons[i] - g\n    print(movements)\n", "passed": false, "raw_code": "import sys\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_ints():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef min_movements():\n    n = get_int()\n    x = get_ints()\n    q = get_int()\n    persons = [0] * (n + 1)\n    movements = 0\n    for i in range(1, n + 1):\n        persons[i] = x[i - 1]\n    for _ in range(q):\n        t, g = get_ints()\n        if t < persons[1] or t > persons[n]:\n            movements += abs(persons[1] - g) if abs(persons[1] - g) > abs(persons[n] - g) else abs(persons[n] - g)\n            if persons[1] > g:\n                for i in range(1, n + 1):\n                    persons[i] -= abs(persons[1] - g)\n                persons[1] = g\n            else:\n                for i in range(n, 0, -1):\n                    persons[i] += abs(persons[n] - g)\n                persons[n] = g\n        else:\n            for i in range(1, n + 1):\n                if persons[i] > persons[i - 1] and persons[i] > g and persons[i - 1] <= g:\n                    movements += persons[i] - g\n                    for j in range(i, n + 1):\n                        persons[j] -= persons[i] - g\n                    persons[i - 1] += persons[i] - g\n    print(movements)\n"}
{"task_id": "abc372_e", "code": "from heapq import nlargest\nfrom collections import defaultdict\nimport sys\n\ndef main():\n    # read the first line\n    N, Q = map(int, sys.stdin.readline().split())\n    \n    # initialize adjacency list\n    adj_list = defaultdict(set)\n    \n    queries = []\n    for _ in range(Q):\n        q = sys.stdin.readline().split()\n        queries.append(q)\n    \n    # process queries\n    for q in queries:\n        op = q[0]\n        if op == '1':\n            u, v = int(q[1]), int(q[2])\n            adj_list[min(u, v)].add(max(u, v))\n            adj_list[max(u, v)].add(min(u, v))\n        elif op == '2':\n            v, k = int(q[1]), int(q[2])\n            kth_largest = nlargest(k, adj_list[v])\n            if len(kth_largest) < k:\n                print(-1)\n            else:\n                print(kth_largest[-1])\n\nif __name__ == \"__main__\":\n    main()\n", "passed": false, "raw_code": "from heapq import nlargest\nfrom collections import defaultdict\nimport sys\n\ndef main():\n    # read the first line\n    N, Q = map(int, sys.stdin.readline().split())\n    \n    # initialize adjacency list\n    adj_list = defaultdict(set)\n    \n    queries = []\n    for _ in range(Q):\n        q = sys.stdin.readline().split()\n        queries.append(q)\n    \n    # process queries\n    for q in queries:\n        op = q[0]\n        if op == '1':\n            u, v = int(q[1]), int(q[2])\n            adj_list[min(u, v)].add(max(u, v))\n            adj_list[max(u, v)].add(min(u, v))\n        elif op == '2':\n            v, k = int(q[1]), int(q[2])\n            kth_largest = nlargest(k, adj_list[v])\n            if len(kth_largest) < k:\n                print(-1)\n            else:\n                print(kth_largest[-1])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "abc373_f", "code": "def readInput():\n    N, W = map(int, input().split())\n    items = [list(map(int, input().split())) for _ in range(N)]\n    return N, W, items\n\ndef solve(N, W, items):\n    dp = [0 for _ in range(W+1)]\n    for w, v in items:\n        for i in range(W, w-1, -1):\n            dp[i] = max(dp[i], dp[i-w] + v * w)\n    return dp[-1]\n\nif __name__ == \"__main__\":\n    N, W, items = readInput()\n    print(solve(N, W, items))\n", "passed": false, "raw_code": "def readInput():\n    N, W = map(int, input().split())\n    items = [list(map(int, input().split())) for _ in range(N)]\n    return N, W, items\n\ndef solve(N, W, items):\n    dp = [0 for _ in range(W+1)]\n    for w, v in items:\n        for i in range(W, w-1, -1):\n            dp[i] = max(dp[i], dp[i-w] + v * w)\n    return dp[-1]\n\nif __name__ == \"__main__\":\n    N, W, items = readInput()\n    print(solve(N, W, items))\n"}
{"task_id": "arc182_e", "code": "if __name__ == '__main__':\n    N, M, C, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(min_sum(N, M, C, K, A))\n", "passed": false, "raw_code": "if __name__ == '__main__':\n    N, M, C, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    print(min_sum(N, M, C, K, A))\n"}
{"task_id": "abc373_g", "code": "def read_input():\n    N = int(input())\n    points = []\n    points_dict = {}\n    for _ in range(N):\n        A, B = map(int, input().split())\n        points.append((A, B))\n        points_dict[(A, B)] = len(points)\n    for _ in range(N):\n        C, D = map(int, input().split())\n        points.append((C, D))\n    return N, points, points_dict\n\n\ndef ccw(A, B, C):\n    return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0])\n\n\ndef distance(A, B):\n    return (A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2\n\n\ndef graham_scan(N, points):\n    points = sorted(points)\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and ccw(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and ccw(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return lower[:-1] + upper[:-1]\n\n\ndef solve():\n    N, points, points_dict = read_input()\n    hull = graham_scan(N, points)\n    if len(hull) != N:\n        print(-1)\n        return\n    R = [points_dict[p] for p in hull]\n    print(' '.join(map(str, R)))\n\n\nif __name__ == '__main__':\n    solve()\n", "passed": false, "raw_code": "def read_input():\n    N = int(input())\n    points = []\n    points_dict = {}\n    for _ in range(N):\n        A, B = map(int, input().split())\n        points.append((A, B))\n        points_dict[(A, B)] = len(points)\n    for _ in range(N):\n        C, D = map(int, input().split())\n        points.append((C, D))\n    return N, points, points_dict\n\n\ndef ccw(A, B, C):\n    return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0])\n\n\ndef distance(A, B):\n    return (A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2\n\n\ndef graham_scan(N, points):\n    points = sorted(points)\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and ccw(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and ccw(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return lower[:-1] + upper[:-1]\n\n\ndef solve():\n    N, points, points_dict = read_input()\n    hull = graham_scan(N, points)\n    if len(hull) != N:\n        print(-1)\n        return\n    R = [points_dict[p] for p in hull]\n    print(' '.join(map(str, R)))\n\n\nif __name__ == '__main__':\n    solve()\n"}
{"task_id": "arc181_b", "code": "def f(s, x, y):\n    return ''.join(s if x[i] == '0' else y[i] for i in range(len(x)))\n    \ndef solve(s, x, y):\n    if len(x) != len(y):\n        return 'No'\n    if f(s, x, y) == f(s, y, x):\n        return 'Yes'\n    return 'No'\n\nt = int(input().strip())\n\nfor _ in range(t):\n    s = input().strip()\n    x = input().strip()\n    y = input().strip()\n    print(solve(s, x, y))\n", "passed": false, "raw_code": "def f(s, x, y):\n    return ''.join(s if x[i] == '0' else y[i] for i in range(len(x)))\n    \ndef solve(s, x, y):\n    if len(x) != len(y):\n        return 'No'\n    if f(s, x, y) == f(s, y, x):\n        return 'Yes'\n    return 'No'\n\nt = int(input().strip())\n\nfor _ in range(t):\n    s = input().strip()\n    x = input().strip()\n    y = input().strip()\n    print(solve(s, x, y))\n"}
{"task_id": "abc373_e", "code": "def get_additional_votes():\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    total_votes = sum(A)\n    remaining_votes = K - total_votes\n\n    if M > remaining_votes:\n        print(-1)\n    else:\n        A.sort()\n        C = [0]*N\n        for i in range(N-1, -1, -1):\n            if A[i] + remaining_votes < M:\n                C[i] = A[i-1] - A[i] + 1 if i > 0 else 1\n                remaining_votes -= C[i]\n\n        print(' '.join([str(x) if x >= 0 else '-1' for x in C]))\n\n# test the function\nget_additional_votes()\n", "passed": false, "raw_code": "def get_additional_votes():\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    total_votes = sum(A)\n    remaining_votes = K - total_votes\n\n    if M > remaining_votes:\n        print(-1)\n    else:\n        A.sort()\n        C = [0]*N\n        for i in range(N-1, -1, -1):\n            if A[i] + remaining_votes < M:\n                C[i] = A[i-1] - A[i] + 1 if i > 0 else 1\n                remaining_votes -= C[i]\n\n        print(' '.join([str(x) if x >= 0 else '-1' for x in C]))\n\n# test the function\nget_additional_votes()\n"}
{"task_id": "arc182_d", "code": "from collections import defaultdict as dd\nfrom sys import stdin\n\ndef get_ints():\n    return list(map(int, stdin.readline().strip().split()))\n\ndef solve(n, m, a, b):\n    diff = [0]*n\n    for i in range(n):\n        diff[i] = (b[i]-a[i])%m\n    count = [0]*m\n    count[diff[0]] = 1\n    for i in range(1,n):\n        count = [(count[j]+count[(j-diff[i])%m])%(10**9+7) for j in range(m)]\n    return count[0]\n\ndef main():\n    n, m = get_ints()\n    a = get_ints()\n    b = get_ints()\n    if a==b:\n        print(0)\n    else:\n        print(solve(n, m, a, b))\n\nif __name__=='__main__':\n    main()\n", "passed": false, "raw_code": "from collections import defaultdict as dd\nfrom sys import stdin\n\ndef get_ints():\n    return list(map(int, stdin.readline().strip().split()))\n\ndef solve(n, m, a, b):\n    diff = [0]*n\n    for i in range(n):\n        diff[i] = (b[i]-a[i])%m\n    count = [0]*m\n    count[diff[0]] = 1\n    for i in range(1,n):\n        count = [(count[j]+count[(j-diff[i])%m])%(10**9+7) for j in range(m)]\n    return count[0]\n\ndef main():\n    n, m = get_ints()\n    a = get_ints()\n    b = get_ints()\n    if a==b:\n        print(0)\n    else:\n        print(solve(n, m, a, b))\n\nif __name__=='__main__':\n    main()\n"}
{"task_id": "arc181_c", "code": "import sys\nfrom bisect import bisect_left\n\ndef generate_grid(N, P, Q):\n    P = [p - 1 for p in P]\n    Q = [q - 1 for q in Q]\n\n    P_inv = [0] * N\n    for i, p in enumerate(P):\n        P_inv[p] = i\n\n    Q_inv = [0] * N\n    for i, q in enumerate(Q):\n        Q_inv[q] = i\n\n    grid = [['0'] * N for _ in range(N)]\n    S = [''.join(grid[i][j] for j in range(N)) for i in range(N)]\n    T = [''.join(grid[i][j] for i in range(N)) for j in range(N)]\n\n    def find_next(s, p):\n        s_inv = [(char, i) for i, char in enumerate(s)]\n        s_inv.sort()\n        p_val = s_inv[p][0]\n\n        indices = [i for char, i in s_inv if char == p_val]\n        p_next = bisect_left(indices, P_inv[p])\n        if p_next == len(indices):\n            p_next = 0\n\n        s_inv[p] = ('1', s_inv[p][1])\n        s_inv.sort()\n        s_next = ''.join(char for char, i in s_inv)\n        return s_next\n\n    for _ in range(N * N - 1):\n        for i, si in enumerate(S):\n            if si < T[i]:\n                S[i] = find_next(si, P[i])\n                break\n        else:\n            for j, tj in enumerate(T):\n                if S[j] < tj:\n                    T[j] = find_next(tj, j)\n                    break\n\n    for i, p in enumerate(P):\n        grid[i][Q[i]] = '1'\n    return '\\n'.join(''.join(row) for row in grid)\n\nif __name__ == '__main__':\n    N = int(sys.stdin.readline())\n    P = list(map(int, sys.stdin.readline().split()))\n    Q = list(map(int, sys.stdin.readline().split()))\n    print(generate_grid(N, P, Q))\n", "passed": false, "raw_code": "import sys\nfrom bisect import bisect_left\n\ndef generate_grid(N, P, Q):\n    P = [p - 1 for p in P]\n    Q = [q - 1 for q in Q]\n\n    P_inv = [0] * N\n    for i, p in enumerate(P):\n        P_inv[p] = i\n\n    Q_inv = [0] * N\n    for i, q in enumerate(Q):\n        Q_inv[q] = i\n\n    grid = [['0'] * N for _ in range(N)]\n    S = [''.join(grid[i][j] for j in range(N)) for i in range(N)]\n    T = [''.join(grid[i][j] for i in range(N)) for j in range(N)]\n\n    def find_next(s, p):\n        s_inv = [(char, i) for i, char in enumerate(s)]\n        s_inv.sort()\n        p_val = s_inv[p][0]\n\n        indices = [i for char, i in s_inv if char == p_val]\n        p_next = bisect_left(indices, P_inv[p])\n        if p_next == len(indices):\n            p_next = 0\n\n        s_inv[p] = ('1', s_inv[p][1])\n        s_inv.sort()\n        s_next = ''.join(char for char, i in s_inv)\n        return s_next\n\n    for _ in range(N * N - 1):\n        for i, si in enumerate(S):\n            if si < T[i]:\n                S[i] = find_next(si, P[i])\n                break\n        else:\n            for j, tj in enumerate(T):\n                if S[j] < tj:\n                    T[j] = find_next(tj, j)\n                    break\n\n    for i, p in enumerate(P):\n        grid[i][Q[i]] = '1'\n    return '\\n'.join(''.join(row) for row in grid)\n\nif __name__ == '__main__':\n    N = int(sys.stdin.readline())\n    P = list(map(int, sys.stdin.readline().split()))\n    Q = list(map(int, sys.stdin.readline().split()))\n    print(generate_grid(N, P, Q))\n"}
{"task_id": "3550", "code": "", "passed": false, "raw_code": ""}
{"task_id": "arc183_b", "code": "def solve(n, k, a, b):\n    count_a = {i: 0 for i in range(1, n+1)}\n    count_b = {i: 0 for i in range(1, n+1)}\n\n    for i in range(n):\n        count_a[a[i]] += 1\n        count_b[b[i]] += 1\n\n    if count_a != count_b:\n        return \"No\"\n\n    occur_a = {i: [] for i in range(1, n+1)}\n    occur_b = {i: [] for i in range(1, n+1)}\n\n    for i in range(n):\n        occur_a[a[i]].append(i+1)\n        occur_b[b[i]].append(i+1)\n\n    for i in range(1, n+1):\n        if len(occur_a[i]) != len(occur_b[i]):\n            return \"No\"\n\n        count_occur_a = {j: 0 for j in range(1, n+1)}\n        count_occur_b = {j: 0 for j in range(1, n+1)}\n\n        for j in range(len(occur_a[i])):\n            count_occur_a[occur_a[i][j]] += 1\n            count_occur_b[occur_b[i][j]] += 1\n\n        if count_occur_a != count_occur_b:\n            return \"No\"\n\n    return \"Yes\"\n\n# usage\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(solve(n, k, a, b))\n", "passed": false, "raw_code": "def solve(n, k, a, b):\n    count_a = {i: 0 for i in range(1, n+1)}\n    count_b = {i: 0 for i in range(1, n+1)}\n\n    for i in range(n):\n        count_a[a[i]] += 1\n        count_b[b[i]] += 1\n\n    if count_a != count_b:\n        return \"No\"\n\n    occur_a = {i: [] for i in range(1, n+1)}\n    occur_b = {i: [] for i in range(1, n+1)}\n\n    for i in range(n):\n        occur_a[a[i]].append(i+1)\n        occur_b[b[i]].append(i+1)\n\n    for i in range(1, n+1):\n        if len(occur_a[i]) != len(occur_b[i]):\n            return \"No\"\n\n        count_occur_a = {j: 0 for j in range(1, n+1)}\n        count_occur_b = {j: 0 for j in range(1, n+1)}\n\n        for j in range(len(occur_a[i])):\n            count_occur_a[occur_a[i][j]] += 1\n            count_occur_b[occur_b[i][j]] += 1\n\n        if count_occur_a != count_occur_b:\n            return \"No\"\n\n    return \"Yes\"\n\n# usage\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    print(solve(n, k, a, b))\n"}
{"task_id": "3552", "code": "", "passed": false, "raw_code": ""}
{"task_id": "arc183_c", "code": "import sys\n\ndef solve(n, m, conditions):\n    MOD = 998244353\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    pre = [0] * (n + 1)\n    pre[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * i % MOD\n        pre[i] = pre[i - 1] + dp[i]\n    ans, cnt = 1, 1\n    conditions.sort()\n    for i in range(m):\n        l, r, x = conditions[i]\n        while cnt < l:\n            ans = ans * (dp[r - cnt] - dp[r - l]) % MOD\n            ans = ans * pow(dp[cnt] - dp[cnt - 1], MOD - 2, MOD) % MOD\n            cnt += 1\n        if cnt >= l and cnt <= r:\n            ans = ans * (dp[r - l] - dp[x - cnt]) % MOD\n            ans = ans * pow(dp[cnt] - dp[cnt - 1], MOD - 2, MOD) % MOD\n            cnt += 1\n    while cnt <= n:\n        ans = ans * (dp[n - cnt] - dp[n - cnt - 1]) % MOD\n        ans = ans * pow(dp[cnt], MOD - 2, MOD) % MOD\n        cnt += 1\n    return ans\n\nif __name__ == '__main__':\n    n, m = map(int, sys.stdin.readline().strip().split())\n    conditions = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(m)]\n    print(solve(n, m, conditions))\n", "passed": false, "raw_code": "import sys\n\ndef solve(n, m, conditions):\n    MOD = 998244353\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    pre = [0] * (n + 1)\n    pre[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * i % MOD\n        pre[i] = pre[i - 1] + dp[i]\n    ans, cnt = 1, 1\n    conditions.sort()\n    for i in range(m):\n        l, r, x = conditions[i]\n        while cnt < l:\n            ans = ans * (dp[r - cnt] - dp[r - l]) % MOD\n            ans = ans * pow(dp[cnt] - dp[cnt - 1], MOD - 2, MOD) % MOD\n            cnt += 1\n        if cnt >= l and cnt <= r:\n            ans = ans * (dp[r - l] - dp[x - cnt]) % MOD\n            ans = ans * pow(dp[cnt] - dp[cnt - 1], MOD - 2, MOD) % MOD\n            cnt += 1\n    while cnt <= n:\n        ans = ans * (dp[n - cnt] - dp[n - cnt - 1]) % MOD\n        ans = ans * pow(dp[cnt], MOD - 2, MOD) % MOD\n        cnt += 1\n    return ans\n\nif __name__ == '__main__':\n    n, m = map(int, sys.stdin.readline().strip().split())\n    conditions = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(m)]\n    print(solve(n, m, conditions))\n"}
{"task_id": "arc182_c", "code": "MOD = 998244353\n\ndef powmod(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b = b >> 1\n    return res\n\ndef solve(N, M):\n    F = [1]\n    for i in range(1, N * M + 2):\n        F.append(F[-1] * i % MOD)\n    invF = [1]\n    for i in range(1, N * M + 2):\n        invF.append((MOD - MOD // i) * invF[MOD % i] % MOD)\n    invF.reverse()\n    S = [0]\n    for i in range(1, N * M + 2):\n        S.append((S[-1] + invF[i]) % MOD)\n    R = 0\n    for x in range(1, M + 1):\n        r = powmod(x, N)\n        t = (S[min(x - 1, N * M)] - S[max(0, N * M + 1 - r)] + MOD) % MOD\n        R = (R + r * t) % MOD\n    return R\n\nN, M = map(int, input().split())\nprint(solve(N, M))\n", "passed": false, "raw_code": "MOD = 998244353\n\ndef powmod(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b = b >> 1\n    return res\n\ndef solve(N, M):\n    F = [1]\n    for i in range(1, N * M + 2):\n        F.append(F[-1] * i % MOD)\n    invF = [1]\n    for i in range(1, N * M + 2):\n        invF.append((MOD - MOD // i) * invF[MOD % i] % MOD)\n    invF.reverse()\n    S = [0]\n    for i in range(1, N * M + 2):\n        S.append((S[-1] + invF[i]) % MOD)\n    R = 0\n    for x in range(1, M + 1):\n        r = powmod(x, N)\n        t = (S[min(x - 1, N * M)] - S[max(0, N * M + 1 - r)] + MOD) % MOD\n        R = (R + r * t) % MOD\n    return R\n\nN, M = map(int, input().split())\nprint(solve(N, M))\n"}
{"task_id": "abc372_f", "code": "MOD = 998244353\nN, M, K = map(int, input().split())\ngraph = [[0] * (N+1) for _ in range(N+1)]\nfor _ in range(M):\n    x, y = map(int, input().split())\n    graph[x][y] = 1\n\n# Calculate number of ways Takahashi can move from each vertex to other\ndp = [[0] * (K+1) for _ in range(N+1)]\ndp[1][0] = 1\nfor k in range(K):\n    for n in range(1, N+1):\n        dp[n][k+1] = sum(dp[i][k] for i in range(1, N+1) if graph[i][n]) % MOD\n\n# Output the number of ways Takahashi can move exactly K times starting from vertex 1\nprint(dp[1][K])\n", "passed": false, "raw_code": "MOD = 998244353\nN, M, K = map(int, input().split())\ngraph = [[0] * (N+1) for _ in range(N+1)]\nfor _ in range(M):\n    x, y = map(int, input().split())\n    graph[x][y] = 1\n\n# Calculate number of ways Takahashi can move from each vertex to other\ndp = [[0] * (K+1) for _ in range(N+1)]\ndp[1][0] = 1\nfor k in range(K):\n    for n in range(1, N+1):\n        dp[n][k+1] = sum(dp[i][k] for i in range(1, N+1) if graph[i][n]) % MOD\n\n# Output the number of ways Takahashi can move exactly K times starting from vertex 1\nprint(dp[1][K])\n"}
{"task_id": "arc182_a", "code": "N, Q = map(int, input().split())\nPV = [tuple(map(int, input().split())) for _ in range(Q)]\nmod = 998244353\n\n# Sort the positives and their corresponding values\nPV.sort()\n\n# Initialize an array to keep track of the ways to build sequences \ndp = [0] * (N + 2)\ndp[0] = dp[1] = 1\n\n# Initialize an array to store the current max value at each position \nmaxv = [0] * (N + 1)\n\n# Calculate the ways to build sequences\nfor p, v in PV:\n    maxv = [max(x, v) for x in maxv]\n    tmp = [0] * (N + 2)\n    tmp[0] = dp[0]\n    for i in range(N + 1)[::-1]:\n        tmp[i + 1] = (tmp[i] + dp[i + 1] * maxv[i] % mod) % mod\n        dp[i + 1] = (dp[i] + dp[i + 1] * max(maxv[i - 1], v) % mod) % mod\n\nprint(dp[N] if N > 1 else dp[1])\n", "passed": false, "raw_code": "N, Q = map(int, input().split())\nPV = [tuple(map(int, input().split())) for _ in range(Q)]\nmod = 998244353\n\n# Sort the positives and their corresponding values\nPV.sort()\n\n# Initialize an array to keep track of the ways to build sequences \ndp = [0] * (N + 2)\ndp[0] = dp[1] = 1\n\n# Initialize an array to store the current max value at each position \nmaxv = [0] * (N + 1)\n\n# Calculate the ways to build sequences\nfor p, v in PV:\n    maxv = [max(x, v) for x in maxv]\n    tmp = [0] * (N + 2)\n    tmp[0] = dp[0]\n    for i in range(N + 1)[::-1]:\n        tmp[i + 1] = (tmp[i] + dp[i + 1] * maxv[i] % mod) % mod\n        dp[i + 1] = (dp[i] + dp[i + 1] * max(maxv[i - 1], v) % mod) % mod\n\nprint(dp[N] if N > 1 else dp[1])\n"}
{"task_id": "arc181_d", "code": "def count_inversions(n, p, m, a):\n    bit = [0] * (n+1)\n    ans = 0\n    def update(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n    def query(i):\n        s = 0\n        while i > 0:\n            s += bit[i]\n            i -= i & -i\n        return s\n    for i in range(m-1, -1, -1):\n        index = p.index(a[i])\n        ans += index - query(index)\n        update(index)\n        p[index] = 'v'\n        p = [x for x in p if x != 'v'] + [a[i]]\n    return ans\n\nn = int(input())\np = list(map(int, input().split()))\nm = int(input())\na = list(map(int, input().split()))\nprint(count_inversions(n, p, m, a))\n", "passed": false, "raw_code": "def count_inversions(n, p, m, a):\n    bit = [0] * (n+1)\n    ans = 0\n    def update(i):\n        while i <= n:\n            bit[i] += 1\n            i += i & -i\n    def query(i):\n        s = 0\n        while i > 0:\n            s += bit[i]\n            i -= i & -i\n        return s\n    for i in range(m-1, -1, -1):\n        index = p.index(a[i])\n        ans += index - query(index)\n        update(index)\n        p[index] = 'v'\n        p = [x for x in p if x != 'v'] + [a[i]]\n    return ans\n\nn = int(input())\np = list(map(int, input().split()))\nm = int(input())\na = list(map(int, input().split()))\nprint(count_inversions(n, p, m, a))\n"}
{"task_id": "abc370_g", "code": "def goodNumbers(n, m):\n    MOD = 998244353\n    A = [0 for _ in range(n+1)]\n    A[0] = A[1] = 1\n    F = [0 for _ in range(n+1)]\n    F[0] = F[1] = 1\n    for i in range(2, n+1):\n        A[i] = A[i-1]*2%MOD\n        F[i] = F[i-1]*A[i]%MOD\n    for i in range(2, n+1):\n        A[i] = (A[i] - F[i] + MOD) % MOD\n    D = [0 for _ in range(n+1)]\n    D[0] = 1\n    for i in range(1, n+1):\n        D[i] = D[i-1]*A[i] % MOD\n    result = 1\n    while m:\n        if m & 1:\n            result = result * D[n] % MOD\n        D[n] = D[n-1]*A[n] % MOD\n        n -= 1\n        m >>= 1\n    return result\n\nn, m = map(int, input().split())\nprint(goodNumbers(n, m))\n", "passed": false, "raw_code": "def goodNumbers(n, m):\n    MOD = 998244353\n    A = [0 for _ in range(n+1)]\n    A[0] = A[1] = 1\n    F = [0 for _ in range(n+1)]\n    F[0] = F[1] = 1\n    for i in range(2, n+1):\n        A[i] = A[i-1]*2%MOD\n        F[i] = F[i-1]*A[i]%MOD\n    for i in range(2, n+1):\n        A[i] = (A[i] - F[i] + MOD) % MOD\n    D = [0 for _ in range(n+1)]\n    D[0] = 1\n    for i in range(1, n+1):\n        D[i] = D[i-1]*A[i] % MOD\n    result = 1\n    while m:\n        if m & 1:\n            result = result * D[n] % MOD\n        D[n] = D[n-1]*A[n] % MOD\n        n -= 1\n        m >>= 1\n    return result\n\nn, m = map(int, input().split())\nprint(goodNumbers(n, m))\n"}
{"task_id": "arc183_d", "code": "", "passed": false, "raw_code": ""}
{"final_accuracy": "0.00%"}
{"difficulty": "hard", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_no_public_tests", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "deepseek-ai/deepseek-coder-6.7b-instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majority_dk7b_n_16_hard.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "deepseek-ai/deepseek-coder-6.7b-instruct", "api_base": "http://10.96.183.224:63019/8003/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3550", "code": "def maxRooks(board):\n    # get the row and column sums\n    row_sums = [max(row) for row in board]\n    col_sums = [max(column) for column in zip(*board)]\n\n    # get the top 3 maximum sums\n    max_sums = sorted(row_sums + col_sums, reverse=True)[:3]\n\n    # return the sum of the top 3 maximum sums\n    return sum(max_sums)\n", "passed": false, "raw_code": "def maxRooks(board):\n    # get the row and column sums\n    row_sums = [max(row) for row in board]\n    col_sums = [max(column) for column in zip(*board)]\n\n    # get the top 3 maximum sums\n    max_sums = sorted(row_sums + col_sums, reverse=True)[:3]\n\n    # return the sum of the top 3 maximum sums\n    return sum(max_sums)\n"}
{"task_id": "3552", "code": "", "passed": false, "raw_code": ""}
{"task_id": "arc183_d", "code": "from sys import stdin\nfrom collections import namedtuple\n\nPair = namedtuple('Pair', 'first second')\n\ndef solve(n, pairs):\n    pairs.sort(key=lambda p: (p.first, p.second))\n    next_vals = [float('inf')] * n\n    stack = []\n    for pair in reversed(pairs):\n        if pair.second < next_vals[0]:\n            next_vals.pop(0)\n            if stack:\n                print('{} {}'.format(*stack.pop()))\n            stack.append(pair)\n        else:\n            next_vals.append(pair.second)\n            next_vals.sort()\n    while stack:\n        print('{} {}'.format(*stack.pop()))\n\ndef main():\n    n = int(stdin.readline().strip())\n    pairs = []\n    for _ in range(n - 1):\n        line = stdin.readline().strip()\n        first, second = map(int, line.split())\n        pairs.append(Pair(first, second))\n    pairs.sort(key=lambda p: (p.first, p.second))\n    solve(n, pairs)\n\nif __name__ == '__main__':\n    main()\n", "passed": false, "raw_code": "from sys import stdin\nfrom collections import namedtuple\n\nPair = namedtuple('Pair', 'first second')\n\ndef solve(n, pairs):\n    pairs.sort(key=lambda p: (p.first, p.second))\n    next_vals = [float('inf')] * n\n    stack = []\n    for pair in reversed(pairs):\n        if pair.second < next_vals[0]:\n            next_vals.pop(0)\n            if stack:\n                print('{} {}'.format(*stack.pop()))\n            stack.append(pair)\n        else:\n            next_vals.append(pair.second)\n            next_vals.sort()\n    while stack:\n        print('{} {}'.format(*stack.pop()))\n\ndef main():\n    n = int(stdin.readline().strip())\n    pairs = []\n    for _ in range(n - 1):\n        line = stdin.readline().strip()\n        first, second = map(int, line.split())\n        pairs.append(Pair(first, second))\n    pairs.sort(key=lambda p: (p.first, p.second))\n    solve(n, pairs)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "abc368_d", "code": "from collections import defaultdict, deque\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ndef main():\n    N, K = map(int, input().split())\n    graph = defaultdict(list)\n    parent = [0]*(N+1)\n    depth = [0]*(N+1)\n    nodes = set(range(1, N+1))\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    V = list(map(int, input().split()))\n    if K == N:\n        print(0)\n        return\n    q = deque([(V[0], -1)])\n    while q:\n        node, d = q.popleft()\n        depth[node] = d+1\n        parent[node] = d\n        for nxt in graph[node]:\n            if nxt != parent[node]:\n                q.append((nxt, depth[node]))\n    lca = [0]*K\n    lca[0] = V[0]\n    for i in range(1, K):\n        lca[i] = parent[V[i]] > depth[V[i]]*2 - depth[lca[i-1]]\n    cover = [0]*(N+1)\n    for i in range(K):\n        node = V[i]\n        cover[node] += 1\n        if i == K-1 or parent[V[i+1]] != depth[V[i+1]]*2 - depth[V[i]] - 1:\n            while node != lca[i]:\n                cover[node] -= 1\n                node = parent[node]\n            cover[lca[i]] += 1\n        else:\n            while node != lca[i]:\n                cover[node] -= 1\n                node = parent[node]\n    print(sum(v == 0 for v in cover))\n\nif __name__ == \"__main__\":\n    main()\n", "passed": false, "raw_code": "from collections import defaultdict, deque\nimport sys\n\nsys.setrecursionlimit(10**9)\n\ndef main():\n    N, K = map(int, input().split())\n    graph = defaultdict(list)\n    parent = [0]*(N+1)\n    depth = [0]*(N+1)\n    nodes = set(range(1, N+1))\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    V = list(map(int, input().split()))\n    if K == N:\n        print(0)\n        return\n    q = deque([(V[0], -1)])\n    while q:\n        node, d = q.popleft()\n        depth[node] = d+1\n        parent[node] = d\n        for nxt in graph[node]:\n            if nxt != parent[node]:\n                q.append((nxt, depth[node]))\n    lca = [0]*K\n    lca[0] = V[0]\n    for i in range(1, K):\n        lca[i] = parent[V[i]] > depth[V[i]]*2 - depth[lca[i-1]]\n    cover = [0]*(N+1)\n    for i in range(K):\n        node = V[i]\n        cover[node] += 1\n        if i == K-1 or parent[V[i+1]] != depth[V[i+1]]*2 - depth[V[i]] - 1:\n            while node != lca[i]:\n                cover[node] -= 1\n                node = parent[node]\n            cover[lca[i]] += 1\n        else:\n            while node != lca[i]:\n                cover[node] -= 1\n                node = parent[node]\n    print(sum(v == 0 for v in cover))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"final_accuracy": "0.00%"}
{"difficulty": "hard", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_no_public_tests", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "deepseek-ai/deepseek-coder-6.7b-instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majority_dk7b_n_16_hard.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "deepseek-ai/deepseek-coder-6.7b-instruct", "api_base": "http://10.96.183.224:63019/8003/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3552", "code": "", "passed": false, "raw_code": ""}
{"final_accuracy": "0.00%"}
{"difficulty": "hard", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_no_public_tests", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "deepseek-ai/deepseek-coder-6.7b-instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majority_dk7b_n_16_hard.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "deepseek-ai/deepseek-coder-6.7b-instruct", "api_base": "http://10.96.183.224:63019/8003/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3552", "code": "", "passed": false, "raw_code": ""}
{"final_accuracy": "0.00%"}
