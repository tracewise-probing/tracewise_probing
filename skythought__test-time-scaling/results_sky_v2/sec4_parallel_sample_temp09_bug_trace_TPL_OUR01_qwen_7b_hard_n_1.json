"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.9, \"n\": 1, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_temp09_bug_trace_TPL_OUR01_qwen_7b_hard_n_1.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42, \"resume\": true}"
{"task_id": "3532", "codes": ["def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj = defaultdict(list)\n    \n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    times = [0] * n\n    marked = [False] * n\n    marked[0] = True\n    \n    q = deque([0])\n    time = 0\n    \n    while q:\n        for _ in range(len(q)):\n            node = q.popleft()\n            for neighbor in adj[node]:\n                if not marked[neighbor]:\n                    marked[neighbor] = True\n                    if node % 2 == 0:\n                        times[neighbor] = time + 2\n                    else:\n                        times[neighbor] = time + 1\n                    q.append(neighbor)\n        time += 1\n    \n    return times[1:]"], "passed": [false], "raw_code": ["```python\ndef minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj = defaultdict(list)\n    \n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    times = [0] * n\n    marked = [False] * n\n    marked[0] = True\n    \n    q = deque([0])\n    time = 0\n    \n    while q:\n        for _ in range(len(q)):\n            node = q.popleft()\n            for neighbor in adj[node]:\n                if not marked[neighbor]:\n                    marked[neighbor] = True\n                    if node % 2 == 0:\n                        times[neighbor] = time + 2\n                    else:\n                        times[neighbor] = time + 1\n                    q.append(neighbor)\n        time += 1\n    \n    return times[1:]\n```"]}
{"task_id": "abc368_f", "codes": ["```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_one = sum(1 for x in A if x > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()"], "passed": [false], "raw_code": ["```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_one = sum(1 for x in A if x > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()"]}
{"task_id": "abc370_e", "codes": ["def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Iterate over each element in the array\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - A[i - 1]]) % MOD\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n    \n    # Sum up all valid partitions where the last subsequence sum is not K\n    result = 0\n    for j in range(K + 1):\n        if j != K:\n            result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(count_partitions(N, K, A))"], "passed": [false], "raw_code": ["```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Iterate over each element in the array\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - A[i - 1]]) % MOD\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n    \n    # Sum up all valid partitions where the last subsequence sum is not K\n    result = 0\n    for j in range(K + 1):\n        if j != K:\n            result = (result + dp[N][j]) % MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(count_partitions(N, K, A))\n```"]}
{"task_id": "arc181_b", "codes": ["```python\ndef f(S, T, X):\n    result = \"\"\n    for i in range(len(X)):\n        if X[i] == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        if len(X) == len(Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nsolve()"], "passed": [false], "raw_code": ["```python\ndef f(S, T, X):\n    result = \"\"\n    for i in range(len(X)):\n        if X[i] == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        if len(X) == len(Y):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nsolve()"]}
{"task_id": "abc369_g", "codes": ["```python\nimport sys\nfrom collections import defaultdict, deque\nfrom functools import lru_cache\n\ndef bfs_distances(n, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    def bfs(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor, weight in graph[node]:\n                if dist[neighbor] == -1:\n                    dist[neighbor] = dist[node] + weight\n                    queue.append(neighbor)\n        return dist\n    \n    return [bfs(i) for i in range(1, n + 1)]\n\n@lru_cache(None)\ndef min_path_length(mask, last_vertex):\n    if mask == 0:\n        return 0\n    min_len = float('inf')\n    for i in range(1, n + 1):\n        if mask & (1 << i):\n            new_mask = mask ^ (1 << i)\n            if new_mask == 0:\n                min_len = min(min_len, dist[last_vertex][i])\n            else:\n                min_len = min(min_len, dist[last_vertex][i] + min_path_length(new_mask, i))\n    return min_len\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    dist = bfs_distances(n, edges)\n    \n    results = []\n    for K in range(1, n + 1):\n        result = min_path_length((1 << (K + 1)) - 1, 0) + dist[0][1]\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict, deque\nfrom functools import lru_cache\n\ndef bfs_distances(n, edges):\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    def bfs(start):\n        dist = [-1] * (n + 1)\n        dist[start] = 0\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor, weight in graph[node]:\n                if dist[neighbor] == -1:\n                    dist[neighbor] = dist[node] + weight\n                    queue.append(neighbor)\n        return dist\n    \n    return [bfs(i) for i in range(1, n + 1)]\n\n@lru_cache(None)\ndef min_path_length(mask, last_vertex):\n    if mask == 0:\n        return 0\n    min_len = float('inf')\n    for i in range(1, n + 1):\n        if mask & (1 << i):\n            new_mask = mask ^ (1 << i)\n            if new_mask == 0:\n                min_len = min(min_len, dist[last_vertex][i])\n            else:\n                min_len = min(min_len, dist[last_vertex][i] + min_path_length(new_mask, i))\n    return min_len\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    dist = bfs_distances(n, edges)\n    \n    results = []\n    for K in range(1, n + 1):\n        result = min_path_length((1 << (K + 1)) - 1, 0) + dist[0][1]\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"]}
{"task_id": "abc372_g", "codes": ["def count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    \n    # Iterate over possible values of x\n    for x in range(1, max(A) * max(C) // min(B) + 1):\n        # Calculate the maximum possible y using binary search\n        low, high = 0, max(C)\n        while low <= high:\n            mid = (low + high) // 2\n            if A[x-1] * x + B[x-1] * mid < C[x-1]:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        # The number of valid y values for this x\n        count += low\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        B = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        C = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        \n        results.append(count_valid_pairs(A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    \n    # Iterate over possible values of x\n    for x in range(1, max(A) * max(C) // min(B) + 1):\n        # Calculate the maximum possible y using binary search\n        low, high = 0, max(C)\n        while low <= high:\n            mid = (low + high) // 2\n            if A[x-1] * x + B[x-1] * mid < C[x-1]:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        # The number of valid y values for this x\n        count += low\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        B = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        C = [int(data[index]) for index in range(index, index + N)]\n        index += N\n        \n        results.append(count_valid_pairs(A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc366_f", "codes": ["```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    x = 1\n    for i in range(K):\n        A, B = functions[i]\n        x = A * x + B\n    \n    print(x)\n\n# Call the function\nmax_nested_function_value()"], "passed": [false], "raw_code": ["```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    x = 1\n    for i in range(K):\n        A, B = functions[i]\n        x = A * x + B\n    \n    print(x)\n\n# Call the function\nmax_nested_function_value()"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Initialize base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i-1][j-1]) % MOD\n            dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i-1][j]) % MOD\n            \n            if j < 50:\n                dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i-1][j+1]) % MOD\n            dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i-1][j]) % MOD\n    \n    count = 0\n    for j in range(51):\n        count = (count + dp_inc[-1][j] * dp_dec[-1][j]) % MOD\n    \n    return count"], "passed": [false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Initialize base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            if j > 0:\n                dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i-1][j-1]) % MOD\n            dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i-1][j]) % MOD\n            \n            if j < 50:\n                dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i-1][j+1]) % MOD\n            dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i-1][j]) % MOD\n    \n    count = 0\n    for j in range(51):\n        count = (count + dp_inc[-1][j] * dp_dec[-1][j]) % MOD\n    \n    return count\n```"]}
{"task_id": "abc371_f", "codes": ["```python\ndef min_movements(N, X, Q, tasks):\n    # Sort people by their initial positions\n    sorted_people = sorted(range(N), key=lambda i: X[i])\n    \n    # Sort tasks by their target positions\n    sorted_tasks = sorted(tasks, key=lambda x: x[1])\n    \n    # Initialize pointers and used array\n    person_ptr = 0\n    used = [False] * N\n    total_moves = 0\n    \n    # Process each task\n    for task in sorted_tasks:\n        target_person = task[0] - 1\n        target_position = task[1]\n        \n        while True:\n            if not used[sorted_people[person_ptr]]:\n                used[sorted_people[person_ptr]] = True\n                break\n            person_ptr += 1\n        \n        # Calculate the distance to the target position\n        moves = abs(X[sorted_people[person_ptr]] - target_position)\n        total_moves += moves\n    \n    return total_moves\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\ntasks = [(int(data[N+2 + 2*i]) - 1, int(data[N+3 + 2*i])) for i in range(Q)]\n\n# Calculate and print result\nresult = min_movements(N, X, Q, tasks)\nprint"], "passed": [false], "raw_code": ["```python\ndef min_movements(N, X, Q, tasks):\n    # Sort people by their initial positions\n    sorted_people = sorted(range(N), key=lambda i: X[i])\n    \n    # Sort tasks by their target positions\n    sorted_tasks = sorted(tasks, key=lambda x: x[1])\n    \n    # Initialize pointers and used array\n    person_ptr = 0\n    used = [False] * N\n    total_moves = 0\n    \n    # Process each task\n    for task in sorted_tasks:\n        target_person = task[0] - 1\n        target_position = task[1]\n        \n        while True:\n            if not used[sorted_people[person_ptr]]:\n                used[sorted_people[person_ptr]] = True\n                break\n            person_ptr += 1\n        \n        # Calculate the distance to the target position\n        moves = abs(X[sorted_people[person_ptr]] - target_position)\n        total_moves += moves\n    \n    return total_moves\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\ntasks = [(int(data[N+2 + 2*i]) - 1, int(data[N+3 + 2*i])) for i in range(Q)]\n\n# Calculate and print result\nresult = min_movements(N, X, Q, tasks)\nprint"]}
{"task_id": "abc367_e", "codes": ["```python\ndef process_sequence(N, K, X, A):\n    # Create a mapping to find the next index in the cycle\n    next_index = {i: X[i - 1] for i in range(1, N + 1)}\n    \n    # Function to follow the cycle starting from index i\n    def follow_cycle(i):\n        indices = []\n        while i not in indices:\n            indices.append(i)\n            i = next_index[i]\n        return indices\n    \n    # Find all cycles\n    visited = set()\n    cycles = []\n    for i in range(1, N + 1):\n        if i not in visited:\n            cycle = follow_cycle(i)\n            visited.update(cycle)\n            cycles.append(cycle)\n    \n    # Function to apply the operation within a cycle k times\n    def apply_operation_in_cycle(A, cycle, k):\n        n = len(cycle)\n        for _ in range(k):\n            for j in range(n):\n                A[cycle[j] - 1] = A[next_index[cycle[j]] - 1]\n        return A\n    \n    # Apply the operation to each cycle\n    for cycle in cycles:\n        cycle_length = len(cycle)\n        k_effective = K % cycle_length\n        A = apply_operation_in_cycle(A, cycle, k_effective)\n    \n    return A\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Process the sequence\nresult = process_sequence(N, K, X, A)\n\n# Print the result\nprint(' '.join(map(str, result)))"], "passed": [false], "raw_code": ["```python\ndef process_sequence(N, K, X, A):\n    # Create a mapping to find the next index in the cycle\n    next_index = {i: X[i - 1] for i in range(1, N + 1)}\n    \n    # Function to follow the cycle starting from index i\n    def follow_cycle(i):\n        indices = []\n        while i not in indices:\n            indices.append(i)\n            i = next_index[i]\n        return indices\n    \n    # Find all cycles\n    visited = set()\n    cycles = []\n    for i in range(1, N + 1):\n        if i not in visited:\n            cycle = follow_cycle(i)\n            visited.update(cycle)\n            cycles.append(cycle)\n    \n    # Function to apply the operation within a cycle k times\n    def apply_operation_in_cycle(A, cycle, k):\n        n = len(cycle)\n        for _ in range(k):\n            for j in range(n):\n                A[cycle[j] - 1] = A[next_index[cycle[j]] - 1]\n        return A\n    \n    # Apply the operation to each cycle\n    for cycle in cycles:\n        cycle_length = len(cycle)\n        k_effective = K % cycle_length\n        A = apply_operation_in_cycle(A, cycle, k_effective)\n    \n    return A\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Process the sequence\nresult = process_sequence(N, K, X, A)\n\n# Print the result\nprint(' '.join(map(str, result)))"]}
{"task_id": "abc368_e", "codes": ["```python\ndef calculate_delays(N, M, X1, trains):\n    X = [X1] * M\n    for i in range(M):\n        for j in range(M):\n            if trains[i][1] == trains[j][0] and trains[i][2] <= trains[j][1]:\n                X[j] = max(X[j], trains[j][1] - trains[i][2] + X[i])\n    return X[1:]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nindex = 3\nfor _ in range(M):\n    A = int(data[index])\n    B = int(data[index + 1])\n    S = int(data[index + 2])\n    T = int(data[index + 3])\n    trains.append((A, B, S, T))\n    index += 4\n\n# Calculate delays\ndelays = calculate_delays(N, M, X1, trains)\n\n# Print results\nprint(\" \".join(map(str, delays)))"], "passed": [false], "raw_code": ["```python\ndef calculate_delays(N, M, X1, trains):\n    X = [X1] * M\n    for i in range(M):\n        for j in range(M):\n            if trains[i][1] == trains[j][0] and trains[i][2] <= trains[j][1]:\n                X[j] = max(X[j], trains[j][1] - trains[i][2] + X[i])\n    return X[1:]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\ntrains = []\nindex = 3\nfor _ in range(M):\n    A = int(data[index])\n    B = int(data[index + 1])\n    S = int(data[index + 2])\n    T = int(data[index + 3])\n    trains.append((A, B, S, T))\n    index += 4\n\n# Calculate delays\ndelays = calculate_delays(N, M, X1, trains)\n\n# Print results\nprint(\" \".join(map(str, delays)))"]}
{"task_id": "abc365_e", "codes": ["def calculate_xor_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Compute the prefix XOR array\n    prefix_xor = [0]\n    xor_val = 0\n    for num in A:\n        xor_val ^= num\n        prefix_xor.append(xor_val)\n\n    total_sum = 0\n    # Iterate over all pairs (i, j) and compute the XOR sum\n    for i in range(1, N):\n        for j in range(i, N):\n            total_sum += prefix_xor[j] ^ prefix_xor[i - 1]\n\n    print(total_sum)\n\ncalculate_xor_sum()"], "passed": [false], "raw_code": ["```python\ndef calculate_xor_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Compute the prefix XOR array\n    prefix_xor = [0]\n    xor_val = 0\n    for num in A:\n        xor_val ^= num\n        prefix_xor.append(xor_val)\n\n    total_sum = 0\n    # Iterate over all pairs (i, j) and compute the XOR sum\n    for i in range(1, N):\n        for j in range(i, N):\n            total_sum += prefix_xor[j] ^ prefix_xor[i - 1]\n\n    print(total_sum)\n\ncalculate_xor_sum()\n```"]}
{"task_id": "abc373_g", "codes": ["```python\nimport sys\n\ndef find_non_intersecting_permutation(N, P, Q):\n    # Sort points P based on x-coordinate\n    P.sort(key=lambda p: p[0])\n    \n    # Function to check if adding a new segment intersects with existing ones\n    def intersects(i, j):\n        nonlocal P, Q\n        for k in range(i):\n            x1, y1 = P[i]\n            x2, y2 = Q[i]\n            x3, y3 = P[k]\n            x4, y4 = Q[j]\n            if (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0:\n                return True\n        return False\n    \n    # Try to find a permutation R using a greedy approach\n    R = [-1] * N\n    used = [False] * N\n    \n    for i in range(N):\n        for j in range(N):\n            if not used[j] and not intersects(i, j):\n                R[i] = j\n                used[j] = True\n                break\n    \n    return R\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = []\nQ = []\n\nfor i in range(1, 2*N+1, 2):\n    P.append((int(data[i]), int(data[i+1])))\n\nfor i in range(2*N+1, 3*N+1, 2):\n    Q.append((int(data[i]), int(data[i+1])))\n\n# Find the permutation\nR = find_non_intersecting_permutation(N, P, Q)\n\n# Print the result\nif all(x == -1 for x in R):\n    print(-1)\nelse:\n    print(' '.join(map(str, R)))"], "passed": [false], "raw_code": ["```python\nimport sys\n\ndef find_non_intersecting_permutation(N, P, Q):\n    # Sort points P based on x-coordinate\n    P.sort(key=lambda p: p[0])\n    \n    # Function to check if adding a new segment intersects with existing ones\n    def intersects(i, j):\n        nonlocal P, Q\n        for k in range(i):\n            x1, y1 = P[i]\n            x2, y2 = Q[i]\n            x3, y3 = P[k]\n            x4, y4 = Q[j]\n            if (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0:\n                return True\n        return False\n    \n    # Try to find a permutation R using a greedy approach\n    R = [-1] * N\n    used = [False] * N\n    \n    for i in range(N):\n        for j in range(N):\n            if not used[j] and not intersects(i, j):\n                R[i] = j\n                used[j] = True\n                break\n    \n    return R\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = []\nQ = []\n\nfor i in range(1, 2*N+1, 2):\n    P.append((int(data[i]), int(data[i+1])))\n\nfor i in range(2*N+1, 3*N+1, 2):\n    Q.append((int(data[i]), int(data[i+1])))\n\n# Find the permutation\nR = find_non_intersecting_permutation(N, P, Q)\n\n# Print the result\nif all(x == -1 for x in R):\n    print(-1)\nelse:\n    print(' '.join(map(str, R)))"]}
{"task_id": "abc372_f", "codes": ["```python\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index]) - 1\n        Y = int(data[index + 1]) - 1\n        edges.append((X, Y))\n        index += 2\n    \n    dp = [[0] * (K + 1) for _ in range(N)]\n    dp[0][0] = 1\n    \n    for k in range(1, K + 1):\n        for v in range(N):\n            dp[v][k] = dp[v][(k - 1) % (K + 1)]\n            for u, w in edges:\n                if w == v:\n                    dp[v][k] = (dp[v][k] + dp[u][(k - 1) % (K + 1)]) % MOD\n    \n    result = sum(dp[v][K] for v in range(N)) % MOD\n    print(result)\n\nmain()"], "passed": [false], "raw_code": ["```python\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index]) - 1\n        Y = int(data[index + 1]) - 1\n        edges.append((X, Y))\n        index += 2\n    \n    dp = [[0] * (K + 1) for _ in range(N)]\n    dp[0][0] = 1\n    \n    for k in range(1, K + 1):\n        for v in range(N):\n            dp[v][k] = dp[v][(k - 1) % (K + 1)]\n            for u, w in edges:\n                if w == v:\n                    dp[v][k] = (dp[v][k] + dp[u][(k - 1) % (K + 1)]) % MOD\n    \n    result = sum(dp[v][K] for v in range(N)) % MOD\n    print(result)\n\nmain()"]}
{"task_id": "arc183_d", "codes": ["```python\ndef max_score_operations(N):\n    operations = []\n    for i in range(1, N//2 + 1):\n        operations.append((i * 2, i * 2 - 1))\n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = data[1:]\n\n# Generate operations\noperations = max_score_operations(N)\n\n# Print operations\nfor op in operations:\n    print(op[0], op[1])"], "passed": [false], "raw_code": ["```python\ndef max_score_operations(N):\n    operations = []\n    for i in range(1, N//2 + 1):\n        operations.append((i * 2, i * 2 - 1))\n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = data[1:]\n\n# Generate operations\noperations = max_score_operations(N)\n\n# Print operations\nfor op in operations:\n    print(op[0], op[1])"]}
{"task_id": "abc366_g", "codes": ["import sys\nfrom collections import defaultdict\n\ndef solve(N, M, edges):\n    # Create adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Check if there's a solution using Gaussian elimination over GF(2)\n    def xor(a, b):\n        return a ^ b\n\n    def gaussian_elimination(A, b):\n        n = len(b)\n        for i in range(n):\n            max_row = i\n            for j in range(i + 1, n):\n                if A[j][i] > A[max_row][i]:\n                    max_row = j\n            A[i], A[max_row] = A[max_row], A[i]\n            b[i], b[max_row] = b[max_row], b[i]\n            pivot = A[i][i]\n            for j in range(i, n):\n                A[i][j] ^= pivot\n            b[i] ^= pivot\n            for j in range(n):\n                if j != i:\n                    factor = A[j][i]\n                    for k in range(i, n):\n                        A[j][k] ^= factor * A[i][k]\n                    b[j] ^= factor * b[i]\n\n        # Check if the system is consistent\n        for i in range(n):\n            if A[i][i] == 0 and b[i] != 0:\n                return False\n        return True\n\n    # Set up the system of equations\n    A = [[0] * N for _ in range(N)]\n    b = [0] * N\n    for i in range(1, N + 1):\n        for neighbor in adj_list[i]:\n            A[neighbor - 1][i - 1] = 1\n\n    # Solve the system\n    if not gaussian_elimination(A, b):\n        print('No')\n        return\n\n    # Assign values to vertices\n    values = [0] * N\n    for i in range(N):\n        if i == 0:\n            values[i] = 1  # Start with any value for the first vertex\n        else:\n            values[i] = sum(values[j - 1] for j in adj_list[i + 1])\n\n    # Print the solution\n    print('Yes')\n    print(' '.join(map(str, values)))\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    edges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(M)]\n    solve(N, M, edges)"], "passed": [false], "raw_code": ["import sys\nfrom collections import defaultdict\n\ndef solve(N, M, edges):\n    # Create adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Check if there's a solution using Gaussian elimination over GF(2)\n    def xor(a, b):\n        return a ^ b\n\n    def gaussian_elimination(A, b):\n        n = len(b)\n        for i in range(n):\n            max_row = i\n            for j in range(i + 1, n):\n                if A[j][i] > A[max_row][i]:\n                    max_row = j\n            A[i], A[max_row] = A[max_row], A[i]\n            b[i], b[max_row] = b[max_row], b[i]\n            pivot = A[i][i]\n            for j in range(i, n):\n                A[i][j] ^= pivot\n            b[i] ^= pivot\n            for j in range(n):\n                if j != i:\n                    factor = A[j][i]\n                    for k in range(i, n):\n                        A[j][k] ^= factor * A[i][k]\n                    b[j] ^= factor * b[i]\n\n        # Check if the system is consistent\n        for i in range(n):\n            if A[i][i] == 0 and b[i] != 0:\n                return False\n        return True\n\n    # Set up the system of equations\n    A = [[0] * N for _ in range(N)]\n    b = [0] * N\n    for i in range(1, N + 1):\n        for neighbor in adj_list[i]:\n            A[neighbor - 1][i - 1] = 1\n\n    # Solve the system\n    if not gaussian_elimination(A, b):\n        print('No')\n        return\n\n    # Assign values to vertices\n    values = [0] * N\n    for i in range(N):\n        if i == 0:\n            values[i] = 1  # Start with any value for the first vertex\n        else:\n            values[i] = sum(values[j - 1] for j in adj_list[i + 1])\n\n    # Print the solution\n    print('Yes')\n    print(' '.join(map(str, values)))\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    edges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(M)]\n    solve(N, M, edges)"]}
{"task_id": "arc182_d", "codes": ["def min_operations_to_transform():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:]))\n    \n    # Check if A and B are good sequences\n    for i in range(N - 1):\n        if A[i] == A[i + 1] or B[i] == B[i + 1]:\n            return -1\n    \n    # Calculate minimum operations\n    total_operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        total_operations += min(diff, M - diff)\n    \n    return total_operations\n\n# Call the function to get the result\nresult = min_operations_to_transform()\nprint(result)"], "passed": [false], "raw_code": ["```python\ndef min_operations_to_transform():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:]))\n    \n    # Check if A and B are good sequences\n    for i in range(N - 1):\n        if A[i] == A[i + 1] or B[i] == B[i + 1]:\n            return -1\n    \n    # Calculate minimum operations\n    total_operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        total_operations += min(diff, M - diff)\n    \n    return total_operations\n\n# Call the function to get the result\nresult = min_operations_to_transform()\nprint(result)\n```"]}
{"task_id": "arc182_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Precompute the minimum values for each possible remainder\n    min_values = [float('inf')] * M\n    for Ai in A:\n        for k in range(M):\n            min_values[(C * k + Ai) % M] = min(min_values[(C * k + Ai) % M], Ai)\n    \n    # Find the cycle length\n    cycle_length = gcd(C, M)\n    \n    # Compute the sum of minimums for the first cycle\n    sum_first_cycle = sum(min_values[:cycle_length])\n    \n    # Number of full cycles\n    num_full_cycles = K // cycle_length\n    \n    # Sum for full cycles\n    total_sum = num_full_cycles * sum_first_cycle\n    \n    # Remaining elements\n    remaining_elements = K % cycle_length\n    \n    # Sum for remaining elements\n    for k in range(remaining_elements):\n        total_sum += min_values[k]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n\nimport math\ndef gcd(a, b):\n    return math.gcd(a, b)"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Precompute the minimum values for each possible remainder\n    min_values = [float('inf')] * M\n    for Ai in A:\n        for k in range(M):\n            min_values[(C * k + Ai) % M] = min(min_values[(C * k + Ai) % M], Ai)\n    \n    # Find the cycle length\n    cycle_length = gcd(C, M)\n    \n    # Compute the sum of minimums for the first cycle\n    sum_first_cycle = sum(min_values[:cycle_length])\n    \n    # Number of full cycles\n    num_full_cycles = K // cycle_length\n    \n    # Sum for full cycles\n    total_sum = num_full_cycles * sum_first_cycle\n    \n    # Remaining elements\n    remaining_elements = K % cycle_length\n    \n    # Sum for remaining elements\n    for k in range(remaining_elements):\n        total_sum += min_values[k]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n\nimport math\ndef gcd(a, b):\n    return math.gcd(a, b)\n```"]}
{"task_id": "arc182_a", "codes": ["```python\nMOD = 998244353\n\ndef count_valid_sequences(N, Q, P, V):\n    dp = [0] * (Q + 1)\n    dp[0] = 1\n    \n    for i in range(1, Q + 1):\n        dp[i] = dp[i - 1]\n        \n        if P[i - 1] == 1:\n            dp[i] += dp[i - 1]\n        else:\n            for j in range(P[i - 1], N + 1):\n                dp[i] += dp[j - 1]\n        \n        dp[i] %= MOD\n    \n    return dp[Q]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\n\nfor i in range(Q):\n    p = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    P.append(p)\n    V.append(v)\n\n# Calculate the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)"], "passed": [false], "raw_code": ["```python\nMOD = 998244353\n\ndef count_valid_sequences(N, Q, P, V):\n    dp = [0] * (Q + 1)\n    dp[0] = 1\n    \n    for i in range(1, Q + 1):\n        dp[i] = dp[i - 1]\n        \n        if P[i - 1] == 1:\n            dp[i] += dp[i - 1]\n        else:\n            for j in range(P[i - 1], N + 1):\n                dp[i] += dp[j - 1]\n        \n        dp[i] %= MOD\n    \n    return dp[Q]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\n\nfor i in range(Q):\n    p = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    P.append(p)\n    V.append(v)\n\n# Calculate the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)"]}
{"task_id": "abc368_d", "codes": ["```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef dfs_lca(u, parent, depth):\n    depths[u] = depth\n    parents[u][0] = parent\n    for v in adj[u]:\n        if v != parent:\n            dfs_lca(v, u, depth + 1)\n\ndef preprocess_lca():\n    global depths, parents\n    for k in range(1, max_depth):\n        for u in range(n + 1):\n            if parents[u][k - 1] != -1:\n                parents[u][k] = parents[parents[u][k - 1]][k - 1]\n\ndef get_lca(u, v):\n    if depths[u] > depths[v]:\n        u, v = v, u\n    d = depths[v] - depths[u]\n    for k in range(max_depth):\n        if (d >> k) & 1:\n            v = parents[v][k]\n    if u == v:\n        return u\n    for k in range(max_depth - 1, -1, -1):\n        if parents[u][k] != parents[v][k]:\n            u, v = parents[u][k], parents[v][k]\n    return parents[u][0]\n\ndef min_vertices_in_subtree(n, edges, k, vertices):\n    global adj, depths, parents, max_depth\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Preprocess for LCA\n    depths = [-1] * (n + 1)\n    parents = [[-1] * 20 for _ in range(n + 1)]  # Assuming log(N) <= 20\n    max_depth = 20\n    dfs_lca(1, -1, 0)\n    preprocess_lca()\n    \n    result = 0\n    for i in range(k - 1):\n        lca = get_lca(vertices[i], vertices[i + 1])\n        result += depths[lca] - depths[vertices[i]]\n    result += k\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 + 2 * i]) - 1\n    v = int(data[3 + 2 * i]) - 1\n    edges.append((u, v))\nvertices = [int(x) - 1 for x in data[2 + 2 * n:]]\n\n# Calculate and print the result\nresult = min_vertices_in_subtree(n, edges, k, vertices)\nprint(result)"], "passed": [false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef dfs_lca(u, parent, depth):\n    depths[u] = depth\n    parents[u][0] = parent\n    for v in adj[u]:\n        if v != parent:\n            dfs_lca(v, u, depth + 1)\n\ndef preprocess_lca():\n    global depths, parents\n    for k in range(1, max_depth):\n        for u in range(n + 1):\n            if parents[u][k - 1] != -1:\n                parents[u][k] = parents[parents[u][k - 1]][k - 1]\n\ndef get_lca(u, v):\n    if depths[u] > depths[v]:\n        u, v = v, u\n    d = depths[v] - depths[u]\n    for k in range(max_depth):\n        if (d >> k) & 1:\n            v = parents[v][k]\n    if u == v:\n        return u\n    for k in range(max_depth - 1, -1, -1):\n        if parents[u][k] != parents[v][k]:\n            u, v = parents[u][k], parents[v][k]\n    return parents[u][0]\n\ndef min_vertices_in_subtree(n, edges, k, vertices):\n    global adj, depths, parents, max_depth\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Preprocess for LCA\n    depths = [-1] * (n + 1)\n    parents = [[-1] * 20 for _ in range(n + 1)]  # Assuming log(N) <= 20\n    max_depth = 20\n    dfs_lca(1, -1, 0)\n    preprocess_lca()\n    \n    result = 0\n    for i in range(k - 1):\n        lca = get_lca(vertices[i], vertices[i + 1])\n        result += depths[lca] - depths[vertices[i]]\n    result += k\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 + 2 * i]) - 1\n    v = int(data[3 + 2 * i]) - 1\n    edges.append((u, v))\nvertices = [int(x) - 1 for x in data[2 + 2 * n:]]\n\n# Calculate and print the result\nresult = min_vertices_in_subtree(n, edges, k, vertices)\nprint(result)"]}
{"task_id": "abc367_f", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read input values\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n\n    results = []\n\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n\n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n\n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n\n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read input values\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n\n    results = []\n\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n\n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n\n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n\n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3575", "codes": ["def max_value_of_subsequence(nums, k):\n    n = len(nums)\n    dp = [[0] * (1 << n) for _ in range(k + 1)]\n    \n    for i in range(n):\n        dp[0][1 << i] = nums[i]\n    \n    for i in range(1, k + 1):\n        for mask in range(1 << n):\n            if bin(mask).count('1') == i:\n                for j in range(i):\n                    left_mask = (1 << j) - 1\n                    right_mask = (1 << (i - j)) - 1\n                    if (mask & left_mask) == left_mask and (mask & right_mask) == right_mask:\n                        dp[i][mask] = max(dp[i][mask], dp[j][left_mask] ^ dp[i - j][right_mask])\n    \n    return dp[k][(1 << (2 * k)) - 1]"], "passed": [false], "raw_code": ["```python\ndef max_value_of_subsequence(nums, k):\n    n = len(nums)\n    dp = [[0] * (1 << n) for _ in range(k + 1)]\n    \n    for i in range(n):\n        dp[0][1 << i] = nums[i]\n    \n    for i in range(1, k + 1):\n        for mask in range(1 << n):\n            if bin(mask).count('1') == i:\n                for j in range(i):\n                    left_mask = (1 << j) - 1\n                    right_mask = (1 << (i - j)) - 1\n                    if (mask & left_mask) == left_mask and (mask & right_mask) == right_mask:\n                        dp[i][mask] = max(dp[i][mask], dp[j][left_mask] ^ dp[i - j][right_mask])\n    \n    return dp[k][(1 << (2 * k)) - 1]\n```"]}
{"task_id": "abc370_g", "codes": ["import sys\nfrom collections import defaultdict\n\nMOD = 998244353\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n\n    # Function to calculate the number of divisors of a number modulo 3\n    def num_divisors_mod_3(n):\n        count = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                count += 1\n                if count > 3:\n                    return 0\n        return count % 3\n\n    # Initialize DP table\n    dp = [[0] * 3 for _ in range(M + 1)]\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, M + 1):\n        for j in range(3):\n            for k in range(1, N + 1):\n                if num_divisors_mod_3(k) == j:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][(j - num_divisors_mod_3(k) + 3) % 3]) % MOD\n\n    # Sum up all valid sequences of length M\n    result = sum(dp[M]) % MOD\n    print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["import sys\nfrom collections import defaultdict\n\nMOD = 998244353\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n\n    # Function to calculate the number of divisors of a number modulo 3\n    def num_divisors_mod_3(n):\n        count = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                count += 1\n                if count > 3:\n                    return 0\n        return count % 3\n\n    # Initialize DP table\n    dp = [[0] * 3 for _ in range(M + 1)]\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, M + 1):\n        for j in range(3):\n            for k in range(1, N + 1):\n                if num_divisors_mod_3(k) == j:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][(j - num_divisors_mod_3(k) + 3) % 3]) % MOD\n\n    # Sum up all valid sequences of length M\n    result = sum(dp[M]) % MOD\n    print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "abc366_e", "codes": ["def count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    count = 0\n    max_x = max(points, key=lambda p: p[0])[0]\n    min_x = min(points, key=lambda p: p[0])[0]\n    max_y = max(points, key=lambda p: p[1])[1]\n    min_y = min(points, key=lambda p: p[1])[1]\n    \n    for x in range(min_x, max_x + 1):\n        for y in range(min_y, max_y + 1):\n            dist_sum = sum(abs(x - px) + abs(y - py) for px, py in points)\n            if dist_sum <= D:\n                count += 1\n    \n    print(count)\n\n# Call the function\ncount_valid_pairs()"], "passed": [false], "raw_code": ["```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    count = 0\n    max_x = max(points, key=lambda p: p[0])[0]\n    min_x = min(points, key=lambda p: p[0])[0]\n    max_y = max(points, key=lambda p: p[1])[1]\n    min_y = min(points, key=lambda p: p[1])[1]\n    \n    for x in range(min_x, max_x + 1):\n        for y in range(min_y, max_y + 1):\n            dist_sum = sum(abs(x - px) + abs(y - py) for px, py in points)\n            if dist_sum <= D:\n                count += 1\n    \n    print(count)\n\n# Call the function\ncount_valid_pairs()\n```"]}
{"task_id": "abc371_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize variables\n    total_sum = 0\n    \n    # Iterate over each starting point i\n    for i in range(N):\n        unique_elements = set()\n        distinct_count = 0\n        \n        # Expand the window to the right\n        for j in range(i, N):\n            if A[j] not in unique_elements:\n                unique_elements.add(A[j])\n                distinct_count += 1\n            \n            # Add the distinct count for the current window [i, j]\n            total_sum += distinct_count\n    \n    # Print the result\n    print(total_sum)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize variables\n    total_sum = 0\n    \n    # Iterate over each starting point i\n    for i in range(N):\n        unique_elements = set()\n        distinct_count = 0\n        \n        # Expand the window to the right\n        for j in range(i, N):\n            if A[j] not in unique_elements:\n                unique_elements.add(A[j])\n                distinct_count += 1\n            \n            # Add the distinct count for the current window [i, j]\n            total_sum += distinct_count\n    \n    # Print the result\n    print(total_sum)\n\nmain()\n```"]}
{"task_id": "3563", "codes": ["def max_score(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Set to keep track of used values\n    used_values = set()\n    total_score = 0\n    \n    # Iterate through each column\n    for col in range(len(grid[0])):\n        # Try to find an unused value in the current column\n        found = False\n        for row in range(len(grid)):\n            if grid[row][col] not in used_values:\n                total_score += grid[row][col]\n                used_values.add(grid[row][col])\n                found = True\n                break\n        \n        # If no unused value was found, stop as we cannot proceed further\n        if not found:\n            break\n    \n    return total_score"], "passed": [false], "raw_code": ["```python\ndef max_score(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Set to keep track of used values\n    used_values = set()\n    total_score = 0\n    \n    # Iterate through each column\n    for col in range(len(grid[0])):\n        # Try to find an unused value in the current column\n        found = False\n        for row in range(len(grid)):\n            if grid[row][col] not in used_values:\n                total_score += grid[row][col]\n                used_values.add(grid[row][col])\n                found = True\n                break\n        \n        # If no unused value was found, stop as we cannot proceed further\n        if not found:\n            break\n    \n    return total_score\n```"]}
{"task_id": "arc181_c", "codes": ["def fill_grid(N, P, Q):\n    grid = [['?' for _ in range(N)] for _ in range(N)]\n    \n    def is_valid(grid, row, col, value):\n        # Check row\n        for c in range(col):\n            if grid[row][c] == value and ord(value) <= ord(grid[row][c]):\n                return False\n        # Check column\n        for r in range(row):\n            if grid[r][col] == value and ord(value) <= ord(grid[r][col]):\n                return False\n        return True\n    \n    def backtrack(row, col):\n        if row == N:\n            return True\n        if col == N:\n            return backtrack(row + 1, 0)\n        \n        for value in ['0', '1']:\n            if is_valid(grid, row, col, value):\n                grid[row][col] = value\n                if backtrack(row, col + 1):\n                    return True\n                grid[row][col] = '?'\n        \n        return False\n    \n    backtrack(0, 0)\n    \n    for row in grid:\n        print(''.join(row))\n\n# Example usage\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    Q = list(map(int, data[N+1:]))\n    \n    fill_grid(N, P, Q)"], "passed": [false], "raw_code": ["```python\ndef fill_grid(N, P, Q):\n    grid = [['?' for _ in range(N)] for _ in range(N)]\n    \n    def is_valid(grid, row, col, value):\n        # Check row\n        for c in range(col):\n            if grid[row][c] == value and ord(value) <= ord(grid[row][c]):\n                return False\n        # Check column\n        for r in range(row):\n            if grid[r][col] == value and ord(value) <= ord(grid[r][col]):\n                return False\n        return True\n    \n    def backtrack(row, col):\n        if row == N:\n            return True\n        if col == N:\n            return backtrack(row + 1, 0)\n        \n        for value in ['0', '1']:\n            if is_valid(grid, row, col, value):\n                grid[row][col] = value\n                if backtrack(row, col + 1):\n                    return True\n                grid[row][col] = '?'\n        \n        return False\n    \n    backtrack(0, 0)\n    \n    for row in grid:\n        print(''.join(row))\n\n# Example usage\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    Q = list(map(int, data[N+1:]))\n    \n    fill_grid(N, P, Q)\n```"]}
{"task_id": "abc367_g", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * M for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        x = A[i - 1]\n        for j in range(M):\n            dp[i][j] += dp[i - 1][j]\n            dp[i][(j + x) % M] += dp[i - 1][j]\n    \n    result = sum(dp[N][j] for j in range(M)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * M for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        x = A[i - 1]\n        for j in range(M):\n            dp[i][j] += dp[i - 1][j]\n            dp[i][(j + x) % M] += dp[i - 1][j]\n    \n    result = sum(dp[N][j] for j in range(M)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc371_g", "codes": ["def get_cycle_decomposition(n, p):\n    visited = [False] * n\n    cycles = []\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = p[x] - 1\n            cycles.append(cycle)\n    \n    return cycles\n\ndef sort_cycles(cycles, a):\n    sorted_a = list(a)\n    for cycle in cycles:\n        subarray = [sorted_a[i] for i in cycle]\n        subarray.sort()\n        for i, idx in enumerate(cycle):\n            sorted_a[idx] = subarray[i]\n    \n    return sorted_a\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n+1]))\n    a = list(map(int, data[n+1:2*n+1]))\n    \n    cycles = get_cycle_decomposition(n, p)\n    sorted_a = sort_cycles(cycles, a)\n    \n    print(' '.join(map(str, sorted_a)))\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef get_cycle_decomposition(n, p):\n    visited = [False] * n\n    cycles = []\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = p[x] - 1\n            cycles.append(cycle)\n    \n    return cycles\n\ndef sort_cycles(cycles, a):\n    sorted_a = list(a)\n    for cycle in cycles:\n        subarray = [sorted_a[i] for i in cycle]\n        subarray.sort()\n        for i, idx in enumerate(cycle):\n            sorted_a[idx] = subarray[i]\n    \n    return sorted_a\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n+1]))\n    a = list(map(int, data[n+1:2*n+1]))\n    \n    cycles = get_cycle_decomposition(n, p)\n    sorted_a = sort_cycles(cycles, a)\n    \n    print(' '.join(map(str, sorted_a)))\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    # Combine damage and health into a list of tuples and sort by health in descending order\n    enemies = sorted(zip(damage, health), key=lambda x: x[1], reverse=True)\n    \n    total_damage = 0\n    \n    for d, h in enemies:\n        if h > 0:\n            # Calculate the number of attacks needed to kill the enemy\n            attacks_needed = (h - 1) // power + 1\n            total_damage += attacks_needed * d\n    \n    return total_damage"], "passed": [false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    # Combine damage and health into a list of tuples and sort by health in descending order\n    enemies = sorted(zip(damage, health), key=lambda x: x[1], reverse=True)\n    \n    total_damage = 0\n    \n    for d, h in enemies:\n        if h > 0:\n            # Calculate the number of attacks needed to kill the enemy\n            attacks_needed = (h - 1) // power + 1\n            total_damage += attacks_needed * d\n    \n    return total_damage\n```"]}
{"task_id": "arc183_c", "codes": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    constraints = []\n    for _ in range(M):\n        L = int(data[index]) - 1\n        R = int(data[index + 1]) - 1\n        X = int(data[index + 2]) - 1\n        constraints.append((L, R, X))\n        index += 3\n    \n    MOD = 998244353\n    \n    # dp[i][j]: number of valid permutations of length i ending at j\n    dp = [[0] * N for _ in range(N)]\n    \n    # Initial state: all permutations of length 1 are valid\n    for j in range(N):\n        dp[0][j] = 1\n    \n    for i in range(1, N):\n        new_dp = [[0] * N for _ in range(N)]\n        for k in range(N):\n            total = sum(dp[i-1][j] for j in range(N)) % MOD\n            for L, R, X in constraints:\n                if L <= i < R and X == k:\n                    left = max(L, 0)\n                    right = min(R, i)\n                    if left <= right:\n                        invalid_count = sum(dp[right-left-1][j] for j in range(k+1)) % MOD\n                        new_dp[i][k] = (total - invalid_count) % MOD\n                    break\n            else:\n                new_dp[i][k] = total\n        \n        dp = new_dp\n    \n    result = sum(dp[N-1][j] for j in range(N)) % MOD\n    print(result)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    constraints = []\n    for _ in range(M):\n        L = int(data[index]) - 1\n        R = int(data[index + 1]) - 1\n        X = int(data[index + 2]) - 1\n        constraints.append((L, R, X))\n        index += 3\n    \n    MOD = 998244353\n    \n    # dp[i][j]: number of valid permutations of length i ending at j\n    dp = [[0] * N for _ in range(N)]\n    \n    # Initial state: all permutations of length 1 are valid\n    for j in range(N):\n        dp[0][j] = 1\n    \n    for i in range(1, N):\n        new_dp = [[0] * N for _ in range(N)]\n        for k in range(N):\n            total = sum(dp[i-1][j] for j in range(N)) % MOD\n            for L, R, X in constraints:\n                if L <= i < R and X == k:\n                    left = max(L, 0)\n                    right = min(R, i)\n                    if left <= right:\n                        invalid_count = sum(dp[right-left-1][j] for j in range(k+1)) % MOD\n                        new_dp[i][k] = (total - invalid_count) % MOD\n                    break\n            else:\n                new_dp[i][k] = total\n        \n        dp = new_dp\n    \n    result = sum(dp[N-1][j] for j in range(N)) % MOD\n    print(result)\n\nmain()"]}
{"task_id": "3550", "codes": ["def max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    row_sums = [max(row) for row in board]\n    col_sums = [max(col) for col in zip(*board)]\n    \n    # Find indices of the maximum values in each row and column\n    row_indices = sorted(range(rows), key=lambda i: row_sums[i], reverse=True)\n    col_indices = sorted(range(cols), key=lambda j: col_sums[j], reverse=True)\n    \n    # Select one index from each row and column to ensure no conflict\n    selected_indices = set()\n    result = 0\n    \n    for ri in row_indices:\n        for ci in col_indices:\n            if ri not in selected_indices and ci not in selected_indices:\n                result += board[ri][ci]\n                selected_indices.add(ri)\n                selected_indices.add(ci)\n                break\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    row_sums = [max(row) for row in board]\n    col_sums = [max(col) for col in zip(*board)]\n    \n    # Find indices of the maximum values in each row and column\n    row_indices = sorted(range(rows), key=lambda i: row_sums[i], reverse=True)\n    col_indices = sorted(range(cols), key=lambda j: col_sums[j], reverse=True)\n    \n    # Select one index from each row and column to ensure no conflict\n    selected_indices = set()\n    result = 0\n    \n    for ri in row_indices:\n        for ci in col_indices:\n            if ri not in selected_indices and ci not in selected_indices:\n                result += board[ri][ci]\n                selected_indices.add(ri)\n                selected_indices.add(ci)\n                break\n    \n    return result\n```"]}
{"task_id": "abc368_g", "codes": ["```python\ndef build_segment_tree(n, A, B):\n    def merge(x, y):\n        return (max(x[0], y[0]), max(x[1], y[1]))\n    \n    def push_up(p):\n        seg[p] = merge(seg[2 * p], seg[2 * p + 1])\n    \n    seg = [(0, 0)] * (4 * n)\n    \n    def build(pos, l, r):\n        if l == r:\n            seg[pos] = (A[l - 1], B[l - 1])\n            return\n        mid = (l + r) // 2\n        build(2 * pos, l, mid)\n        build(2 * pos + 1, mid + 1, r)\n        push_up(pos)\n    \n    build(1, 1, n)\n    return seg\n\ndef update_segment_tree(n, pos, idx, val, seg, A, B):\n    def push_down(pos, l, r):\n        if not lazy[pos]:\n            return\n        mid = (l + r) // 2\n        seg[2 * pos] = (seg[2 * pos][0], seg[2 * pos][1])\n        seg[2 * pos + 1] = (seg[2 * pos + 1][0], seg[2 * pos + 1][1])\n        lazy[2 * pos] ^= 1\n        lazy[2 * pos + 1] ^= 1\n        lazy[pos] = False\n    \n    def update(pos, l, r, ql, qr, val, seg, A, B):\n        if ql <= l and r <= qr:\n            if val == 'A':\n                seg[pos] = (seg[pos][0], A[r - 1])\n            elif val == 'B':\n                seg[pos] = (B[r - 1], seg[pos][1])\n            lazy[pos] ^= 1\n            return\n        push_down(pos, l, r)\n        mid = (l + r) // 2\n        if ql <= mid:\n            update(2 * pos, l, mid, ql, qr, val, seg, A, B)\n        if qr > mid:\n            update(2 * pos + 1, mid + 1, r, ql, qr, val, seg, A, B)\n        push_up(pos)\n    \n    return seg\n\ndef query_segment_tree(pos, l, r, ql, qr, seg):\n    def push_down(pos, l, r):\n        if not lazy[pos]:\n            return\n        mid = (l + r) // 2\n        seg[2 * pos] = (seg[2 * pos][0], seg[2 * pos][1])\n        seg[2 * pos + 1] = (seg[2 * pos + 1][0], seg[2 * pos + 1][1])\n        lazy[2 * pos] ^= 1\n        lazy[2 * pos + 1] ^= 1\n        lazy[pos] = False\n    \n    def query(pos, l, r, ql, qr, seg):\n        if ql <= l and r <= qr:\n            return seg[pos]\n        push_down(pos, l, r)\n        mid = ("], "passed": [false], "raw_code": ["```python\ndef build_segment_tree(n, A, B):\n    def merge(x, y):\n        return (max(x[0], y[0]), max(x[1], y[1]))\n    \n    def push_up(p):\n        seg[p] = merge(seg[2 * p], seg[2 * p + 1])\n    \n    seg = [(0, 0)] * (4 * n)\n    \n    def build(pos, l, r):\n        if l == r:\n            seg[pos] = (A[l - 1], B[l - 1])\n            return\n        mid = (l + r) // 2\n        build(2 * pos, l, mid)\n        build(2 * pos + 1, mid + 1, r)\n        push_up(pos)\n    \n    build(1, 1, n)\n    return seg\n\ndef update_segment_tree(n, pos, idx, val, seg, A, B):\n    def push_down(pos, l, r):\n        if not lazy[pos]:\n            return\n        mid = (l + r) // 2\n        seg[2 * pos] = (seg[2 * pos][0], seg[2 * pos][1])\n        seg[2 * pos + 1] = (seg[2 * pos + 1][0], seg[2 * pos + 1][1])\n        lazy[2 * pos] ^= 1\n        lazy[2 * pos + 1] ^= 1\n        lazy[pos] = False\n    \n    def update(pos, l, r, ql, qr, val, seg, A, B):\n        if ql <= l and r <= qr:\n            if val == 'A':\n                seg[pos] = (seg[pos][0], A[r - 1])\n            elif val == 'B':\n                seg[pos] = (B[r - 1], seg[pos][1])\n            lazy[pos] ^= 1\n            return\n        push_down(pos, l, r)\n        mid = (l + r) // 2\n        if ql <= mid:\n            update(2 * pos, l, mid, ql, qr, val, seg, A, B)\n        if qr > mid:\n            update(2 * pos + 1, mid + 1, r, ql, qr, val, seg, A, B)\n        push_up(pos)\n    \n    return seg\n\ndef query_segment_tree(pos, l, r, ql, qr, seg):\n    def push_down(pos, l, r):\n        if not lazy[pos]:\n            return\n        mid = (l + r) // 2\n        seg[2 * pos] = (seg[2 * pos][0], seg[2 * pos][1])\n        seg[2 * pos + 1] = (seg[2 * pos + 1][0], seg[2 * pos + 1][1])\n        lazy[2 * pos] ^= 1\n        lazy[2 * pos + 1] ^= 1\n        lazy[pos] = False\n    \n    def query(pos, l, r, ql, qr, seg):\n        if ql <= l and r <= qr:\n            return seg[pos]\n        push_down(pos, l, r)\n        mid = ("]}
{"task_id": "arc183_b", "codes": ["def can_transform_to_B(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        \n        index += 2 + 2 * N\n        \n        # Count frequencies of elements in A and B\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for a in A:\n            freq_A[a] += 1\n        \n        for b in B:\n            freq_B[b] += 1\n        \n        # Check if frequencies match\n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_to_B(int(input()))"], "passed": [false], "raw_code": ["```python\ndef can_transform_to_B(T):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        \n        index += 2 + 2 * N\n        \n        # Count frequencies of elements in A and B\n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for a in A:\n            freq_A[a] += 1\n        \n        for b in B:\n            freq_B[b] += 1\n        \n        # Check if frequencies match\n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_to_B(int(input()))\n```"]}
{"task_id": "abc373_e", "codes": ["def min_votes_to_win(N, M, K, A):\n    # Calculate the total number of votes received so far\n    total_votes_received = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_votes_received\n    # Initialize an array to store the result\n    C = [-1] * N\n    # Iterate over each candidate\n    for i in range(N):\n        # If the candidate's current votes are already sufficient to win\n        if A[i] > (M - 1) * (remaining_votes // (N - 1)):\n            C[i] = 0\n            continue\n        # Calculate the minimum votes needed to guarantee victory\n        max_votes_other_candidates = [max(0, A[j] + remaining_votes - A[i]) for j in range(N) if j != i]\n        max_votes_other_candidates.sort()\n        # Check how many votes are needed to ensure the candidate wins\n        for j in range(M - 1):\n            if A[i] <= max_votes_other_candidates[j]:\n                C[i] = max_votes_other_candidates[j] - A[i] + 1\n                break\n    # Print the results\n    print(' '.join(map(str, C)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Call the function with the input values\nmin_votes_to_win(N, M, K, A)"], "passed": [false], "raw_code": ["def min_votes_to_win(N, M, K, A):\n    # Calculate the total number of votes received so far\n    total_votes_received = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_votes_received\n    # Initialize an array to store the result\n    C = [-1] * N\n    # Iterate over each candidate\n    for i in range(N):\n        # If the candidate's current votes are already sufficient to win\n        if A[i] > (M - 1) * (remaining_votes // (N - 1)):\n            C[i] = 0\n            continue\n        # Calculate the minimum votes needed to guarantee victory\n        max_votes_other_candidates = [max(0, A[j] + remaining_votes - A[i]) for j in range(N) if j != i]\n        max_votes_other_candidates.sort()\n        # Check how many votes are needed to ensure the candidate wins\n        for j in range(M - 1):\n            if A[i] <= max_votes_other_candidates[j]:\n                C[i] = max_votes_other_candidates[j] - A[i] + 1\n                break\n    # Print the results\n    print(' '.join(map(str, C)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Call the function with the input values\nmin_votes_to_win(N, M, K, A)"]}
{"task_id": "abc373_f", "codes": ["def max_happiness(N, W, weights, values):\n    # Initialize DP array\n    dp = [0] * (W + 1)\n\n    # Iterate over each item type\n    for i in range(N):\n        w, v = weights[i], values[i]\n        # Update DP array from back to front to avoid overwriting\n        for j in range(W, w - 1, -1):\n            dp[j] = max(dp[j], dp[j - w] + v * (j // w) - (j // w)**2)\n\n    return dp[W]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2*i]))\n    values.append(int(data[3 + 2*i]))\n\n# Calculate and print the result\nresult = max_happiness(N, W, weights, values)\nprint(result)\n"], "passed": [false], "raw_code": ["def max_happiness(N, W, weights, values):\n    # Initialize DP array\n    dp = [0] * (W + 1)\n\n    # Iterate over each item type\n    for i in range(N):\n        w, v = weights[i], values[i]\n        # Update DP array from back to front to avoid overwriting\n        for j in range(W, w - 1, -1):\n            dp[j] = max(dp[j], dp[j - w] + v * (j // w) - (j // w)**2)\n\n    return dp[W]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2*i]))\n    values.append(int(data[3 + 2*i]))\n\n# Calculate and print the result\nresult = max_happiness(N, W, weights, values)\nprint(result)\n"]}
{"task_id": "abc372_e", "codes": ["import sys\nfrom heapq import heappush, heappop, nlargest\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n\n    # Read N and Q\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    # Initialize graph and heaps\n    graph = [[] for _ in range(N + 1)]\n    heaps = [([]) for _ in range(N + 1)]\n\n    # Process each query\n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            graph[u].append(v)\n            graph[v].append(u)\n            heappush(heaps[u], v)\n            heappush(heaps[v], u)\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            index += 3\n            if len(graph[v]) < k:\n                results.append(-1)\n            else:\n                # Extract k-th largest element from the heap\n                top_k_elements = nlargest(k, heaps[v])\n                results.append(top_k_elements[-1])\n\n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["import sys\nfrom heapq import heappush, heappop, nlargest\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n\n    # Read N and Q\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    # Initialize graph and heaps\n    graph = [[] for _ in range(N + 1)]\n    heaps = [([]) for _ in range(N + 1)]\n\n    # Process each query\n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            graph[u].append(v)\n            graph[v].append(u)\n            heappush(heaps[u], v)\n            heappush(heaps[v], u)\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            index += 3\n            if len(graph[v]) < k:\n                results.append(-1)\n            else:\n                # Extract k-th largest element from the heap\n                top_k_elements = nlargest(k, heaps[v])\n                results.append(top_k_elements[-1])\n\n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "arc182_c", "codes": ["def sum_of_divisors(N, M):\n    MOD = 998244353\n    \n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        i = 2\n        factors = {}\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                x //= i\n                if i in factors:\n                    factors[i] += 1\n                else:\n                    factors[i] = 1\n        if x > 1:\n            factors[x] = 1\n        return factors\n    \n    # Get prime factorizations of numbers from 1 to M\n    factorizations = [prime_factors(i) for i in range(1, M + 1)]\n    \n    # DP table\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, M + 1):\n        for j in range(N, 0, -1):\n            for k in range(j, 0, -1):\n                new_factors = factorizations[i]\n                new_product = 1\n                for prime, exp in new_factors.items():\n                    new_product *= (exp + 1)\n                dp[j][k] += dp[k - 1][j - 1] * new_product\n                dp[j][k] %= MOD\n    \n    # Calculate the total sum of divisors contributions\n    total_sum = 0\n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            new_factors = factorizations[i]\n            new_product = 1\n            for prime, exp in new_factors.items():\n                new_product *= (exp + 1)\n            total_sum += dp[j][j] * new_product\n            total_sum %= MOD\n    \n    return total_sum\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(sum_of_divisors(N, M))"], "passed": [false], "raw_code": ["```python\ndef sum_of_divisors(N, M):\n    MOD = 998244353\n    \n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        i = 2\n        factors = {}\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                x //= i\n                if i in factors:\n                    factors[i] += 1\n                else:\n                    factors[i] = 1\n        if x > 1:\n            factors[x] = 1\n        return factors\n    \n    # Get prime factorizations of numbers from 1 to M\n    factorizations = [prime_factors(i) for i in range(1, M + 1)]\n    \n    # DP table\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, M + 1):\n        for j in range(N, 0, -1):\n            for k in range(j, 0, -1):\n                new_factors = factorizations[i]\n                new_product = 1\n                for prime, exp in new_factors.items():\n                    new_product *= (exp + 1)\n                dp[j][k] += dp[k - 1][j - 1] * new_product\n                dp[j][k] %= MOD\n    \n    # Calculate the total sum of divisors contributions\n    total_sum = 0\n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            new_factors = factorizations[i]\n            new_product = 1\n            for prime, exp in new_factors.items():\n                new_product *= (exp + 1)\n            total_sum += dp[j][j] * new_product\n            total_sum %= MOD\n    \n    return total_sum\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(sum_of_divisors(N, M))\n```"]}
{"task_id": "abc369_e", "codes": ["import sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\ndef read_int():\nglobal index\nresult = int(data[index])\nindex += 1\nreturn result\ndef read_str():\nglobal index\nresult = data[index]\nindex += 1\nreturn result\nN = read_int()\nM = read_int()\nbridges = [defaultdict(int) for _ in range(M)]\nfor _ in range(M):\nu = read_int() - 1\nv = read_int() - 1\nt = read_int()\nbridges[u][v] = t\nbridges[v][u] = t\nQ = read_int()\nqueries = []\nfor _ in range(Q):\nk = read_int()\nquery = set()\nfor _ in range(k):\nb = read_int() - 1\nquery.add(b)\nqueries.append(query)\ndist = [[float('inf')] * (1 << M) for _ in range(N)]\ndist[0][0] = 0\npq = [(0, 0, 0)]\nwhile pq:\ncurr_dist, curr_node, used_bridges = heappop(pq)\nif dist[curr_node][used_bridges] < curr_dist:\ncontinue\nfor neighbor in bridges[curr_node]:\nnew_used_bridges = used_bridges | (1 << neighbor)\nnew_dist = curr_dist + bridges[curr_node][neighbor]\nif new_dist < dist[neighbor][new_used_bridges]:\ndist[neighbor][new_used_bridges] = new_dist\nheappush(pq, (new_dist, neighbor, new_used_bridges))\nresults = []\nfor query in queries:\nmin_time = float('inf')\nfor mask in range(1 << M):\nif (mask & ((1 << len(query)) - 1)) == (1 << len(query)) - 1:\nmin_time = min(min_time, dist[N-1][mask])\nprint(min_time)"], "passed": [false], "raw_code": ["import sys\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\ndef read_int():\nglobal index\nresult = int(data[index])\nindex += 1\nreturn result\ndef read_str():\nglobal index\nresult = data[index]\nindex += 1\nreturn result\nN = read_int()\nM = read_int()\nbridges = [defaultdict(int) for _ in range(M)]\nfor _ in range(M):\nu = read_int() - 1\nv = read_int() - 1\nt = read_int()\nbridges[u][v] = t\nbridges[v][u] = t\nQ = read_int()\nqueries = []\nfor _ in range(Q):\nk = read_int()\nquery = set()\nfor _ in range(k):\nb = read_int() - 1\nquery.add(b)\nqueries.append(query)\ndist = [[float('inf')] * (1 << M) for _ in range(N)]\ndist[0][0] = 0\npq = [(0, 0, 0)]\nwhile pq:\ncurr_dist, curr_node, used_bridges = heappop(pq)\nif dist[curr_node][used_bridges] < curr_dist:\ncontinue\nfor neighbor in bridges[curr_node]:\nnew_used_bridges = used_bridges | (1 << neighbor)\nnew_dist = curr_dist + bridges[curr_node][neighbor]\nif new_dist < dist[neighbor][new_used_bridges]:\ndist[neighbor][new_used_bridges] = new_dist\nheappush(pq, (new_dist, neighbor, new_used_bridges))\nresults = []\nfor query in queries:\nmin_time = float('inf')\nfor mask in range(1 << M):\nif (mask & ((1 << len(query)) - 1)) == (1 << len(query)) - 1:\nmin_time = min(min_time, dist[N-1][mask])\nprint(min_time)"]}
{"task_id": "3551", "codes": ["class TrieNode:\n    def __init__(self):\n        self.children = {}\n\ndef insert(root, num):\n    node = root\n    for bit in range(31, -1, -1):\n        bit_value = (num >> bit) & 1\n        if bit_value not in node.children:\n            node.children[bit_value] = TrieNode()\n        node = node.children[bit_value]\n\ndef query(root, num):\n    max_xor = 0\n    node = root\n    for bit in range(31, -1, -1):\n        bit_value = (num >> bit) & 1\n        opposite_bit_value = 1 - bit_value\n        if opposite_bit_value in node.children:\n            max_xor |= (1 << bit)\n            node = node.children[opposite_bit_value]\n        else:\n            node = node.children[bit_value]\n    return max_xor\n\ndef xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    trie_root = TrieNode()\n    \n    # Build prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n        insert(trie_root, prefix_xor[i + 1])\n    \n    # Process each query\n    result = []\n    for l, r in queries:\n        current_xor = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(query(trie_root, current_xor))\n    \n    return result"], "passed": [false], "raw_code": ["```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n\ndef insert(root, num):\n    node = root\n    for bit in range(31, -1, -1):\n        bit_value = (num >> bit) & 1\n        if bit_value not in node.children:\n            node.children[bit_value] = TrieNode()\n        node = node.children[bit_value]\n\ndef query(root, num):\n    max_xor = 0\n    node = root\n    for bit in range(31, -1, -1):\n        bit_value = (num >> bit) & 1\n        opposite_bit_value = 1 - bit_value\n        if opposite_bit_value in node.children:\n            max_xor |= (1 << bit)\n            node = node.children[opposite_bit_value]\n        else:\n            node = node.children[bit_value]\n    return max_xor\n\ndef xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    trie_root = TrieNode()\n    \n    # Build prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n        insert(trie_root, prefix_xor[i + 1])\n    \n    # Process each query\n    result = []\n    for l, r in queries:\n        current_xor = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(query(trie_root, current_xor))\n    \n    return result\n```"]}
{"task_id": "3583", "codes": ["from math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Calculate GCD for all pairs and count their occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    # Sort unique GCD values and prepare the result list\n    unique_gcds = sorted(gcd_count.keys())\n    cum_sum = [0]\n    for count in gcd_count.values():\n        cum_sum.append(cum_sum[-1] + count)\n    \n    # Process each query\n    result = []\n    for q in queries:\n        pos = bisect.bisect_left(cum_sum, q + 1)\n        if pos > 0:\n            result.append(unique_gcds[pos - 1])\n        else:\n            result.append(0)\n    \n    return result"], "passed": [false], "raw_code": ["```python\nfrom math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Calculate GCD for all pairs and count their occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    # Sort unique GCD values and prepare the result list\n    unique_gcds = sorted(gcd_count.keys())\n    cum_sum = [0]\n    for count in gcd_count.values():\n        cum_sum.append(cum_sum[-1] + count)\n    \n    # Process each query\n    result = []\n    for q in queries:\n        pos = bisect.bisect_left(cum_sum, q + 1)\n        if pos > 0:\n            result.append(unique_gcds[pos - 1])\n        else:\n            result.append(0)\n    \n    return result\n```"]}
{"task_id": "arc181_d", "codes": ["import sys\nfrom bisect import bisect_left\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def add(self, index, value):\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def sum(self, index):\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef count_inversions(arr):\n    n = len(arr)\n    ft = FenwickTree(n)\n    inversions = 0\n    for num in arr[::-1]:\n        inversions += ft.sum(num - 1)\n        ft.add(num, 1)\n    return inversions\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    p = list(map(int, data[1:n+1]))\n    m = int(data[n+1])\n    a = list(map(int, data[n+2:n+m+2]))\n\n    results = []\n    current_p = p[:]\n    for op in a:\n        target_index = bisect_left(current_p, op)\n        current_p[target_index], current_p[target_index - 1] = current_p[target_index - 1], current_p[target_index]\n        results.append(count_inversions(current_p))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["import sys\nfrom bisect import bisect_left\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def add(self, index, value):\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def sum(self, index):\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef count_inversions(arr):\n    n = len(arr)\n    ft = FenwickTree(n)\n    inversions = 0\n    for num in arr[::-1]:\n        inversions += ft.sum(num - 1)\n        ft.add(num, 1)\n    return inversions\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    p = list(map(int, data[1:n+1]))\n    m = int(data[n+1])\n    a = list(map(int, data[n+2:n+m+2]))\n\n    results = []\n    current_p = p[:]\n    for op in a:\n        target_index = bisect_left(current_p, op)\n        current_p[target_index], current_p[target_index - 1] = current_p[target_index - 1], current_p[target_index]\n        results.append(count_inversions(current_p))\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3571", "codes": ["def max_increasing_path(coordinates, k):\n    def dfs(x, y):\n        if (x, y) in memo:\n            return memo[(x, y)]\n        \n        max_length = 1\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < len(coords) and 0 <= ny < len(coords[0]) and coords[nx][ny] > coords[x][y]:\n                max_length = max(max_length, 1 + dfs(nx, ny))\n        \n        memo[(x, y)] = max_length\n        return max_length\n    \n    # Sort coordinates based on x, and y if x is the same\n    coords = sorted(coordinates)\n    \n    # Initialize memoization table\n    memo = {}\n    directions = [(1, 0), (0, 1)]\n    \n    # Find the index of the k-th coordinate\n    k_index = coordinates.index([coords[k][0], coords[k][1]])\n    \n    # Compute the maximum increasing path length starting from the k-th coordinate\n    result = dfs(k_index // len(coords[0]), k_index % len(coords[0]))\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef max_increasing_path(coordinates, k):\n    def dfs(x, y):\n        if (x, y) in memo:\n            return memo[(x, y)]\n        \n        max_length = 1\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < len(coords) and 0 <= ny < len(coords[0]) and coords[nx][ny] > coords[x][y]:\n                max_length = max(max_length, 1 + dfs(nx, ny))\n        \n        memo[(x, y)] = max_length\n        return max_length\n    \n    # Sort coordinates based on x, and y if x is the same\n    coords = sorted(coordinates)\n    \n    # Initialize memoization table\n    memo = {}\n    directions = [(1, 0), (0, 1)]\n    \n    # Find the index of the k-th coordinate\n    k_index = coordinates.index([coords[k][0], coords[k][1]])\n    \n    # Compute the maximum increasing path length starting from the k-th coordinate\n    result = dfs(k_index // len(coords[0]), k_index % len(coords[0]))\n    \n    return result\n```"]}
{"task_id": "3560", "codes": ["def min_moves(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef max_min_moves(kx, ky, positions, memo=None):\n    if memo is None:\n        memo = {}\n    \n    pos_tuple = tuple(positions)\n    if (kx, ky, pos_tuple) in memo:\n        return memo[(kx, ky, pos_tuple)]\n    \n    if not positions:\n        return 0\n    \n    if len(positions) == 1:\n        return min_moves(kx, ky, positions[0][0], positions[0][1])\n    \n    max_moves = float('-inf')\n    min_moves_total = float('inf')\n    \n    for i in range(len(positions)):\n        px, py = positions[i]\n        new_positions = positions[:i] + positions[i+1:]\n        \n        if len(new_positions) % 2 == 0:\n            # Bob's turn\n            bob_moves = min_moves(kx, ky, px, py) + max_min_moves(px, py, new_positions, memo)\n            min_moves_total = min(min_moves_total, bob_moves)\n        else:\n            # Alice's turn\n            alice_moves = min_moves(kx, ky, px, py) + max_min_moves(px, py, new_positions, memo)\n            max_moves = max(max_moves, alice_moves)\n    \n    if len(positions) % 2 == 0:\n        result = min_moves_total\n    else:\n        result = max_moves\n    \n    memo[(kx, ky, pos_tuple)] = result\n    return result\n\ndef knight_pawn_game(kx, ky, positions):\n    return max_min_moves(kx, ky, positions)"], "passed": [false], "raw_code": ["```python\ndef min_moves(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if cx == px and cy == py:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef max_min_moves(kx, ky, positions, memo=None):\n    if memo is None:\n        memo = {}\n    \n    pos_tuple = tuple(positions)\n    if (kx, ky, pos_tuple) in memo:\n        return memo[(kx, ky, pos_tuple)]\n    \n    if not positions:\n        return 0\n    \n    if len(positions) == 1:\n        return min_moves(kx, ky, positions[0][0], positions[0][1])\n    \n    max_moves = float('-inf')\n    min_moves_total = float('inf')\n    \n    for i in range(len(positions)):\n        px, py = positions[i]\n        new_positions = positions[:i] + positions[i+1:]\n        \n        if len(new_positions) % 2 == 0:\n            # Bob's turn\n            bob_moves = min_moves(kx, ky, px, py) + max_min_moves(px, py, new_positions, memo)\n            min_moves_total = min(min_moves_total, bob_moves)\n        else:\n            # Alice's turn\n            alice_moves = min_moves(kx, ky, px, py) + max_min_moves(px, py, new_positions, memo)\n            max_moves = max(max_moves, alice_moves)\n    \n    if len(positions) % 2 == 0:\n        result = min_moves_total\n    else:\n        result = max_moves\n    \n    memo[(kx, ky, pos_tuple)] = result\n    return result\n\ndef knight_pawn_game(kx, ky, positions):\n    return max_min_moves(kx, ky, positions)\n```"]}
{"task_id": "3548", "codes": ["def count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * k for _ in range(n // 2 + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, n // 2 + 1):\n        for j in range(k):\n            for d in range(10):\n                dp[i][(j + d) % k] += dp[i - 1][j]\n                dp[i][(j + d) % k] %= MOD\n    \n    # Calculate the result\n    result = 0\n    for d in range(1, 10):\n        if n % 2 == 0:\n            result += dp[n // 2][(d * 2) % k]\n        else:\n            result += dp[(n - 1) // 2][(d * 2) % k] * 2\n            result -= dp[(n - 1) // 2][((d * 2) % k + d) % k]\n            result += dp[(n - 1) // 2][((d * 2) % k - d) % k]\n    \n    return result % MOD"], "passed": [false], "raw_code": ["```python\ndef count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * k for _ in range(n // 2 + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, n // 2 + 1):\n        for j in range(k):\n            for d in range(10):\n                dp[i][(j + d) % k] += dp[i - 1][j]\n                dp[i][(j + d) % k] %= MOD\n    \n    # Calculate the result\n    result = 0\n    for d in range(1, 10):\n        if n % 2 == 0:\n            result += dp[n // 2][(d * 2) % k]\n        else:\n            result += dp[(n - 1) // 2][(d * 2) % k] * 2\n            result -= dp[(n - 1) // 2][((d * 2) % k + d) % k]\n            result += dp[(n - 1) // 2][((d * 2) % k - d) % k]\n    \n    return result % MOD\n```"]}
{"task_id": "abc370_f", "codes": ["import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Sort pieces in descending order\n    A.sort(reverse=True)\n\n    # Initialize variables for the partition\n    partition = [[] for _ in range(K)]\n    min_weight = float('inf')\n\n    # Assign pieces to minimize the maximum weight of any partition\n    for i in range(N):\n        person_index = partition.index(min(sum(partition[j]) for j in range(K)))\n        partition[person_index].append(A[i])\n        min_weight = min(min_weight, sum(partition[person_index]))\n\n    # Count the number of uncut cut lines\n    num_uncut_cut_lines = 0\n    for i in range(1, N):\n        if partition[(i - 1) % K][-1] != partition[i % K][0]:\n            num_uncut_cut_lines += 1\n\n    # Print the results\n    print(min_weight, num_uncut_cut_lines)\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Sort pieces in descending order\n    A.sort(reverse=True)\n\n    # Initialize variables for the partition\n    partition = [[] for _ in range(K)]\n    min_weight = float('inf')\n\n    # Assign pieces to minimize the maximum weight of any partition\n    for i in range(N):\n        person_index = partition.index(min(sum(partition[j]) for j in range(K)))\n        partition[person_index].append(A[i])\n        min_weight = min(min_weight, sum(partition[person_index]))\n\n    # Count the number of uncut cut lines\n    num_uncut_cut_lines = 0\n    for i in range(1, N):\n        if partition[(i - 1) % K][-1] != partition[i % K][0]:\n            num_uncut_cut_lines += 1\n\n    # Print the results\n    print(min_weight, num_uncut_cut_lines)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3527", "codes": ["def countAlternatingGroups(colors, queries):\n    n = len(colors)\n    MOD = 10**9 + 7\n    \n    # Initialize counts of alternating groups for all sizes\n    counts = [0] * (n + 1)\n    \n    # Function to check if a segment is alternating\n    def is_alternating(start, end):\n        for i in range(start, end):\n            if colors[i] == colors[(i + 1) % n]:\n                return False\n        return True\n    \n    # Count initial alternating groups for each size\n    for size in range(3, n + 1):\n        for start in range(n):\n            if is_alternating(start, start + size):\n                counts[size] += 1\n    \n    # Process queries\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(counts[query[1]])\n        elif query[0] == 2:\n            old_color = colors[query[1]]\n            new_color = query[2]\n            \n            # Update counts based on the change\n            for size in range(3, n + 1):\n                if (size % 2 != 0 and (old_color != new_color)):\n                    start = query[1]\n                    if is_alternating(start, start + size):\n                        counts[size] -= 1\n                    if is_alternating((start + size - 1) % n, start + size):\n                        counts[size] += 1\n                \n                if (size % 2 == 0 and old_color == new_color):\n                    start = query[1]\n                    if is_alternating(start, start + size):\n                        counts[size] += 1\n                    if is_alternating((start + size - 1) % n, start + size):\n                        counts[size] -= 1\n            \n            colors[query[1]] = new_color\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef countAlternatingGroups(colors, queries):\n    n = len(colors)\n    MOD = 10**9 + 7\n    \n    # Initialize counts of alternating groups for all sizes\n    counts = [0] * (n + 1)\n    \n    # Function to check if a segment is alternating\n    def is_alternating(start, end):\n        for i in range(start, end):\n            if colors[i] == colors[(i + 1) % n]:\n                return False\n        return True\n    \n    # Count initial alternating groups for each size\n    for size in range(3, n + 1):\n        for start in range(n):\n            if is_alternating(start, start + size):\n                counts[size] += 1\n    \n    # Process queries\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(counts[query[1]])\n        elif query[0] == 2:\n            old_color = colors[query[1]]\n            new_color = query[2]\n            \n            # Update counts based on the change\n            for size in range(3, n + 1):\n                if (size % 2 != 0 and (old_color != new_color)):\n                    start = query[1]\n                    if is_alternating(start, start + size):\n                        counts[size] -= 1\n                    if is_alternating((start + size - 1) % n, start + size):\n                        counts[size] += 1\n                \n                if (size % 2 == 0 and old_color == new_color):\n                    start = query[1]\n                    if is_alternating(start, start + size):\n                        counts[size] += 1\n                    if is_alternating((start + size - 1) % n, start + size):\n                        counts[size] -= 1\n            \n            colors[query[1]] = new_color\n    \n    return result\n```"]}
{"task_id": "3580", "codes": ["def find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1"], "passed": [false], "raw_code": ["```python\ndef find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"]}
{"task_id": "3552", "codes": ["def largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(i for i in range(1, 10) if i % k == 0))\n    \n    half_length = (n + 1) // 2\n    max_half = '9' * half_length\n    \n    while True:\n        # Construct the left half of the palindrome\n        left_half = str(int(max_half) - 1)\n        if len(left_half) < half_length:\n            break\n        \n        # Construct the full palindrome\n        if n % 2 == 0:\n            full_palindrome = left_half + left_half[::-1]\n        else:\n            full_palindrome = left_half[:-1] + left_half[-1] + left_half[::-1][:-1]\n        \n        # Check if the palindrome is divisible by k\n        if int(full_palindrome) % k == 0:\n            return full_palindrome"], "passed": [false], "raw_code": ["```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(i for i in range(1, 10) if i % k == 0))\n    \n    half_length = (n + 1) // 2\n    max_half = '9' * half_length\n    \n    while True:\n        # Construct the left half of the palindrome\n        left_half = str(int(max_half) - 1)\n        if len(left_half) < half_length:\n            break\n        \n        # Construct the full palindrome\n        if n % 2 == 0:\n            full_palindrome = left_half + left_half[::-1]\n        else:\n            full_palindrome = left_half[:-1] + left_half[-1] + left_half[::-1][:-1]\n        \n        # Check if the palindrome is divisible by k\n        if int(full_palindrome) % k == 0:\n            return full_palindrome\n```"]}
{"final_accuracy": "0.00%"}
