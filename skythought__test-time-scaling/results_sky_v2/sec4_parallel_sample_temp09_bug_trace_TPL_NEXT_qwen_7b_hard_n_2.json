"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.9, \"n\": 2, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_temp09_bug_trace_TPL_NEXT_qwen_7b_hard_n_2.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    n = len(damage)\n    edps = [(damage[i], health[i]) for i in range(n)]\n    edps.sort(key=lambda x: -x[0] / x[1])\n    \n    total_damage = 0\n    time = 0\n    \n    for d, h in edps:\n        if h <= power:\n            time += 1\n        else:\n            time += h // power\n            if h % power != 0:\n                time += 1\n        \n        total_damage += d * time\n    \n    return total_damage", "def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, range(len(damage))), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    # Simulate the process of Bob attacking the enemies\n    for time, index in sorted_enemies:\n        if current_time >= time:\n            break\n        remaining_health = health[index]\n        full_attacks = remaining_health // power\n        partial_attack = 1 if remaining_health % power != 0 else 0\n        total_damage += (full_attacks * power + partial_attack * power)\n        current_time += full_attacks + partial_attack\n    \n    return int(total_damage)"], "passed": [false, false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    edps = [(damage[i], health[i]) for i in range(n)]\n    edps.sort(key=lambda x: -x[0] / x[1])\n    \n    total_damage = 0\n    time = 0\n    \n    for d, h in edps:\n        if h <= power:\n            time += 1\n        else:\n            time += h // power\n            if h % power != 0:\n                time += 1\n        \n        total_damage += d * time\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, range(len(damage))), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    # Simulate the process of Bob attacking the enemies\n    for time, index in sorted_enemies:\n        if current_time >= time:\n            break\n        remaining_health = health[index]\n        full_attacks = remaining_health // power\n        partial_attack = 1 if remaining_health % power != 0 else 0\n        total_damage += (full_attacks * power + partial_attack * power)\n        current_time += full_attacks + partial_attack\n    \n    return int(total_damage)\n```"]}
{"task_id": "3563", "codes": ["def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each row\n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score", "def maxScore(grid):\n    for row in grid:\n        row.sort()\n    \n    score = 0\n    selected_values = set()\n    \n    for row in reversed(grid):\n        for value in reversed(row):\n            if value not in selected_values:\n                selected_values.add(value)\n                score += value\n                break\n    \n    return score"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each row\n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort()\n    \n    score = 0\n    selected_values = set()\n    \n    for row in reversed(grid):\n        for value in reversed(row):\n            if value not in selected_values:\n                selected_values.add(value)\n                score += value\n                break\n    \n    return score\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def binom(n, k):\n        if k > n:\n            return 0\n        res = 1\n        for i in range(k):\n            res = res * (n - i) // (i + 1)\n        return res\n    \n    count = 0\n    dp = [0] * (max(nums) + 1)\n    dp[0] = 1\n    \n    for num in nums:\n        new_dp = [0] * (num + 1)\n        for i in range(num + 1):\n            if dp[i] > 0:\n                new_dp[min(i + 1, num)] += dp[i]\n                new_dp[max(0, i - 1)] += dp[i]\n        count = (count + sum(new_dp)) % MOD\n        dp = new_dp\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_up = [[0] * 51 for _ in range(n)]\n    dp_down = [[0] * 51 for _ in range(n)]\n    \n    for i in range(n):\n        for num in range(1, nums[i] + 1):\n            if i == 0:\n                dp_up[i][num] = 1\n                dp_down[i][nums[i] - num] = 1\n            else:\n                dp_up[i][num] = (dp_up[i-1][num] + dp_up[i-1][num-1]) % MOD if num > 0 else dp_up[i-1][num]\n                dp_down[i][nums[i] - num] = (dp_down[i-1][nums[i] - num] + dp_down[i-1][nums[i] - num + 1]) % MOD if nums[i] - num < 51 else dp_down[i-1][nums[i] - num]\n    \n    result = 0\n    for i in range(n):\n        result = (result + dp_up[i][nums[i]] * dp_down[i][0]) % MOD\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def binom(n, k):\n        if k > n:\n            return 0\n        res = 1\n        for i in range(k):\n            res = res * (n - i) // (i + 1)\n        return res\n    \n    count = 0\n    dp = [0] * (max(nums) + 1)\n    dp[0] = 1\n    \n    for num in nums:\n        new_dp = [0] * (num + 1)\n        for i in range(num + 1):\n            if dp[i] > 0:\n                new_dp[min(i + 1, num)] += dp[i]\n                new_dp[max(0, i - 1)] += dp[i]\n        count = (count + sum(new_dp)) % MOD\n        dp = new_dp\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_up = [[0] * 51 for _ in range(n)]\n    dp_down = [[0] * 51 for _ in range(n)]\n    \n    for i in range(n):\n        for num in range(1, nums[i] + 1):\n            if i == 0:\n                dp_up[i][num] = 1\n                dp_down[i][nums[i] - num] = 1\n            else:\n                dp_up[i][num] = (dp_up[i-1][num] + dp_up[i-1][num-1]) % MOD if num > 0 else dp_up[i-1][num]\n                dp_down[i][nums[i] - num] = (dp_down[i-1][nums[i] - num] + dp_down[i-1][nums[i] - num + 1]) % MOD if nums[i] - num < 51 else dp_down[i-1][nums[i] - num]\n    \n    result = 0\n    for i in range(n):\n        result = (result + dp_up[i][nums[i]] * dp_down[i][0]) % MOD\n    \n    return result\n```"]}
{"task_id": "3552", "codes": ["def is_k_palindromic(num, k):\n    return str(num) == str(num)[::-1] and num % k == 0\n\ndef largest_k_palindromic(n, k):\n    if n == 1:\n        return str(k * (10 // k))\n    \n    mid = (10 ** ((n - 1) // 2)) - 1\n    while True:\n        mid += 1\n        left = str(mid)\n        right = left[::-1] if n % 2 == 0 else left[:-1][::-1]\n        num = int(left + right)\n        if is_k_palindromic(num, k):\n            return str(num)\n\n# Example usage:\n# print(largest_k_palindromic(3, 5))  # Output: \"595\"\n# print(largest_k_palindromic(1, 4))  # Output: \"8\"\n# print(largest_k_palindromic(5, 6))  # Output: \"89898\"", "def largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    half_length = (n + 1) // 2\n    max_digit = '9'\n    \n    # Construct the first half of the palindrome\n    for i in range(half_length):\n        if i == half_length - 1:\n            max_digit = str(k - 1) if k < 10 else '9'\n        elif i == half_length - 2:\n            max_digit = '9' if (k % 10 != 0) else '8'\n        else:\n            max_digit = '9'\n        \n        if int(max_digit * (i + 1)) >= 10**i:\n            break\n    \n    first_half = max_digit * i\n    \n    # Construct the full palindrome\n    if n % 2 == 0:\n        palindrome = first_half + first_half[::-1]\n    else:\n        middle_digit = str((k // 10) * 10) if k % 10 == 0 else str(k - 1)\n        palindrome = first_half + middle_digit + first_half[::-1]\n    \n    # Ensure the number is divisible by k\n    while int(palindrome) % k != 0:\n        if n % 2 == 0:\n            first_half = str(int(first_half) - 1).zfill(i)\n            palindrome = first_half + first_half[::-1]\n        else:\n            first_half = str(int(first_half) - 1).zfill(i)\n            middle_digit = str((int(middle_digit) - 1) % 10)\n            palindrome = first_half + middle_digit + first_half[::-1]\n    \n    return palindrome if int(palindrome[0]) != 0 else '0'"], "passed": [false, false], "raw_code": ["```python\ndef is_k_palindromic(num, k):\n    return str(num) == str(num)[::-1] and num % k == 0\n\ndef largest_k_palindromic(n, k):\n    if n == 1:\n        return str(k * (10 // k))\n    \n    mid = (10 ** ((n - 1) // 2)) - 1\n    while True:\n        mid += 1\n        left = str(mid)\n        right = left[::-1] if n % 2 == 0 else left[:-1][::-1]\n        num = int(left + right)\n        if is_k_palindromic(num, k):\n            return str(num)\n\n# Example usage:\n# print(largest_k_palindromic(3, 5))  # Output: \"595\"\n# print(largest_k_palindromic(1, 4))  # Output: \"8\"\n# print(largest_k_palindromic(5, 6))  # Output: \"89898\"\n```", "```python\ndef largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    half_length = (n + 1) // 2\n    max_digit = '9'\n    \n    # Construct the first half of the palindrome\n    for i in range(half_length):\n        if i == half_length - 1:\n            max_digit = str(k - 1) if k < 10 else '9'\n        elif i == half_length - 2:\n            max_digit = '9' if (k % 10 != 0) else '8'\n        else:\n            max_digit = '9'\n        \n        if int(max_digit * (i + 1)) >= 10**i:\n            break\n    \n    first_half = max_digit * i\n    \n    # Construct the full palindrome\n    if n % 2 == 0:\n        palindrome = first_half + first_half[::-1]\n    else:\n        middle_digit = str((k // 10) * 10) if k % 10 == 0 else str(k - 1)\n        palindrome = first_half + middle_digit + first_half[::-1]\n    \n    # Ensure the number is divisible by k\n    while int(palindrome) % k != 0:\n        if n % 2 == 0:\n            first_half = str(int(first_half) - 1).zfill(i)\n            palindrome = first_half + first_half[::-1]\n        else:\n            first_half = str(int(first_half) - 1).zfill(i)\n            middle_digit = str((int(middle_digit) - 1) % 10)\n            palindrome = first_half + middle_digit + first_half[::-1]\n    \n    return palindrome if int(palindrome[0]) != 0 else '0'\n```"]}
{"task_id": "3550", "codes": ["def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_positions = []\n    \n    # Find all positions in each row where a rook can be placed\n    for i in range(m):\n        positions = [j for j in range(n) if board[i][j] != -3]\n        row_positions.append(positions)\n    \n    max_sum = float('-inf')\n    \n    # Iterate through all combinations of three different rows and columns\n    for r1 in range(m):\n        for c1 in range(len(row_positions[r1])):\n            for r2 in range(r1 + 1, m):\n                for c2 in range(len(row_positions[r2])):\n                    if c1 != c2:\n                        for r3 in range(r2 + 1, m):\n                            for c3 in range(len(row_positions[r3])):\n                                if c3 != c1 and c3 != c2:\n                                    current_sum = board[row_positions[r1][c1]][row_positions[r2][c2]] + \\\n                                                  board[row_positions[r1][c1]][row_positions[r3][c3]] + \\\n                                                  board[row_positions[r2][c2]][row_positions[r3][c3]]\n                                    max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate column sums\n    col_sums = [sum(board[row][col] for row in range(m)) for col in range(n)]\n    \n    # Get the indices of the top three rows and columns by their sums\n    top_rows = sorted(range(m), key=lambda i: -row_sums[i])[:3]\n    top_cols = sorted(range(n), key=lambda i: -col_sums[i])[:3]\n    \n    # Ensure no common row or column among the top three\n    valid_rows = []\n    valid_cols = []\n    for row in top_rows:\n        if row not in valid_rows:\n            valid_rows.append(row)\n    for col in top_cols:\n        if col not in valid_cols:\n            valid_cols.append(col)\n    \n    # If there are fewer than 3 valid rows or columns, return the sum of all elements\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return sum(sum(row) for row in board)\n    \n    # Calculate the maximum sum of the selected cells\n    max_sum = 0\n    for row in valid_rows:\n        for col in valid_cols:\n            max_sum += board[row][col]\n    \n    return max_sum"], "passed": [false, false], "raw_code": ["```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_positions = []\n    \n    # Find all positions in each row where a rook can be placed\n    for i in range(m):\n        positions = [j for j in range(n) if board[i][j] != -3]\n        row_positions.append(positions)\n    \n    max_sum = float('-inf')\n    \n    # Iterate through all combinations of three different rows and columns\n    for r1 in range(m):\n        for c1 in range(len(row_positions[r1])):\n            for r2 in range(r1 + 1, m):\n                for c2 in range(len(row_positions[r2])):\n                    if c1 != c2:\n                        for r3 in range(r2 + 1, m):\n                            for c3 in range(len(row_positions[r3])):\n                                if c3 != c1 and c3 != c2:\n                                    current_sum = board[row_positions[r1][c1]][row_positions[r2][c2]] + \\\n                                                  board[row_positions[r1][c1]][row_positions[r3][c3]] + \\\n                                                  board[row_positions[r2][c2]][row_positions[r3][c3]]\n                                    max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate column sums\n    col_sums = [sum(board[row][col] for row in range(m)) for col in range(n)]\n    \n    # Get the indices of the top three rows and columns by their sums\n    top_rows = sorted(range(m), key=lambda i: -row_sums[i])[:3]\n    top_cols = sorted(range(n), key=lambda i: -col_sums[i])[:3]\n    \n    # Ensure no common row or column among the top three\n    valid_rows = []\n    valid_cols = []\n    for row in top_rows:\n        if row not in valid_rows:\n            valid_rows.append(row)\n    for col in top_cols:\n        if col not in valid_cols:\n            valid_cols.append(col)\n    \n    # If there are fewer than 3 valid rows or columns, return the sum of all elements\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return sum(sum(row) for row in board)\n    \n    # Calculate the maximum sum of the selected cells\n    max_sum = 0\n    for row in valid_rows:\n        for col in valid_cols:\n            max_sum += board[row][col]\n    \n    return max_sum\n```"]}
{"task_id": "3575", "codes": ["def max_subsequence_xor(nums, k):\n    # Sort the array\n    nums.sort()\n    \n    # Initialize the maximum XOR value\n    max_xor = 0\n    \n    # Pair the smallest and largest numbers\n    for i in range(k):\n        max_xor = max(max_xor, nums[i] | nums[-i - 1])\n    \n    return max_xor", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if k == 1:\n        return max(nums)\n    \n    max_val = 0\n    \n    for i in range(n - 2 * k + 1):\n        left_or = 0\n        right_or = 0\n        \n        # Compute OR for the first half of the subsequence\n        for j in range(i, i + k):\n            left_or |= nums[j]\n        \n        # Compute OR for the second half of the subsequence\n        for j in range(i + k, i + 2 * k):\n            right_or |= nums[j]\n        \n        # Compute XOR and update max_val\n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val"], "passed": [false, false], "raw_code": ["```python\ndef max_subsequence_xor(nums, k):\n    # Sort the array\n    nums.sort()\n    \n    # Initialize the maximum XOR value\n    max_xor = 0\n    \n    # Pair the smallest and largest numbers\n    for i in range(k):\n        max_xor = max(max_xor, nums[i] | nums[-i - 1])\n    \n    return max_xor\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if k == 1:\n        return max(nums)\n    \n    max_val = 0\n    \n    for i in range(n - 2 * k + 1):\n        left_or = 0\n        right_or = 0\n        \n        # Compute OR for the first half of the subsequence\n        for j in range(i, i + k):\n            left_or |= nums[j]\n        \n        # Compute OR for the second half of the subsequence\n        for j in range(i + k, i + 2 * k):\n            right_or |= nums[j]\n        \n        # Compute XOR and update max_val\n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val\n```"]}
{"task_id": "3548", "codes": ["def count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    elif n == 2:\n        return len([i for i in range(10, 100) if str(i) == str(i)[::-1] and i % k == 0])\n    else:\n        # For larger n, we would need a more complex combinatorial approach\n        pass", "def count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_combinations(digits):\n        from collections import Counter\n        count = Counter(digits)\n        half_count = sum(count[d] // 2 for d in count)\n        total = 1\n        for v in count.values():\n            total *= factorial(v) // (factorial(v // 2) * factorial(v - v // 2))\n        return total\n    \n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    good_count = 0\n    for i in range(1, 10):\n        if i % k == 0:\n            remaining_digits = n - 1\n            while remaining_digits > 0:\n                digit_sum = i + remaining_digits\n                if digit_sum % 2 != 0:\n                    break\n                if digit_sum // 2 < 10:\n                    remaining_digits -= 1\n                else:\n                    break\n            else:\n                good_count += count_combinations(str(i) * (n // 2) + str(digit_sum // 2))\n    \n    return good_count"], "passed": [false, false], "raw_code": ["def count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    elif n == 2:\n        return len([i for i in range(10, 100) if str(i) == str(i)[::-1] and i % k == 0])\n    else:\n        # For larger n, we would need a more complex combinatorial approach\n        pass", "```python\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_combinations(digits):\n        from collections import Counter\n        count = Counter(digits)\n        half_count = sum(count[d] // 2 for d in count)\n        total = 1\n        for v in count.values():\n            total *= factorial(v) // (factorial(v // 2) * factorial(v - v // 2))\n        return total\n    \n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    good_count = 0\n    for i in range(1, 10):\n        if i % k == 0:\n            remaining_digits = n - 1\n            while remaining_digits > 0:\n                digit_sum = i + remaining_digits\n                if digit_sum % 2 != 0:\n                    break\n                if digit_sum // 2 < 10:\n                    remaining_digits -= 1\n                else:\n                    break\n            else:\n                good_count += count_combinations(str(i) * (n // 2) + str(digit_sum // 2))\n    \n    return good_count\n```"]}
{"task_id": "3560", "codes": ["def min_moves(kx, ky, px, py):\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if (x, y) == (px, py):\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\n@lru_cache(None)\ndef minimax(pawns, turn):\n    if not pawns:\n        return 0\n    \n    if turn == 'A':\n        max_moves = float('-inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(*pawns[0], px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            max_moves = max(max_moves, moves + minimax(remaining_pawns, 'B'))\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(*pawns[0], px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            min_moves = min(min_moves, moves + minimax(remaining_pawns, 'A'))\n        return min_moves\n\ndef knight_capture(kx, ky, positions):\n    return minimax(tuple(positions), 'A')", "def min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if (x, y) == (px, py):\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\n@functools.lru_cache(None)\ndef dfs(kx, ky, positions, turn):\n    if not positions:\n        return 0\n    \n    max_moves = float('-inf') if turn == 'Alice' else float('inf')\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        new_positions = positions[:i] + positions[i+1:]\n        \n        if turn == 'Alice':\n            result = moves + dfs(px, py, new_positions, 'Bob')\n            max_moves = max(max_moves, result)\n        else:\n            result = moves + dfs(px, py, new_positions, 'Alice')\n            max_moves = min(max_moves, result)\n    \n    return max_moves\n\ndef knight_game(kx, ky, positions):\n    return dfs(kx, ky, tuple(map(tuple, positions)), 'Alice')"], "passed": [false, false], "raw_code": ["```python\ndef min_moves(kx, ky, px, py):\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if (x, y) == (px, py):\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\n@lru_cache(None)\ndef minimax(pawns, turn):\n    if not pawns:\n        return 0\n    \n    if turn == 'A':\n        max_moves = float('-inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(*pawns[0], px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            max_moves = max(max_moves, moves + minimax(remaining_pawns, 'B'))\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for i, (px, py) in enumerate(pawns):\n            moves = min_moves(*pawns[0], px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            min_moves = min(min_moves, moves + minimax(remaining_pawns, 'A'))\n        return min_moves\n\ndef knight_capture(kx, ky, positions):\n    return minimax(tuple(positions), 'A')\n```", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if (x, y) == (px, py):\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\n@functools.lru_cache(None)\ndef dfs(kx, ky, positions, turn):\n    if not positions:\n        return 0\n    \n    max_moves = float('-inf') if turn == 'Alice' else float('inf')\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        new_positions = positions[:i] + positions[i+1:]\n        \n        if turn == 'Alice':\n            result = moves + dfs(px, py, new_positions, 'Bob')\n            max_moves = max(max_moves, result)\n        else:\n            result = moves + dfs(px, py, new_positions, 'Alice')\n            max_moves = min(max_moves, result)\n    \n    return max_moves\n\ndef knight_game(kx, ky, positions):\n    return dfs(kx, ky, tuple(map(tuple, positions)), 'Alice')\n```"]}
{"task_id": "3532", "codes": ["from collections import defaultdict, deque\n\ndef minTimeToMarkAllNodes(edges):\n    def bfs(start):\n        queue = deque([start])\n        visited = set()\n        visited.add(start)\n        marking_time = {start: 0}\n        \n        while queue:\n            current = queue.popleft()\n            time = marking_time[current]\n            \n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if current % 2 == 1:\n                        marking_time[neighbor] = time + 1\n                    else:\n                        marking_time[neighbor] = time + 2\n                    queue.append(neighbor)\n        \n        return marking_time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    max_marking_time = 0\n    \n    for node in range(n):\n        marking_time = bfs(node)\n        max_marking_time = max(max_marking_time, max(marking_time.values()))\n    \n    return [max_marking_time] * n", "def minTimeToMarkNodes(edges):\n    from collections import defaultdict\n    \n    def dfs(node, parent, time):\n        max_time = time\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                neighbor_time = dfs(neighbor, node, time + 1)\n                if node % 2 == 0:\n                    max_time = max(max_time, neighbor_time + 1)\n                else:\n                    max_time = max(max_time, neighbor_time)\n        return max_time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for i in range(n):\n        result[i] = dfs(i, -1, 0)\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\nfrom collections import defaultdict, deque\n\ndef minTimeToMarkAllNodes(edges):\n    def bfs(start):\n        queue = deque([start])\n        visited = set()\n        visited.add(start)\n        marking_time = {start: 0}\n        \n        while queue:\n            current = queue.popleft()\n            time = marking_time[current]\n            \n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if current % 2 == 1:\n                        marking_time[neighbor] = time + 1\n                    else:\n                        marking_time[neighbor] = time + 2\n                    queue.append(neighbor)\n        \n        return marking_time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    max_marking_time = 0\n    \n    for node in range(n):\n        marking_time = bfs(node)\n        max_marking_time = max(max_marking_time, max(marking_time.values()))\n    \n    return [max_marking_time] * n\n```", "```python\ndef minTimeToMarkNodes(edges):\n    from collections import defaultdict\n    \n    def dfs(node, parent, time):\n        max_time = time\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                neighbor_time = dfs(neighbor, node, time + 1)\n                if node % 2 == 0:\n                    max_time = max(max_time, neighbor_time + 1)\n                else:\n                    max_time = max(max_time, neighbor_time)\n        return max_time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for i in range(n):\n        result[i] = dfs(i, -1, 0)\n    \n    return result\n```"]}
{"task_id": "3580", "codes": ["def smallest_almost_equal_substring(s, pattern):\n    m, n = len(s), len(pattern)\n    for i in range(m - n + 1):\n        diff = 0\n        for j in range(n):\n            if s[i + j] != pattern[j]:\n                diff += 1\n            if diff > 1:\n                break\n        if diff <= 1:\n            return i\n    return -1", "def find_almost_equal_substring(s, pattern):\n    n, m = len(s), len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1"], "passed": [false, false], "raw_code": ["```python\ndef smallest_almost_equal_substring(s, pattern):\n    m, n = len(s), len(pattern)\n    for i in range(m - n + 1):\n        diff = 0\n        for j in range(n):\n            if s[i + j] != pattern[j]:\n                diff += 1\n            if diff > 1:\n                break\n        if diff <= 1:\n            return i\n    return -1\n```", "```python\ndef find_almost_equal_substring(s, pattern):\n    n, m = len(s), len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"]}
{"task_id": "3571", "codes": ["def maxIncreasingPath(coordinates, k):\n    coordinates.sort()\n    n = len(coordinates)\n    dp = [1] * n\n    for i in range(n):\n        x1, y1 = coordinates[i]\n        for j in range(i):\n            x2, y2 = coordinates[j]\n            if x2 < x1 and y2 < y1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[k]", "def longestIncreasingPath(coordinates, k):\n    from functools import lru_cache\n    from collections import defaultdict\n    n = len(coordinates)\n    coordinates.sort()\n    \n    @lru_cache(None)\n    def dfs(x, y):\n        max_length = 1\n        for dx, dy in [(0, 1), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and coordinates[ny][0] > coordinates[nx][0] and coordinates[ny][1] > coordinates[nx][1]:\n                max_length = max(max_length, 1 + dfs(nx, ny))\n        return max_length\n    \n    return dfs(*coordinates[k])"], "passed": [false, false], "raw_code": ["```python\ndef maxIncreasingPath(coordinates, k):\n    coordinates.sort()\n    n = len(coordinates)\n    dp = [1] * n\n    for i in range(n):\n        x1, y1 = coordinates[i]\n        for j in range(i):\n            x2, y2 = coordinates[j]\n            if x2 < x1 and y2 < y1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[k]\n```", "```python\ndef longestIncreasingPath(coordinates, k):\n    from functools import lru_cache\n    from collections import defaultdict\n    n = len(coordinates)\n    coordinates.sort()\n    \n    @lru_cache(None)\n    def dfs(x, y):\n        max_length = 1\n        for dx, dy in [(0, 1), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and coordinates[ny][0] > coordinates[nx][0] and coordinates[ny][1] > coordinates[nx][1]:\n                max_length = max(max_length, 1 + dfs(nx, ny))\n        return max_length\n    \n    return dfs(*coordinates[k])\n```"]}
{"task_id": "3583", "codes": ["def solve_gcd_pairs(nums, queries):\n    from math import gcd\n    from collections import defaultdict\n    \n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Iterate over all pairs (i, j) with i < j\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    # Convert counts to a sorted list of GCD values\n    gcd_values = sorted(gcd_counts.keys())\n    \n    # Prepare the result array\n    answer = []\n    for q in queries:\n        idx = q // gcd_counts[gcd_values[q]]\n        answer.append(gcd_values[idx])\n    \n    return answer", "def getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef answerQueries(nums, queries):\n    max_gcd = max(nums)\n    gcd_count = [0] * (max_gcd + 1)\n    prefix_sum = [0] * (max_gcd + 1)\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_value = getGCD(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n\n    prefix_sum[0] = gcd_count[0]\n    for i in range(1, max_gcd + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + gcd_count[i]\n\n    result = []\n    for query in queries:\n        result.append(prefix_sum[query])\n\n    return result"], "passed": [false, false], "raw_code": ["```python\ndef solve_gcd_pairs(nums, queries):\n    from math import gcd\n    from collections import defaultdict\n    \n    max_val = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Iterate over all pairs (i, j) with i < j\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            gcd_counts[g] += 1\n    \n    # Convert counts to a sorted list of GCD values\n    gcd_values = sorted(gcd_counts.keys())\n    \n    # Prepare the result array\n    answer = []\n    for q in queries:\n        idx = q // gcd_counts[gcd_values[q]]\n        answer.append(gcd_values[idx])\n    \n    return answer\n```", "```python\ndef getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef answerQueries(nums, queries):\n    max_gcd = max(nums)\n    gcd_count = [0] * (max_gcd + 1)\n    prefix_sum = [0] * (max_gcd + 1)\n\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_value = getGCD(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n\n    prefix_sum[0] = gcd_count[0]\n    for i in range(1, max_gcd + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + gcd_count[i]\n\n    result = []\n    for query in queries:\n        result.append(prefix_sum[query])\n\n    return result\n```"]}
{"task_id": "3527", "codes": ["def countAlternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend the array to handle circular nature\n    diff = [0] * (n + 2)\n    result = []\n\n    def update(i, val):\n        diff[i] += val\n        diff[i + 1] -= val\n\n    def query(size):\n        count = 0\n        current_color = colors[0]\n        length = 0\n\n        for i in range(1, n + size):\n            if colors[i] != current_color:\n                if length >= size - 1:\n                    count += 1\n                length = 1\n                current_color = colors[i]\n            else:\n                length += 1\n\n        return count\n\n    for q in queries:\n        if q[0] == 1:\n            result.append(query(q[1]))\n        elif q[0] == 2:\n            old_color = colors[q[1]]\n            new_color = q[2]\n            colors[q[1]] = new_color\n            update(q[1] + n, new_color - old_color)\n\n    return result", "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors[:2]  # Extend the list to handle circular nature\n    group_counts = {}\n    current_groups = []\n    \n    def add_group(size):\n        if size in group_counts:\n            group_counts[size] += 1\n    \n    def remove_group(size):\n        if size in group_counts:\n            group_counts[size] -= 1\n            if group_counts[size] == 0:\n                del group_counts[size]\n    \n    for i in range(n):\n        current_groups.append((colors[i], colors[(i + 1) % n]))\n        if len(current_groups) >= 3:\n            if current_groups[-1][0] != current_groups[-2][1]:\n                add_group(len(current_groups))\n            elif len(current_groups) > 3 and current_groups[-1][0] != current_groups[-3][1]:\n                remove_group(len(current_groups) - 1)\n    \n    result = []\n    \n    for query in queries:\n        if query[0] == 2:\n            old_color, new_color = colors[query[1]], query[2]\n            colors[query[1]] = new_color\n            \n            # Remove old groups\n            for size in range(3, n + 1):\n                if (old_color, colors[(query[1] + size - 2) % n]) in current_groups and \\\n                   (colors[(query[1] + size - 1) % n], old_color) in current_groups:\n                    remove_group(size)\n            \n            # Add new groups\n            for size in range(3, n + 1):\n                if (new_color, colors[(query[1] + size - 2) % n]) in current_groups and \\\n                   (colors[(query[1] + size - 1) % n], new_color) in current_groups:\n                    add_group(size)\n        \n        elif query[0] == 1:\n            size = query[1]\n            if size in group_counts:\n                result.append(group_counts[size])\n            else:\n                result.append(0)\n    \n    return result"], "passed": [false, false], "raw_code": ["def countAlternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend the array to handle circular nature\n    diff = [0] * (n + 2)\n    result = []\n\n    def update(i, val):\n        diff[i] += val\n        diff[i + 1] -= val\n\n    def query(size):\n        count = 0\n        current_color = colors[0]\n        length = 0\n\n        for i in range(1, n + size):\n            if colors[i] != current_color:\n                if length >= size - 1:\n                    count += 1\n                length = 1\n                current_color = colors[i]\n            else:\n                length += 1\n\n        return count\n\n    for q in queries:\n        if q[0] == 1:\n            result.append(query(q[1]))\n        elif q[0] == 2:\n            old_color = colors[q[1]]\n            new_color = q[2]\n            colors[q[1]] = new_color\n            update(q[1] + n, new_color - old_color)\n\n    return result", "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors[:2]  # Extend the list to handle circular nature\n    group_counts = {}\n    current_groups = []\n    \n    def add_group(size):\n        if size in group_counts:\n            group_counts[size] += 1\n    \n    def remove_group(size):\n        if size in group_counts:\n            group_counts[size] -= 1\n            if group_counts[size] == 0:\n                del group_counts[size]\n    \n    for i in range(n):\n        current_groups.append((colors[i], colors[(i + 1) % n]))\n        if len(current_groups) >= 3:\n            if current_groups[-1][0] != current_groups[-2][1]:\n                add_group(len(current_groups))\n            elif len(current_groups) > 3 and current_groups[-1][0] != current_groups[-3][1]:\n                remove_group(len(current_groups) - 1)\n    \n    result = []\n    \n    for query in queries:\n        if query[0] == 2:\n            old_color, new_color = colors[query[1]], query[2]\n            colors[query[1]] = new_color\n            \n            # Remove old groups\n            for size in range(3, n + 1):\n                if (old_color, colors[(query[1] + size - 2) % n]) in current_groups and \\\n                   (colors[(query[1] + size - 1) % n], old_color) in current_groups:\n                    remove_group(size)\n            \n            # Add new groups\n            for size in range(3, n + 1):\n                if (new_color, colors[(query[1] + size - 2) % n]) in current_groups and \\\n                   (colors[(query[1] + size - 1) % n], new_color) in current_groups:\n                    add_group(size)\n        \n        elif query[0] == 1:\n            size = query[1]\n            if size in group_counts:\n                result.append(group_counts[size])\n            else:\n                result.append(0)\n    \n    return result\n```"]}
{"task_id": "3551", "codes": ["class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_val = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for bit in reversed(format(num, '032b')):\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n            node.max_val = max(node.max_val, num)\n\n    def getMaxXor(self, num):\n        node = self.root\n        maxXor = 0\n        for bit in reversed(format(num, '032b')):\n            opposite_bit = '1' if bit == '0' else '0'\n            if opposite_bit in node.children:\n                maxXor |= int(opposite_bit) << (format(num, '032b').index(bit))\n                node = node.children[opposite_bit]\n            elif bit in node.children:\n                node = node.children[bit]\n            else:\n                break\n        return maxXor\n\ndef xorQueries(nums, queries):\n    trie = Trie()\n    prefix_xor = [0] * len(nums)\n    result = []\n    \n    # Compute prefix XORs and insert them into the Trie\n    for i in range(len(nums)):\n        prefix_xor[i] = prefix_xor[i-1] ^ nums[i]\n        trie.insert(prefix_xor[i])\n    \n    # Answer each query\n    for l, r in queries:\n        if l == 0:\n            result.append(trie.getMaxXor(prefix_xor[r]))\n        else:\n            result.append(trie.getMaxXor(prefix_xor[r]) ^ trie.getMaxXor(prefix_xor[l-1]))\n    \n    return result", "def max_xor(nums, queries):\n    def insert(trie, num):\n        node = trie\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n        node['#'] = num\n    \n    def query(trie, num):\n        node = trie\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit ^ 1 in node:\n                xor |= (1 << i)\n                node = node[bit ^ 1]\n            else:\n                node = node[bit]\n        return xor\n    \n    n = len(nums)\n    trie = {}\n    result = [0] * len(queries)\n    \n    for i, (l_i, r_i) in enumerate(queries):\n        insert(trie, nums[r_i])\n        for j in range(r_i, l_i - 1, -1):\n            if j < r_i:\n                insert(trie, nums[j])\n            result[i] = max(result[i], query(trie, nums[j]))\n    \n    return result"], "passed": [false, false], "raw_code": ["```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_val = 0\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, num):\n        node = self.root\n        for bit in reversed(format(num, '032b')):\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n            node.max_val = max(node.max_val, num)\n\n    def getMaxXor(self, num):\n        node = self.root\n        maxXor = 0\n        for bit in reversed(format(num, '032b')):\n            opposite_bit = '1' if bit == '0' else '0'\n            if opposite_bit in node.children:\n                maxXor |= int(opposite_bit) << (format(num, '032b').index(bit))\n                node = node.children[opposite_bit]\n            elif bit in node.children:\n                node = node.children[bit]\n            else:\n                break\n        return maxXor\n\ndef xorQueries(nums, queries):\n    trie = Trie()\n    prefix_xor = [0] * len(nums)\n    result = []\n    \n    # Compute prefix XORs and insert them into the Trie\n    for i in range(len(nums)):\n        prefix_xor[i] = prefix_xor[i-1] ^ nums[i]\n        trie.insert(prefix_xor[i])\n    \n    # Answer each query\n    for l, r in queries:\n        if l == 0:\n            result.append(trie.getMaxXor(prefix_xor[r]))\n        else:\n            result.append(trie.getMaxXor(prefix_xor[r]) ^ trie.getMaxXor(prefix_xor[l-1]))\n    \n    return result\n```", "```python\ndef max_xor(nums, queries):\n    def insert(trie, num):\n        node = trie\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n        node['#'] = num\n    \n    def query(trie, num):\n        node = trie\n        xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit ^ 1 in node:\n                xor |= (1 << i)\n                node = node[bit ^ 1]\n            else:\n                node = node[bit]\n        return xor\n    \n    n = len(nums)\n    trie = {}\n    result = [0] * len(queries)\n    \n    for i, (l_i, r_i) in enumerate(queries):\n        insert(trie, nums[r_i])\n        for j in range(r_i, l_i - 1, -1):\n            if j < r_i:\n                insert(trie, nums[j])\n            result[i] = max(result[i], query(trie, nums[j]))\n    \n    return result\n```"]}
{"final_accuracy": "0.00%"}
{"difficulty": "hard", "num_threads": 32, "temperature": 0.9, "n": 2, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp09_bug_trace_TPL_NEXT_qwen_7b_hard_n_2.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc367_e", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef perform_operations(N, K, X, A):\n    # Function to find all cycles in the permutation X\n    def find_cycles(X):\n        visited = [False] * N\n        cycles = []\n        for i in range(N):\n            if not visited[i]:\n                cycle = []\n                x = i\n                while not visited[x]:\n                    visited[x] = True\n                    cycle.append(x)\n                    x = X[x] - 1\n                cycles.append(cycle)\n        return cycles\n    \n    # Find all cycles in the permutation X\n    cycles = find_cycles(X)\n    \n    # Function to apply K operations to a single cycle\n    def apply_cycle_to_cycle(cycle, A, K):\n        n = len(cycle)\n        effective_K = K % n\n        for _ in range(effective_K):\n            new_A = A[:]\n            for j in range(n):\n                new_A[cycle[j]] = A[cycle[(j + 1) % n]]\n            A = new_A\n        return A\n    \n    # Apply the operations to each cycle\n    for cycle in cycles:\n        A = apply_cycle_to_cycle(cycle, A, K)\n    \n    # Print the resulting sequence\n    print(\" \".join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nperform_operations(N, K, X, A)", "```python\ndef transform_sequence(N, K, X, A):\n    # Create a list to store the cycle leaders\n    leaders = [i for i in range(N)]\n    \n    # Find the cycle leader for each element\n    for i in range(N):\n        while leaders[i] != X[leaders[i] - 1] - 1:\n            leaders[i] = X[leaders[i] - 1] - 1\n    \n    # Create a dictionary to store the transformed sequences for each cycle\n    cycle_transforms = {}\n    \n    for i in range(N):\n        if leaders[i] not in cycle_transforms:\n            cycle = []\n            x = i\n            while x not in cycle:\n                cycle.append(x)\n                x = leaders[x]\n            \n            transformed_cycle = []\n            for idx in cycle:\n                transformed_cycle.append(A[X[idx] - 1])\n            \n            cycle_transforms[leaders[i]] = transformed_cycle\n    \n    # Apply the transformation for the effective number of operations\n    result = A[:]\n    for i in range(N):\n        cycle_leader = leaders[i]\n        cycle_length = len(cycle_transforms[cycle_leader])\n        effective_operations = K % cycle_length\n        result[i] = cycle_transforms[cycle_leader][effective_operations * cycle_transforms[cycle_leader].index(result[i])]\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Get the result\nresult = transform_sequence(N, K, X, A)\n\n# Print the result\nprint(' '.join(map(str, result)))"]}
{"task_id": "arc182_d", "codes": ["d", "def min_operations_to_transform(N, M, A, B):\n    total_operations = 0\n    \n    for i in range(N):\n        if A[i] != B[i]:\n            diff = abs(A[i] - B[i])\n            wrap_diff = M - diff\n            total_operations += min(diff, wrap_diff)\n    \n    # Check if the transformation is feasible\n    for i in range(N - 1):\n        if (A[i] == B[i]) or ((A[i] + 1) % M == B[i]) or ((A[i] - 1) % M == B[i]):\n            continue\n        return -1\n    \n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print the result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)"], "passed": [false, false], "raw_code": ["```python\ndef min_operations_to_transform(A, B, M):\n    N = len(A)\n    operations = 0\n    \n    for i in range(N):\n        if A[i] != B[i]:\n            # Calculate the difference between A[i] and B[i]\n            diff = abs(B[i] - A[i])\n            \n            # Check if the direct transformation is valid\n            if diff == 1 or (diff == M - 1 and abs((A[i] + M - B[i]) % M) == 1):\n                operations += diff\n            else:\n                return -1\n    \n    return operations\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print the result\nresult = min_operations_to_transform(A, B, M)\nprint(result)", "```python\ndef min_operations_to_transform(N, M, A, B):\n    total_operations = 0\n    \n    for i in range(N):\n        if A[i] != B[i]:\n            diff = abs(A[i] - B[i])\n            wrap_diff = M - diff\n            total_operations += min(diff, wrap_diff)\n    \n    # Check if the transformation is feasible\n    for i in range(N - 1):\n        if (A[i] == B[i]) or ((A[i] + 1) % M == B[i]) or ((A[i] - 1) % M == B[i]):\n            continue\n        return -1\n    \n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\n\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print the result\nresult = min_operations_to_transform(N, M, A, B)\nprint(result)\n```"]}
{"task_id": "abc366_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n\n    x_points = []\n    y_points = []\n\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_points.append(x)\n        y_points.append(y)\n        index += 2\n\n    x_points.sort()\n    y_points.sort()\n\n    def count_valid_points(points, target):\n        left = 0\n        right = 0\n        count = 0\n        current_sum = 0\n\n        while right < len(points):\n            if current_sum <= target:\n                current_sum += points[right] - points[left]\n                right += 1\n            else:\n                count += (right - left) * (len(points) - right)\n                current_sum -= points[left] - points[left + 1]\n                left += 1\n\n        count += (right - left) * (len(points) - right)\n        return count\n\n    x_count = count_valid_points(x_points, D)\n    y_count = count_valid_points(y_points, D)\n\n    print(x_count * y_count)\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_points = []\n    y_points = []\n    for _ in range(N):\n        x_points.append(int(data[index]))\n        y_points.append(int(data[index + 1]))\n        index += 2\n    \n    def count_valid_points(points):\n        points.sort()\n        prefix_sum = [0]\n        for point in points:\n            prefix_sum.append(prefix_sum[-1] + point)\n        \n        left, right = 0, 0\n        count = 0\n        \n        while right < len(points):\n            while left <= right and points[right] - points[left] > D:\n                left += 1\n            \n            if left > right:\n                right += 1\n            else:\n                count += prefix_sum[right + 1] - prefix_sum[left]\n                right += 1\n        \n        return count\n    \n    x_count = count_valid_points(x_points)\n    y_count = count_valid_points(y_points)\n    \n    print(x_count * y_count)\n\nmain()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n\n    x_points = []\n    y_points = []\n\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_points.append(x)\n        y_points.append(y)\n        index += 2\n\n    x_points.sort()\n    y_points.sort()\n\n    def count_valid_points(points, target):\n        left = 0\n        right = 0\n        count = 0\n        current_sum = 0\n\n        while right < len(points):\n            if current_sum <= target:\n                current_sum += points[right] - points[left]\n                right += 1\n            else:\n                count += (right - left) * (len(points) - right)\n                current_sum -= points[left] - points[left + 1]\n                left += 1\n\n        count += (right - left) * (len(points) - right)\n        return count\n\n    x_count = count_valid_points(x_points, D)\n    y_count = count_valid_points(y_points, D)\n\n    print(x_count * y_count)\n\nmain()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_points = []\n    y_points = []\n    for _ in range(N):\n        x_points.append(int(data[index]))\n        y_points.append(int(data[index + 1]))\n        index += 2\n    \n    def count_valid_points(points):\n        points.sort()\n        prefix_sum = [0]\n        for point in points:\n            prefix_sum.append(prefix_sum[-1] + point)\n        \n        left, right = 0, 0\n        count = 0\n        \n        while right < len(points):\n            while left <= right and points[right] - points[left] > D:\n                left += 1\n            \n            if left > right:\n                right += 1\n            else:\n                count += prefix_sum[right + 1] - prefix_sum[left]\n                right += 1\n        \n        return count\n    \n    x_count = count_valid_points(x_points)\n    y_count = count_valid_points(y_points)\n    \n    print(x_count * y_count)\n\nmain()\n```"]}
{"task_id": "abc368_d", "codes": ["import sys\nfrom collections import defaultdict\n\ndef lca(tree, u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    \n    while depth[u] > depth[v]:\n        u = parent[u]\n    \n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    \n    return u\n\ndef dfs(node, par, dist):\n    parent[node] = par\n    depth[node] = dist\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node, dist + 1)\n\ndef min_vertices_to_cover(vertices):\n    n = len(vertices)\n    if n == 1:\n        return 1\n    \n    # Sort vertices based on depth to ensure LCA calculation works correctly\n    vertices.sort(key=lambda x: depth[x])\n    \n    # Calculate LCA for pairs of vertices\n    max_lca = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            current_lca = lca(tree, vertices[i], vertices[j])\n            max_lca = max(max_lca, current_lca)\n    \n    # Count unique vertices including the LCA\n    covered_vertices = set()\n    for vertex in vertices:\n        covered_vertices.add(vertex)\n    covered_vertices.add(max_lca)\n    \n    return len(covered_vertices)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i]) - 1\n    v = int(data[3 + 2 * i]) - 1\n    edges.append((u, v))\n\nvertices = list(map(int, data[2 * N + 1:])) - 1\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Initialize depth and parent arrays\ndepth = [-1] * N\nparent = [-1] * N\n\n# Perform DFS to fill depth and parent arrays\ndfs(0, -1, 0)\n\n# Get the minimum number of vertices to cover all K vertices\nresult = min_vertices_to_cover(vertices)\n\nprint(result)", "import sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N - 1):\n    A = int(data[2 + 2 * i]) - 1\n    B = int(data[3 + 2 * i]) - 1\n    edges.append((A, B))\n\nvertices = list(map(int, data[N + 2:N + 2 + K])) - 1\n\n# Build adjacency list\nadj_list = [[] for _ in range(N)]\nfor u, v in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Function to find LCA using DFS\ndef dfs(node, parent, depth, lca_depths, path, lca_node):\n    path.append(node)\n    lca_depths[node] = len(path)\n    \n    if node in vertices:\n        path_to_vertex = path[:]\n        \n        for other in vertices:\n            if other != node:\n                path_length = lca_depths[node] - lca_depths[lca_node]\n                if lca_depths[other] > lca_depths[node]:\n                    path_length += lca_depths[other] - lca_depths[node]\n                elif lca_depths[other] < lca_depths[node]:\n                    path_length -= lca_depths[node] - lca_depths[other]\n                \n                path_length += abs(len(path_to_vertex) - len(path))\n                \n                # Update the minimum number of vertices needed\n                min_vertices_needed = min(min_vertices_needed, path_length)\n    \n    for neighbor in adj_list[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, lca_depths, path, lca_node)\n    \n    path.pop()\n    return min_vertices_needed\n\nmin_vertices_needed = float('inf')\nlca_node = 0\ndfs(lca_node, -1, 0, [0] * N, [], lca_node)\n\nprint(min_vertices_needed)"], "passed": [false, false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict\n\ndef lca(tree, u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    \n    while depth[u] > depth[v]:\n        u = parent[u]\n    \n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    \n    return u\n\ndef dfs(node, par, dist):\n    parent[node] = par\n    depth[node] = dist\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node, dist + 1)\n\ndef min_vertices_to_cover(vertices):\n    n = len(vertices)\n    if n == 1:\n        return 1\n    \n    # Sort vertices based on depth to ensure LCA calculation works correctly\n    vertices.sort(key=lambda x: depth[x])\n    \n    # Calculate LCA for pairs of vertices\n    max_lca = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            current_lca = lca(tree, vertices[i], vertices[j])\n            max_lca = max(max_lca, current_lca)\n    \n    # Count unique vertices including the LCA\n    covered_vertices = set()\n    for vertex in vertices:\n        covered_vertices.add(vertex)\n    covered_vertices.add(max_lca)\n    \n    return len(covered_vertices)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i]) - 1\n    v = int(data[3 + 2 * i]) - 1\n    edges.append((u, v))\n\nvertices = list(map(int, data[2 * N + 1:])) - 1\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Initialize depth and parent arrays\ndepth = [-1] * N\nparent = [-1] * N\n\n# Perform DFS to fill depth and parent arrays\ndfs(0, -1, 0)\n\n# Get the minimum number of vertices to cover all K vertices\nresult = min_vertices_to_cover(vertices)\n\nprint(result)\n```", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N - 1):\n    A = int(data[2 + 2 * i]) - 1\n    B = int(data[3 + 2 * i]) - 1\n    edges.append((A, B))\n\nvertices = list(map(int, data[N + 2:N + 2 + K])) - 1\n\n# Build adjacency list\nadj_list = [[] for _ in range(N)]\nfor u, v in edges:\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\n# Function to find LCA using DFS\ndef dfs(node, parent, depth, lca_depths, path, lca_node):\n    path.append(node)\n    lca_depths[node] = len(path)\n    \n    if node in vertices:\n        path_to_vertex = path[:]\n        \n        for other in vertices:\n            if other != node:\n                path_length = lca_depths[node] - lca_depths[lca_node]\n                if lca_depths[other] > lca_depths[node]:\n                    path_length += lca_depths[other] - lca_depths[node]\n                elif lca_depths[other] < lca_depths[node]:\n                    path_length -= lca_depths[node] - lca_depths[other]\n                \n                path_length += abs(len(path_to_vertex) - len(path))\n                \n                # Update the minimum number of vertices needed\n                min_vertices_needed = min(min_vertices_needed, path_length)\n    \n    for neighbor in adj_list[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1, lca_depths, path, lca_node)\n    \n    path.pop()\n    return min_vertices_needed\n\nmin_vertices_needed = float('inf')\nlca_node = 0\ndfs(lca_node, -1, 0, [0] * N, [], lca_node)\n\nprint(min_vertices_needed)\n```"]}
{"task_id": "abc371_e", "codes": ["f", "d"], "passed": [false, false], "raw_code": ["```python\nfrom collections import defaultdict\n\n\ndef count_distinct_subsequences(N, A):\n    total_sum = 0\n\n    for i in range(N):\n        distinct_count = defaultdict(int)\n        for j in range(i, N):\n            distinct_count[A[j]] += 1\n            total_sum += len(distinct_count)\n\n    return total_sum\n\n\n# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_distinct_subsequences(N, A)\nprint(result)", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize variables\n    total_sum = 0\n    count = [0] * (N + 1)\n    distinct = 0\n    \n    for i in range(N):\n        if count[A[i]] == 0:\n            distinct += 1\n        count[A[i]] += 1\n        \n        for j in range(i, N):\n            if count[A[j]] == 1:\n                distinct -= 1\n            count[A[j]] -= 1\n            total_sum += distinct\n    \n    print(total_sum)\n\nmain()"]}
{"task_id": "abc373_g", "codes": ["d", "import sys\nfrom collections import defaultdict, deque\n\ndef dfs(node, visited, stack, adj):\n    visited[node] = True\n    \n    for neighbor in adj[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, visited, stack, adj)\n    \n    stack.appendleft(node)\n\ndef topological_sort(N, edges):\n    adj = defaultdict(list)\n    in_degree = [0] * (N + 1)\n    \n    for u, v in edges:\n        adj[u].append(v)\n        in_degree[v] += 1\n    \n    queue = deque([i for i in range(1, N + 1) if in_degree[i] == 0])\n    stack = []\n    \n    while queue:\n        node = queue.popleft()\n        stack.append(node)\n        \n        for neighbor in adj[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(stack) != N:\n        return -1\n    \n    return list(stack)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    P = []\n    Q = []\n    \n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        P.append((A, B))\n        index += 2\n    \n    for _ in range(N):\n        C = int(data[index])\n        D = int(data[index + 1])\n        Q.append((C, D))\n        index += 2\n    \n    edges = []\n    for i in range(N):\n        edges.append((i + 1, Q.index(Q[i]) + 1))\n    \n    result = topological_sort(N, edges)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef find_permutation(N, points, queries):\n    # Sort points based on x-coordinates\n    sorted_points = sorted(points, key=lambda p: p[0])\n    \n    # Create a list to store the permutation\n    permutation = [-1] * N\n    \n    # Use a set to keep track of used y-coordinates\n    used_y = set()\n    \n    # Iterate over the sorted points and assign the closest available y-coordinate\n    for i in range(N):\n        x, y = sorted_points[i]\n        min_diff = float('inf')\n        best_index = -1\n        \n        # Find the closest available y-coordinate\n        for j in range(N):\n            if queries[j][0] != x and queries[j][1] != y and (queries[j][1], queries[j][0]) not in used_y:\n                diff = abs(queries[j][1] - y)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_index = j\n        \n        if best_index == -1:\n            return -1\n        \n        permutation[i] = best_index + 1\n        used_y.add((y, queries[best_index][1]))\n    \n    return permutation\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\nqueries = [(int(data[2*(N+i)+1]), int(data[2*(N+i)+2])) for i in range(N)]\n\n# Find the permutation\nresult = find_permutation(N, points, queries)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))", "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef dfs(node, visited, stack, adj):\n    visited[node] = True\n    \n    for neighbor in adj[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, visited, stack, adj)\n    \n    stack.appendleft(node)\n\ndef topological_sort(N, edges):\n    adj = defaultdict(list)\n    in_degree = [0] * (N + 1)\n    \n    for u, v in edges:\n        adj[u].append(v)\n        in_degree[v] += 1\n    \n    queue = deque([i for i in range(1, N + 1) if in_degree[i] == 0])\n    stack = []\n    \n    while queue:\n        node = queue.popleft()\n        stack.append(node)\n        \n        for neighbor in adj[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(stack) != N:\n        return -1\n    \n    return list(stack)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    P = []\n    Q = []\n    \n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        P.append((A, B))\n        index += 2\n    \n    for _ in range(N):\n        C = int(data[index])\n        D = int(data[index + 1])\n        Q.append((C, D))\n        index += 2\n    \n    edges = []\n    for i in range(N):\n        edges.append((i + 1, Q.index(Q[i]) + 1))\n    \n    result = topological_sort(N, edges)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc370_e", "codes": ["def count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    prefix_sum = [0]\n    for num in A:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    for i in range(1, N + 1):\n        for j in range(K + 1):\n            dp[i][j] = dp[i - 1][j]\n            if prefix_sum[i] - prefix_sum[j] != K:\n                dp[i][j] += dp[j][prefix_sum[i] - prefix_sum[j]]\n                dp[i][j] %= MOD\n    \n    result = sum(dp[N]) % MOD\n    print(result)\n\n# Example usage:\n# N = int(input())\n# K = int(input())\n# A = list(map(int, input().split()))\n# count_partitions(N, K, A)", "d"], "passed": [false, false], "raw_code": ["```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    prefix_sum = [0]\n    for num in A:\n        prefix_sum.append(prefix_sum[-1] + num)\n    \n    for i in range(1, N + 1):\n        for j in range(K + 1):\n            dp[i][j] = dp[i - 1][j]\n            if prefix_sum[i] - prefix_sum[j] != K:\n                dp[i][j] += dp[j][prefix_sum[i] - prefix_sum[j]]\n                dp[i][j] %= MOD\n    \n    result = sum(dp[N]) % MOD\n    print(result)\n\n# Example usage:\n# N = int(input())\n# K = int(input())\n# A = list(map(int, input().split()))\n# count_partitions(N, K, A)\n```", "```python\ndef count_partitions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    MOD = 998244353\n    \n    # dp[i][j] := number of valid partitions of the first i elements ending at j\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(i, 0, -1):\n            prefix_sum += A[j - 1]\n            if prefix_sum == K:\n                continue\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD\n    \n    result = sum(dp[N][:N + 1]) % MOD\n    print(result)\n\ncount_partitions()"]}
{"task_id": "abc366_f", "codes": ["i", "i"], "passed": [false, false], "raw_code": ["```python\nimport sys\nfrom itertools import permutations\n\ndef max_nested_functions(N, K, functions):\n    # Precompute f_i(1) for all i\n    precomputed_values = [A * 1 + B for A, B in functions]\n    \n    # Generate all possible sequences of K distinct integers between 1 and N\n    max_value = float('-inf')\n    for seq in permutations(range(1, N + 1), K):\n        value = 1\n        for function_index in seq:\n            value = functions[function_index - 1][0] * value + functions[function_index - 1][1]\n        max_value = max(max_value, value)\n    \n    return max_value\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    functions = []\n    index = 2\n    for i in range(N):\n        functions.append((int(data[index]), int(data[index + 1])))\n        index += 2\n    \n    result = max_nested_functions(N, K, functions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "```python\nimport sys\nfrom itertools import permutations\n\ndef parse_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    coefficients = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        coefficients.append((A, B))\n        index += 2\n    \n    return N, K, coefficients\n\ndef apply_sequence(coefficients, sequence):\n    result = 1\n    for i in sequence:\n        A, B = coefficients[i - 1]\n        result = A * result + B\n    return result\n\ndef main():\n    N, K, coefficients = parse_input()\n    \n    max_value = 0\n    for seq in permutations(range(1, N + 1), K):\n        value = apply_sequence(coefficients, seq)\n        if value > max_value:\n            max_value = value\n    \n    print(max_value)"]}
{"task_id": "abc368_f", "codes": ["def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_moves = 0\n    \n    for num in A:\n        count = 0\n        for i in range(2, num):\n            if num % i == 0:\n                count += 1\n        total_moves += count\n    \n    if total_moves % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "d"], "passed": [false, false], "raw_code": ["```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_moves = 0\n    \n    for num in A:\n        count = 0\n        for i in range(2, num):\n            if num % i == 0:\n                count += 1\n        total_moves += count\n    \n    if total_moves % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Check if there is at least one even number\n    has_even = any(x % 2 == 0 for x in A)\n    \n    if has_even:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Call the function\ndetermine_winner()"]}
{"task_id": "arc182_c", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef sum_of_scores():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    MOD = 998244353\n    \n    # Precompute the number of divisors for products of numbers up to M\n    max_val = M * M * M\n    max_exp = 60  # Upper bound for the maximum exponent\n    divisors = [0] * (max_val + 1)\n    \n    for i in range(1, max_val + 1):\n        divisors[i] = divisors[i - 1]\n        if i % i == 0:\n            divisors[i] += 1\n    \n    # Dynamic programming table\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    # Fill the DP table\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            dp[i] = (dp[i] + dp[i - 1] * divisors[j]) % MOD\n    \n    print(dp[N])\n\nsum_of_scores()", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    MOD = 998244353\n    \n    # Function to get the prime factors of a number\n    def prime_factors(n):\n        i = 2\n        factors = {}\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                if i in factors:\n                    factors[i] += 1\n                else:\n                    factors[i] = 1\n        if n > 1:\n            factors[n] = 1\n        return factors\n    \n    # Get all unique prime factors up to M\n    max_prime = 0\n    for m in range(1, M + 1):\n        factors = prime_factors(m)\n        for prime in factors:\n            if prime > max_prime:\n                max_prime = prime\n    \n    # Precompute prime powers up to M\n    prime_powers = [set() for _ in range(max_prime + 1)]\n    for p in range(2, max_prime + 1):\n        power = p\n        while power <= M:\n            prime_powers[p].add(power)\n            power *= p\n    \n    # DP table initialization\n    dp = [[0] * (max_prime + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Iterate over sequence lengths\n    for n in range(1, N + 1):\n        new_dp = [[0] * (max_prime + 1) for _ in range(max_prime + 1)]\n        for mask in range(1 << (max_prime + 1)):\n            count = dp[n - 1][mask]\n            if count == 0:\n                continue\n            for p in range(1, max_prime + 1):\n                if mask & (1 << p):\n                    for power in prime_powers[p]:\n                        new_mask = mask ^ (1 << p)\n                        if new_mask not in new_dp or new_dp[new_mask][power] < count:\n                            new_dp[new_mask][power] = count\n                else:\n                    new_dp[mask][p] += count\n        dp = new_dp\n    \n    # Sum the scores\n    total_score = 0\n    for mask in range(1 << (max_prime + 1)):\n        count = dp[N][mask]\n        num_divisors = 1\n        for i in range(1, max_prime + 1):\n            if mask & (1 << i):\n                num_divisors *= i + 1\n                num_divisors %= MOD\n        total_score += count * num_divisors\n        total_score %= MOD\n    \n    print(total_score)\n\nmain()"]}
{"task_id": "abc365_e", "codes": ["def calculate_xor_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0]\n    current_xor = 0\n    for num in A:\n        current_xor ^= num\n        prefix_xor.append(current_xor)\n    \n    # Initialize result\n    total_sum = 0\n    \n    # Count occurrences of each prefix XOR\n    from collections import defaultdict\n    xor_count = defaultdict(int)\n    xor_count[0] = 1\n    \n    # Iterate through the prefix XOR array to count valid subarrays\n    for i in range(1, len(prefix_xor)):\n        for j in range(i):\n            if prefix_xor[j] != prefix_xor[i]:\n                total_sum += 1\n    \n    print(total_sum)\n\ncalculate_xor_sum()", "d"], "passed": [false, false], "raw_code": ["```python\ndef calculate_xor_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0]\n    current_xor = 0\n    for num in A:\n        current_xor ^= num\n        prefix_xor.append(current_xor)\n    \n    # Initialize result\n    total_sum = 0\n    \n    # Count occurrences of each prefix XOR\n    from collections import defaultdict\n    xor_count = defaultdict(int)\n    xor_count[0] = 1\n    \n    # Iterate through the prefix XOR array to count valid subarrays\n    for i in range(1, len(prefix_xor)):\n        for j in range(i):\n            if prefix_xor[j] != prefix_xor[i]:\n                total_sum += 1\n    \n    print(total_sum)\n\ncalculate_xor_sum()\n```", "```python\ndef xor_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    prefix = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix[i] = prefix[i - 1] ^ A[i - 1]\n    \n    total_sum = 0\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            total_sum += prefix[j] ^ prefix[i]\n    \n    print(total_sum)\n\nxor_sum()"]}
{"task_id": "abc366_g", "codes": ["import sys\nfrom collections import defaultdict\n\ndef can_assign(graph, vertex, assignment, visited):\n    if vertex in visited:\n        return assignment[vertex]\n    for neighbor in graph[vertex]:\n        if neighbor not in assignment:\n            assignment[neighbor] = 1\n        if assignment[neighbor] == assignment[vertex]:\n            return None\n        assignment[neighbor] ^= assignment[vertex]\n        if assignment[neighbor] == 0:\n            assignment[neighbor] = 1\n        if assignment[neighbor] == assignment[vertex]:\n            return None\n    return assignment[vertex]\n\ndef solve(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    assignment = {1: 1}\n    for vertex in range(2, n + 1):\n        assignment[vertex] = 1\n        if not can_assign(graph, vertex, assignment, set()):\n            return 'No'\n        for neighbor in graph[vertex]:\n            assignment[neighbor] ^= assignment[vertex]\n    result = [str(assignment[i]) for i in range(1, n + 1)]\n    return 'Yes\\n' + ' '.join(result)\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n    print(solve(n, edges))\n", "def solve_graph_xor(n, m, edges):\n    # Step 1: Create adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Initialize visited array\n    visited = [False] * (n + 1)\n    \n    # Step 3: Recursive function to assign values\n    def dfs(vertex, xor_sum):\n        if len(adj_list[vertex]) == 0:\n            return False\n        \n        for neighbor in adj_list[vertex]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                if dfs(neighbor, xor_sum ^ vertex):\n                    continue\n                else:\n                    visited[neighbor] = False\n                    return False\n        \n        return True\n    \n    # Step 4: Assign values starting from vertex 1\n    for i in range(1, n + 1):\n        if not visited[i]:\n            visited[i] = True\n            if not dfs(i, 0):\n                return \"No\"\n    \n    # If we reach here, a valid assignment exists\n    result = []\n    for i in range(1, n + 1):\n        result.append(str(i))\n    \n    return \"Yes\\n\" + \" \".join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = [(int(data[2 + 2*i]), int(data[3 + 2*i])) for i in range(m)]\n\n# Solve and print result\nprint(solve_graph_xor(n, m, edges))"], "passed": [false, false], "raw_code": ["import sys\nfrom collections import defaultdict\n\ndef can_assign(graph, vertex, assignment, visited):\n    if vertex in visited:\n        return assignment[vertex]\n    for neighbor in graph[vertex]:\n        if neighbor not in assignment:\n            assignment[neighbor] = 1\n        if assignment[neighbor] == assignment[vertex]:\n            return None\n        assignment[neighbor] ^= assignment[vertex]\n        if assignment[neighbor] == 0:\n            assignment[neighbor] = 1\n        if assignment[neighbor] == assignment[vertex]:\n            return None\n    return assignment[vertex]\n\ndef solve(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    assignment = {1: 1}\n    for vertex in range(2, n + 1):\n        assignment[vertex] = 1\n        if not can_assign(graph, vertex, assignment, set()):\n            return 'No'\n        for neighbor in graph[vertex]:\n            assignment[neighbor] ^= assignment[vertex]\n    result = [str(assignment[i]) for i in range(1, n + 1)]\n    return 'Yes\\n' + ' '.join(result)\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n    print(solve(n, edges))\n", "```python\ndef solve_graph_xor(n, m, edges):\n    # Step 1: Create adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Initialize visited array\n    visited = [False] * (n + 1)\n    \n    # Step 3: Recursive function to assign values\n    def dfs(vertex, xor_sum):\n        if len(adj_list[vertex]) == 0:\n            return False\n        \n        for neighbor in adj_list[vertex]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                if dfs(neighbor, xor_sum ^ vertex):\n                    continue\n                else:\n                    visited[neighbor] = False\n                    return False\n        \n        return True\n    \n    # Step 4: Assign values starting from vertex 1\n    for i in range(1, n + 1):\n        if not visited[i]:\n            visited[i] = True\n            if not dfs(i, 0):\n                return \"No\"\n    \n    # If we reach here, a valid assignment exists\n    result = []\n    for i in range(1, n + 1):\n        result.append(str(i))\n    \n    return \"Yes\\n\" + \" \".join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = [(int(data[2 + 2*i]), int(data[3 + 2*i])) for i in range(m)]\n\n# Solve and print result\nprint(solve_graph_xor(n, m, edges))\n```"]}
{"task_id": "abc368_g", "codes": ["d", "f"], "passed": [false, false], "raw_code": ["```python\ndef build_tree(arr, tree, node, start, end):\n    if start == end:\n        tree[node] = (arr[start], 0)\n    else:\n        mid = (start + end) // 2\n        build_tree(arr, tree, 2 * node, start, mid)\n        build_tree(arr, tree, 2 * node + 1, mid + 1, end)\n        tree[node] = (max(tree[2 * node][0], tree[2 * node + 1][0]), max(tree[2 * node][1], tree[2 * node + 1][1]))\n\ndef update_tree(tree, node, start, end, idx, val, operation):\n    if start == end:\n        if operation == 'A':\n            tree[node] = (val, 0)\n        elif operation == 'B':\n            tree[node] = (0, val)\n    else:\n        mid = (start + end) // 2\n        if start <= idx <= mid:\n            update_tree(tree, 2 * node, start, mid, idx, val, operation)\n        else:\n            update_tree(tree, 2 * node + 1, mid + 1, end, idx, val, operation)\n        tree[node] = (max(tree[2 * node][0], tree[2 * node + 1][0]), max(tree[2 * node][1], tree[2 * node + 1][1]))\n\ndef query_tree(tree, node, start, end, l, r, operation):\n    if r < start or end < l:\n        return (0, 0)\n    elif l <= start and end <= r:\n        if operation == 'A':\n            return tree[node][0], 0\n        elif operation == 'B':\n            return 0, tree[node][1]\n    mid = (start + end) // 2\n    left = query_tree(tree, 2 * node, start, mid, l, r, operation)\n    right = query_tree(tree, 2 * node + 1, mid + 1, end, l, r, operation)\n    return (max(left[0], right[0]), max(left[1], right[1]))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    queries = data[2*N+2:]\n    \n    tree_A = [0] * (4 * N)\n    tree_B = [0] * (4 * N)\n    \n    build_tree(A, tree_A,", "```python\nfrom collections import deque\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nA = list(map(int, data[1:N+1]))\nB = list(map(int, data[N+1:2*N+1]))\nQ = int(data[2*N+1])\n\n# Deques to keep track of indices with potential contributions\ndeq_A = deque(range(N))\ndeq_B = deque(range(N))\n\ndef update(A, deq, idx, val):\n    deq.remove(idx)\n    if val > 1:\n        deq.append(idx)\n\ndef query(deq_A, deq_B, l, r):\n    v = 0\n    max_v = 0\n    for i in range(l-1, r):\n        if deq_A and deq_B:\n            if A[deq_A[0]] >= B[deq_B[0]]:\n                v += A[deq_A.popleft()]\n            else:\n                v *= B[deq_B.popleft()]\n        elif deq_A:\n            v += A[deq_A.popleft()]\n        elif deq_B:\n            v *= B[deq_B.popleft()]\n    return v\n\nfor i in range(Q):\n    query_type = int(data[2*N+2+i*3])\n    if query_type == 1:\n        idx = int(data[2*N+3+i*3]) - 1\n        val = int(data[2*N+4+i*3])\n        update(A, deq_A, idx, val)\n    elif query_type == 2:\n        idx = int(data[2*N+3+i*3]) - 1\n        val = int(data[2*N+4+i*3])\n        update(B, deq_B, idx, val)\n    elif query_type == 3:\n        l = int(data[2*N+3+i*3])\n        r = int(data[2*N+4+i*3])\n        print(query(deq_A, deq_B, l, r))"]}
{"task_id": "abc368_e", "codes": ["def min_delays(N, M, X1, trains):\n    # Sort trains by their departure and arrival times\n    trains.sort(key=lambda x: (x[1], x[2]))\n    delays = [0] * M\n    current_delay = X1\n    for i in range(M):\n        for j in range(i):\n            if trains[j][1] == trains[i][0] and trains[j][2] <= trains[i][1]:\n                if trains[i][1] + current_delay > trains[j][2] + delays[j]:\n                    current_delay = trains[j][2] + delays[j] - trains[i][1]\n        delays[i] = current_delay\n        current_delay += X1\n    return delays\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    X1 = int(data[2])\n    trains = [(int(data[3 + 5 * i]), int(data[4 + 5 * i]), int(data[5 + 5 * i]), int(data[6 + 5 * i])) for i in range(M)]\n    result = min_delays(N, M, X1, trains)\n    print(' '.join(map(str, result)))", "d"], "passed": [false, false], "raw_code": ["def min_delays(N, M, X1, trains):\n    # Sort trains by their departure and arrival times\n    trains.sort(key=lambda x: (x[1], x[2]))\n    delays = [0] * M\n    current_delay = X1\n    for i in range(M):\n        for j in range(i):\n            if trains[j][1] == trains[i][0] and trains[j][2] <= trains[i][1]:\n                if trains[i][1] + current_delay > trains[j][2] + delays[j]:\n                    current_delay = trains[j][2] + delays[j] - trains[i][1]\n        delays[i] = current_delay\n        current_delay += X1\n    return delays\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    X1 = int(data[2])\n    trains = [(int(data[3 + 5 * i]), int(data[4 + 5 * i]), int(data[5 + 5 * i]), int(data[6 + 5 * i])) for i in range(M)]\n    result = min_delays(N, M, X1, trains)\n    print(' '.join(map(str, result)))", "```python\ndef calculate_delays(N, M, X1, A, B, S, T):\n    # Initialize delays to zero\n    X = [0] * M\n    \n    # Apply initial delay X1 to the first train\n    X[0] = X1\n    \n    # Sort trains by arrival time\n    trains = sorted(zip(A, B, S, T))\n    \n    # Ensure transfer conditions are met\n    for i in range(1, M):\n        for j in range(i):\n            if trains[j][1] == trains[i][0] and trains[j][3] <= trains[i][2]:\n                X[i] = max(X[i], trains[j][2] - trains[i][3])\n    \n    # Adjust delays to ensure all conditions are met\n    for i in range(M):\n        for j in range(i):\n            if trains[j][1] == trains[i][0] and trains[j][3] <= trains[i][2]:\n                X[j] = max(X[j], trains[i][2] - trains[j][3])\n    \n    return X[1:]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\n\nA = []\nB = []\nS = []\nT = []\n\nindex = 3\nfor _ in range(M):\n    A.append(int(data[index]))\n    B.append(int(data[index + 1]))\n    S.append(int(data[index + 2]))\n    T.append(int(data[index + 3]))\n    index += 4\n\n# Calculate and print delays\ndelays = calculate_delays(N, M, X1, A, B, S, T)\nprint(' '.join(map(str, delays)))"]}
{"task_id": "abc373_f", "codes": ["def max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        items.append((w, v))\n    \n    dp = [-float('inf')] * (W + 1)\n    dp[0] = 0\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            k = min(j // w, 10**10)\n            dp[j] = max(dp[j], dp[j - k * w] + k * v - k ** 2)\n    \n    print(max(dp[:W + 1]))\n\nmax_happiness()", "d"], "passed": [false, false], "raw_code": ["```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        items.append((w, v))\n    \n    dp = [-float('inf')] * (W + 1)\n    dp[0] = 0\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            k = min(j // w, 10**10)\n            dp[j] = max(dp[j], dp[j - k * w] + k * v - k ** 2)\n    \n    print(max(dp[:W + 1]))\n\nmax_happiness()\n```", "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            dp[j] = max(dp[j], dp[j - w] + v - (j // w) ** 2)\n    \n    print(dp[W])\n\nmax_happiness()"]}
{"task_id": "abc370_f", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Calculate prefix sums\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n\n    # Initialize DP table\n    dp = [[float('inf')] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(1, min(i, K) + 1):\n            for k in range(i):\n                dp[i][j] = min(dp[i][j], max(dp[k][j - 1], prefix_sum[i] - prefix_sum[k]))\n\n    # Find the maximum possible minimum weight\n    max_min_weight = float('-inf')\n    for j in range(1, K + 1):\n        max_min_weight = max(max_min_weight, dp[N][j])\n\n    # Count the number of cut lines that are never cut\n    count_cut_lines = 0\n    for i in range(1, N + 1):\n        if A[i - 1] > max_min_weight:\n            count_cut_lines += 1\n\n    print(max_min_weight, count_cut_lines)\n\nif __name__ == '__main__':\n    main()", "def main():\n import sys\n input = sys.stdin.read\n data = input().split()\n N = int(data[0])\n K = int(data[1])\n A = list(map(int, data[2:]))\n\n def can_divide(min_weight):\n total = 0\n cut_count = 0\n person_cut_count = 0\n for weight in A:\n total += weight\n if total >= min_weight:\n total = 0\n cut_count += 1\n person_cut_count = 0\n else:\n person_cut_count += 1\n if person_cut_count == K:\n return False\n return True\n\n left = max(A)\n right = sum(A)\n ans = 0\n never_cut_count = 0\n while left <= right:\n mid = (left + right) // 2\n if can_divide(mid):\n ans = mid\n left = mid + 1\n never_cut_count += 1\n else:\n right = mid - 1\n\n print(ans, never_cut_count)\n\nif __name__ == '__main__':\n main()\n"], "passed": [false, false], "raw_code": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    # Calculate prefix sums\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + A[i]\n\n    # Initialize DP table\n    dp = [[float('inf')] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n\n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(1, min(i, K) + 1):\n            for k in range(i):\n                dp[i][j] = min(dp[i][j], max(dp[k][j - 1], prefix_sum[i] - prefix_sum[k]))\n\n    # Find the maximum possible minimum weight\n    max_min_weight = float('-inf')\n    for j in range(1, K + 1):\n        max_min_weight = max(max_min_weight, dp[N][j])\n\n    # Count the number of cut lines that are never cut\n    count_cut_lines = 0\n    for i in range(1, N + 1):\n        if A[i - 1] > max_min_weight:\n            count_cut_lines += 1\n\n    print(max_min_weight, count_cut_lines)\n\nif __name__ == '__main__':\n    main()", "def main():\n import sys\n input = sys.stdin.read\n data = input().split()\n N = int(data[0])\n K = int(data[1])\n A = list(map(int, data[2:]))\n\n def can_divide(min_weight):\n total = 0\n cut_count = 0\n person_cut_count = 0\n for weight in A:\n total += weight\n if total >= min_weight:\n total = 0\n cut_count += 1\n person_cut_count = 0\n else:\n person_cut_count += 1\n if person_cut_count == K:\n return False\n return True\n\n left = max(A)\n right = sum(A)\n ans = 0\n never_cut_count = 0\n while left <= right:\n mid = (left + right) // 2\n if can_divide(mid):\n ans = mid\n left = mid + 1\n never_cut_count += 1\n else:\n right = mid - 1\n\n print(ans, never_cut_count)\n\nif __name__ == '__main__':\n main()\n"]}
{"task_id": "abc371_f", "codes": ["d", "def min_movements():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    X = list(map(int, data[1:N+1]))\n    Q = int(data[N+1])\n    tasks = [(int(data[N+2 + 2*i]), int(data[N+3 + 2*i])) for i in range(Q)]\n    total_moves = 0\n    for T, G in tasks:\n        pos = X[T-1]\n        moves = abs(pos - G)\n        total_moves += moves\n    print(total_moves)\nmin_movements()"], "passed": [false, false], "raw_code": ["```python\ndef min_movements(N, X, Q, tasks):\n    from sortedcontainers import SortedList\n    \n    # Sort the initial positions\n    X = SortedList(X)\n    \n    # Initialize a list to keep track of movements for each position\n    movements = [0] * (max(X[-1], max(G)) + 1)\n    \n    # Process each task\n    total_moves = 0\n    for T, G in tasks:\n        T -= 1  # Convert to zero-indexed\n        pos = X[T]\n        \n        # Calculate the number of movements needed to reach the target position\n        moves_to_left = pos - G if pos > G else 0\n        moves_to_right = G - pos if G > pos else 0\n        \n        # Update the total movements\n        total_moves += moves_to_left + moves_to_right\n        \n        # Update the movements for the current position\n        if pos == G:\n            continue\n        elif pos < G:\n            for p in X.irange(pos + 1, G):\n                movements[p] += 1\n        else:\n            for p in X.irange(G, pos - 1, reverse=True):\n                movements[p] += 1\n    \n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\ntasks = [(int(data[N+2+2*i])-1, int(data[N+3+2*i])) for i in range(Q)]\n\n# Print the result\nprint(min_movements(N, X, Q, tasks))", "def min_movements():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    X = list(map(int, data[1:N+1]))\n    Q = int(data[N+1])\n    tasks = [(int(data[N+2 + 2*i]), int(data[N+3 + 2*i])) for i in range(Q)]\n    total_moves = 0\n    for T, G in tasks:\n        pos = X[T-1]\n        moves = abs(pos - G)\n        total_moves += moves\n    print(total_moves)\nmin_movements()"]}
{"task_id": "abc367_g", "codes": ["d", "def sum_of_scores(N, M, K, A):\n    MOD = 998244353\n    \n    total_sum = 0\n    total_count = 1 << N\n    \n    for mask in range(1, total_count):\n        xor_val = 0\n        length = 0\n        for i in range(N):\n            if mask & (1 << i):\n                xor_val ^= A[i]\n                length += 1\n        \n        if length % M == 0:\n            total_sum = (total_sum + pow(xor_val, K, MOD)) % MOD\n    \n    return total_sum\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    result = sum_of_scores(N, M, K, A)\n    print(result)"], "passed": [false, false], "raw_code": ["```python\ndef calculate_score(N, M, K, A):\n    MOD = 998244353\n    \n    # Calculate the total number of subsequences\n    total_subsequences = 2**N - 1\n    \n    # Initialize DP array to store the count of subsequences with specific properties\n    dp = [0] * 20\n    dp[0] = total_subsequences\n    \n    # Iterate through each bit position\n    for i in range(20):\n        new_dp = [0] * 20\n        for j in range(20):\n            new_dp[j] += dp[j]\n            new_dp[j] %= MOD\n        \n        # Update the DP array based on the current bit\n        for j in range(20):\n            if (A[i] >> j) & 1:\n                new_dp[j] -= dp[j]\n                new_dp[j] += dp[(j + 1) % 20]\n                new_dp[j] %= MOD\n        \n        dp = new_dp\n    \n    # Calculate the final sum of scores\n    result = 0\n    for i in range(20):\n        if dp[i] % M == 0:\n            result += pow(dp[i], K, MOD)\n            result %= MOD\n    \n    return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin", "```python\ndef sum_of_scores(N, M, K, A):\n    MOD = 998244353\n    \n    total_sum = 0\n    total_count = 1 << N\n    \n    for mask in range(1, total_count):\n        xor_val = 0\n        length = 0\n        for i in range(N):\n            if mask & (1 << i):\n                xor_val ^= A[i]\n                length += 1\n        \n        if length % M == 0:\n            total_sum = (total_sum + pow(xor_val, K, MOD)) % MOD\n    \n    return total_sum\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    result = sum_of_scores(N, M, K, A)\n    print(result)\n```"]}
{"task_id": "arc183_b", "codes": ["d", "i"], "passed": [false, false], "raw_code": ["```python\ndef can_transform(A, B, K):\n    # Check if frequency distributions are the same\n    if sorted(A) != sorted(B):\n        return \"No\"\n    \n    # Try to transform A into B by sorting elements within each window of size 2K+1\n    n = len(A)\n    for i in range(n):\n        if A[i] != B[i]:\n            found = False\n            for j in range(max(0, i-K), min(n, i+K+1)):\n                if A[j] == B[i]:\n                    A[i], A[j] = A[j], A[i]\n                    found = True\n                    break\n            if not found:\n                return \"No\"\n    return \"Yes\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 * N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nsolve()", "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_transform_to_B(T, test_cases):\n    def build_components(N, K, seq):\n        components = defaultdict(list)\n        for i in range(N):\n            components[seq[i]].append(i)\n        component_id = 0\n        visited = [0] * N\n        component_map = [-1] * N\n        for i in range(N):\n            if visited[i] == 0:\n                queue = deque([i])\n                component_map[i] = component_id\n                while queue:\n                    current = queue.popleft()\n                    visited[current] = 1\n                    for neighbor in range(max(0, current - K), min(N, current + K + 1)):\n                        if visited[neighbor] == 0 and seq[neighbor] == seq[current]:\n                            queue.append(neighbor)\n                            component_map[neighbor] = component_id\n                component_id += 1\n        return component_map\n    \n    results = []\n    for N, K, A, B in test_cases:\n        comp_A = build_components(N, K, A)\n        comp_B = build_components(N, K, B)\n        sorted_comp_A = sorted(comp_A)\n        sorted_comp_B = sorted(comp_B)\n        if sorted_comp_A == sorted_comp_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    A = list(map(int, data[index + 2:index + 2 + N]))\n    B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n    test_cases.append((N, K, A, B))\n    index += 2 * N\n\n# Solve\nresults = can_transform_to_B(T, test_cases)\n\n# Print results\nfor result in results:\n    print(result)"]}
{"task_id": "abc369_e", "codes": ["import sys\nfrom collections import defaultdict, deque\nimport math\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nbridges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\nt = int(data[index + 2])\nbridges.append((u, v, t))\nindex += 3\nq = int(data[index])\nqueries = [[] for _ in range(q)]\nindex += 1\nfor i in range(q):\n    k = int(data[index])\n    query_bridges = [int(data[index + j]) - 1 for j in range(k)]\n    queries[i] = query_bridges\n    index += k\n\ndef bfs(start, end, required_bridges):\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        current, cost = queue.popleft()\n        if (current, frozenset(required_bridges)) in visited:\n            continue\n        visited.add((current, frozenset(required_bridges)))\n        if current == end:\n            return cost\n        for u, v, t in bridges:\n            if u == current or v == current:\n                new_required_bridges = required_bridges.copy()\n                if (u, v) in new_required_bridges:\n                    new_required_bridges.remove((u, v))\n                elif (v, u) in new_required_bridges:\n                    new_required_bridges.remove((v, u))\n                if not new_required_bridges:\n                    queue.append((v if u == current else u, cost + t))\n    return math.inf\n\nresults = []\nfor query in queries:\n    result = bfs(0, n - 1, query)\n    results.append(result)\n\nfor result in results:\n    print(result)", "import heapq\n\ndef min_time_to_travel(N"], "passed": [false, false], "raw_code": ["import sys\nfrom collections import defaultdict, deque\nimport math\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nbridges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\nt = int(data[index + 2])\nbridges.append((u, v, t))\nindex += 3\nq = int(data[index])\nqueries = [[] for _ in range(q)]\nindex += 1\nfor i in range(q):\n    k = int(data[index])\n    query_bridges = [int(data[index + j]) - 1 for j in range(k)]\n    queries[i] = query_bridges\n    index += k\n\ndef bfs(start, end, required_bridges):\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        current, cost = queue.popleft()\n        if (current, frozenset(required_bridges)) in visited:\n            continue\n        visited.add((current, frozenset(required_bridges)))\n        if current == end:\n            return cost\n        for u, v, t in bridges:\n            if u == current or v == current:\n                new_required_bridges = required_bridges.copy()\n                if (u, v) in new_required_bridges:\n                    new_required_bridges.remove((u, v))\n                elif (v, u) in new_required_bridges:\n                    new_required_bridges.remove((v, u))\n                if not new_required_bridges:\n                    queue.append((v if u == current else u, cost + t))\n    return math.inf\n\nresults = []\nfor query in queries:\n    result = bfs(0, n - 1, query)\n    results.append(result)\n\nfor result in results:\n    print(result)", "import heapq\n\ndef min_time_to_travel(N"]}
{"task_id": "abc373_e", "codes": ["def min_additional_votes():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    # Calculate remaining votes\n    remaining_votes = K - sum(A)\n    \n    # Initialize result array\n    C = [0] * N\n    \n    # Sort candidates by their votes\n    sorted_indices = sorted(range(N), key=lambda x: A[x])\n    \n    # Determine the minimum additional votes needed for each candidate\n    for i in range(N):\n        candidate_index = sorted_indices[i]\n        max_other_votes = A[candidate_index] + remaining_votes\n        \n        # Find the number of candidates with more votes than the current candidate\n        count_more_voted = 0\n        for j in range(i + 1, N):\n            if A[sorted_indices[j]] > A[candidate_index]:\n                count_more_voted += 1\n        \n        # Check if the current candidate can win\n        if count_more_voted < M:\n            C[candidate_index] = 0\n        elif max_other_votes < 2 * A[candidate_index]:\n            C[candidate_index] = 1\n        else:\n            C[candidate_index] = -1\n    \n    # Print the results\n    print(' '.join(map(str, C)))\n\nmin_additional_votes()", "import heapq\n\ndef min_additional_votes(N, M, K, A):\n    # Calculate the current total votes\n    current_total_votes = sum(A)\n    \n    # Remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Convert A to a max heap by negating the values\n    A = [-x for x in A]\n    heapq.heapify(A)\n    \n    # List to store the result\n    results = []\n    \n    for _ in range(N):\n        # Pop the largest element (most votes)\n        max_votes = -heapq.heappop(A)\n        \n        # Check if the candidate can secure their victory\n        if M == 1 or max_votes > remaining_votes // (M - 1):\n            results.append(0)\n        else:\n            # Calculate the minimum additional votes needed\n            additional_votes_needed = (remaining_votes // (M - 1)) - max_votes + 1\n            if additional_votes_needed <= remaining_votes:\n                results.append(additional_votes_needed)\n            else:\n                results.append(-1)\n    \n    return ' '.join(map(str, results))\n\n# Call the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    result = min_additional_votes(N, M, K, A)\n    print(result)"], "passed": [false, false], "raw_code": ["```python\ndef min_additional_votes():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    # Calculate remaining votes\n    remaining_votes = K - sum(A)\n    \n    # Initialize result array\n    C = [0] * N\n    \n    # Sort candidates by their votes\n    sorted_indices = sorted(range(N), key=lambda x: A[x])\n    \n    # Determine the minimum additional votes needed for each candidate\n    for i in range(N):\n        candidate_index = sorted_indices[i]\n        max_other_votes = A[candidate_index] + remaining_votes\n        \n        # Find the number of candidates with more votes than the current candidate\n        count_more_voted = 0\n        for j in range(i + 1, N):\n            if A[sorted_indices[j]] > A[candidate_index]:\n                count_more_voted += 1\n        \n        # Check if the current candidate can win\n        if count_more_voted < M:\n            C[candidate_index] = 0\n        elif max_other_votes < 2 * A[candidate_index]:\n            C[candidate_index] = 1\n        else:\n            C[candidate_index] = -1\n    \n    # Print the results\n    print(' '.join(map(str, C)))\n\nmin_additional_votes()\n```", "```python\nimport heapq\n\ndef min_additional_votes(N, M, K, A):\n    # Calculate the current total votes\n    current_total_votes = sum(A)\n    \n    # Remaining votes\n    remaining_votes = K - current_total_votes\n    \n    # Convert A to a max heap by negating the values\n    A = [-x for x in A]\n    heapq.heapify(A)\n    \n    # List to store the result\n    results = []\n    \n    for _ in range(N):\n        # Pop the largest element (most votes)\n        max_votes = -heapq.heappop(A)\n        \n        # Check if the candidate can secure their victory\n        if M == 1 or max_votes > remaining_votes // (M - 1):\n            results.append(0)\n        else:\n            # Calculate the minimum additional votes needed\n            additional_votes_needed = (remaining_votes // (M - 1)) - max_votes + 1\n            if additional_votes_needed <= remaining_votes:\n                results.append(additional_votes_needed)\n            else:\n                results.append(-1)\n    \n    return ' '.join(map(str, results))\n\n# Call the function\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    result = min_additional_votes(N, M, K, A)\n    print(result)\n```"]}
{"task_id": "abc367_f", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = sorted(A[l_i:r_i + 1])\n        subseq_B = sorted(B[L_i:R_i + 1])\n        \n        if subseq_A == subseq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def check_subarray_rearrangement():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    Q = int(data[1])\n\n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:2*N+2]))\n\n    queries = []\n    index = 2*N+2\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        queries.append((l_i, r_i, L_i, R_i))\n        index += 4\n\n    def can_rearrange(l_i, r_i, L_i, R_i):\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        for i in range(l_i, r_i + 1):\n            count_A[A[i]] += 1\n        for i in range(L_i, R_i + 1):\n            count_B[B[i]] += 1\n        return count_A == count_B\n\n    results = [\"Yes\" if can_rearrange(l_i, r_i, L_i, R_i) else \"No\" for l_i, r_i, L_i, R_i in queries]\n\n    for result in results:\n        print(result)\n\ncheck_subarray_rearrangement()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = sorted(A[l_i:r_i + 1])\n        subseq_B = sorted(B[L_i:R_i + 1])\n        \n        if subseq_A == subseq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "def check_subarray_rearrangement():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    Q = int(data[1])\n\n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:2*N+2]))\n\n    queries = []\n    index = 2*N+2\n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        queries.append((l_i, r_i, L_i, R_i))\n        index += 4\n\n    def can_rearrange(l_i, r_i, L_i, R_i):\n        count_A = [0] * (N + 1)\n        count_B = [0] * (N + 1)\n        for i in range(l_i, r_i + 1):\n            count_A[A[i]] += 1\n        for i in range(L_i, R_i + 1):\n            count_B[B[i]] += 1\n        return count_A == count_B\n\n    results = [\"Yes\" if can_rearrange(l_i, r_i, L_i, R_i) else \"No\" for l_i, r_i, L_i, R_i in queries]\n\n    for result in results:\n        print(result)\n\ncheck_subarray_rearrangement()"]}
{"task_id": "arc181_d", "codes": ["def count_inversions(P):\n    n = len(P)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if P[i] > P[j]:\n                inversions += 1\n    return inversions\n\ndef process_operations(N, P, M, A):\n    results = []\n    for k in A:\n        for i in range(1, k):\n            if P[i] > P[i + 1]:\n                P[i], P[i + 1] = P[i + 1], P[i]\n        results.append(count_inversions(P))\n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N + 1]))\nM = int(data[N + 1])\nA = list(map(int, data[N + 2:N + 2 + M]))\n\n# Processing operations and getting results\nresults = process_operations(N, P, M, A)\n\n# Printing results\nfor result in results:\n    print(result)", "import sys\nfrom bisect import insort_right\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index, value):\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def query(self, index):\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    fenwick_tree = FenwickTree(N)\n    inversion_count = 0\n    results = []\n\n    for a in A:\n        # Find the current position of 'a' in the permutation\n        pos = P.index(a)\n        # Calculate the number of inversions involving 'a'\n        inversions = pos - fenwick_tree.query(pos)\n        inversion_count += inversions\n        # Update the Fenwick Tree with the new position of 'a'\n        fenwick_tree.update(pos, 1)\n        # Move 'a' to the end of the permutation\n        P.pop(pos)\n        P.append(a)\n        results.append(inversion_count)\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef count_inversions(P):\n    n = len(P)\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if P[i] > P[j]:\n                inversions += 1\n    return inversions\n\ndef process_operations(N, P, M, A):\n    results = []\n    for k in A:\n        for i in range(1, k):\n            if P[i] > P[i + 1]:\n                P[i], P[i + 1] = P[i + 1], P[i]\n        results.append(count_inversions(P))\n    return results\n\n# Reading input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N + 1]))\nM = int(data[N + 1])\nA = list(map(int, data[N + 2:N + 2 + M]))\n\n# Processing operations and getting results\nresults = process_operations(N, P, M, A)\n\n# Printing results\nfor result in results:\n    print(result)\n```", "import sys\nfrom bisect import insort_right\n\nclass FenwickTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index, value):\n        while index <= self.size:\n            self.tree[index] += value\n            index += index & -index\n\n    def query(self, index):\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    fenwick_tree = FenwickTree(N)\n    inversion_count = 0\n    results = []\n\n    for a in A:\n        # Find the current position of 'a' in the permutation\n        pos = P.index(a)\n        # Calculate the number of inversions involving 'a'\n        inversions = pos - fenwick_tree.query(pos)\n        inversion_count += inversions\n        # Update the Fenwick Tree with the new position of 'a'\n        fenwick_tree.update(pos, 1)\n        # Move 'a' to the end of the permutation\n        P.pop(pos)\n        P.append(a)\n        results.append(inversion_count)\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "arc182_e", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Compute the minimum values for each A_i modulo M\n    min_values = [float('inf')] * M\n    for A_i in A:\n        for k in range(M):\n            min_values[k] = min(min_values[k], (C * k + A_i) % M)\n    \n    # Sum the minimum values for each k from 0 to K-1\n    result = 0\n    for k in range(K):\n        result += min_values[k % M]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "def solve(N, M, C, K, A):\n    # Dictionary to count the frequency of each remainder\n    frequency = [0] * M\n    \n    # Initialize with the first value of A_i for each possible remainder\n    for i in range(N):\n        frequency[(C * 0 + A[i]) % M] += 1\n    \n    # Iterate through the possible values of k and update the frequency\n    for k in range(1, K):\n        for i in range(N):\n            a_i = A[i]\n            old_remainder = (C * (k - 1) + a_i) % M\n            new_remainder = (C * k + a_i) % M\n            frequency[new_remainder] += frequency[old_remainder]\n            frequency[old_remainder] = 0\n    \n    # Calculate the result\n    result = sum(r * freq for r, freq in enumerate(frequency))\n    print(result)\n\n# Call the function with stdin input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nC = int(data[2])\nK = int(data[3])\nA = list(map(int, data[4:]))\nsolve(N, M, C, K, A)"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Compute the minimum values for each A_i modulo M\n    min_values = [float('inf')] * M\n    for A_i in A:\n        for k in range(M):\n            min_values[k] = min(min_values[k], (C * k + A_i) % M)\n    \n    # Sum the minimum values for each k from 0 to K-1\n    result = 0\n    for k in range(K):\n        result += min_values[k % M]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef solve(N, M, C, K, A):\n    # Dictionary to count the frequency of each remainder\n    frequency = [0] * M\n    \n    # Initialize with the first value of A_i for each possible remainder\n    for i in range(N):\n        frequency[(C * 0 + A[i]) % M] += 1\n    \n    # Iterate through the possible values of k and update the frequency\n    for k in range(1, K):\n        for i in range(N):\n            a_i = A[i]\n            old_remainder = (C * (k - 1) + a_i) % M\n            new_remainder = (C * k + a_i) % M\n            frequency[new_remainder] += frequency[old_remainder]\n            frequency[old_remainder] = 0\n    \n    # Calculate the result\n    result = sum(r * freq for r, freq in enumerate(frequency))\n    print(result)\n\n# Call the function with stdin input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nC = int(data[2])\nK = int(data[3])\nA = list(map(int, data[4:]))\nsolve(N, M, C, K, A)\n```"]}
{"task_id": "abc372_g", "codes": ["def count_valid_pairs(A, B, C):\n    N = len(A)\n    max_y = 10**9\n    count = 0\n    \n    for x in range(1, max_y + 1):\n        valid = True\n        for i in range(N):\n            if A[i] * x + B[i] * max_y >= C[i]:\n                valid = False\n                break\n        if valid:\n            count += 1\n            \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index]) for _ in range(N)]\n        index += N\n        B = [int(data[index]) for _ in range(N)]\n        index += N\n        C = [int(data[index]) for _ in range(N)]\n        index += N\n        \n        result = count_valid_pairs(A, B, C)\n        results.append(result)\n        \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "i"], "passed": [false, false], "raw_code": ["```python\ndef count_valid_pairs(A, B, C):\n    N = len(A)\n    max_y = 10**9\n    count = 0\n    \n    for x in range(1, max_y + 1):\n        valid = True\n        for i in range(N):\n            if A[i] * x + B[i] * max_y >= C[i]:\n                valid = False\n                break\n        if valid:\n            count += 1\n            \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = [int(data[index]) for _ in range(N)]\n        index += N\n        B = [int(data[index]) for _ in range(N)]\n        index += N\n        C = [int(data[index]) for _ in range(N)]\n        index += N\n        \n        result = count_valid_pairs(A, B, C)\n        results.append(result)\n        \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef count_valid_pairs(A, B, C):\n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        max_x = 0\n        \n        for i in range(N):\n            Ai = int(data[index])\n            Bi = int(data[index + 1])\n            Ci = int(data[index + 2])\n            index += 3\n            \n            # Binary search to find the maximum x\n            left, right = 1, Ci // Ai\n            while left <= right:\n                mid = (left + right) // 2\n                if Ai * mid + Bi * (Ci - Ai * mid) < Ci:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            max_x = max(max_x, right)\n        \n        # Count the number of valid pairs (x, y)\n        result = 0\n        for x in range(1, max_x + 1):\n            y_max = (Ci - Ai * x) // Bi\n            if y_max > 0:\n                result += y_max\n        results.append(result)\n    \n    return results\n\n# Read input data\nresults = count_valid_pairs([], [], [])\n\n# Print results\nfor result in results:\n    print(result)"]}
{"task_id": "arc183_d", "codes": ["d", "def max_score_operations(N, edges):\\n    from collections import defaultdict, deque\\n\\n    # Build the adjacency list\\n    adj_list = defaultdict(list)\\n    for a, b in edges:\\n        adj_list[a].append(b)\\n        adj_list[b].append(a)\\n\\n    # Find all the leaf nodes\\n    leaves = deque([i for i in range(1, N+1) if len(adj_list[i]) == 1])\\n\\n    # Perform the operations\\n    operations = []\\n    while len(leaves) >= 2:\\n        leaf1 = leaves.popleft()\\n        leaf2 = leaves.popleft()\\n\\n        # Find the corresponding vertex in the matching\\n        for v in adj_list[leaf1]:\\n            if v in adj_list[leaf2]:\\n                operations.append((leaf1, v))\\n                # Remove the edge from the adjacency list\\n                adj_list[leaf1].remove(v)\\n                adj_list[v].remove(leaf1)\\n                break\\n\\n    return operations\\n\\n# Read input\\nimport sys\\ninput = sys.stdin.read\\ndata = input().split()\\nN = int(data[0])\\nedges = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N-1)]\\n\\n# Find the operations that maximize the total score\\noperations = max_score_operations(N, edges)\\n\\n# Print the operations\\nfor op in operations:\\n    print(op[0], op[1])\\n"], "passed": [false, false], "raw_code": ["```python\ndef find_farthest_leaves(leaves):\n    n = len(leaves)\n    if n <= 2:\n        return leaves[0], leaves[-1]\n    \n    # Find the two farthest leaves\n    max_distance = 0\n    farthest_pair = (leaves[0], leaves[-1])\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(leaves[i] - leaves[j])\n            if distance > max_distance:\n                max_distance = distance\n                farthest_pair = (leaves[i], leaves[j])\n    \n    return farthest_pair\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        A = int(data[index]) - 1\n        B = int(data[index + 1]) - 1\n        edges.append((A, B))\n        index += 2\n    \n    # Initialize leaves\n    leaves = [i for i in range(N)]\n    \n    scores = []\n    while len(leaves) > 1:\n        A, B = find_farthest_leaves(leaves)\n        scores.append((A + 1, B + 1))\n        leaves.remove(A)\n        leaves.remove(B)\n    \n    for score in scores:\n        print(score[0], score[1])\n\n# Call the function to execute\nsolve()", "def max_score_operations(N, edges):\\n    from collections import defaultdict, deque\\n\\n    # Build the adjacency list\\n    adj_list = defaultdict(list)\\n    for a, b in edges:\\n        adj_list[a].append(b)\\n        adj_list[b].append(a)\\n\\n    # Find all the leaf nodes\\n    leaves = deque([i for i in range(1, N+1) if len(adj_list[i]) == 1])\\n\\n    # Perform the operations\\n    operations = []\\n    while len(leaves) >= 2:\\n        leaf1 = leaves.popleft()\\n        leaf2 = leaves.popleft()\\n\\n        # Find the corresponding vertex in the matching\\n        for v in adj_list[leaf1]:\\n            if v in adj_list[leaf2]:\\n                operations.append((leaf1, v))\\n                # Remove the edge from the adjacency list\\n                adj_list[leaf1].remove(v)\\n                adj_list[v].remove(leaf1)\\n                break\\n\\n    return operations\\n\\n# Read input\\nimport sys\\ninput = sys.stdin.read\\ndata = input().split()\\nN = int(data[0])\\nedges = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N-1)]\\n\\n# Find the operations that maximize the total score\\noperations = max_score_operations(N, edges)\\n\\n# Print the operations\\nfor op in operations:\\n    print(op[0], op[1])\\n"]}
{"task_id": "arc183_c", "codes": ["d", "def count_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (1 << N) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for length in range(1, N + 1):\n        for mask in range(1 << N):\n            if bin(mask).count('1') != length:\n                continue\n            for l, r, x in conditions:\n                if l <= x <= r and (mask & (1 << (x - 1))) == 0:\n                    break\n            else:\n                dp[length][mask] += dp[length - 1][mask]\n                dp[length][mask] %= MOD\n\n    return sum(dp[N]) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = []\ni = 2\nwhile i < len(data):\n    L = int(data[i])\n    R = int(data[i + 1])\n    X = int(data[i + 2])\n    conditions.append((L, R, X))\n    i += 3\n\nresult = count_permutations(N, M, conditions)\nprint(result)\n"], "passed": [false, false], "raw_code": ["```python\ndef count_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    constraints = [(int(data[2 + 3 * i]), int(data[3 + 3 * i]), int(data[4 + 3 * i])) for i in range(M)]\n    \n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    \n    # Initialize dp table\n    for i in range(1, N + 1):\n        dp[i][i] = 1\n    \n    for l, r, x in constraints:\n        for i in range(l, r + 1):\n            if i == x:\n                continue\n            for j in range(N, x - 1, -1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n    \n    result = 0\n    for j in range(1, N + 1):\n        result = (result + dp[N][j]) % MOD\n    \n    print(result)\n\ncount_permutations()", "def count_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (1 << N) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for length in range(1, N + 1):\n        for mask in range(1 << N):\n            if bin(mask).count('1') != length:\n                continue\n            for l, r, x in conditions:\n                if l <= x <= r and (mask & (1 << (x - 1))) == 0:\n                    break\n            else:\n                dp[length][mask] += dp[length - 1][mask]\n                dp[length][mask] %= MOD\n\n    return sum(dp[N]) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = []\ni = 2\nwhile i < len(data):\n    L = int(data[i])\n    R = int(data[i + 1])\n    X = int(data[i + 2])\n    conditions.append((L, R, X))\n    i += 3\n\nresult = count_permutations(N, M, conditions)\nprint(result)\n"]}
{"task_id": "arc182_a", "codes": ["def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (max(V) + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(Q):\n        pi, vi = P[i], V[i]\n        \n        # Create a new DP table for the current operation\n        new_dp = [row[:] for row in dp]\n        \n        # Case 1: Replace the first pi elements with vi\n        for j in range(pi):\n            for k in range(max(V) + 1):\n                if k <= vi:\n                    new_dp[j + 1][k] += dp[j][k]\n                    new_dp[j + 1][k] %= MOD\n        \n        # Case 2: Replace elements from pi to N with vi\n        for j in range(pi, N):\n            for k in range(max(V) + 1):\n                if k <= vi:\n                    new_dp[N][k] += dp[j][k]\n                    new_dp[N][k] %= MOD\n        \n        dp = new_dp\n    \n    return sum(dp[N]) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\n\nfor i in range(Q):\n    pi = int(data[2 + 2 * i])\n    vi = int(data[3 + 2 * i])\n    P.append(pi)\n    V.append(vi)\n\n# Get the result\nresult = count_valid_sequences(N, Q, P, V)\n\n# Print the result\nprint(result)", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(i + 1):\n            if dp[i - 1][j] == 0:\n                continue\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n            \n            if j < i:\n                if V[-1] > max(S[j:i]):\n                    dp[i][i] = (dp[i][i] + dp[i - 1][j]) % MOD\n                else:\n                    dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j]) % MOD\n    \n    print(dp[N][0])\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (max(V) + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(Q):\n        pi, vi = P[i], V[i]\n        \n        # Create a new DP table for the current operation\n        new_dp = [row[:] for row in dp]\n        \n        # Case 1: Replace the first pi elements with vi\n        for j in range(pi):\n            for k in range(max(V) + 1):\n                if k <= vi:\n                    new_dp[j + 1][k] += dp[j][k]\n                    new_dp[j + 1][k] %= MOD\n        \n        # Case 2: Replace elements from pi to N with vi\n        for j in range(pi, N):\n            for k in range(max(V) + 1):\n                if k <= vi:\n                    new_dp[N][k] += dp[j][k]\n                    new_dp[N][k] %= MOD\n        \n        dp = new_dp\n    \n    return sum(dp[N]) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\n\nfor i in range(Q):\n    pi = int(data[2 + 2 * i])\n    vi = int(data[3 + 2 * i])\n    P.append(pi)\n    V.append(vi)\n\n# Get the result\nresult = count_valid_sequences(N, Q, P, V)\n\n# Print the result\nprint(result)\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(i + 1):\n            if dp[i - 1][j] == 0:\n                continue\n            dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n            \n            if j < i:\n                if V[-1] > max(S[j:i]):\n                    dp[i][i] = (dp[i][i] + dp[i - 1][j]) % MOD\n                else:\n                    dp[i][j + 1] = (dp[i][j + 1] + dp[i - 1][j]) % MOD\n    \n    print(dp[N][0])\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc370_g", "codes": ["def count_good_sequences(N, M):\n    MOD = 998244353\n    MAX_N = int(1e10)\n    MAX_M = int(1e5)\n    max_power = 0\n    for i in range(2, MAX_N + 1):\n        power = 0\n        while i % i == 0:\n            i //= i\n            power += 1\n        if power > 0:\n            max_power = max(max_power, power)\n    dp = [[0] * (max_power + 1) for _ in range(M + 1)]\n    dp[0][0] = 1\n    for m in range(1, M + 1):\n        for n in range(1, N + 1):\n            prime_factors = []\n            temp_n = n\n            for i in range(2, temp_n + 1):\n                power = 0\n                while temp_n % i == 0:\n                    temp_n //= i\n                    power += 1\n                if power > 0:\n                    prime_factors.append((i, power))\n            for factor, power in prime_factors:\n                for p in range(max_power, power - 1, -1):\n                    dp[m][p] = (dp[m][p] + dp[m - 1][p - power]) % MOD\n    return dp[M][0]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    result = count_good_sequences(N, M)\n    print(result)\n\nif __name__ == '__main__':\n    main()", "import sys\nfrom functools import lru_cache\nMOD = 998244353\ndef sum_of_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\n@lru_cache(None)\ndef is_good(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef dp(n, m, product):\n    if m == 0:\n        return 1 if product == 1 else 0\n    result = 0\n    for i in range(1, n + 1):\n        if product * i > N:\n            break\n        if is_good(product * i):\n            result = (result + dp(n, m - 1, product * i)) % MOD\n    return result\n\nN, M = map(int, input().split())\nprint(dp(N, M, 1))"], "passed": [false, false], "raw_code": ["def count_good_sequences(N, M):\n    MOD = 998244353\n    MAX_N = int(1e10)\n    MAX_M = int(1e5)\n    max_power = 0\n    for i in range(2, MAX_N + 1):\n        power = 0\n        while i % i == 0:\n            i //= i\n            power += 1\n        if power > 0:\n            max_power = max(max_power, power)\n    dp = [[0] * (max_power + 1) for _ in range(M + 1)]\n    dp[0][0] = 1\n    for m in range(1, M + 1):\n        for n in range(1, N + 1):\n            prime_factors = []\n            temp_n = n\n            for i in range(2, temp_n + 1):\n                power = 0\n                while temp_n % i == 0:\n                    temp_n //= i\n                    power += 1\n                if power > 0:\n                    prime_factors.append((i, power))\n            for factor, power in prime_factors:\n                for p in range(max_power, power - 1, -1):\n                    dp[m][p] = (dp[m][p] + dp[m - 1][p - power]) % MOD\n    return dp[M][0]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    result = count_good_sequences(N, M)\n    print(result)\n\nif __name__ == '__main__':\n    main()", "import sys\nfrom functools import lru_cache\nMOD = 998244353\ndef sum_of_divisors(n):\n    divisors = [1]\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    return sum(divisors)\n\n@lru_cache(None)\ndef is_good(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef dp(n, m, product):\n    if m == 0:\n        return 1 if product == 1 else 0\n    result = 0\n    for i in range(1, n + 1):\n        if product * i > N:\n            break\n        if is_good(product * i):\n            result = (result + dp(n, m - 1, product * i)) % MOD\n    return result\n\nN, M = map(int, input().split())\nprint(dp(N, M, 1))"]}
{"task_id": "arc181_b", "codes": ["def f(S, T, X):\n    result = []\n    for char in X:\n        if char == '0':\n            result.append(S)\n        else:\n            result.append(T)\n    return ''.join(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        \n        # Try all possible lengths of T\n        found = False\n        for length in range(len(X) + 1):\n            T = ''\n            for i in range(length):\n                T += chr((i % 26) + ord('a'))\n            \n            if f(S, T, X) == f(S, T, Y):\n                found = True\n                break\n        \n        results.append(\"Yes\" if found else \"No\")\n        index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "def check_f_equals(s, x, y):\n    def count_chars(s):\n        return s.count('0'), s.count('1')\n    \n    cx0, cx1 = count_chars(x)\n    cy0, cy1 = count_chars(y)\n    \n    if cx0 == cy0 and cx1 == cy1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        s = data[index]\n        x = data[index + 1]\n        y = data[index + 2]\n        index += 3\n        \n        result = check_f_equals(s, x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef f(S, T, X):\n    result = []\n    for char in X:\n        if char == '0':\n            result.append(S)\n        else:\n            result.append(T)\n    return ''.join(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        \n        # Try all possible lengths of T\n        found = False\n        for length in range(len(X) + 1):\n            T = ''\n            for i in range(length):\n                T += chr((i % 26) + ord('a'))\n            \n            if f(S, T, X) == f(S, T, Y):\n                found = True\n                break\n        \n        results.append(\"Yes\" if found else \"No\")\n        index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef check_f_equals(s, x, y):\n    def count_chars(s):\n        return s.count('0'), s.count('1')\n    \n    cx0, cx1 = count_chars(x)\n    cy0, cy1 = count_chars(y)\n    \n    if cx0 == cy0 and cx1 == cy1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        s = data[index]\n        x = data[index + 1]\n        y = data[index + 2]\n        index += 3\n        \n        result = check_f_equals(s, x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc372_f", "codes": ["import numpy as np\n\nMOD = 998244353\n\ndef matrix_multiply(A, B):\n    return np.dot(A, B) % MOD\n\ndef matrix_power(A, k):\n    result = np.eye(len(A), dtype=int) % MOD\n    while k > 0:\n        if k % 2 == 1:\n            result = matrix_multiply(result, A)\n        A = matrix_multiply(A, A)\n        k //= 2\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    A = np.zeros((N + 1, N + 1), dtype=int)\n    for i in range(1, N + 1):\n        A[i - 1][i] = 1\n    A[N - 1][0] = 1\n    \n    for _ in range(M):\n        x = int(data[index]) - 1\n        y = int(data[index + 1]) - 1\n        A[x][y] = 1\n        index += 2\n    \n    A[K % N][K // N * N] = 1\n    \n    result_matrix = matrix_power(A, K)\n    print(result_matrix[0][0])\n\nif __name__ == \"__main__\":\n    main()", "M"], "passed": [false, false], "raw_code": ["```python\nimport numpy as np\n\nMOD = 998244353\n\ndef matrix_multiply(A, B):\n    return np.dot(A, B) % MOD\n\ndef matrix_power(A, k):\n    result = np.eye(len(A), dtype=int) % MOD\n    while k > 0:\n        if k % 2 == 1:\n            result = matrix_multiply(result, A)\n        A = matrix_multiply(A, A)\n        k //= 2\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    A = np.zeros((N + 1, N + 1), dtype=int)\n    for i in range(1, N + 1):\n        A[i - 1][i] = 1\n    A[N - 1][0] = 1\n    \n    for _ in range(M):\n        x = int(data[index]) - 1\n        y = int(data[index + 1]) - 1\n        A[x][y] = 1\n        index += 2\n    \n    A[K % N][K // N * N] = 1\n    \n    result_matrix = matrix_power(A, K)\n    print(result_matrix[0][0])\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nMOD = 998244353\n\ndef multiply(A, B):\n    n = len(A)\n    C = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                C[i][j] += A[i][k] * B[k][j]\n                C[i][j] %= MOD\n    return C\n\ndef matrix_power(A, k):\n    n = len(A)\n    result = [[int(i == j) for j in range(n)] for i in range(n)]\n    while k > 0:\n        if k % 2 == 1:\n            result = multiply(result, A)\n        A = multiply(A, A)\n        k //= 2\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    adj = [[0] * N for _ in range(N)]\n    for _ in range(M):\n        X = int(data[index]) - 1\n        Y = int(data[index + 1]) - 1\n        adj[X][Y] = 1\n        index += 2\n    \n    # Add self-loops for each vertex\n    for i in range(N):\n        adj[i][i] = 1\n    \n    # Convert adjacency list to adjacency matrix\n    A = adj\n    \n    # Compute A^K\n    P = matrix_power(A, K)\n    \n    # Number of ways to reach vertex 1 after K moves\n    result = P[0][0]\n    print(result)\n\nmain()"]}
{"task_id": "arc181_c", "codes": ["import sys\n\ndef generate_grid(N, P, Q):\n    grid = [[0] * N for _ in range(N)]\n    for i in range(N):\n        row_binary = bin(i)[2:].zfill(N)\n        for j in range(N):\n            if j == P.index(i + 1):\n                grid[i][j] = int(row_binary[j])\n    return grid\n\ndef print_grid(grid):\n    N = len(grid)\n    for i in range(N):\n        print(''.join(map(str, grid[i])))\n\nif __name__ == \"__main__\":\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    \n    grid = generate_grid(N, P, Q)\n    print_grid(grid)", "def generate_grid(N, P, Q):\n    grid = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(i + 1, N):\n            if P[i] < P[j] and Q[i] < Q[j]:\n                grid[i][j] = 1\n    for row in grid:\n        print(''.join(map(str, row)))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\ngenerate_grid(N, P, Q)"], "passed": [false, false], "raw_code": ["```python\nimport sys\n\ndef generate_grid(N, P, Q):\n    grid = [[0] * N for _ in range(N)]\n    for i in range(N):\n        row_binary = bin(i)[2:].zfill(N)\n        for j in range(N):\n            if j == P.index(i + 1):\n                grid[i][j] = int(row_binary[j])\n    return grid\n\ndef print_grid(grid):\n    N = len(grid)\n    for i in range(N):\n        print(''.join(map(str, grid[i])))\n\nif __name__ == \"__main__\":\n    N = int(input())\n    P = list(map(int, input().split()))\n    Q = list(map(int, input().split()))\n    \n    grid = generate_grid(N, P, Q)\n    print_grid(grid)\n```", "```python\ndef generate_grid(N, P, Q):\n    grid = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(i + 1, N):\n            if P[i] < P[j] and Q[i] < Q[j]:\n                grid[i][j] = 1\n    for row in grid:\n        print(''.join(map(str, row)))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\ngenerate_grid(N, P, Q)\n```"]}
{"task_id": "abc371_g", "codes": ["def get_smallest_array(N, P, A):\n    visited = [False] * N\n    result = A[:]\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = P[x] - 1\n            \n            # Sort the cycle elements\n            cycle.sort(key=lambda idx: A[idx])\n            \n            # Replace the original elements with sorted ones\n            for idx, pos in enumerate(cycle):\n                result[pos] = cycle[idx] + 1\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the smallest array and print it\nget_smallest_array(N, P, A)", "def min_lexicographic_array(N, P, A):\n    # Create a list to store the sorted elements within each cycle\n    sorted_cycles = []\n    \n    # Create a visited list to keep track of processed elements\n    visited = [False] * (N + 1)\n    \n    for i in range(1, N + 1):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(A[x - 1])\n                x = P[x - 1]\n            sorted_cycles.append(sorted(cycle))\n    \n    # Reconstruct the array A with sorted elements\n    result = []\n    for i in range(1, N + 1):\n        x = i\n        idx = 0\n        for cycle in sorted_cycles:\n            if x in cycle:\n                result.append(str(cycle[idx]))\n                idx += 1\n                break\n            x = P[x - 1]\n    \n    print(' '.join(result))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\nmin_lexicographic_array(N, P, A)"], "passed": [false, false], "raw_code": ["```python\ndef get_smallest_array(N, P, A):\n    visited = [False] * N\n    result = A[:]\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(x)\n                x = P[x] - 1\n            \n            # Sort the cycle elements\n            cycle.sort(key=lambda idx: A[idx])\n            \n            # Replace the original elements with sorted ones\n            for idx, pos in enumerate(cycle):\n                result[pos] = cycle[idx] + 1\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the smallest array and print it\nget_smallest_array(N, P, A)\n```", "```python\ndef min_lexicographic_array(N, P, A):\n    # Create a list to store the sorted elements within each cycle\n    sorted_cycles = []\n    \n    # Create a visited list to keep track of processed elements\n    visited = [False] * (N + 1)\n    \n    for i in range(1, N + 1):\n        if not visited[i]:\n            cycle = []\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                cycle.append(A[x - 1])\n                x = P[x - 1]\n            sorted_cycles.append(sorted(cycle))\n    \n    # Reconstruct the array A with sorted elements\n    result = []\n    for i in range(1, N + 1):\n        x = i\n        idx = 0\n        for cycle in sorted_cycles:\n            if x in cycle:\n                result.append(str(cycle[idx]))\n                idx += 1\n                break\n            x = P[x - 1]\n    \n    print(' '.join(result))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\nmin_lexicographic_array(N, P, A)\n```"]}
{"task_id": "abc369_g", "codes": ["import sys\nfrom collections import defaultdict, deque\n\ndef find_longest_path(graph, root):\n    stack = [(root, -1, 0)]\n    max_dist = 0\n    farthest_node = None\n    while stack:\n        node, parent, dist = stack.pop()\n        if dist > max_dist:\n            max_dist = dist\n            farthest_node = node\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                stack.append((neighbor, node, dist + 1))\n    return farthest_node, max_dist\n\ndef min_max_score(N, edges):\n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Find the diameter of the tree\n    _, d1 = find_longest_path(graph, 1)\n    _, d2 = find_longest_path(graph, d1)\n    diameter = d2\n\n    # For K >= 3, the optimal score is the diameter\n    for _ in range(1, N + 1):\n        print(diameter)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nedges = []\ni = 1\nfor _ in range(N - 1):\n    u = int(data[i])\n    v = int(data[i + 1])\n    l = int(data[i + 2])\n    edges.append((u, v, l))\n    i += 3\n\n# Print results\nmin_max_score(N, edges)\n", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    edges = []\n    for i in range(N - 1):\n        u = int(data[2 * i + 1])\n        v = int(data[2 * i + 2])\n        l = int(data[2 * i + 3])\n        edges.append((u, v, l))\n\n    def find(x, parent):\n        if parent[x] != x:\n            parent[x] = find(parent[x], parent)\n        return parent[x]\n\n    def union(x, y, parent, rank):\n        rootX = find(x, parent)\n        rootY = find(y, parent)\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n\n    for u, v, _ in edges:\n        union(u, v, parent, rank)\n\n    def dfs(node, visited, current_length):\n        visited[node] = True\n        for neighbor, _, length in adjacency_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, current_length + length)\n\n    adjacency_list = [[] for _ in range(N + 1)]\n    for u, v, l in edges:\n        adjacency_list[u].append((v, u, l))\n        adjacency_list[v].append((u, v, l))\n\n    results = [0] * N\n    for K in range(1, N + 1):\n        max_score = float('-inf')\n        for combination in combinations(range(1, N + 1), K):\n            visited = [False] * (N + 1)\n            for node in combination:\n                if not visited[node]:\n                    dfs(node, visited, 0)\n            max_score = max(max_score, sum(visited))\n        results[K - 1] = max_score\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"], "passed": [false, false], "raw_code": ["import sys\nfrom collections import defaultdict, deque\n\ndef find_longest_path(graph, root):\n    stack = [(root, -1, 0)]\n    max_dist = 0\n    farthest_node = None\n    while stack:\n        node, parent, dist = stack.pop()\n        if dist > max_dist:\n            max_dist = dist\n            farthest_node = node\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                stack.append((neighbor, node, dist + 1))\n    return farthest_node, max_dist\n\ndef min_max_score(N, edges):\n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Find the diameter of the tree\n    _, d1 = find_longest_path(graph, 1)\n    _, d2 = find_longest_path(graph, d1)\n    diameter = d2\n\n    # For K >= 3, the optimal score is the diameter\n    for _ in range(1, N + 1):\n        print(diameter)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nedges = []\ni = 1\nfor _ in range(N - 1):\n    u = int(data[i])\n    v = int(data[i + 1])\n    l = int(data[i + 2])\n    edges.append((u, v, l))\n    i += 3\n\n# Print results\nmin_max_score(N, edges)\n", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    edges = []\n    for i in range(N - 1):\n        u = int(data[2 * i + 1])\n        v = int(data[2 * i + 2])\n        l = int(data[2 * i + 3])\n        edges.append((u, v, l))\n\n    def find(x, parent):\n        if parent[x] != x:\n            parent[x] = find(parent[x], parent)\n        return parent[x]\n\n    def union(x, y, parent, rank):\n        rootX = find(x, parent)\n        rootY = find(y, parent)\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n\n    for u, v, _ in edges:\n        union(u, v, parent, rank)\n\n    def dfs(node, visited, current_length):\n        visited[node] = True\n        for neighbor, _, length in adjacency_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, current_length + length)\n\n    adjacency_list = [[] for _ in range(N + 1)]\n    for u, v, l in edges:\n        adjacency_list[u].append((v, u, l))\n        adjacency_list[v].append((u, v, l))\n\n    results = [0] * N\n    for K in range(1, N + 1):\n        max_score = float('-inf')\n        for combination in combinations(range(1, N + 1), K):\n            visited = [False] * (N + 1)\n            for node in combination:\n                if not visited[node]:\n                    dfs(node, visited, 0)\n            max_score = max(max_score, sum(visited))\n        results[K - 1] = max_score\n\n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "abc372_e", "codes": ["import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    heaps = {}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            \n            graph[u].append(v)\n            graph[v].append(u)\n            \n            # Ensure the heap is initialized for these vertices\n            if u not in heaps:\n                heaps[u] = []\n            if v not in heaps:\n                heaps[v] = []\n            \n            # Push the other vertex into the respective heap\n            heapq.heappush(heaps[u], -v)\n            heapq.heappush(heaps[v], -u)\n        \n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            if v not in heaps or len(heaps[v]) < k:\n                results.append(-1)\n            else:\n                # Extract the k-th largest element\n                top_k = heapq.nsmallest(k, heaps[v])\n                results.append(-top_k[-1])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "import heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    graph = {}\n    answers = []\n\n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            if u not in graph:\n                graph[u] = []\n            if v not in graph:\n                graph[v] = []\n            heapq.heappush(graph[u], v)\n            heapq.heappush(graph[v], u)\n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            if v not in graph or len(graph[v]) < k:\n                answers.append(-1)\n            else:\n                heap = graph[v].copy()\n                while len(heap) > k:\n                    heapq.heappop(heap)\n                answers.append(heap[0] + 1)\n\n    for answer in answers:\n        print(answer)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\nimport sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    heaps = {}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            \n            graph[u].append(v)\n            graph[v].append(u)\n            \n            # Ensure the heap is initialized for these vertices\n            if u not in heaps:\n                heaps[u] = []\n            if v not in heaps:\n                heaps[v] = []\n            \n            # Push the other vertex into the respective heap\n            heapq.heappush(heaps[u], -v)\n            heapq.heappush(heaps[v], -u)\n        \n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            if v not in heaps or len(heaps[v]) < k:\n                results.append(-1)\n            else:\n                # Extract the k-th largest element\n                top_k = heapq.nsmallest(k, heaps[v])\n                results.append(-top_k[-1])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    graph = {}\n    answers = []\n\n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            if u not in graph:\n                graph[u] = []\n            if v not in graph:\n                graph[v] = []\n            heapq.heappush(graph[u], v)\n            heapq.heappush(graph[v], u)\n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            if v not in graph or len(graph[v]) < k:\n                answers.append(-1)\n            else:\n                heap = graph[v].copy()\n                while len(heap) > k:\n                    heapq.heappop(heap)\n                answers.append(heap[0] + 1)\n\n    for answer in answers:\n        print(answer)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"final_accuracy": "0.00%"}
