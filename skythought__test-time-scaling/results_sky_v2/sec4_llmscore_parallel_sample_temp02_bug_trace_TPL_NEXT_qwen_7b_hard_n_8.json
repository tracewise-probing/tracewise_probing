{"difficulty": "hard", "num_threads": 32, "temperature": 0.2, "n": 8, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp02_bug_trace_TPL_NEXT_qwen_7b_hard_n_8.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "def determine_winner(N):\n    if N % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine the winner\nwinner = determine_winner(N)\nprint(winner)", "passed": false, "raw_code": "```python\ndef determine_winner(N):\n    if N % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine the winner\nwinner = determine_winner(N)\nprint(winner)\n```"}
{"task_id": "abc366_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(coords, D):\n        n = len(coords)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + coords[i]\n        \n        count = 0\n        \n        for i in range(n):\n            left = max(0, i - D // 2)\n            right = min(n, i + D // 2 + 1)\n            count += prefix_sum[right] - prefix_sum[left]\n        \n        return count\n    \n    x_count = count_points(x_coords, D)\n    y_count = count_points(y_coords, D)\n    \n    result = x_count * y_count\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(coords, D):\n        n = len(coords)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + coords[i]\n        \n        count = 0\n        \n        for i in range(n):\n            left = max(0, i - D // 2)\n            right = min(n, i + D // 2 + 1)\n            count += prefix_sum[right] - prefix_sum[left]\n        \n        return count\n    \n    x_count = count_points(x_coords, D)\n    y_count = count_points(y_coords, D)\n    \n    result = x_count * y_count\n    print(result)\n\nmain()\n```"}
{"task_id": "abc367_f", "code": "def can_rearrange_subsequence():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequence()", "passed": false, "raw_code": "```python\ndef can_rearrange_subsequence():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequence()\n```"}
{"task_id": "3532", "code": "def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 2: Initialize variables\n    n = len(graph)\n    times = [-1] * n\n    times[0] = 0\n    queue = deque([0])\n    visited = {0}\n    \n    # Step 3: Perform BFS simulation\n    while queue:\n        current_node = queue.popleft()\n        \n        # Check neighbors\n        for neighbor in graph[current_node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if current_node % 2 == 0:\n                    times[neighbor] = times[current_node] + 2\n                else:\n                    times[neighbor] = times[current_node] + 1\n                queue.append(neighbor)\n    \n    return times", "passed": false, "raw_code": "```python\ndef minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 2: Initialize variables\n    n = len(graph)\n    times = [-1] * n\n    times[0] = 0\n    queue = deque([0])\n    visited = {0}\n    \n    # Step 3: Perform BFS simulation\n    while queue:\n        current_node = queue.popleft()\n        \n        # Check neighbors\n        for neighbor in graph[current_node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                if current_node % 2 == 0:\n                    times[neighbor] = times[current_node] + 2\n                else:\n                    times[neighbor] = times[current_node] + 1\n                queue.append(neighbor)\n    \n    return times\n```"}
{"task_id": "abc366_f", "code": "def max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    # Compute the nested function value\n    result = 1\n    for A, B in functions[:K]:\n        result = A * result + B\n    \n    print(result)\n\nmax_nested_function_value()", "passed": false, "raw_code": "```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    # Compute the nested function value\n    result = 1\n    for A, B in functions[:K]:\n        result = A * result + B\n    \n    print(result)\n\nmax_nested_function_value()\n```"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    for i in range(n):\n        dp_inc[i][nums[i]] += 1\n        dp_dec[i][nums[i]] += 1\n        \n        for j in range(nums[i]):\n            dp_inc[i][j] += dp_inc[i-1][j]\n            dp_dec[i][j+1] += dp_dec[i-1][j]\n        \n        dp_inc[i][nums[i]] %= MOD\n        dp_dec[i][nums[i]] %= MOD\n    \n    result = 0\n    for i in range(n):\n        result += dp_inc[i][nums[i]] * dp_dec[i][nums[i]]\n        result %= MOD\n    \n    return result", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    for i in range(n):\n        dp_inc[i][nums[i]] += 1\n        dp_dec[i][nums[i]] += 1\n        \n        for j in range(nums[i]):\n            dp_inc[i][j] += dp_inc[i-1][j]\n            dp_dec[i][j+1] += dp_dec[i-1][j]\n        \n        dp_inc[i][nums[i]] %= MOD\n        dp_dec[i][nums[i]] %= MOD\n    \n    result = 0\n    for i in range(n):\n        result += dp_inc[i][nums[i]] * dp_dec[i][nums[i]]\n        result %= MOD\n    \n    return result\n```"}
{"task_id": "arc181_c", "code": "def fill_grid(N, P, Q):\n    # Convert numbers to binary strings\n    binary_strings = [format(i, f'0{N}b') for i in range(N)]\n    \n    # Sort rows based on permutation P\n    sorted_rows = [binary_strings[i-1] for i in P]\n    \n    # Sort columns based on permutation Q\n    sorted_columns = [''.join(row[i] for row in sorted_rows) for i in Q]\n    \n    # Print the grid\n    for row in sorted_columns:\n        print(row)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:2*N+1]))\n\n# Call the function\nfill_grid(N, P, Q)", "passed": false, "raw_code": "```python\ndef fill_grid(N, P, Q):\n    # Convert numbers to binary strings\n    binary_strings = [format(i, f'0{N}b') for i in range(N)]\n    \n    # Sort rows based on permutation P\n    sorted_rows = [binary_strings[i-1] for i in P]\n    \n    # Sort columns based on permutation Q\n    sorted_columns = [''.join(row[i] for row in sorted_rows) for i in Q]\n    \n    # Print the grid\n    for row in sorted_columns:\n        print(row)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:2*N+1]))\n\n# Call the function\nfill_grid(N, P, Q)\n```"}
{"task_id": "abc367_e", "code": "def process_sequence(N, K, X, A):\n    # Function to perform one operation\n    def apply_operation(A, X):\n        return [A[X[i] - 1] for i in range(N)]\n    \n    # Find the cycle length\n    current_A = A[:]\n    visited = {tuple(current_A): 0}\n    cycle_length = 0\n    \n    while True:\n        current_A = apply_operation(current_A, X)\n        cycle_length += 1\n        if tuple(current_A) in visited:\n            break\n        visited[tuple(current_A)] = cycle_length\n    \n    # Effective number of operations within one cycle\n    effective_K = K % cycle_length\n    \n    # Apply the effective number of operations\n    for _ in range(effective_K):\n        A = apply_operation(A, X)\n    \n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)", "passed": false, "raw_code": "```python\ndef process_sequence(N, K, X, A):\n    # Function to perform one operation\n    def apply_operation(A, X):\n        return [A[X[i] - 1] for i in range(N)]\n    \n    # Find the cycle length\n    current_A = A[:]\n    visited = {tuple(current_A): 0}\n    cycle_length = 0\n    \n    while True:\n        current_A = apply_operation(current_A, X)\n        cycle_length += 1\n        if tuple(current_A) in visited:\n            break\n        visited[tuple(current_A)] = cycle_length\n    \n    # Effective number of operations within one cycle\n    effective_K = K % cycle_length\n    \n    # Apply the effective number of operations\n    for _ in range(effective_K):\n        A = apply_operation(A, X)\n    \n    # Print the final sequence\n    print(' '.join(map(str, A)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)\n```"}
{"task_id": "abc365_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    total_sum = 0\n    \n    # Iterate through all subarrays\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            total_sum += prefix_xor[j] ^ prefix_xor[i - 1]\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    total_sum = 0\n    \n    # Iterate through all subarrays\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            total_sum += prefix_xor[j] ^ prefix_xor[i - 1]\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc370_e", "code": "def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - A[i - 1]]) % MOD\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # Sum up all valid partitions\n    total_ways = sum(dp[N]) % MOD\n    \n    # Subtract invalid partitions (those ending with sum K)\n    invalid_ways = dp[N][K] if K <= K else 0\n    \n    return (total_ways - invalid_ways) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))", "passed": false, "raw_code": "```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            if j >= A[i - 1]:\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - A[i - 1]]) % MOD\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # Sum up all valid partitions\n    total_ways = sum(dp[N]) % MOD\n    \n    # Subtract invalid partitions (those ending with sum K)\n    invalid_ways = dp[N][K] if K <= K else 0\n    \n    return (total_ways - invalid_ways) % MOD\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))\n```"}
{"task_id": "arc181_b", "code": "d", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    result = []\n    for char in X:\n        if char == '0':\n            result.append(S)\n        else:\n            result.append(T)\n    return ''.join(result)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        count_X_0 = X.count('0')\n        count_X_1 = X.count('1')\n        count_Y_0 = Y.count('0')\n        count_Y_1 = Y.count('1')\n        \n        if count_X_0 == count_Y_0 and count_X_1 == count_Y_1:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nsolve()"}
{"task_id": "abc368_e", "code": "def find_min_delays(N, M, X1, trains):\n    # Sort trains based on their arrival times\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize the list to store delays\n    delays = [0] * M\n    \n    # Set the initial delay for the first train\n    delays[0] = X1\n    \n    # Iterate through the sorted list of trains\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(i):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                # Calculate the minimum delay required for train i\n                delays[i] = max(delays[i], S_j - T_i + delays[j])\n    \n    # Print the delays\n    print(' '.join(map(str, delays[1:])))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = []\n\nindex = 3\nfor i in range(M):\n    A_i = int(data[index])\n    B_i = int(data[index + 1])\n    S_i = int(data[index + 2])\n    T_i = int(data[index + 3])\n    trains.append((A_i, B_i, S_i, T_i))\n    index += 4\n\n# Call the function with the parsed input\nfind_min_delays(N, M, X1, trains)", "passed": false, "raw_code": "```python\ndef find_min_delays(N, M, X1, trains):\n    # Sort trains based on their arrival times\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize the list to store delays\n    delays = [0] * M\n    \n    # Set the initial delay for the first train\n    delays[0] = X1\n    \n    # Iterate through the sorted list of trains\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(i):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                # Calculate the minimum delay required for train i\n                delays[i] = max(delays[i], S_j - T_i + delays[j])\n    \n    # Print the delays\n    print(' '.join(map(str, delays[1:])))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = []\n\nindex = 3\nfor i in range(M):\n    A_i = int(data[index])\n    B_i = int(data[index + 1])\n    S_i = int(data[index + 2])\n    T_i = int(data[index + 3])\n    trains.append((A_i, B_i, S_i, T_i))\n    index += 4\n\n# Call the function with the parsed input\nfind_min_delays(N, M, X1, trains)\n```"}
{"task_id": "abc372_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    # Read additional edges\n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    # Process each move\n    for k in range(1, K + 1):\n        new_dp = [0] * (N + 1)\n        for v in range(1, N + 1):\n            if v == N:\n                new_dp[1] += dp[v][k - 1]\n            else:\n                new_dp[v + 1] += dp[v][k - 1]\n            new_dp[v] += dp[v][k - 1]\n        \n        for X, Y in edges:\n            new_dp[Y] += dp[X][k - 1]\n        \n        for v in range(1, N + 1):\n            new_dp[v] %= MOD\n        \n        dp = new_dp\n    \n    # Sum up the number of ways to reach any vertex after K moves\n    result = sum(dp[v][K] for v in range(1, N + 1)) % MOD\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    # Read additional edges\n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    # Process each move\n    for k in range(1, K + 1):\n        new_dp = [0] * (N + 1)\n        for v in range(1, N + 1):\n            if v == N:\n                new_dp[1] += dp[v][k - 1]\n            else:\n                new_dp[v + 1] += dp[v][k - 1]\n            new_dp[v] += dp[v][k - 1]\n        \n        for X, Y in edges:\n            new_dp[Y] += dp[X][k - 1]\n        \n        for v in range(1, N + 1):\n            new_dp[v] %= MOD\n        \n        dp = new_dp\n    \n    # Sum up the number of ways to reach any vertex after K moves\n    result = sum(dp[v][K] for v in range(1, N + 1)) % MOD\n    print(result)\n\nmain()\n```"}
{"task_id": "abc373_f", "code": "def max_happiness(N, W, weights, values):\n    dp = [0] * (W + 1)\n\n    for i in range(N):\n        for w in range(W, weights[i] - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if w >= k * weights[i]:\n                    dp[w] = max(dp[w], dp[w - k * weights[i]] + k * values[i] - k ** 2)\n                else:\n                    break\n\n    return dp[W]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2 * i]))\n    values.append(int(data[3 + 2 * i]))\n\nprint(max_happiness(N, W, weights, values))\n", "passed": false, "raw_code": "def max_happiness(N, W, weights, values):\n    dp = [0] * (W + 1)\n\n    for i in range(N):\n        for w in range(W, weights[i] - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if w >= k * weights[i]:\n                    dp[w] = max(dp[w], dp[w - k * weights[i]] + k * values[i] - k ** 2)\n                else:\n                    break\n\n    return dp[W]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nW = int(data[1])\nweights = []\nvalues = []\nfor i in range(N):\n    weights.append(int(data[2 + 2 * i]))\n    values.append(int(data[3 + 2 * i]))\n\nprint(max_happiness(N, W, weights, values))\n"}
{"task_id": "abc371_g", "code": "def smallest_permutation(N, P, A):\n    # Create a list of lists to store the cycles\n    cycles = [[] for _ in range(N)]\n    \n    # Populate the cycles based on the permutation P\n    visited = [False] * N\n    for i in range(N):\n        if not visited[i]:\n            current = i\n            while not visited[current]:\n                visited[current] = True\n                cycles[P[current] - 1].append(A[current])\n                current = P[current] - 1\n    \n    # Sort each cycle\n    for cycle in cycles:\n        cycle.sort()\n    \n    # Reconstruct the array using the sorted cycles\n    result = [0] * N\n    index = 0\n    for i in range(N):\n        result[P[i] - 1] = cycles[i][index % len(cycles[i])]\n        index += 1\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Call the function with the input\nsmallest_permutation(N, P, A)", "passed": false, "raw_code": "```python\ndef smallest_permutation(N, P, A):\n    # Create a list of lists to store the cycles\n    cycles = [[] for _ in range(N)]\n    \n    # Populate the cycles based on the permutation P\n    visited = [False] * N\n    for i in range(N):\n        if not visited[i]:\n            current = i\n            while not visited[current]:\n                visited[current] = True\n                cycles[P[current] - 1].append(A[current])\n                current = P[current] - 1\n    \n    # Sort each cycle\n    for cycle in cycles:\n        cycle.sort()\n    \n    # Reconstruct the array using the sorted cycles\n    result = [0] * N\n    index = 0\n    for i in range(N):\n        result[P[i] - 1] = cycles[i][index % len(cycles[i])]\n        index += 1\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Call the function with the input\nsmallest_permutation(N, P, A)\n```"}
{"task_id": "abc373_e", "code": "d", "passed": false, "raw_code": "```python\ndef min_additional_votes(N, M, K, A):\n    remaining_votes = K - sum(A)\n    C = [-1] * N\n    \n    for i in range(N):\n        if A[i] > sum(A[:i] + A[i+1:]) + remaining_votes:\n            C[i] = 0\n            continue\n        \n        max_votes_other = max(A[:i] + A[i+1:])\n        additional_votes_needed = max_votes_other - A[i] + 1\n        \n        if additional_votes_needed <= remaining_votes:\n            C[i] = additional_votes_needed\n    \n    return C\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Calculate and print the result\nresult = min_additional_votes(N, M, K, A)\nprint(' '.join(map(str, result)))"}
{"task_id": "abc371_e", "code": "def calculate_distinct_subsequences(N, A):\n    total_sum = 0\n    \n    for i in range(N):\n        distinct_elements = set()\n        for j in range(i, N):\n            distinct_elements.add(A[j])\n            total_sum += len(distinct_elements)\n    \n    return total_sum\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = calculate_distinct_subsequences(N, A)\nprint(result)", "passed": false, "raw_code": "```python\ndef calculate_distinct_subsequences(N, A):\n    total_sum = 0\n    \n    for i in range(N):\n        distinct_elements = set()\n        for j in range(i, N):\n            distinct_elements.add(A[j])\n            total_sum += len(distinct_elements)\n    \n    return total_sum\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = calculate_distinct_subsequences(N, A)\nprint(result)\n```"}
{"task_id": "abc369_e", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict\nimport heapq\n\ndef min_time_to_travel(N, M, bridges, Q, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    # Initialize DP table\n    dp = [[float('inf')] * (1 << M) for _ in range(N + 1)]\n    dp[1][0] = 0\n\n    # Perform Dijkstra's algorithm for each state\n    pq = [(0, 1, 0)]\n    while pq:\n        current_time, current_node, used_bridges = heapq.heappop(pq)\n        if current_time > dp[current_node][used_bridges]:\n            continue\n        for neighbor, time in graph[current_node]:\n            new_used_bridges = used_bridges | (1 << (bridges.index((min(current_node, neighbor), max(current_node, neighbor))) if (current_node, neighbor) in bridges else bridges.index((max(current_node, neighbor), min(current_node, neighbor)))))\n            if current_time + time < dp[neighbor][new_used_bridges]:\n                dp[neighbor][new_used_bridges] = current_time + time\n                heapq.heappush(pq, (dp[neighbor][new_used_bridges], neighbor, new_used_bridges))\n\n    # Answer each query\n    results = []\n    for K, query in zip(Q, queries):\n        required_bridges = set(query)\n        min_time = float('inf')\n        for used_bridges in range(1 << M):\n            if all((1 << i) & used_bridges for i in required_bridges):\n                min_time = min(min_time, dp[N][used_bridges])\n        results.append(min_time)\n\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nbridges = []\nindex = 2\nfor _ in range(M):\n    u = int(data[index])\n    v = int(data[index + 1])\n    t = int(data[index + 2])\n    bridges.append((u, v, t))\n    index += 3\n\nQ = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(Q):\n    K = int(data[index])\n    query = set()\n    for _ in range(K):\n        b = int(data[index + _]) - 1\n        query.add(b)\n    queries.append(query)\n    index += K\n\n# Compute and print results\nresults = min_time_to_travel(N, M, bridges, Q, queries)\nfor result in results:\n    print(result)"}
{"task_id": "arc181_d", "code": "def update(bit, idx, val):\n    while idx < len(bit):\n        bit[idx] += val\n        idx += idx & -idx\n\ndef query(bit, idx):\n    result = 0\n    while idx > 0:\n        result += bit[idx]\n        idx -= idx & -idx\n    return result\n\ndef fenwick_inversions(arr):\n    n = len(arr)\n    bit = [0] * (n + 1)\n    inversions = 0\n    \n    for i in range(n):\n        inversions += i - query(bit, arr[i])\n        update(bit, arr[i], 1)\n    \n    return inversions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    for a in A:\n        for i in range(a-1):\n            if P[i] > P[i+1]:\n                P[i], P[i+1] = P[i+1], P[i]\n        \n        inversions = fenwick_inversions(P)\n        print(inversions)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef update(bit, idx, val):\n    while idx < len(bit):\n        bit[idx] += val\n        idx += idx & -idx\n\ndef query(bit, idx):\n    result = 0\n    while idx > 0:\n        result += bit[idx]\n        idx -= idx & -idx\n    return result\n\ndef fenwick_inversions(arr):\n    n = len(arr)\n    bit = [0] * (n + 1)\n    inversions = 0\n    \n    for i in range(n):\n        inversions += i - query(bit, arr[i])\n        update(bit, arr[i], 1)\n    \n    return inversions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    for a in A:\n        for i in range(a-1):\n            if P[i] > P[i+1]:\n                P[i], P[i+1] = P[i+1], P[i]\n        \n        inversions = fenwick_inversions(P)\n        print(inversions)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc366_g", "code": "def can_assign_numbers(N, M, edges):\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # DFS to try assigning numbers\n    def dfs(node, parent, assigned):\n        if node == N + 1:\n            return True\n\n        for num in range(1, 2**60):\n            valid = True\n            for neighbor in adj_list[node]:\n                if neighbor != parent and assigned[neighbor] ^ num != 0:\n                    valid = False\n                    break\n            if valid:\n                assigned[node] = num\n                if dfs(node + 1, node, assigned):\n                    return True\n                assigned[node] = 0\n\n        return False\n\n    # Initialize assignment array\n    assigned = [0] * (N + 1)\n\n    # Start DFS from node 1\n    if dfs(1, -1, assigned):\n        print('Yes')\n        for i in range(1, N + 1):\n            print(assigned[i], end=' ')\n    else:\n        print('No')\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n\ncan_assign_numbers(N, M, edges)", "passed": false, "raw_code": "def can_assign_numbers(N, M, edges):\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # DFS to try assigning numbers\n    def dfs(node, parent, assigned):\n        if node == N + 1:\n            return True\n\n        for num in range(1, 2**60):\n            valid = True\n            for neighbor in adj_list[node]:\n                if neighbor != parent and assigned[neighbor] ^ num != 0:\n                    valid = False\n                    break\n            if valid:\n                assigned[node] = num\n                if dfs(node + 1, node, assigned):\n                    return True\n                assigned[node] = 0\n\n        return False\n\n    # Initialize assignment array\n    assigned = [0] * (N + 1)\n\n    # Start DFS from node 1\n    if dfs(1, -1, assigned):\n        print('Yes')\n        for i in range(1, N + 1):\n            print(assigned[i], end=' ')\n    else:\n        print('No')\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n\ncan_assign_numbers(N, M, edges)"}
{"task_id": "abc370_f", "code": "d", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    # Sort pieces in descending order\n    A.sort(reverse=True)\n    \n    # Initialize variables\n    min_mass = float('inf')\n    current_mass = 0\n    current_person = 0\n    cut_lines_never_cut = 0\n    \n    # Distribute pieces\n    for i in range(N):\n        if current_mass + A[i] >= min_mass:\n            current_person += 1\n            current_mass = A[i]\n        else:\n            current_mass += A[i]\n        \n        # Check if the current cut line is never cut\n        if current_person == K:\n            cut_lines_never_cut += 1\n            current_person = 0\n            current_mass = 0\n    \n    # The minimum mass is the last calculated minimum mass\n    min_mass = current_mass\n    \n    # Print the result\n    print(min_mass, cut_lines_never_cut)\n\n# Call the function\nmain()"}
{"task_id": "abc373_g", "code": "i", "passed": false, "raw_code": "```python\nimport itertools\nimport sys\n\ndef cross_product(p1, p2, p3):\n    return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = cross_product(p1, q1, p2)\n    o2 = cross_product(p1, q1, q2)\n    o3 = cross_product(p2, q2, p1)\n    o4 = cross_product(p2, q2, q1)\n    if o1 != o2 and o3 != o4:\n        return False\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef find_valid_permutation(N, P, Q):\n    for R in itertools.permutations(range(1, N + 1)):\n        valid = True\n        for i in range(N):\n            for j in range(i + 1, N):\n                if do_intersect(P[i], Q[R[i] - 1], P[j], Q[R[j] - 1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return R\n    return None\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(N)]\n    Q = [(int(data[2 * N + 2 * i + 1]), int(data[2 * N + 2 * i + 2])) for i in range(N)]\n    result = find_valid_permutation(N, P, Q)\n    if result:\n        print(' '.join(map(str, result)))\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "abc369_g", "code": "import sys\nfrom collections import deque\n\ndef bfs(n, edges, start):\n    distances = [-1] * (n + 1)\n    distances[start] = 0\n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor, length in edges[current]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[current] + length\n                queue.append(neighbor)\n    \n    return distances\n\ndef min_max_score(n, edges):\n    distances = bfs(n, edges, 1)\n    scores = [0] * (n + 1)\n    \n    for k in range(1, n + 1):\n        max_distance = 0\n        for i in range(1, n + 1):\n            if i in specified_vertices:\n                max_distance = max(max_distance, distances[i])\n        scores[k] = max_distance\n    \n    return scores\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = [[] for _ in range(n + 1)]\n    \n    index = 1\n    for i in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges[u].append((v, l))\n        edges[v].append((u, l))\n        index += 3\n    \n    scores = min_max_score(n, edges)\n    \n    for score in scores[1:]:\n        print(score)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import deque\n\ndef bfs(n, edges, start):\n    distances = [-1] * (n + 1)\n    distances[start] = 0\n    queue = deque([start])\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor, length in edges[current]:\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[current] + length\n                queue.append(neighbor)\n    \n    return distances\n\ndef min_max_score(n, edges):\n    distances = bfs(n, edges, 1)\n    scores = [0] * (n + 1)\n    \n    for k in range(1, n + 1):\n        max_distance = 0\n        for i in range(1, n + 1):\n            if i in specified_vertices:\n                max_distance = max(max_distance, distances[i])\n        scores[k] = max_distance\n    \n    return scores\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = [[] for _ in range(n + 1)]\n    \n    index = 1\n    for i in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges[u].append((v, l))\n        edges[v].append((u, l))\n        index += 3\n    \n    scores = min_max_score(n, edges)\n    \n    for score in scores[1:]:\n        print(score)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc183_d", "code": "d", "passed": false, "raw_code": "```python\ndef max_score_tree_operations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    \n    for _ in range(N - 1):\n        A = int(data[index])\n        B = int(data[index + 1])\n        edges.append((A, B))\n        index += 2\n    \n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    for A, B in edges:\n        adj_list[A].append(B)\n        adj_list[B].append(A)\n    \n    # Find leaves and their corresponding vertices in the perfect matching\n    leaves = []\n    for i in range(1, N + 1):\n        if len(adj_list[i]) == 1:\n            leaves.append(i)\n    \n    # Sort leaves to ensure we get the maximum distance pairs\n    leaves.sort()\n    \n    # Calculate the score and print the pairs\n    score = 0\n    for i in range(len(leaves) // 2):\n        leaf1 = leaves[i]\n        leaf2 = leaves[N - 1 - i]\n        score += abs(leaf1 - leaf2)\n        print(f\"{leaf1} {leaf2}\")\n\n# Call the function\nmax_score_tree_operations()"}
{"task_id": "3552", "code": "def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = 10**(n-1)\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    return None", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    max_num = int('9' * n)\n    min_num = 10**(n-1)\n    \n    for num in range(max_num, min_num - 1, -1):\n        if num % k == 0 and is_palindrome(num):\n            return str(num)\n    return None\n```"}
{"task_id": "3550", "code": "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate column sums\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort rows and columns by their sums in descending order\n    sorted_rows = sorted(range(m), key=lambda i: row_sums[i], reverse=True)\n    sorted_cols = sorted(range(n), key=lambda j: col_sums[j], reverse=True)\n    \n    # Initialize set to keep track of used columns\n    used_cols = set()\n    \n    # Select the top three rows and ensure no shared columns\n    selected_cells = []\n    for i in range(3):\n        for j in sorted_cols:\n            if j not in used_cols:\n                selected_cells.append((sorted_rows[i], j))\n                used_cols.add(j)\n                break\n    \n    # Calculate the sum of the selected cells\n    max_sum = sum(board[i][j] for i, j in selected_cells)\n    \n    return max_sum", "passed": false, "raw_code": "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate row sums\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate column sums\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Sort rows and columns by their sums in descending order\n    sorted_rows = sorted(range(m), key=lambda i: row_sums[i], reverse=True)\n    sorted_cols = sorted(range(n), key=lambda j: col_sums[j], reverse=True)\n    \n    # Initialize set to keep track of used columns\n    used_cols = set()\n    \n    # Select the top three rows and ensure no shared columns\n    selected_cells = []\n    for i in range(3):\n        for j in sorted_cols:\n            if j not in used_cols:\n                selected_cells.append((sorted_rows[i], j))\n                used_cols.add(j)\n                break\n    \n    # Calculate the sum of the selected cells\n    max_sum = sum(board[i][j] for i, j in selected_cells)\n    \n    return max_sum\n```"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    n = len(damage)\n    times = [health[i] // power + (1 if health[i] % power != 0 else 0) for i in range(n)]\n    sorted_indices = sorted(range(n), key=lambda i: times[i], reverse=True)\n    total_damage = 0\n    for i in range(n):\n        total_damage += damage[sorted_indices[i]] * times[sorted_indices[i]]\n    return total_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    times = [health[i] // power + (1 if health[i] % power != 0 else 0) for i in range(n)]\n    sorted_indices = sorted(range(n), key=lambda i: times[i], reverse=True)\n    total_damage = 0\n    for i in range(n):\n        total_damage += damage[sorted_indices[i]] * times[sorted_indices[i]]\n    return total_damage\n```"}
{"task_id": "arc182_e", "code": "def calculate_min_mod_sum(N, M, C, K, A):\n    min_values = [float('inf')] * N\n    for k in range(M):\n        for i in range(N):\n            mod_value = (C * k + A[i]) % M\n            min_values[i] = min(min_values[i], mod_value)\n    \n    total_sum = sum(min_values)\n    complete_cycles = K // M\n    remaining_steps = K % M\n    \n    result = total_sum * complete_cycles\n    for k in range(remaining_steps):\n        for i in range(N):\n            mod_value = (C * k + A[i]) % M\n            min_values[i] = min(min_values[i], mod_value)\n        result += sum(min_values)\n    \n    return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nC = int(data[2])\nK = int(data[3])\nA = list(map(int, data[4:]))\n\n# Calculate and print the result\nprint(calculate_min_mod_sum(N, M, C, K, A))", "passed": false, "raw_code": "```python\ndef calculate_min_mod_sum(N, M, C, K, A):\n    min_values = [float('inf')] * N\n    for k in range(M):\n        for i in range(N):\n            mod_value = (C * k + A[i]) % M\n            min_values[i] = min(min_values[i], mod_value)\n    \n    total_sum = sum(min_values)\n    complete_cycles = K // M\n    remaining_steps = K % M\n    \n    result = total_sum * complete_cycles\n    for k in range(remaining_steps):\n        for i in range(N):\n            mod_value = (C * k + A[i]) % M\n            min_values[i] = min(min_values[i], mod_value)\n        result += sum(min_values)\n    \n    return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nC = int(data[2])\nK = int(data[3])\nA = list(map(int, data[4:]))\n\n# Calculate and print the result\nprint(calculate_min_mod_sum(N, M, C, K, A))\n```"}
{"task_id": "3560", "code": "from collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\n@lru_cache(None)\ndef max_moves(kx, ky, positions, turn=0):\n    if not positions:\n        return 0\n    \n    if turn % 2 == 0:  # Alice's turn\n        max_moves_alice = 0\n        for i, (px, py) in enumerate(positions):\n            new_positions = positions[:i] + positions[i+1:]\n            moves = min_moves_to_capture(kx, ky, px, py)\n            max_moves_alice = max(max_moves_alice, moves + max_moves(px, py, new_positions, turn + 1))\n        return max_moves_alice\n    else:  # Bob's turn\n        min_moves_bob = float('inf')\n        for i, (px, py) in enumerate(positions):\n            new_positions = positions[:i] + positions[i+1:]\n            moves = min_moves_to_capture(kx, ky, px, py)\n            min_moves_bob = min(min_moves_bob, moves + max_moves(px, py, new_positions, turn + 1))\n        return min_moves_bob\n\ndef knight_pawn_game(kx, ky, positions):\n    return max_moves(kx, ky, tuple(map(tuple, positions)))", "passed": false, "raw_code": "```python\nfrom collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\n@lru_cache(None)\ndef max_moves(kx, ky, positions, turn=0):\n    if not positions:\n        return 0\n    \n    if turn % 2 == 0:  # Alice's turn\n        max_moves_alice = 0\n        for i, (px, py) in enumerate(positions):\n            new_positions = positions[:i] + positions[i+1:]\n            moves = min_moves_to_capture(kx, ky, px, py)\n            max_moves_alice = max(max_moves_alice, moves + max_moves(px, py, new_positions, turn + 1))\n        return max_moves_alice\n    else:  # Bob's turn\n        min_moves_bob = float('inf')\n        for i, (px, py) in enumerate(positions):\n            new_positions = positions[:i] + positions[i+1:]\n            moves = min_moves_to_capture(kx, ky, px, py)\n            min_moves_bob = min(min_moves_bob, moves + max_moves(px, py, new_positions, turn + 1))\n        return min_moves_bob\n\ndef knight_pawn_game(kx, ky, positions):\n    return max_moves(kx, ky, tuple(map(tuple, positions)))\n```"}
{"task_id": "abc372_e", "code": "import heapq\nfrom sys import stdin, stdout\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = [[] for _ in range(N + 1)]\n    \n    def add_edge(u, v):\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    def kth_largest_vertex(v, k):\n        if len(adj_list[v]) < k:\n            return -1\n        \n        heap = []\n        for neighbor in adj_list[v]:\n            if len(heap) < k:\n                heapq.heappush(heap, neighbor)\n            elif neighbor > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, neighbor)\n        \n        return heap[0]\n    \n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            add_edge(u, v)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            result = kth_largest_vertex(v, k)\n            results.append(result)\n    \n    for result in results:\n        stdout.write(f\"{result}\\n\")\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport heapq\nfrom sys import stdin, stdout\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = [[] for _ in range(N + 1)]\n    \n    def add_edge(u, v):\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    def kth_largest_vertex(v, k):\n        if len(adj_list[v]) < k:\n            return -1\n        \n        heap = []\n        for neighbor in adj_list[v]:\n            if len(heap) < k:\n                heapq.heappush(heap, neighbor)\n            elif neighbor > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, neighbor)\n        \n        return heap[0]\n    \n    results = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            add_edge(u, v)\n        elif query_type == 2:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            result = kth_largest_vertex(v, k)\n            results.append(result)\n    \n    for result in results:\n        stdout.write(f\"{result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc372_g", "code": "def count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    \n    for i in range(N):\n        if A[i] == 0:\n            if B[i] != 0 and C[i] > 0:\n                count += C[i] // B[i]\n        elif B[i] == 0:\n            if A[i] != 0 and C[i] > 0:\n                count += C[i] // A[i]\n        else:\n            low = 1\n            high = C[i] // A[i]\n            while low <= high:\n                mid = (low + high) // 2\n                if A[i] * mid + B[i] * mid < C[i]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            count += max(0, high)\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        \n        for _ in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    \n    for i in range(N):\n        if A[i] == 0:\n            if B[i] != 0 and C[i] > 0:\n                count += C[i] // B[i]\n        elif B[i] == 0:\n            if A[i] != 0 and C[i] > 0:\n                count += C[i] // A[i]\n        else:\n            low = 1\n            high = C[i] // A[i]\n            while low <= high:\n                mid = (low + high) // 2\n                if A[i] * mid + B[i] * mid < C[i]:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            count += max(0, high)\n    \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        \n        for _ in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3575", "code": "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if n == 2 * k:\n        return nums[0] | nums[1]\n    \n    def or_value(subseq):\n        return reduce(lambda x, y: x | y, subseq)\n    \n    def xor_value(subseq1, subseq2):\n        return or_value(subseq1) ^ or_value(subseq2)\n    \n    max_val = 0\n    for i in range(k):\n        for j in range(i + 1, k + 1):\n            left_subseq = nums[:i] + nums[j:]\n            right_subseq = nums[i:j] + nums[k:]\n            max_val = max(max_val, xor_value(left_subseq, right_subseq))\n    \n    return max_val", "passed": false, "raw_code": "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if n == 2 * k:\n        return nums[0] | nums[1]\n    \n    def or_value(subseq):\n        return reduce(lambda x, y: x | y, subseq)\n    \n    def xor_value(subseq1, subseq2):\n        return or_value(subseq1) ^ or_value(subseq2)\n    \n    max_val = 0\n    for i in range(k):\n        for j in range(i + 1, k + 1):\n            left_subseq = nums[:i] + nums[j:]\n            right_subseq = nums[i:j] + nums[k:]\n            max_val = max(max_val, xor_value(left_subseq, right_subseq))\n    \n    return max_val\n```"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Create adjacency list and indegree dictionary\n    n = len(coordinates)\n    adj_list = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                adj_list[coordinates[i]].append(coordinates[j])\n                indegree[coordinates[j]] += 1\n    \n    # Step 3: Topological sort using Kahn's algorithm\n    queue = deque([node for node in coordinates if indegree[node] == 0])\n    topo_order = []\n    \n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        \n        for neighbor in adj_list[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Step 4: Calculate the longest increasing path\n    dp = {node: 1 for node in coordinates}\n    \n    for node in topo_order:\n        for neighbor in adj_list[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n    \n    return dp[coordinates[k]]", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Create adjacency list and indegree dictionary\n    n = len(coordinates)\n    adj_list = defaultdict(list)\n    indegree = defaultdict(int)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                adj_list[coordinates[i]].append(coordinates[j])\n                indegree[coordinates[j]] += 1\n    \n    # Step 3: Topological sort using Kahn's algorithm\n    queue = deque([node for node in coordinates if indegree[node] == 0])\n    topo_order = []\n    \n    while queue:\n        node = queue.popleft()\n        topo_order.append(node)\n        \n        for neighbor in adj_list[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Step 4: Calculate the longest increasing path\n    dp = {node: 1 for node in coordinates}\n    \n    for node in topo_order:\n        for neighbor in adj_list[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n    \n    return dp[coordinates[k]]\n```"}
{"task_id": "abc368_d", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Function to perform DFS and find the maximum distance from a given vertex\n    def dfs(start, visited):\n        visited[start] = True\n        max_distance = 0\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                distance = dfs(neighbor, visited)\n                max_distance = max(max_distance, distance)\n        return max_distance + 1\n\n    # Find the maximum distance between any two of the K vertices\n    visited = [False] * (N + 1)\n    max_distance = 0\n    for vertex in K_vertices:\n        if not visited[vertex]:\n            distance = dfs(vertex, visited)\n            max_distance = max(max_distance, distance)\n\n    # The minimum number of vertices required is the maximum distance + 1\n    return max_distance\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    edges.append((u, v))\nK_vertices = list(map(int, data[2 * N + 1:]))\n\n# Calculate the result\nresult = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n\n# Print the result\nprint(result)\n\n# Call the function with sample input\ndef test_function():\n    input_data = \"7 3\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\\n1 3 5\"\n    expected_output = \"4\"\n    sys.stdin = io.StringIO(input_data)\n    result = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n    assert str(result) == expected_output, f\"Expected {expected_output}, but got {result}\"\n\n    input_data = \"4 4\\n3 1\\n1 4\\n2 1\\n1 2 3 4\"\n    expected_output = \"4\"\n    sys.stdin = io.StringIO(input_data)\n    result = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n    assert str(result) == expected_output, f\"Expected {expected_output}, but got {result}\"\n\n    input_data = \"5 1\\n1 4\\n2 3\\n5 2\\n1 2\\n1\"\n    expected_output = \"1\"\n    sys.stdin = io.StringIO(input_data)\n    result = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n    assert str(result) == expected_output, f\"Expected {expected_output}, but got {result}\"\n\ntest_function()", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict, deque\n\ndef min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Function to perform DFS and find the maximum distance from a given vertex\n    def dfs(start, visited):\n        visited[start] = True\n        max_distance = 0\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                distance = dfs(neighbor, visited)\n                max_distance = max(max_distance, distance)\n        return max_distance + 1\n\n    # Find the maximum distance between any two of the K vertices\n    visited = [False] * (N + 1)\n    max_distance = 0\n    for vertex in K_vertices:\n        if not visited[vertex]:\n            distance = dfs(vertex, visited)\n            max_distance = max(max_distance, distance)\n\n    # The minimum number of vertices required is the maximum distance + 1\n    return max_distance\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N - 1):\n    u = int(data[2 + 2 * i])\n    v = int(data[3 + 2 * i])\n    edges.append((u, v))\nK_vertices = list(map(int, data[2 * N + 1:]))\n\n# Calculate the result\nresult = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n\n# Print the result\nprint(result)\n\n# Call the function with sample input\ndef test_function():\n    input_data = \"7 3\\n1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n3 7\\n1 3 5\"\n    expected_output = \"4\"\n    sys.stdin = io.StringIO(input_data)\n    result = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n    assert str(result) == expected_output, f\"Expected {expected_output}, but got {result}\"\n\n    input_data = \"4 4\\n3 1\\n1 4\\n2 1\\n1 2 3 4\"\n    expected_output = \"4\"\n    sys.stdin = io.StringIO(input_data)\n    result = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n    assert str(result) == expected_output, f\"Expected {expected_output}, but got {result}\"\n\n    input_data = \"5 1\\n1 4\\n2 3\\n5 2\\n1 2\\n1\"\n    expected_output = \"1\"\n    sys.stdin = io.StringIO(input_data)\n    result = min_vertices_to_include_all_k_vertices(N, K, edges, K_vertices)\n    assert str(result) == expected_output, f\"Expected {expected_output}, but got {result}\"\n\ntest_function()"}
{"task_id": "abc371_f", "code": "def min_movements(N, X, Q, tasks):\n    # Sort tasks based on the target position\n    tasks.sort(key=lambda x: x[1])\n    # Initialize the current position of each person\n    current_positions = {i + 1: X[i] for i in range(N)}\n    # Initialize the total number of movements\n    total_moves = 0\n    # Process each task\n    for t, g in tasks:\n        # Calculate the difference between the current position and the target position\n        diff = abs(current_positions[t] - g)\n        # Update the current position to the target position\n        current_positions[t] = g\n        # Add the difference to the total number of movements\n        total_moves += diff\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\ntasks = [(int(data[N+2+2*i]), int(data[N+3+2*i])) for i in range(Q)]\n\n# Print the result\nprint(min_movements(N, X, Q, tasks))", "passed": false, "raw_code": "def min_movements(N, X, Q, tasks):\n    # Sort tasks based on the target position\n    tasks.sort(key=lambda x: x[1])\n    # Initialize the current position of each person\n    current_positions = {i + 1: X[i] for i in range(N)}\n    # Initialize the total number of movements\n    total_moves = 0\n    # Process each task\n    for t, g in tasks:\n        # Calculate the difference between the current position and the target position\n        diff = abs(current_positions[t] - g)\n        # Update the current position to the target position\n        current_positions[t] = g\n        # Add the difference to the total number of movements\n        total_moves += diff\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nX = list(map(int, data[1:N+1]))\nQ = int(data[N+1])\ntasks = [(int(data[N+2+2*i]), int(data[N+3+2*i])) for i in range(Q)]\n\n# Print the result\nprint(min_movements(N, X, Q, tasks))"}
{"task_id": "3527", "code": "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Duplicate the array to handle circular nature\n    groups = {}\n    count = 0\n    \n    def count_groups(size):\n        nonlocal count\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n    \n    def change_color(index, color):\n        nonlocal colors\n        colors[index] = color\n        colors[index + n] = color\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            count_groups(size)\n            results.append(count)\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            change_color(index, color)\n    \n    return results", "passed": false, "raw_code": "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors  # Duplicate the array to handle circular nature\n    groups = {}\n    count = 0\n    \n    def count_groups(size):\n        nonlocal count\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n    \n    def change_color(index, color):\n        nonlocal colors\n        colors[index] = color\n        colors[index + n] = color\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            count_groups(size)\n            results.append(count)\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            change_color(index, color)\n    \n    return results\n```"}
{"task_id": "abc370_g", "code": "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef prime_factors(n):\n    i = 2\n    factors = defaultdict(int)\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] += 1\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef sum_of_divisors(n):\n    result = 1\n    for p, exp in prime_factors(n).items():\n        result *= (p**(exp + 1) - 1) // (p - 1)\n    return result\n\nMOD = 998244353\n\ndef main():\n    N, M = map(int, input().split())\n    max_product = N ** (1 / M)\n    max_product = int(max_product)\n    dp = [0] * (max_product + 1)\n    dp[1] = 1\n    divisor_sums = [sum_of_divisors(i) for i in range(1, max_product + 1)]\n\n    for _ in range(M):\n        new_dp = [0] * (max_product + 1)\n        for product, count in enumerate(dp):\n            if count == 0:\n                continue\n            for factor in range(1, product + 1):\n                if gcd(factor, product // factor) == 1:\n                    new_dp[factor * product] = (new_dp[factor * product] + count * divisor_sums[factor]) % MOD\n        dp = new_dp\n\n    print(sum(dp[:max_product + 1]) % MOD)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef prime_factors(n):\n    i = 2\n    factors = defaultdict(int)\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] += 1\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef sum_of_divisors(n):\n    result = 1\n    for p, exp in prime_factors(n).items():\n        result *= (p**(exp + 1) - 1) // (p - 1)\n    return result\n\nMOD = 998244353\n\ndef main():\n    N, M = map(int, input().split())\n    max_product = N ** (1 / M)\n    max_product = int(max_product)\n    dp = [0] * (max_product + 1)\n    dp[1] = 1\n    divisor_sums = [sum_of_divisors(i) for i in range(1, max_product + 1)]\n\n    for _ in range(M):\n        new_dp = [0] * (max_product + 1)\n        for product, count in enumerate(dp):\n            if count == 0:\n                continue\n            for factor in range(1, product + 1):\n                if gcd(factor, product // factor) == 1:\n                    new_dp[factor * product] = (new_dp[factor * product] + count * divisor_sums[factor]) % MOD\n        dp = new_dp\n\n    print(sum(dp[:max_product + 1]) % MOD)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "arc182_d", "code": "def min_operations_to_equalize_sequences(N, M, A, B):\n    total_operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        circular_diff = M - diff\n        total_operations += min(diff, circular_diff)\n    return total_operations\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Calculate and print the result\nresult = min_operations_to_equalize_sequences(N, M, A, B)\nprint(result)", "passed": false, "raw_code": "def min_operations_to_equalize_sequences(N, M, A, B):\n    total_operations = 0\n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        circular_diff = M - diff\n        total_operations += min(diff, circular_diff)\n    return total_operations\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:2*N+2]))\n\n# Calculate and print the result\nresult = min_operations_to_equalize_sequences(N, M, A, B)\nprint(result)"}
{"task_id": "arc183_b", "code": "def can_transform(A, B, K):\n    N = len(A)\n    used = [False] * N\n    \n    for b in B:\n        found = False\n        for i in range(N):\n            if not used[i] and abs(A[i] - b) <= K:\n                used[i] = True\n                found = True\n                break\n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_transform(A, B, K):\n    N = len(A)\n    used = [False] * N\n    \n    for b in B:\n        found = False\n        for i in range(N):\n            if not used[i] and abs(A[i] - b) <= K:\n                used[i] = True\n                found = True\n                break\n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, Q + 1):\n        for j in range(1, N + 1):\n            if P[i - 1] <= j <= N:\n                dp[i][j] = dp[i - 1][j - 1]\n            if P[i - 1] <= N:\n                dp[i][N] = (dp[i][N] + dp[i - 1][j - 1]) % MOD\n\n    return dp[Q][N]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\nP = [int(data[2 + 2 * i]) for i in range(Q)]\nV = [int(data[3 + 2 * i]) for i in range(Q)]\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)", "passed": false, "raw_code": "```python\ndef count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, Q + 1):\n        for j in range(1, N + 1):\n            if P[i - 1] <= j <= N:\n                dp[i][j] = dp[i - 1][j - 1]\n            if P[i - 1] <= N:\n                dp[i][N] = (dp[i][N] + dp[i - 1][j - 1]) % MOD\n\n    return dp[Q][N]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\nP = [int(data[2 + 2 * i]) for i in range(Q)]\nV = [int(data[3 + 2 * i]) for i in range(Q)]\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)\n```"}
{"task_id": "3563", "code": "def maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    def backtrack(row, selected, score):\n        if row == len(grid):\n            return score\n        max_score = score\n        for col in range(len(grid[0])):\n            if grid[row][col] not in selected:\n                selected.add(grid[row][col])\n                max_score = max(max_score, backtrack(row + 1, selected, score + grid[row][col]))\n                selected.remove(grid[row][col])\n        return max_score\n    \n    return backtrack(0, set(), 0)", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    def backtrack(row, selected, score):\n        if row == len(grid):\n            return score\n        max_score = score\n        for col in range(len(grid[0])):\n            if grid[row][col] not in selected:\n                selected.add(grid[row][col])\n                max_score = max(max_score, backtrack(row + 1, selected, score + grid[row][col]))\n                selected.remove(grid[row][col])\n        return max_score\n    \n    return backtrack(0, set(), 0)\n```"}
{"task_id": "abc368_g", "code": "d", "passed": false, "raw_code": "```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    queries = data[2*N+2:]\n    \n    # Precompute prefix sums and suffix products\n    prefix_sum_A = [0] * (N + 1)\n    prefix_sum_B = [0] * (N + 1)\n    suffix_product_A = [0] * (N + 1)\n    suffix_product_B = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        prefix_sum_A[i] = max(prefix_sum_A[i - 1], prefix_sum_A[i - 1] + A[i - 1])\n        prefix_sum_B[i] = max(prefix_sum_B[i - 1], prefix_sum_B[i - 1] + B[i - 1])\n    \n    for i in range(N, 0, -1):\n        suffix_product_A[i] = max(suffix_product_A[i + 1], suffix_product_A[i + 1] * A[i - 1])\n        suffix_product_B[i] = max(suffix_product_B[i + 1], suffix_product_B[i + 1] * B[i - 1])\n    \n    # Process queries\n    result = []\n    index = 0\n    for i in range(Q):\n        query = queries[index:index + 3]\n        index += 3\n        if query[0] == '1':\n            i = int(query[1]) - 1\n            x = int(query[2])\n            A[i] = x\n        elif query[0] == '2':\n            i = int(query[1]) - 1\n            x = int(query[2])\n            B[i] = x\n        elif query[0] == '3':\n            l = int(query[1]) - 1\n            r = int(query[2]) - 1\n            v = 0\n            for i in range(l, r + 1):\n                v = max(v + A[i], v * B[i])\n            result.append(v)\n    \n    # Print results\n    for r in result:\n        print(r)\n\nprocess_queries()"}
{"task_id": "arc182_c", "code": "d", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    MOD = 998244353\n    \n    # Step 1: Prime factorization of M\n    def prime_factors(n):\n        factors = {}\n        d = 2\n        while n >= d * d:\n            if n % d == 0:\n                if d in factors:\n                    factors[d] += 1\n                else:\n                    factors[d] = 1\n                n //= d\n            else:\n                d += 1\n        if n > 1:\n            factors[n] = 1\n        return factors\n    \n    factors = prime_factors(M)\n    \n    # Step 2: Initialize DP table\n    dp = [[0] * (len(factors) + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Step 3: Fill DP table\n    for i in range(1, N + 1):\n        for j in range(len(factors)):\n            dp[i][j] = dp[i - 1][j]\n        for f, exp in factors.items():\n            for j in range(len(factors) - 1, exp - 1, -1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - exp]) % MOD\n    \n    # Step 4: Calculate the result\n    result = 0\n    for j in range(len(factors) + 1):\n        result = (result + dp[N][j]) % MOD\n    \n    print(result)\n\nmain()"}
{"task_id": "arc183_c", "code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(1 << N)]\n    dp[0][0] = 1\n\n    for mask in range(1 << N):\n        for i in range(N):\n            if mask & (1 << i) == 0:\n                continue\n            max_val = -1\n            start = None\n            end = None\n            for j in range(N):\n                if mask & (1 << j) != 0:\n                    if start is None or j < start:\n                        start = j\n                    if end is None or j > end:\n                        end = j\n                    max_val = max(max_val, j + 1)\n            for cond in conditions:\n                l, r, x = cond\n                if start <= x - 1 <= end and max_val == x:\n                    break\n            else:\n                new_mask = mask ^ (1 << i)\n                for j in range(N):\n                    if new_mask & (1 << j) == 0:\n                        dp[new_mask][j] += dp[mask][i]\n                        dp[new_mask][j] %= MOD\n\n    return sum(dp[(1 << N) - 1]) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = []\nfor i in range(M):\n    l = int(data[2 + 3 * i]) - 1\n    r = int(data[3 + 3 * i]) - 1\n    x = int(data[4 + 3 * i]) - 1\n    conditions.append((l, r, x))\n\nprint(count_valid_permutations(N, M, conditions))", "passed": false, "raw_code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(1 << N)]\n    dp[0][0] = 1\n\n    for mask in range(1 << N):\n        for i in range(N):\n            if mask & (1 << i) == 0:\n                continue\n            max_val = -1\n            start = None\n            end = None\n            for j in range(N):\n                if mask & (1 << j) != 0:\n                    if start is None or j < start:\n                        start = j\n                    if end is None or j > end:\n                        end = j\n                    max_val = max(max_val, j + 1)\n            for cond in conditions:\n                l, r, x = cond\n                if start <= x - 1 <= end and max_val == x:\n                    break\n            else:\n                new_mask = mask ^ (1 << i)\n                for j in range(N):\n                    if new_mask & (1 << j) == 0:\n                        dp[new_mask][j] += dp[mask][i]\n                        dp[new_mask][j] %= MOD\n\n    return sum(dp[(1 << N) - 1]) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = []\nfor i in range(M):\n    l = int(data[2 + 3 * i]) - 1\n    r = int(data[3 + 3 * i]) - 1\n    x = int(data[4 + 3 * i]) - 1\n    conditions.append((l, r, x))\n\nprint(count_valid_permutations(N, M, conditions))"}
{"task_id": "3551", "code": "def max_xor_subarray(nums, queries):\n    def xor_range(l, r):\n        if l == r:\n            return nums[l]\n        return nums[l] ^ xor_range(l + 1, r)\n    \n    def max_xor_in_range(l, r):\n        max_xor = 0\n        current_xor = 0\n        for i in range(l, r + 1):\n            current_xor ^= nums[i]\n            max_xor = max(max_xor, current_xor)\n        return max_xor\n    \n    sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][1])\n    result = [0] * len(queries)\n    j = 0\n    current_xor = 0\n    current_window = []\n    \n    for i, (query_index, (l, r)) in enumerate(sorted_queries):\n        while j < r:\n            current_xor ^= nums[j]\n            current_window.append(nums[j])\n            j += 1\n        \n        while current_window and current_window[0] < l:\n            current_xor ^= current_window.pop(0)\n        \n        result[query_index] = max_xor_in_range(l, r)\n    \n    return result", "passed": false, "raw_code": "```python\ndef max_xor_subarray(nums, queries):\n    def xor_range(l, r):\n        if l == r:\n            return nums[l]\n        return nums[l] ^ xor_range(l + 1, r)\n    \n    def max_xor_in_range(l, r):\n        max_xor = 0\n        current_xor = 0\n        for i in range(l, r + 1):\n            current_xor ^= nums[i]\n            max_xor = max(max_xor, current_xor)\n        return max_xor\n    \n    sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][1])\n    result = [0] * len(queries)\n    j = 0\n    current_xor = 0\n    current_window = []\n    \n    for i, (query_index, (l, r)) in enumerate(sorted_queries):\n        while j < r:\n            current_xor ^= nums[j]\n            current_window.append(nums[j])\n            j += 1\n        \n        while current_window and current_window[0] < l:\n            current_xor ^= current_window.pop(0)\n        \n        result[query_index] = max_xor_in_range(l, r)\n    \n    return result\n```"}
{"task_id": "abc367_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * 20 for _ in range(N + 1)]\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(20):\n            dp[i][j] = dp[i - 1][j]\n            if A[i - 1] & (1 << j):\n                dp[i][j] += dp[i - 1][j] ^ (1 << j)\n    \n    # Calculate the total score\n    total_score = 0\n    for i in range(1, N + 1):\n        if i % M == 0:\n            total_score += pow(dp[i][0], K, MOD)\n    \n    print(total_score % MOD)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * 20 for _ in range(N + 1)]\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(20):\n            dp[i][j] = dp[i - 1][j]\n            if A[i - 1] & (1 << j):\n                dp[i][j] += dp[i - 1][j] ^ (1 << j)\n    \n    # Calculate the total score\n    total_score = 0\n    for i in range(1, N + 1):\n        if i % M == 0:\n            total_score += pow(dp[i][0], K, MOD)\n    \n    print(total_score % MOD)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    return -1\n```"}
{"task_id": "3583", "code": "from collections import Counter\nimport math\n\ndef solve_gcd_pairs(nums, queries):\n    n = len(nums)\n    gcd_count = Counter()\n    \n    # Compute GCD for all pairs and count their occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_value = math.gcd(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n    \n    # Get unique GCD values sorted\n    unique_gcds = sorted(gcd_count.keys())\n    \n    # Create prefix sum array\n    prefix_sum = [0]\n    current_sum = 0\n    for gcd_value in unique_gcds:\n        current_sum += gcd_count[gcd_value]\n        prefix_sum.append(current_sum)\n    \n    # Answer each query\n    result = []\n    for query in queries:\n        # Find the smallest index such that prefix_sum[index] > query\n        left, right = 0, len(prefix_sum) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if prefix_sum[mid] <= query:\n                left = mid + 1\n            else:\n                right = mid\n        result.append(unique_gcds[left - 1])\n    \n    return result", "passed": false, "raw_code": "```python\nfrom collections import Counter\nimport math\n\ndef solve_gcd_pairs(nums, queries):\n    n = len(nums)\n    gcd_count = Counter()\n    \n    # Compute GCD for all pairs and count their occurrences\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_value = math.gcd(nums[i], nums[j])\n            gcd_count[gcd_value] += 1\n    \n    # Get unique GCD values sorted\n    unique_gcds = sorted(gcd_count.keys())\n    \n    # Create prefix sum array\n    prefix_sum = [0]\n    current_sum = 0\n    for gcd_value in unique_gcds:\n        current_sum += gcd_count[gcd_value]\n        prefix_sum.append(current_sum)\n    \n    # Answer each query\n    result = []\n    for query in queries:\n        # Find the smallest index such that prefix_sum[index] > query\n        left, right = 0, len(prefix_sum) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if prefix_sum[mid] <= query:\n                left = mid + 1\n            else:\n                right = mid\n        result.append(unique_gcds[left - 1])\n    \n    return result\n```"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def is_divisible_by_k(num, k):\n        return num % k == 0\n    \n    count = 0\n    for i in range(10**(n-1), 10**n):\n        if is_palindrome(i) and is_divisible_by_k(i, k):\n            count += 1\n    return count", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def is_divisible_by_k(num, k):\n        return num % k == 0\n    \n    count = 0\n    for i in range(10**(n-1), 10**n):\n        if is_palindrome(i) and is_divisible_by_k(i, k):\n            count += 1\n    return count\n```"}
{"final_accuracy": "0.00%"}
