"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.7, \"n\": 4, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_vanilla_bug_trace_TPL_OUR01_qwen_7b_hard_n_4.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42, \"resume\": true}"
{"task_id": "3563", "codes": ["import numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef max_score(grid):\n    # Transpose the grid\n    transposed_grid = np.array(grid).T\n    \n    # Apply the Hungarian algorithm\n    row_ind, col_ind = linear_sum_assignment(transposed_grid)\n    \n    # Calculate the maximum score\n    max_score = np.sum(np.max(grid, axis=1)) - np.sum(transposed_grid[row_ind, col_ind])\n    \n    return int(max_score)", "def max_score(grid):\n    for row in grid:\n        row.sort()\n    selected = set()\n    score = 0\n    for i in range(len(grid[0])):\n        for row in grid:\n            if row[i] not in selected:\n                selected.add(row[i])\n                score += row[i]\n                break\n    return score", "def maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    # Set to keep track of used values\n    used_values = set()\n    max_score = 0\n    \n    # Iterate through the grid and select the largest unique value\n    for row in grid:\n        for val in reversed(row):\n            if val not in used_values:\n                used_values.add(val)\n                max_score += val\n                break\n    \n    return max_score", "def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Set to keep track of used values\n    used_values = set()\n    score = 0\n    \n    # Iterate through each column\n    for col in range(len(grid[0])):\n        for row in range(len(grid)):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                score += grid[row][col]\n                break\n    \n    return score"], "passed": [false, false, false, false], "raw_code": ["```python\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef max_score(grid):\n    # Transpose the grid\n    transposed_grid = np.array(grid).T\n    \n    # Apply the Hungarian algorithm\n    row_ind, col_ind = linear_sum_assignment(transposed_grid)\n    \n    # Calculate the maximum score\n    max_score = np.sum(np.max(grid, axis=1)) - np.sum(transposed_grid[row_ind, col_ind])\n    \n    return int(max_score)\n```", "```python\ndef max_score(grid):\n    for row in grid:\n        row.sort()\n    selected = set()\n    score = 0\n    for i in range(len(grid[0])):\n        for row in grid:\n            if row[i] not in selected:\n                selected.add(row[i])\n                score += row[i]\n                break\n    return score\n```", "```python\ndef maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    # Set to keep track of used values\n    used_values = set()\n    max_score = 0\n    \n    # Iterate through the grid and select the largest unique value\n    for row in grid:\n        for val in reversed(row):\n            if val not in used_values:\n                used_values.add(val)\n                max_score += val\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Set to keep track of used values\n    used_values = set()\n    score = 0\n    \n    # Iterate through each column\n    for col in range(len(grid[0])):\n        for row in range(len(grid)):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                score += grid[row][col]\n                break\n    \n    return score\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    n = len(damage)\n    times_to_die = [(health[i] / damage[i], i) for i in range(n)]\n    times_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time, idx in times_to_die:\n        if health[idx] > 0:\n            attack_duration = int(health[idx] // power)\n            if health[idx] % power != 0:\n                attack_duration += 1\n            total_damage += attack_duration * damage[idx]\n            current_time += attack_duration\n            health[idx] = 0\n    \n    return total_damage", "def min_damage(power, damage, health):\n    # Calculate the total damage each enemy can inflict on Bob\n    total_damage = [(d * h) / p for d, h, p in zip(damage, health, [power] * len(damage))]\n    \n    # Sort enemies based on their damage potential\n    sorted_enemies = sorted(zip(total_damage, range(len(total_damage))))\n    \n    # Initialize variables\n    bob_health = 10**9  # Assume Bob starts with very high health\n    total_bob_damage = 0\n    \n    # Simulate the process of Bob attacking the enemies\n    for td, idx in sorted_enemies:\n        if bob_health <= td:\n            break\n        bob_health -= td\n        total_bob_damage += td\n    \n    return int(total_bob_damage)", "def minDamage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict over time until it dies\n    total_damage = [(d * h) // p if d < p else h for d, h, p in zip(damage, health, [power] * n)]\n    \n    # Sort enemies by their total damage in descending order\n    sorted_enemies = sorted(zip(total_damage, range(n)), reverse=True)\n    \n    total_bob_damage = 0\n    current_health = sum(health)\n    \n    for td, idx in sorted_enemies:\n        # Calculate how many seconds it takes to defeat the enemy\n        seconds_to_defeat = (current_health - 1) // power + 1\n        # Calculate the damage Bob takes during this period\n        bob_damage = td * seconds_to_defeat\n        total_bob_damage += bob_damage\n        \n        # Update the current health after defeating the enemy\n        current_health -= power * seconds_to_defeat\n    \n    return total_bob_damage", "def min_damage(power: int, damage: list[int], health: list[int]) -> int:\n    n = len(damage)\n    time_to_die = [(health[i] / damage[i], i) for i in range(n)]\n    time_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    while time_to_die:\n        _, index = time_to_die.pop(0)\n        time_taken = health[index] // power\n        if health[index] % power != 0:\n            time_taken += 1\n        \n        if current_time + time_taken >= time_to_die[0][0]:\n            total_damage += power * time_taken\n            health[index] -= power * time_taken\n            if health[index] <= 0:\n                continue\n            \n            time_to_die.append((health[index] / damage[index], index))\n            time_to_die.sort(reverse=True)\n        \n        current_time += time_taken\n    \n    return total_damage"], "passed": [false, false, false, false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    times_to_die = [(health[i] / damage[i], i) for i in range(n)]\n    times_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for time, idx in times_to_die:\n        if health[idx] > 0:\n            attack_duration = int(health[idx] // power)\n            if health[idx] % power != 0:\n                attack_duration += 1\n            total_damage += attack_duration * damage[idx]\n            current_time += attack_duration\n            health[idx] = 0\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    # Calculate the total damage each enemy can inflict on Bob\n    total_damage = [(d * h) / p for d, h, p in zip(damage, health, [power] * len(damage))]\n    \n    # Sort enemies based on their damage potential\n    sorted_enemies = sorted(zip(total_damage, range(len(total_damage))))\n    \n    # Initialize variables\n    bob_health = 10**9  # Assume Bob starts with very high health\n    total_bob_damage = 0\n    \n    # Simulate the process of Bob attacking the enemies\n    for td, idx in sorted_enemies:\n        if bob_health <= td:\n            break\n        bob_health -= td\n        total_bob_damage += td\n    \n    return int(total_bob_damage)\n```", "```python\ndef minDamage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict over time until it dies\n    total_damage = [(d * h) // p if d < p else h for d, h, p in zip(damage, health, [power] * n)]\n    \n    # Sort enemies by their total damage in descending order\n    sorted_enemies = sorted(zip(total_damage, range(n)), reverse=True)\n    \n    total_bob_damage = 0\n    current_health = sum(health)\n    \n    for td, idx in sorted_enemies:\n        # Calculate how many seconds it takes to defeat the enemy\n        seconds_to_defeat = (current_health - 1) // power + 1\n        # Calculate the damage Bob takes during this period\n        bob_damage = td * seconds_to_defeat\n        total_bob_damage += bob_damage\n        \n        # Update the current health after defeating the enemy\n        current_health -= power * seconds_to_defeat\n    \n    return total_bob_damage\n```", "```python\ndef min_damage(power: int, damage: list[int], health: list[int]) -> int:\n    n = len(damage)\n    time_to_die = [(health[i] / damage[i], i) for i in range(n)]\n    time_to_die.sort(reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    while time_to_die:\n        _, index = time_to_die.pop(0)\n        time_taken = health[index] // power\n        if health[index] % power != 0:\n            time_taken += 1\n        \n        if current_time + time_taken >= time_to_die[0][0]:\n            total_damage += power * time_taken\n            health[index] -= power * time_taken\n            if health[index] <= 0:\n                continue\n            \n            time_to_die.append((health[index] / damage[index], index))\n            time_to_die.sort(reverse=True)\n        \n        current_time += time_taken\n    \n    return total_damage\n```"]}
{"task_id": "3583", "codes": ["def getGCDPairs(nums, queries):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_counts = {}\n    \n    # Count GCDs of all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g not in gcd_counts:\n                gcd_counts[g] = 0\n            gcd_counts[g] += 1\n    \n    # Sort unique GCDs and build prefix sums\n    sorted_gcds = sorted(gcd_counts.keys())\n    prefix_sum = [0]\n    for g in sorted_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_counts[g])\n    \n    # Answer each query using binary search\n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(prefix_sum, q + 1)\n        if idx > 0:\n            result.append(sorted_gcds[idx - 1])\n        else:\n            result.append(0)\n    \n    return result", "def minGCD(self, nums: List[int]) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    max_num = max(nums)\n    count = [0] * (max_num + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                count[d] += 1\n    \n    prefix_sum = [0] * (max_num + 1)\n    for i in range(1, max_num + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + count[i]\n    \n    def get_min_gcd(k):\n        left, right = 1, max_num\n        while left < right:\n            mid = (left + right) // 2\n            if prefix_sum[mid] >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    return get_min_gcd(k)", "from math import gcd\nfrom collections import defaultdict\n\ndef solve_gcd_pairs(nums, queries):\n    # Step 1: Initialize a dictionary to store the counts of each GCD value\n    gcd_count = defaultdict(int)\n    \n    # Step 2: Iterate through all pairs of numbers and compute their GCD\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    # Step 3: Extract the sorted unique GCD values\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Step 4: Create a prefix sum array to map each GCD value to its position\n    prefix_sum = [0]\n    for g in sorted_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_count[g])\n    \n    # Step 5: Answer each query using the prefix sum array\n    answer = []\n    for q in queries:\n        idx = prefix_sum[bisect_right(sorted_gcds, q)] - 1\n        if idx >= 0:\n            answer.append(sorted_gcds[idx])\n        else:\n            answer.append(0)  # In case of invalid query index\n    \n    return answer", "def minOperations(self, nums: List[int]) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    max_gcd = max(nums)\n    freq = [0] * (max_gcd + 1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            freq[gcd(nums[i], nums[j])] += 1\n    \n    prefix_sum = [0] * (max_gcd + 1)\n    for i in range(1, max_gcd + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + freq[i]\n    \n    return prefix_sum"], "passed": [false, false, false, false], "raw_code": ["```python\ndef getGCDPairs(nums, queries):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    gcd_counts = {}\n    \n    # Count GCDs of all pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            if g not in gcd_counts:\n                gcd_counts[g] = 0\n            gcd_counts[g] += 1\n    \n    # Sort unique GCDs and build prefix sums\n    sorted_gcds = sorted(gcd_counts.keys())\n    prefix_sum = [0]\n    for g in sorted_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_counts[g])\n    \n    # Answer each query using binary search\n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(prefix_sum, q + 1)\n        if idx > 0:\n            result.append(sorted_gcds[idx - 1])\n        else:\n            result.append(0)\n    \n    return result\n```", "```python\ndef minGCD(self, nums: List[int]) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    max_num = max(nums)\n    count = [0] * (max_num + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                count[d] += 1\n    \n    prefix_sum = [0] * (max_num + 1)\n    for i in range(1, max_num + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + count[i]\n    \n    def get_min_gcd(k):\n        left, right = 1, max_num\n        while left < right:\n            mid = (left + right) // 2\n            if prefix_sum[mid] >= k:\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    return get_min_gcd(k)\n```", "```python\nfrom math import gcd\nfrom collections import defaultdict\n\ndef solve_gcd_pairs(nums, queries):\n    # Step 1: Initialize a dictionary to store the counts of each GCD value\n    gcd_count = defaultdict(int)\n    \n    # Step 2: Iterate through all pairs of numbers and compute their GCD\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    # Step 3: Extract the sorted unique GCD values\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Step 4: Create a prefix sum array to map each GCD value to its position\n    prefix_sum = [0]\n    for g in sorted_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_count[g])\n    \n    # Step 5: Answer each query using the prefix sum array\n    answer = []\n    for q in queries:\n        idx = prefix_sum[bisect_right(sorted_gcds, q)] - 1\n        if idx >= 0:\n            answer.append(sorted_gcds[idx])\n        else:\n            answer.append(0)  # In case of invalid query index\n    \n    return answer\n```", "```python\ndef minOperations(self, nums: List[int]) -> int:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    n = len(nums)\n    max_gcd = max(nums)\n    freq = [0] * (max_gcd + 1)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            freq[gcd(nums[i], nums[j])] += 1\n    \n    prefix_sum = [0] * (max_gcd + 1)\n    for i in range(1, max_gcd + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + freq[i]\n    \n    return prefix_sum\n```"]}
{"task_id": "3552", "codes": ["def largest_k_palindrome(n: int, k: int) -> str:\n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    # Start with the largest possible n-digit number\n    max_num = int('9' * n)\n    \n    while True:\n        # Convert the number to a string\n        num_str = str(max_num)\n        \n        # Create the largest possible palindrome from the number\n        palindrome = int(num_str + num_str[-2::-1])\n        \n        # Check if the palindrome is divisible by k\n        if palindrome % k == 0:\n            return str(palindrome)\n        \n        # Decrement the number and try again\n        max_num -= 1\n        \n        # If we reach 0 without finding a valid palindrome, return -1\n        if max_num == 0:\n            return \"-1\"", "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max(1, k))\n    \n    # Generate the largest n-digit number\n    half = '9' * ((n + 1) // 2)\n    number = int(half + half[:-1][::-1] if n % 2 == 0 else half + half[::-1])\n    \n    while True:\n        # Create the palindrome from the number\n        palindrome = int(half + half[:-1][::-1] if n % 2 == 0 else half + half[::-1])\n        \n        # Check if the palindrome is divisible by k\n        if palindrome % k == 0:\n            return str(palindrome)\n        \n        # Decrement the number and create a new palindrome\n        half = str(int(half) - 1)\n        if len(half) == 0:\n            return \"0\"", "def largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k * (k + 1) // 2 % k)\n    \n    half_length = (n + 1) // 2\n    max_prefix = int('9' * half_length)\n    \n    while True:\n        prefix = max_prefix\n        while prefix > 0:\n            candidate = int(str(prefix) + str(prefix)[::-1])\n            if candidate % k == 0:\n                return str(candidate)\n            prefix -= 1\n        \n        max_prefix -= 1\n        if max_prefix == 0:\n            break\n    \n    return \"0\"  # In case no valid palindrome is found, which theoretically shouldn't happen\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"", "def largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    # Start from the largest n-digit number and go downwards\n    for num in range(10**(n-1), 10**n - 1):\n        str_num = str(num)\n        if int(str_num[-n//2:]) % k == 0 and is_palindrome(str_num):\n            return str_num\n    return \"-1\"  # In case no such number exists, though constraints ensure one always exists\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\""], "passed": [false, false, false, false], "raw_code": ["```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    # Start with the largest possible n-digit number\n    max_num = int('9' * n)\n    \n    while True:\n        # Convert the number to a string\n        num_str = str(max_num)\n        \n        # Create the largest possible palindrome from the number\n        palindrome = int(num_str + num_str[-2::-1])\n        \n        # Check if the palindrome is divisible by k\n        if palindrome % k == 0:\n            return str(palindrome)\n        \n        # Decrement the number and try again\n        max_num -= 1\n        \n        # If we reach 0 without finding a valid palindrome, return -1\n        if max_num == 0:\n            return \"-1\"\n```", "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max(1, k))\n    \n    # Generate the largest n-digit number\n    half = '9' * ((n + 1) // 2)\n    number = int(half + half[:-1][::-1] if n % 2 == 0 else half + half[::-1])\n    \n    while True:\n        # Create the palindrome from the number\n        palindrome = int(half + half[:-1][::-1] if n % 2 == 0 else half + half[::-1])\n        \n        # Check if the palindrome is divisible by k\n        if palindrome % k == 0:\n            return str(palindrome)\n        \n        # Decrement the number and create a new palindrome\n        half = str(int(half) - 1)\n        if len(half) == 0:\n            return \"0\"", "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k * (k + 1) // 2 % k)\n    \n    half_length = (n + 1) // 2\n    max_prefix = int('9' * half_length)\n    \n    while True:\n        prefix = max_prefix\n        while prefix > 0:\n            candidate = int(str(prefix) + str(prefix)[::-1])\n            if candidate % k == 0:\n                return str(candidate)\n            prefix -= 1\n        \n        max_prefix -= 1\n        if max_prefix == 0:\n            break\n    \n    return \"0\"  # In case no valid palindrome is found, which theoretically shouldn't happen\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```", "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    # Start from the largest n-digit number and go downwards\n    for num in range(10**(n-1), 10**n - 1):\n        str_num = str(num)\n        if int(str_num[-n//2:]) % k == 0 and is_palindrome(str_num):\n            return str_num\n    return \"-1\"  # In case no such number exists, though constraints ensure one always exists\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * 51 for _ in range(n)]\n    \n    # Base case: single element arrays\n    for i in range(51):\n        dp[0][i] = 1\n    \n    # Fill DP table\n    for i in range(1, n):\n        prefix_sum = [0] * 51\n        for j in range(51):\n            prefix_sum[j] = prefix_sum[j-1] + dp[i-1][j]\n        \n        for j in range(51):\n            if j <= nums[i]:\n                dp[i][j] = prefix_sum[j]\n    \n    # Sum up all valid pairs\n    result = 0\n    for i in range(51):\n        result += dp[-1][i]\n    \n    return result % MOD", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize dp1 and dp2 tables\n    dp1 = [[0] * 51 for _ in range(n)]\n    dp2 = [[0] * 51 for _ in range(n)]\n    \n    # Fill dp1 table\n    for j in range(51):\n        dp1[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            dp1[i][j] = dp1[i-1][j]\n            if j > 0:\n                dp1[i][j", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def countSubarrays(arr):\n        count = 0\n        left = 0\n        for right in range(n):\n            while left <= right and arr[left] > arr[right]:\n                left += 1\n            count += right - left + 1\n        return count\n    \n    count1 = countSubarrays(nums)\n    count2 = countSubarrays(nums[::-1])\n    \n    return (count1 * count2) % MOD", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp1 = [[0] * 51 for _ in range(n)]\n    dp2 = [[0] * 51 for _ in range(n)]\n    \n    for j in range(51):\n        dp1[0][j] = 1\n        dp2[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            dp1[i][j] = sum(dp1[i-1][k] for k in range(j+1)) % MOD\n            dp2[i][j] = sum(dp2[i-1][k] for k in range(j, 51)) % MOD\n    \n    result = 0\n    for i in range(n):\n        result += dp1[i][nums[i]] * dp2[i][nums[i]]\n        result %= MOD\n    \n    return result"], "passed": [false, false, false, false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * 51 for _ in range(n)]\n    \n    # Base case: single element arrays\n    for i in range(51):\n        dp[0][i] = 1\n    \n    # Fill DP table\n    for i in range(1, n):\n        prefix_sum = [0] * 51\n        for j in range(51):\n            prefix_sum[j] = prefix_sum[j-1] + dp[i-1][j]\n        \n        for j in range(51):\n            if j <= nums[i]:\n                dp[i][j] = prefix_sum[j]\n    \n    # Sum up all valid pairs\n    result = 0\n    for i in range(51):\n        result += dp[-1][i]\n    \n    return result % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize dp1 and dp2 tables\n    dp1 = [[0] * 51 for _ in range(n)]\n    dp2 = [[0] * 51 for _ in range(n)]\n    \n    # Fill dp1 table\n    for j in range(51):\n        dp1[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            dp1[i][j] = dp1[i-1][j]\n            if j > 0:\n                dp1[i][j", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    def countSubarrays(arr):\n        count = 0\n        left = 0\n        for right in range(n):\n            while left <= right and arr[left] > arr[right]:\n                left += 1\n            count += right - left + 1\n        return count\n    \n    count1 = countSubarrays(nums)\n    count2 = countSubarrays(nums[::-1])\n    \n    return (count1 * count2) % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp1 = [[0] * 51 for _ in range(n)]\n    dp2 = [[0] * 51 for _ in range(n)]\n    \n    for j in range(51):\n        dp1[0][j] = 1\n        dp2[0][j] = 1\n    \n    for i in range(1, n):\n        for j in range(51):\n            dp1[i][j] = sum(dp1[i-1][k] for k in range(j+1)) % MOD\n            dp2[i][j] = sum(dp2[i-1][k] for k in range(j, 51)) % MOD\n    \n    result = 0\n    for i in range(n):\n        result += dp1[i][nums[i]] * dp2[i][nums[i]]\n        result %= MOD\n    \n    return result\n```"]}
{"task_id": "3548", "codes": ["def count_good_integers(n, k):\n    # Helper function to check if a number is divisible by k\n    def is_divisible_by_k(num):\n        return num % k == 0\n\n    # Helper function to generate all permutations of a list of digits\n    from itertools import permutations\n    def get_permutations(digits):\n        return set(permutations(digits))\n\n    # Helper function to check if a permutation forms a valid palindrome\n    def is_palindrome(perm):\n        perm_str = ''.join(map(str, perm))\n        return perm_str == perm_str[::-1]\n\n    # Generate all possible digits from 1 to 9\n    digits = [i for i in range(1, 10)]\n\n    # Count good integers\n    count = 0\n    for length in range(1, n+1):\n        for comb in combinations(digits, length):\n            perms = get_permutations(comb)\n            for perm in perms:\n                if is_palindrome(perm) and is_divisible_by_k(int(''.join(map(str, perm)))):\n                    count += 1\n\n    return count", "def countGoodIntegers(n, k):\n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * k for _ in range(n)]\n    \n    # Base case: single digit palindromes\n    for i in range(k):\n        dp[0][i] = 1\n    \n    # Fill DP table\n    for length in range(1, n):\n        prefix_sum = [0] * k\n        for remainder in range(k):\n            prefix_sum[remainder] = (prefix_sum[remainder - 1] + dp[length - 1][remainder]) % MOD\n        \n        for remainder in range(k):\n            for i in range(1, 10):\n                new_remainder = (remainder + i) % k\n                dp[length][(new_remainder * 10 + i) % k] += prefix_sum[new_remainder]\n                dp[length][(new_remainder * 10 + i) % k] %= MOD\n    \n    # Sum up all valid counts for n-digit numbers\n    result = 0\n    for remainder in range(k):\n        result += dp[n - 1][remainder]\n        result %= MOD\n    \n    return result", "def countGoodIntegers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_valid_numbers(digits):\n        from collections import Counter\n        count = Counter(digits)\n        half_digits = []\n        odd_digit = None\n        \n        for digit, freq in count.items():\n            half_digits.extend([digit] * (freq // 2))\n            if freq % 2 == 1:\n                odd_digit = digit\n        \n        half_length = len(half_digits)\n        total_count = 0\n        \n        # Generate all permutations of half_digits\n        from itertools import permutations\n        for perm in set(permutations(half_digits)):\n            full_number = int(''.join(perm) + ''.join(reversed(perm)))\n            if odd_digit is not None:\n                full_number = int(''.join(perm) + odd_digit + ''.join(reversed(perm)))\n            \n            if is_palindrome(full_number) and full_number % k == 0:\n                total_count += 1\n        \n        return total_count\n    \n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    digits = [str(i) for i in range(1, 10)] * (n // 9) + [str(i) for i in range(1, n % 9 + 1)]\n    return count_valid_numbers(digits)", "def countGoodIntegers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    if n == 2:\n        return len([i * 10 + i for i in range(1, 10) if (i * 10 + i) % k == 0])\n    dp = [[0] * (k * n) for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k * n):\n            for d in range(1, 10):\n                if j - d >= 0:\n                    dp[i][j] += dp[i-1][j-d]\n    return sum(dp[-1])"], "passed": [false, false, false, false], "raw_code": ["def count_good_integers(n, k):\n    # Helper function to check if a number is divisible by k\n    def is_divisible_by_k(num):\n        return num % k == 0\n\n    # Helper function to generate all permutations of a list of digits\n    from itertools import permutations\n    def get_permutations(digits):\n        return set(permutations(digits))\n\n    # Helper function to check if a permutation forms a valid palindrome\n    def is_palindrome(perm):\n        perm_str = ''.join(map(str, perm))\n        return perm_str == perm_str[::-1]\n\n    # Generate all possible digits from 1 to 9\n    digits = [i for i in range(1, 10)]\n\n    # Count good integers\n    count = 0\n    for length in range(1, n+1):\n        for comb in combinations(digits, length):\n            perms = get_permutations(comb)\n            for perm in perms:\n                if is_palindrome(perm) and is_divisible_by_k(int(''.join(map(str, perm)))):\n                    count += 1\n\n    return count", "```python\ndef countGoodIntegers(n, k):\n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * k for _ in range(n)]\n    \n    # Base case: single digit palindromes\n    for i in range(k):\n        dp[0][i] = 1\n    \n    # Fill DP table\n    for length in range(1, n):\n        prefix_sum = [0] * k\n        for remainder in range(k):\n            prefix_sum[remainder] = (prefix_sum[remainder - 1] + dp[length - 1][remainder]) % MOD\n        \n        for remainder in range(k):\n            for i in range(1, 10):\n                new_remainder = (remainder + i) % k\n                dp[length][(new_remainder * 10 + i) % k] += prefix_sum[new_remainder]\n                dp[length][(new_remainder * 10 + i) % k] %= MOD\n    \n    # Sum up all valid counts for n-digit numbers\n    result = 0\n    for remainder in range(k):\n        result += dp[n - 1][remainder]\n        result %= MOD\n    \n    return result\n```", "```python\ndef countGoodIntegers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_valid_numbers(digits):\n        from collections import Counter\n        count = Counter(digits)\n        half_digits = []\n        odd_digit = None\n        \n        for digit, freq in count.items():\n            half_digits.extend([digit] * (freq // 2))\n            if freq % 2 == 1:\n                odd_digit = digit\n        \n        half_length = len(half_digits)\n        total_count = 0\n        \n        # Generate all permutations of half_digits\n        from itertools import permutations\n        for perm in set(permutations(half_digits)):\n            full_number = int(''.join(perm) + ''.join(reversed(perm)))\n            if odd_digit is not None:\n                full_number = int(''.join(perm) + odd_digit + ''.join(reversed(perm)))\n            \n            if is_palindrome(full_number) and full_number % k == 0:\n                total_count += 1\n        \n        return total_count\n    \n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    digits = [str(i) for i in range(1, 10)] * (n // 9) + [str(i) for i in range(1, n % 9 + 1)]\n    return count_valid_numbers(digits)\n```", "def countGoodIntegers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    if n == 2:\n        return len([i * 10 + i for i in range(1, 10) if (i * 10 + i) % k == 0])\n    dp = [[0] * (k * n) for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k * n):\n            for d in range(1, 10):\n                if j - d >= 0:\n                    dp[i][j] += dp[i-1][j-d]\n    return sum(dp[-1])"]}
{"task_id": "3560", "codes": ["def min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_alice_moves(kx, ky, positions):\n    @lru_cache(None)\n    def dp(positions_left, alice_turn):\n        if not positions_left:\n            return 0\n        \n        max_moves = float('-inf') if alice_turn else float('inf')\n        \n        for i, (px, py) in enumerate(positions_left):\n            moves = min_moves_to_capture(kx, ky, px, py)\n            new_positions = positions_left[:i] + positions_left[i+1:]\n            \n            if alice_turn:\n                max_moves = max(max_moves, moves + dp(new_positions, False))\n            else:\n                max_moves = min(max_moves, moves + dp(new_positions, True))\n        \n        return max_moves\n    \n    return dp(tuple(sorted(positions)), True)\n\n# Example usage:\nprint(max_alice_moves(1, 1, [(0, 0)]))  # Output: 4\nprint(max_alice_moves(0, 2, [(1, 1), (2, 2), (3, 3)]))  # Output: 8\nprint(max_alice_moves(0, 0, [(1, 2), (2, 4)]))  # Output: 3", "from collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, moves = queue.popleft()\n        if x == px and y == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return -1\n\ndef max_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    if (kx, ky, tuple(sorted(positions))) in memo:\n        return memo[(kx, ky, tuple(sorted(positions)))]\n    \n    max_moves_count = 0\n    for px, py in positions:\n        moves = min_moves_to_capture(kx, ky, px, py)\n        if moves != -1:\n            remaining_positions = [pos for pos in positions if pos != (px, py)]\n            opponent_moves = max_moves(px, py, remaining_positions, memo)\n            max_moves_count = max(max_moves_count, moves + opponent_moves)\n    \n    memo[(kx, ky, tuple(sorted(positions)))] = max_moves_count\n    return max_moves_count\n\ndef knight_game(kx, ky, positions):\n    memo = {}\n    return max_moves(kx, ky, positions, memo)\n\ndef solve(kx, ky, positions):\n    return knight_game(kx, ky, positions)", "from collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if (cx, cy) == (px, py):\n            return moves + 1\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    moves = []\n    \n    for px, py in positions:\n        moves.append(min_moves_to_capture(kx, ky, px, py))\n    \n    def dfs(index, alice_turn, total_moves):\n        if index == n:\n            return total_moves\n        \n        if alice_turn:\n            max_moves = 0\n            for i in range(n):\n                if moves[i] != float('inf'):\n                    new_total_moves = total_moves + moves[i]\n                    moves[i] = float('inf')\n                    max_moves = max(max_moves, dfs(i, False, new_total_moves))\n                    moves[i] = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n            return max_moves\n        else:\n            min_moves = float('inf')\n            for i in range(n):\n                if moves[i] != float('inf'):\n                    new_total_moves = total_moves + moves[i]\n                    moves[i] = float('inf')\n                    min_moves = min(min_moves, dfs(i, True, new_total_moves))\n                    moves[i] = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n            return min_moves\n    \n    return dfs(0, True, 0)\n\ndef solution(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)", "def min_moves_to_capture(kx, ky, px, py):\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_total_moves(kx, ky, positions):\n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        if turn == 'A':\n            max_moves = 0\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                remaining_pawns = pawns[:i] + pawns[i+1:]\n                max_moves = max(max_moves, moves + dfs(remaining_pawns, 'B'))\n            return max_moves\n        else:\n            min_moves = float('inf')\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                remaining_pawns = pawns[:i] + pawns[i+1:]\n                min_moves = min(min_moves, moves + dfs(remaining_pawns, 'A'))\n            return min_moves\n    \n    return dfs(positions, 'A')\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3"], "passed": [false, false, false, false], "raw_code": ["```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_alice_moves(kx, ky, positions):\n    @lru_cache(None)\n    def dp(positions_left, alice_turn):\n        if not positions_left:\n            return 0\n        \n        max_moves = float('-inf') if alice_turn else float('inf')\n        \n        for i, (px, py) in enumerate(positions_left):\n            moves = min_moves_to_capture(kx, ky, px, py)\n            new_positions = positions_left[:i] + positions_left[i+1:]\n            \n            if alice_turn:\n                max_moves = max(max_moves, moves + dp(new_positions, False))\n            else:\n                max_moves = min(max_moves, moves + dp(new_positions, True))\n        \n        return max_moves\n    \n    return dp(tuple(sorted(positions)), True)\n\n# Example usage:\nprint(max_alice_moves(1, 1, [(0, 0)]))  # Output: 4\nprint(max_alice_moves(0, 2, [(1, 1), (2, 2), (3, 3)]))  # Output: 8\nprint(max_alice_moves(0, 0, [(1, 2), (2, 4)]))  # Output: 3\n```", "```python\nfrom collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, moves = queue.popleft()\n        if x == px and y == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return -1\n\ndef max_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    if (kx, ky, tuple(sorted(positions))) in memo:\n        return memo[(kx, ky, tuple(sorted(positions)))]\n    \n    max_moves_count = 0\n    for px, py in positions:\n        moves = min_moves_to_capture(kx, ky, px, py)\n        if moves != -1:\n            remaining_positions = [pos for pos in positions if pos != (px, py)]\n            opponent_moves = max_moves(px, py, remaining_positions, memo)\n            max_moves_count = max(max_moves_count, moves + opponent_moves)\n    \n    memo[(kx, ky, tuple(sorted(positions)))] = max_moves_count\n    return max_moves_count\n\ndef knight_game(kx, ky, positions):\n    memo = {}\n    return max_moves(kx, ky, positions, memo)\n\ndef solve(kx, ky, positions):\n    return knight_game(kx, ky, positions)\n```", "```python\nfrom collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if (cx, cy) == (px, py):\n            return moves + 1\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    \n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    moves = []\n    \n    for px, py in positions:\n        moves.append(min_moves_to_capture(kx, ky, px, py))\n    \n    def dfs(index, alice_turn, total_moves):\n        if index == n:\n            return total_moves\n        \n        if alice_turn:\n            max_moves = 0\n            for i in range(n):\n                if moves[i] != float('inf'):\n                    new_total_moves = total_moves + moves[i]\n                    moves[i] = float('inf')\n                    max_moves = max(max_moves, dfs(i, False, new_total_moves))\n                    moves[i] = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n            return max_moves\n        else:\n            min_moves = float('inf')\n            for i in range(n):\n                if moves[i] != float('inf'):\n                    new_total_moves = total_moves + moves[i]\n                    moves[i] = float('inf')\n                    min_moves = min(min_moves, dfs(i, True, new_total_moves))\n                    moves[i] = min_moves_to_capture(kx, ky, positions[i][0], positions[i][1])\n            return min_moves\n    \n    return dfs(0, True, 0)\n\ndef solution(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)\n```", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_total_moves(kx, ky, positions):\n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        if turn == 'A':\n            max_moves = 0\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                remaining_pawns = pawns[:i] + pawns[i+1:]\n                max_moves = max(max_moves, moves + dfs(remaining_pawns, 'B'))\n            return max_moves\n        else:\n            min_moves = float('inf')\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                remaining_pawns = pawns[:i] + pawns[i+1:]\n                min_moves = min(min_moves, moves + dfs(remaining_pawns, 'A'))\n            return min_moves\n    \n    return dfs(positions, 'A')\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```"]}
{"task_id": "3532", "codes": ["def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node, parent, time):\n        nonlocal max_time\n        times[node] = time\n        max_time = max(max_time, time)\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 2 if node % 2 == 0 else time + 1)\n\n    times = [-1] * n\n    max_time = 0\n    dfs(0, -1, 0)\n    return times", "def minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Step 2: Calculate levels using BFS\n    levels = {}\n    visited = set()\n    queue = deque([(0, 0)])  # (node, level)\n    while queue:\n        node, level = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            levels[node] = level\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, level + 1))\n    \n    # Step 3: Simulate marking process for each node\n    def max_mark_time(start_node):\n        marked = set([start_node])\n        time = 0\n        while len(marked) < n:\n            next_level = set()\n            for node in marked:\n                for neighbor in tree[node]:\n                    if neighbor not in marked:\n                        next_level.add(neighbor)\n            marked.update(next_level)\n            time += 1\n        return time\n    \n    # Step 4: Construct the result array\n    times = []\n    for i in range(n):\n        times.append(max_mark_time(i))\n    \n    return times", "def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        visited = set()\n        queue = deque([(start, 0)])\n        marking_times = [0] * n\n        \n        while queue:\n            node, time = queue.popleft()\n            if node not in visited:\n                visited.add(node)\n                marking_times[node] = time\n                \n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        if node % 2 == 0:\n                            queue.append((neighbor, time + 2))\n                        else:\n                            queue.append((neighbor, time + 1))\n        \n        return marking_times\n    \n    times = []\n    for i in range(n):\n        times.append(bfs(i))\n    \n    return times", "def min_time_to_mark_nodes(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    times = [0] * n\n    queue = [i for i in range(n) if i % 2 == 0]\n    time = 0\n\n    while queue:\n        next_queue = []\n        time += 1\n        for node in queue:\n            for neighbor in graph[node]:\n                if times[neighbor] == 0 and neighbor % 2 == 1:\n                    times[neighbor] = time\n                    next_queue.append(neighbor)\n                elif times[neighbor] == 0 and neighbor % 2 == 0:\n                    times[neighbor] = time - 1\n                    next_queue.append(neighbor)\n        queue = next_queue\n\n    return times[1:]"], "passed": [false, false, false, false], "raw_code": ["def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node, parent, time):\n        nonlocal max_time\n        times[node] = time\n        max_time = max(max_time, time)\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 2 if node % 2 == 0 else time + 1)\n\n    times = [-1] * n\n    max_time = 0\n    dfs(0, -1, 0)\n    return times", "```python\ndef minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Step 2: Calculate levels using BFS\n    levels = {}\n    visited = set()\n    queue = deque([(0, 0)])  # (node, level)\n    while queue:\n        node, level = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            levels[node] = level\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, level + 1))\n    \n    # Step 3: Simulate marking process for each node\n    def max_mark_time(start_node):\n        marked = set([start_node])\n        time = 0\n        while len(marked) < n:\n            next_level = set()\n            for node in marked:\n                for neighbor in tree[node]:\n                    if neighbor not in marked:\n                        next_level.add(neighbor)\n            marked.update(next_level)\n            time += 1\n        return time\n    \n    # Step 4: Construct the result array\n    times = []\n    for i in range(n):\n        times.append(max_mark_time(i))\n    \n    return times\n```", "```python\ndef minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        visited = set()\n        queue = deque([(start, 0)])\n        marking_times = [0] * n\n        \n        while queue:\n            node, time = queue.popleft()\n            if node not in visited:\n                visited.add(node)\n                marking_times[node] = time\n                \n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        if node % 2 == 0:\n                            queue.append((neighbor, time + 2))\n                        else:\n                            queue.append((neighbor, time + 1))\n        \n        return marking_times\n    \n    times = []\n    for i in range(n):\n        times.append(bfs(i))\n    \n    return times\n```", "def min_time_to_mark_nodes(edges):\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    times = [0] * n\n    queue = [i for i in range(n) if i % 2 == 0]\n    time = 0\n\n    while queue:\n        next_queue = []\n        time += 1\n        for node in queue:\n            for neighbor in graph[node]:\n                if times[neighbor] == 0 and neighbor % 2 == 1:\n                    times[neighbor] = time\n                    next_queue.append(neighbor)\n                elif times[neighbor] == 0 and neighbor % 2 == 0:\n                    times[neighbor] = time - 1\n                    next_queue.append(neighbor)\n        queue = next_queue\n\n    return times[1:]"]}
{"task_id": "3575", "codes": ["def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    # Convert each number to its binary representation and sort based on the most significant bit\n    nums.sort(key=lambda x: bin(x)[2:].zfill(7))\n    \n    max_xor = 0\n    \n    # Iterate through the sorted list and form pairs\n    for i in range(k):\n        xor_val = 0\n        for j in range(i, n, k):\n            xor_val |= nums[j]\n        max_xor = max(max_xor, xor_val)\n    \n    return max_xor", "def max_xor_subsequence(nums, k):\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = nums[i]\n    \n    for length in range(2, 2 * k + 1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            for mid in range(start, end):\n                dp[start][end] = max(dp[start][end], dp[start][mid] ^ dp[mid + 1][end])\n    \n    return dp[0][-1]", "def max_value(nums, k):\n    n = len(nums)\n    dp = [0] * (n // 2)\n    \n    for i in range(k):\n        new_dp = [0] * (n // 2)\n        for j in range(n // 2):\n            if dp[j] != 0:\n                new_dp[j | nums[i]] = max(new_dp[j | nums[i]], dp[j])\n                new_dp[nums[i]] = max(new_dp[nums[i]], dp[j])\n        dp = new_dp\n    \n    return dp[-1]", "def max_value(nums, k):\n    import heapq\n    \n    # Split the array into two parts of size k\n    first_part = nums[:k]\n    second_part = nums[k:]\n    \n    # Use priority queues to keep track of the maximum elements in each part\n    first_max_heap = [-num for num in first_part]\n    second_max_heap = [-num for num in second_part]\n    \n    heapq.heapify(first_max_heap)\n    heapq.heapify(second_max_heap)\n    \n    # Calculate the XOR value for all possible pairs of elements from the two parts\n    max_xor = 0\n    for _ in range(k):\n        max_first = -heapq.heappop(first_max_heap)\n        max_second = -heapq.heappop(second_max_heap)\n        xor_value = max_first ^ max_second\n        if xor_value > max_xor:\n            max_xor = xor_value\n        \n        # Push the next element back into the heap\n        if len(first_part) > k:\n            heapq.heappush(first_max_heap, -first_part[k])\n            k += 1\n        if len(second_part) > k:\n            heapq.heappush(second_max_heap, -second_part[k])\n            k += 1\n    \n    return max_xor"], "passed": [false, false, false, false], "raw_code": ["```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    # Convert each number to its binary representation and sort based on the most significant bit\n    nums.sort(key=lambda x: bin(x)[2:].zfill(7))\n    \n    max_xor = 0\n    \n    # Iterate through the sorted list and form pairs\n    for i in range(k):\n        xor_val = 0\n        for j in range(i, n, k):\n            xor_val |= nums[j]\n        max_xor = max(max_xor, xor_val)\n    \n    return max_xor\n```", "```python\ndef max_xor_subsequence(nums, k):\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = nums[i]\n    \n    for length in range(2, 2 * k + 1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            for mid in range(start, end):\n                dp[start][end] = max(dp[start][end], dp[start][mid] ^ dp[mid + 1][end])\n    \n    return dp[0][-1]\n```", "```python\ndef max_value(nums, k):\n    n = len(nums)\n    dp = [0] * (n // 2)\n    \n    for i in range(k):\n        new_dp = [0] * (n // 2)\n        for j in range(n // 2):\n            if dp[j] != 0:\n                new_dp[j | nums[i]] = max(new_dp[j | nums[i]], dp[j])\n                new_dp[nums[i]] = max(new_dp[nums[i]], dp[j])\n        dp = new_dp\n    \n    return dp[-1]\n```", "```python\ndef max_value(nums, k):\n    import heapq\n    \n    # Split the array into two parts of size k\n    first_part = nums[:k]\n    second_part = nums[k:]\n    \n    # Use priority queues to keep track of the maximum elements in each part\n    first_max_heap = [-num for num in first_part]\n    second_max_heap = [-num for num in second_part]\n    \n    heapq.heapify(first_max_heap)\n    heapq.heapify(second_max_heap)\n    \n    # Calculate the XOR value for all possible pairs of elements from the two parts\n    max_xor = 0\n    for _ in range(k):\n        max_first = -heapq.heappop(first_max_heap)\n        max_second = -heapq.heappop(second_max_heap)\n        xor_value = max_first ^ max_second\n        if xor_value > max_xor:\n            max_xor = xor_value\n        \n        # Push the next element back into the heap\n        if len(first_part) > k:\n            heapq.heappush(first_max_heap, -first_part[k])\n            k += 1\n        if len(second_part) > k:\n            heapq.heappush(second_max_heap, -second_part[k])\n            k += 1\n    \n    return max_xor\n```"]}
{"task_id": "3550", "codes": ["def placeRooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(board[i]) for i in range(m)]\n    col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n    \n    rows = sorted(range(m), key=lambda x: row_sums[x], reverse=True)\n    cols = sorted(range(n), key=lambda x: col_sums[x], reverse=True)\n    \n    selected_rows = []\n    selected_cols = []\n    selected_count = 0\n    \n    for row in rows:\n        if selected_count == 3:\n            break\n        if all(row not in selected_rows and col not in selected_cols for col in selected_cols):\n            selected_rows.append(row)\n            selected_count += 1\n    \n    for col in cols:\n        if selected_count == 3:\n            break\n        if all(row not in selected_rows and col not in selected_cols for row in selected_rows):\n            selected_cols.append(col)\n            selected_count += 1\n    \n    max_sum = 0\n    for row in selected_rows:\n        for col in selected_cols:\n            max_sum += board[row][col]\n    \n    return max_sum", "def max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    selected_cols = set()\n    total_sum = 0\n    \n    for i in range(rows):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(cols):\n            if j not in selected_cols and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        selected_cols.add(max_col)\n        total_sum += max_val\n    \n    return total_sum", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    def backtrack(row, cols_used, current_sum):\n        if row == m:\n            return current_sum\n        \n        max_val = float('-inf')\n        for col in range(n):\n            if col not in cols_used and board[row][col] != 0:\n                new_cols_used = cols_used | {col}\n                max_val = max(max_val, backtrack(row + 1, new_cols_used, current_sum + board[row][col]))\n        \n        return max_val\n    \n    return backtrack(0, set(), 0)", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero values\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure we have enough non-zero rows and columns to place three rooks\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Initialize the maximum sum\n    max_sum = float('-inf')\n    \n    # Try all combinations of three non-attacking rooks\n    for r1 in non_zero_rows:\n        for c1 in non_zero_cols:\n            for r2 in non_zero_rows:\n                if r2 == r1:\n                    continue\n                for c2 in non_zero_cols:\n                    if c2 == c1 or c2 == c1:\n                        continue\n                    for r3 in non_zero_rows:\n                        if r3 == r1 or r3 == r2:\n                            continue\n                        for c3 in non_zero_cols:\n                            if c3 == c1 or c3 == c2 or c3 == c1:\n                                continue\n                            current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                            max_sum = max(max_sum, current_sum)\n    \n    return max_sum"], "passed": [false, false, false, false], "raw_code": ["```python\ndef placeRooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(board[i]) for i in range(m)]\n    col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n    \n    rows = sorted(range(m), key=lambda x: row_sums[x], reverse=True)\n    cols = sorted(range(n), key=lambda x: col_sums[x], reverse=True)\n    \n    selected_rows = []\n    selected_cols = []\n    selected_count = 0\n    \n    for row in rows:\n        if selected_count == 3:\n            break\n        if all(row not in selected_rows and col not in selected_cols for col in selected_cols):\n            selected_rows.append(row)\n            selected_count += 1\n    \n    for col in cols:\n        if selected_count == 3:\n            break\n        if all(row not in selected_rows and col not in selected_cols for row in selected_rows):\n            selected_cols.append(col)\n            selected_count += 1\n    \n    max_sum = 0\n    for row in selected_rows:\n        for col in selected_cols:\n            max_sum += board[row][col]\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    selected_cols = set()\n    total_sum = 0\n    \n    for i in range(rows):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(cols):\n            if j not in selected_cols and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        selected_cols.add(max_col)\n        total_sum += max_val\n    \n    return total_sum\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    def backtrack(row, cols_used, current_sum):\n        if row == m:\n            return current_sum\n        \n        max_val = float('-inf')\n        for col in range(n):\n            if col not in cols_used and board[row][col] != 0:\n                new_cols_used = cols_used | {col}\n                max_val = max(max_val, backtrack(row + 1, new_cols_used, current_sum + board[row][col]))\n        \n        return max_val\n    \n    return backtrack(0, set(), 0)\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero values\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure we have enough non-zero rows and columns to place three rooks\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Initialize the maximum sum\n    max_sum = float('-inf')\n    \n    # Try all combinations of three non-attacking rooks\n    for r1 in non_zero_rows:\n        for c1 in non_zero_cols:\n            for r2 in non_zero_rows:\n                if r2 == r1:\n                    continue\n                for c2 in non_zero_cols:\n                    if c2 == c1 or c2 == c1:\n                        continue\n                    for r3 in non_zero_rows:\n                        if r3 == r1 or r3 == r2:\n                            continue\n                        for c3 in non_zero_cols:\n                            if c3 == c1 or c3 == c2 or c3 == c1:\n                                continue\n                            current_sum = board[r1][c1] + board[r2][c2] + board[r3][c3]\n                            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"]}
{"task_id": "3527", "codes": ["def create_segment_tree(n):\n    tree = [None] * (4 * n)\n    lazy = [False] * (4 * n)\n    return tree, lazy\n\ndef push_down(tree, lazy, node, start, end):\n    if lazy[node]:\n        mid = (start + end) // 2\n        if tree[node] is None:\n            tree[node] = [0] * (end - start + 1)\n        tree[2 * node] = tree[node][:mid - start + 1]\n        tree[2 * node + 1] = tree[node][mid - start + 1:]\n        lazy[2 * node] = not lazy[2 * node]\n        lazy[2 * node + 1] = not lazy[2 * node + 1]\n        lazy[node] = False\n\ndef update_segment_tree(tree, lazy, node, start, end, idx, new_val):\n    if start > end or idx < start or idx > end:\n        return\n    if start == end:\n        tree[node][idx - start] = new_val\n        return\n    mid = (start + end) // 2\n    push_down(tree, lazy, node, start, end)\n    update_segment_tree(tree, lazy, 2 * node, start, mid, idx, new_val)\n    update_segment_tree(tree, lazy, 2 * node + 1, mid + 1, end, idx, new_val)\n    tree[node] = tree[2 * node] + tree[2 * node + 1]\n\ndef query_alternating_groups(tree, lazy, node, start, end, size):\n    if start > end or size > end - start + 1:\n        return 0\n    if start == end:\n        return 1 if size == 1 else 0\n    mid = (start + end) // 2\n    push_down(tree, lazy, node, start, end)\n    left_count = query_alternating_groups(tree, lazy, 2 * node, start, mid, size)\n    right_count = query_alternating_groups(tree, lazy, 2 * node + 1, mid + 1, end, size)\n    if tree[2 * node][-1] != tree[2 * node + 1][0]:\n        left_count += query_alternating_groups(tree, lazy, 2 * node, start, mid, size - 1)\n        right_count += query_alternating_groups(tree, lazy, 2 * node + 1, mid + 1, end, size - 1)\n    return max(left_count, right_count)\n\ndef process_queries(colors, queries):\n    n = len(colors)\n    tree, lazy = create_segment_tree(n)\n    for i in range(n):\n        update_segment_tree(tree, lazy, 1, 0, n - 1, i, colors[i])\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(query_alternating_groups(tree, lazy, 1, 0, n - 1, size))\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            update_segment_tree(tree, lazy, 1, 0, n - 1, index, color)\n    \n    return result", "def count_alternating_groups(colors, queries):\n    n = len(colors)\n    prefix_sum = [0] * (n + 1)\n    \n    # Initialize prefix sums\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + colors[i]\n    \n    def get_prefix_sum(index):\n        return prefix_sum[(index % n)]\n    \n    def count_alternating_group_size(size):\n        count = 0\n        for start in range(n):\n            end = (start + size) % n\n            if (get_prefix_sum(end) - get_prefix_sum(start)) % size == size // 2:\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_group_size(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            colors[index] = new_color\n            prefix_sum[index + 1] = prefix_sum[index] + new_color - colors[index]\n    \n    return result", "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors[:2]  # Extend colors to simulate circular arrangement\n    result = []\n\n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n        return count\n\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            colors[index] = new_color\n\n    return result", "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend colors to simulate circular nature\n    group_counts = {}\n    \n    def count_alternating_groups(size):\n        if size not in group_counts:\n            count = 0\n            for i in range(n):\n                if colors[i] != colors[(i + size) % n]:\n                    j = i + 1\n                    while j < i + size and colors[j] != colors[(j - 1) % n]:\n                        j += 1\n                    if j == i + size:\n                        count += 1\n            group_counts[size] = count\n        return group_counts[size]\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            colors[index] = new_color\n            \n            # Update group counts\n            for size in range(3, n + 1):\n                if old_color != new_color:\n                    if (index - 1) % n != (index + size - 1) % n:\n                        group_counts[size] -= 1\n                    if (index - size + 1) % n != (index + 1) % n:\n                        group_counts[size] -= 1\n                else:\n                    if (index - 1) % n != (index + size - 1) % n:\n                        group_counts[size] += 1\n                    if (index - size + 1) % n != (index + 1) % n:\n                        group_counts[size] += 1\n    \n    return result"], "passed": [false, false, false, false], "raw_code": ["```python\ndef create_segment_tree(n):\n    tree = [None] * (4 * n)\n    lazy = [False] * (4 * n)\n    return tree, lazy\n\ndef push_down(tree, lazy, node, start, end):\n    if lazy[node]:\n        mid = (start + end) // 2\n        if tree[node] is None:\n            tree[node] = [0] * (end - start + 1)\n        tree[2 * node] = tree[node][:mid - start + 1]\n        tree[2 * node + 1] = tree[node][mid - start + 1:]\n        lazy[2 * node] = not lazy[2 * node]\n        lazy[2 * node + 1] = not lazy[2 * node + 1]\n        lazy[node] = False\n\ndef update_segment_tree(tree, lazy, node, start, end, idx, new_val):\n    if start > end or idx < start or idx > end:\n        return\n    if start == end:\n        tree[node][idx - start] = new_val\n        return\n    mid = (start + end) // 2\n    push_down(tree, lazy, node, start, end)\n    update_segment_tree(tree, lazy, 2 * node, start, mid, idx, new_val)\n    update_segment_tree(tree, lazy, 2 * node + 1, mid + 1, end, idx, new_val)\n    tree[node] = tree[2 * node] + tree[2 * node + 1]\n\ndef query_alternating_groups(tree, lazy, node, start, end, size):\n    if start > end or size > end - start + 1:\n        return 0\n    if start == end:\n        return 1 if size == 1 else 0\n    mid = (start + end) // 2\n    push_down(tree, lazy, node, start, end)\n    left_count = query_alternating_groups(tree, lazy, 2 * node, start, mid, size)\n    right_count = query_alternating_groups(tree, lazy, 2 * node + 1, mid + 1, end, size)\n    if tree[2 * node][-1] != tree[2 * node + 1][0]:\n        left_count += query_alternating_groups(tree, lazy, 2 * node, start, mid, size - 1)\n        right_count += query_alternating_groups(tree, lazy, 2 * node + 1, mid + 1, end, size - 1)\n    return max(left_count, right_count)\n\ndef process_queries(colors, queries):\n    n = len(colors)\n    tree, lazy = create_segment_tree(n)\n    for i in range(n):\n        update_segment_tree(tree, lazy, 1, 0, n - 1, i, colors[i])\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(query_alternating_groups(tree, lazy, 1, 0, n - 1, size))\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            update_segment_tree(tree, lazy, 1, 0, n - 1, index, color)\n    \n    return result\n```", "```python\ndef count_alternating_groups(colors, queries):\n    n = len(colors)\n    prefix_sum = [0] * (n + 1)\n    \n    # Initialize prefix sums\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + colors[i]\n    \n    def get_prefix_sum(index):\n        return prefix_sum[(index % n)]\n    \n    def count_alternating_group_size(size):\n        count = 0\n        for start in range(n):\n            end = (start + size) % n\n            if (get_prefix_sum(end) - get_prefix_sum(start)) % size == size // 2:\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_group_size(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            colors[index] = new_color\n            prefix_sum[index + 1] = prefix_sum[index] + new_color - colors[index]\n    \n    return result\n```", "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors[:2]  # Extend colors to simulate circular arrangement\n    result = []\n\n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n        return count\n\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            colors[index] = new_color\n\n    return result", "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend colors to simulate circular nature\n    group_counts = {}\n    \n    def count_alternating_groups(size):\n        if size not in group_counts:\n            count = 0\n            for i in range(n):\n                if colors[i] != colors[(i + size) % n]:\n                    j = i + 1\n                    while j < i + size and colors[j] != colors[(j - 1) % n]:\n                        j += 1\n                    if j == i + size:\n                        count += 1\n            group_counts[size] = count\n        return group_counts[size]\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            colors[index] = new_color\n            \n            # Update group counts\n            for size in range(3, n + 1):\n                if old_color != new_color:\n                    if (index - 1) % n != (index + size - 1) % n:\n                        group_counts[size] -= 1\n                    if (index - size + 1) % n != (index + 1) % n:\n                        group_counts[size] -= 1\n                else:\n                    if (index - 1) % n != (index + size - 1) % n:\n                        group_counts[size] += 1\n                    if (index - size + 1) % n != (index + 1) % n:\n                        group_counts[size] += 1\n    \n    return result\n```"]}
{"task_id": "3551", "codes": ["def max_xor_score(nums):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Preprocess the prefix XOR array\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ nums[i - 1]\n    \n    return prefix_xor\n\ndef answer_queries(nums, queries):\n    prefix_xor = max_xor_score(nums)\n    result = []\n    \n    # Answer each query\n    for l, r in queries:\n        if l == 0:\n            result.append(prefix_xor[r + 1])\n        else:\n            result.append(prefix_xor[r + 1] ^ prefix_xor[l])\n    \n    return result\n\ndef solve(nums, queries):\n    return answer_queries(nums, queries)", "def max_xor(nums, queries):\n    def max_xor_subarray(arr):\n        prefix_xor = [0]\n        max_xor_val = 0\n        current_xor = 0\n        trie = {}\n        \n        for num in arr:\n            current_xor ^= num\n            prefix_xor.append(current_xor)\n            node = trie\n            xor_val = 0\n            \n            for i in range(31, -1, -1):\n                bit = (current_xor >> i) & 1\n                if bit not in node:\n                    node[bit] = {}\n                node = node[bit]\n                if 1 - bit in node:\n                    xor_val |= (1 << i)\n            \n            max_xor_val = max(max_xor_val, xor_val)\n        \n        return max_xor_val\n    \n    results = []\n    for l, r in queries:\n        subarray = nums[l:r+1]\n        max_xor_val = max_xor_subarray(subarray)\n        results.append(max_xor_val)\n    \n    return results", "def max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute the prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        max_xor = 0\n        current_xor = 0\n        \n        # Iterate through the subarray to find the maximum XOR score\n        for i in range(l, r + 1):\n            current_xor ^= nums[i]\n            max_xor = max(max_xor, current_xor)\n        \n        result.append(max_xor)\n    \n    return result", "def xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        max_xor = 0\n        for i in range(l, r + 1):\n            xor_score = prefix_xor[i] ^ prefix_xor[r + 1]\n            max_xor = max(max_xor, xor_score)\n        result.append(max_xor)\n    \n    return result"], "passed": [false, false, false, false], "raw_code": ["```python\ndef max_xor_score(nums):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Preprocess the prefix XOR array\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ nums[i - 1]\n    \n    return prefix_xor\n\ndef answer_queries(nums, queries):\n    prefix_xor = max_xor_score(nums)\n    result = []\n    \n    # Answer each query\n    for l, r in queries:\n        if l == 0:\n            result.append(prefix_xor[r + 1])\n        else:\n            result.append(prefix_xor[r + 1] ^ prefix_xor[l])\n    \n    return result\n\ndef solve(nums, queries):\n    return answer_queries(nums, queries)\n```", "```python\ndef max_xor(nums, queries):\n    def max_xor_subarray(arr):\n        prefix_xor = [0]\n        max_xor_val = 0\n        current_xor = 0\n        trie = {}\n        \n        for num in arr:\n            current_xor ^= num\n            prefix_xor.append(current_xor)\n            node = trie\n            xor_val = 0\n            \n            for i in range(31, -1, -1):\n                bit = (current_xor >> i) & 1\n                if bit not in node:\n                    node[bit] = {}\n                node = node[bit]\n                if 1 - bit in node:\n                    xor_val |= (1 << i)\n            \n            max_xor_val = max(max_xor_val, xor_val)\n        \n        return max_xor_val\n    \n    results = []\n    for l, r in queries:\n        subarray = nums[l:r+1]\n        max_xor_val = max_xor_subarray(subarray)\n        results.append(max_xor_val)\n    \n    return results\n```", "```python\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute the prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        max_xor = 0\n        current_xor = 0\n        \n        # Iterate through the subarray to find the maximum XOR score\n        for i in range(l, r + 1):\n            current_xor ^= nums[i]\n            max_xor = max(max_xor, current_xor)\n        \n        result.append(max_xor)\n    \n    return result\n```", "```python\ndef xorQueries(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        max_xor = 0\n        for i in range(l, r + 1):\n            xor_score = prefix_xor[i] ^ prefix_xor[r + 1]\n            max_xor = max(max_xor, xor_score)\n        result.append(max_xor)\n    \n    return result\n```"]}
{"task_id": "3580", "codes": ["def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1", "def smallest_almost_equal_substring(s, pattern):\n    n = len(s)\n    m = len(pattern)\n    min_index = -1\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            min_index = i\n            break\n    \n    return min_index", "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count == 1:\n            return i\n    \n    return -1", "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    n, m = len(s), len(pattern)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    return -1"], "passed": [false, false, false, false], "raw_code": ["```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```", "```python\ndef smallest_almost_equal_substring(s, pattern):\n    n = len(s)\n    m = len(pattern)\n    min_index = -1\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            min_index = i\n            break\n    \n    return min_index\n```", "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count == 1:\n            return i\n    \n    return -1\n```", "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    n, m = len(s), len(pattern)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    return -1\n```"]}
