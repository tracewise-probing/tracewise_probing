"{\"difficulty\": \"easy\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"AIDC-AI/Marco-o1\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majoritybug_trace_TPL_OUR01_marcon-o1_n_16_easy.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"AIDC-AI/Marco-o1\", \"api_base\": \"http://10.96.183.224:63019/8002/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3555", "code": "def replace_min_with_multiplier(nums, k, multiplier):\n    for _ in range(k):\n        min_val = min(nums)\n        min_index = nums.index(min_val)\n        nums[min_index] = min_val * multiplier\n    return nums\n", "passed": true, "raw_code": "def replace_min_with_multiplier(nums, k, multiplier):\n    for _ in range(k):\n        min_val = min(nums)\n        min_index = nums.index(min_val)\n        nums[min_index] = min_val * multiplier\n    return nums\n"}
{"task_id": "3606", "code": "def min_after_digit_sum(nums):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(n))\n    \n    nums = list(map(digit_sum, nums))\n    return min(nums)\n", "passed": true, "raw_code": "def min_after_digit_sum(nums):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(n))\n    \n    nums = list(map(digit_sum, nums))\n    return min(nums)\n"}
{"task_id": "3519", "code": "def count_winners(n, pick):\n    # Create a dictionary to store the count of each color for each player\n    color_counts = {}\n    for player, color in pick:\n        if player in color_counts:\n            if color in color_counts[player]:\n                color_counts[player][color] += 1\n            else:\n                color_counts[player][color] = 1\n        else:\n            color_counts[player] = {color: 1}\n    \n    winners = 0\n    for player in range(n):\n        count = sum(color_counts.get(player, {}).values())\n        if count > player:\n            winners += 1\n    return winners\n", "passed": false, "raw_code": "def count_winners(n, pick):\n    # Create a dictionary to store the count of each color for each player\n    color_counts = {}\n    for player, color in pick:\n        if player in color_counts:\n            if color in color_counts[player]:\n                color_counts[player][color] += 1\n            else:\n                color_counts[player][color] = 1\n        else:\n            color_counts[player] = {color: 1}\n    \n    winners = 0\n    for player in range(n):\n        count = sum(color_counts.get(player, {}).values())\n        if count > player:\n            winners += 1\n    return winners\n"}
{"task_id": "3567", "code": "def convert_date_to_binary(date):\n    # Split the date into year, month, and day\n    year, month, day = date.split('-')\n    \n    # Convert each part to integer\n    year_int = int(year)\n    month_int = int(month)\n    day_int = int(day)\n    \n    # Function to convert decimal to binary without leading zeros\n    def decimal_to_binary(n):\n        return bin(n)[2:]\n    \n    # Get binary representations\n    year_bin = decimal_to_binary(year_int)\n    month_bin = decimal_to_binary(month_int)\n    day_bin = decimal_to_binary(day_int)\n    \n    # Combine them in year-month-day format\n    binary_date = f\"{year_bin}-{month_bin}-{day_bin}\"\n    \n    return binary_date\n", "passed": true, "raw_code": "def convert_date_to_binary(date):\n    # Split the date into year, month, and day\n    year, month, day = date.split('-')\n    \n    # Convert each part to integer\n    year_int = int(year)\n    month_int = int(month)\n    day_int = int(day)\n    \n    # Function to convert decimal to binary without leading zeros\n    def decimal_to_binary(n):\n        return bin(n)[2:]\n    \n    # Get binary representations\n    year_bin = decimal_to_binary(year_int)\n    month_bin = decimal_to_binary(month_int)\n    day_bin = decimal_to_binary(day_int)\n    \n    # Combine them in year-month-day format\n    binary_date = f\"{year_bin}-{month_bin}-{day_bin}\"\n    \n    return binary_date\n"}
{"task_id": "3568", "code": "def generate_key(num1, num2, num3):\n    # Convert numbers to strings to easily access individual digits\n    str_num1 = str(num1).zfill(4)\n    str_num2 = str(num2).zfill(4)\n    str_num3 = str(num3).zfill(4)\n    \n    key = ''\n    for i in range(4):\n        # Extract the i-th digit from each number\n        digit1 = int(str_num1[i])\n        digit2 = int(str_num2[i])\n        digit3 = int(str_num3[i])\n        \n        # Find the minimum digit among the three\n        min_digit = min(digit1, digit2, digit3)\n        \n        # Append the minimum digit to the key\n        key += str(min_digit)\n    \n    # Convert the key string back to integer\n    return int(key)\n", "passed": true, "raw_code": "def generate_key(num1, num2, num3):\n    # Convert numbers to strings to easily access individual digits\n    str_num1 = str(num1).zfill(4)\n    str_num2 = str(num2).zfill(4)\n    str_num3 = str(num3).zfill(4)\n    \n    key = ''\n    for i in range(4):\n        # Extract the i-th digit from each number\n        digit1 = int(str_num1[i])\n        digit2 = int(str_num2[i])\n        digit3 = int(str_num3[i])\n        \n        # Find the minimum digit among the three\n        min_digit = min(digit1, digit2, digit3)\n        \n        # Append the minimum digit to the key\n        key += str(min_digit)\n    \n    # Convert the key string back to integer\n    return int(key)\n"}
{"task_id": "3533", "code": "def find_final_position(n, commands):\n    # Initialize the starting position\n    i, j = 0, 0\n    for cmd in commands:\n        if cmd == \"UP\":\n            if i > 0:\n                i -= 1\n        elif cmd == \"DOWN\":\n            if i < n - 1:\n                i += 1\n        elif cmd == \"RIGHT\":\n            if j < n - 1:\n                j += 1\n        elif cmd == \"LEFT\":\n            if j > 0:\n                j -= 1\n    return i * n + j\n", "passed": true, "raw_code": "def find_final_position(n, commands):\n    # Initialize the starting position\n    i, j = 0, 0\n    for cmd in commands:\n        if cmd == \"UP\":\n            if i > 0:\n                i -= 1\n        elif cmd == \"DOWN\":\n            if i < n - 1:\n                i += 1\n        elif cmd == \"RIGHT\":\n            if j < n - 1:\n                j += 1\n        elif cmd == \"LEFT\":\n            if j > 0:\n                j -= 1\n    return i * n + j\n"}
{"task_id": "3543", "code": "def count_k_constrained_substrings(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if s[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            if zeros > k or ones > k:\n                break\n            count += 1\n    return count\n", "passed": false, "raw_code": "def count_k_constrained_substrings(s: str, k: int) -> int:\n    n = len(s)\n    count = 0\n    for i in range(n):\n        zeros = 0\n        ones = 0\n        for j in range(i, n):\n            if s[j] == '0':\n                zeros += 1\n            else:\n                ones += 1\n            if zeros > k or ones > k:\n                break\n            count += 1\n    return count\n"}
{"task_id": "3553", "code": "def same_color(coordinate1, coordinate2):\n    # Define the mapping of columns to numbers\n    columns = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n    \n    # Extract the column and row from both coordinates\n    col1, row1 = coordinate1[0], int(coordinate1[1])\n    col2, row2 = coordinate2[0], int(coordinate2[1])\n    \n    # Convert columns to numerical values\n    col1_num = columns[col1]\n    col2_num = columns[col2]\n    \n    # Determine the color based on the sum of column and row numbers\n    # If the sum is even, the square is black; if odd, it's white\n    color1 = (col1_num + row1) % 2 == 0\n    color2 = (col2_num + row2) % 2 == 0\n    \n    # Compare the colors\n    return color1 == color2\n", "passed": true, "raw_code": "def same_color(coordinate1, coordinate2):\n    # Define the mapping of columns to numbers\n    columns = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8}\n    \n    # Extract the column and row from both coordinates\n    col1, row1 = coordinate1[0], int(coordinate1[1])\n    col2, row2 = coordinate2[0], int(coordinate2[1])\n    \n    # Convert columns to numerical values\n    col1_num = columns[col1]\n    col2_num = columns[col2]\n    \n    # Determine the color based on the sum of column and row numbers\n    # If the sum is even, the square is black; if odd, it's white\n    color1 = (col1_num + row1) % 2 == 0\n    color2 = (col2_num + row2) % 2 == 0\n    \n    # Compare the colors\n    return color1 == color2\n"}
{"task_id": "3600", "code": "def find_kth_character(k):\n    word = \"a\"\n    while len(word) < k:\n        new_word = \"\"\n        for char in word:\n            if char == 'z':\n                new_char = 'a'\n            else:\n                new_char = chr(ord(char) + 1)\n            new_word += new_char\n        word += new_word\n    return word[k - 1]\n", "passed": true, "raw_code": "def find_kth_character(k):\n    word = \"a\"\n    while len(word) < k:\n        new_word = \"\"\n        for char in word:\n            if char == 'z':\n                new_char = 'a'\n            else:\n                new_char = chr(ord(char) + 1)\n            new_word += new_char\n        word += new_word\n    return word[k - 1]\n"}
{"final_accuracy": "77.78%"}
{"difficulty": "easy", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_no_public_tests", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "AIDC-AI/Marco-o1", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majoritybug_trace_TPL_OUR01_marcon-o1_n_16_easy.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "AIDC-AI/Marco-o1", "api_base": "http://127.0.0.1:8003/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc373_a", "code": "def count_matching_lengths():\n    count = 0\n    for i in range(1, 13):\n        line = input()\n        if len(line) == i:\n            count += 1\n    print(count)\n\n# Example usage:\n# count_matching_lengths()\n", "passed": false, "raw_code": "def count_matching_lengths():\n    count = 0\n    for i in range(1, 13):\n        line = input()\n        if len(line) == i:\n            count += 1\n    print(count)\n\n# Example usage:\n# count_matching_lengths()\n"}
{"task_id": "abc372_a", "code": "def remove_dots():\n    import sys\n    S = sys.stdin.readline().strip()\n    result = ''.join([char for char in S if char != '.'])\n    print(result)\n\n# Call the function\nremove_dots()\n", "passed": true, "raw_code": "def remove_dots():\n    import sys\n    S = sys.stdin.readline().strip()\n    result = ''.join([char for char in S if char != '.'])\n    print(result)\n\n# Call the function\nremove_dots()\n"}
{"task_id": "abc370_a", "code": "def check_hand_raising():\n    import sys\n\n    # Read input from stdin\n    line = sys.stdin.readline().strip()\n    \n    # Split the input into two integers\n    L, R = map(int, line.split())\n    \n    # Check the conditions based on the problem statement\n    if (L == 1 and R == 0):\n        print(\"Yes\")\n    elif (L == 0 and R == 1):\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\n# Call the function after its definition\ncheck_hand_raising()\n", "passed": true, "raw_code": "def check_hand_raising():\n    import sys\n\n    # Read input from stdin\n    line = sys.stdin.readline().strip()\n    \n    # Split the input into two integers\n    L, R = map(int, line.split())\n    \n    # Check the conditions based on the problem statement\n    if (L == 1 and R == 0):\n        print(\"Yes\")\n    elif (L == 0 and R == 1):\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\n# Call the function after its definition\ncheck_hand_raising()\n"}
{"task_id": "abc367_a", "code": "def can_shout_takoyaki():\n    # Read input from stdin\n    A, B, C = map(int, input().split())\n    \n    # Determine if Takahashi is awake at A o'clock\n    if A >= B and A < C:\n        print(\"Yes\")\n    elif A < B and A > C:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function after its definition\ncan_shout_takoyaki()\n", "passed": false, "raw_code": "def can_shout_takoyaki():\n    # Read input from stdin\n    A, B, C = map(int, input().split())\n    \n    # Determine if Takahashi is awake at A o'clock\n    if A >= B and A < C:\n        print(\"Yes\")\n    elif A < B and A > C:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function after its definition\ncan_shout_takoyaki()\n"}
{"task_id": "abc366_a", "code": "def determine_election_outcome():\n    import sys\n\n    # Read input from standard input\n    line = sys.stdin.readline()\n    N, T, A = map(int, line.strip().split())\n\n    # Check if the outcome is already decided\n    if (T > A) or (T == A and N - T < A):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function after its definition\ndetermine_election_outcome()\n", "passed": false, "raw_code": "def determine_election_outcome():\n    import sys\n\n    # Read input from standard input\n    line = sys.stdin.readline()\n    N, T, A = map(int, line.strip().split())\n\n    # Check if the outcome is already decided\n    if (T > A) or (T == A and N - T < A):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Call the function after its definition\ndetermine_election_outcome()\n"}
{"task_id": "abc368_a", "code": "def process_stack():\n    import sys\n\n    # Read input from stdin\n    line = sys.stdin.readline().strip()\n    N, K = map(int, line.split())\n\n    # Read the rest of the input\n    line = sys.stdin.readline().strip()\n    A = list(map(int, line.split()))\n\n    # Take K cards from the bottom and move them to the top\n    moved_cards = A[-K:]\n    remaining_cards = A[:-K]\n    new_stack = moved_cards + remaining_cards\n\n    # Print the integers from top to bottom\n    print(' '.join(map(str, new_stack)))\n\n# Call the function\nprocess_stack()\n", "passed": true, "raw_code": "def process_stack():\n    import sys\n\n    # Read input from stdin\n    line = sys.stdin.readline().strip()\n    N, K = map(int, line.split())\n\n    # Read the rest of the input\n    line = sys.stdin.readline().strip()\n    A = list(map(int, line.split()))\n\n    # Take K cards from the bottom and move them to the top\n    moved_cards = A[-K:]\n    remaining_cards = A[:-K]\n    new_stack = moved_cards + remaining_cards\n\n    # Print the integers from top to bottom\n    print(' '.join(map(str, new_stack)))\n\n# Call the function\nprocess_stack()\n"}
{"task_id": "abc365_b", "code": "def find_second_largest():\n    import sys\n\n    # Read input from standard input\n    first_line = sys.stdin.readline().strip()\n    N = int(first_line)\n\n    # Ensure that N is within the constraints\n    if not (2 <= N <= 100):\n        print(\"Invalid number of elements.\")\n        return\n\n    # Read the sequence of integers\n    second_line = sys.stdin.readline().strip()\n    elements = list(map(int, second_line.split()))\n\n    # Ensure all elements are distinct and within the constraints\n    if len(elements) != N or len(set(elements)) != N:\n        print(\"Invalid input: elements must be distinct and within the specified range.\")\n        return\n\n    for num in elements:\n        if not (1 <= num <= 10**9):\n            print(\"Invalid element value.\")\n            return\n\n    # Find the second largest element\n    unique_elements = sorted(set(elements), reverse=True)\n    if len(unique_elements) < 2:\n        print(\"Not enough unique elements to determine the second largest.\")\n        return\n\n    second_largest = unique_elements[1]\n\n    # Find the index of the second largest element\n    index_of_second_largest = elements.index(second_largest) + 1\n\n    print(index_of_second_largest)\n\n# Call the function\nfind_second_largest()\n", "passed": true, "raw_code": "def find_second_largest():\n    import sys\n\n    # Read input from standard input\n    first_line = sys.stdin.readline().strip()\n    N = int(first_line)\n\n    # Ensure that N is within the constraints\n    if not (2 <= N <= 100):\n        print(\"Invalid number of elements.\")\n        return\n\n    # Read the sequence of integers\n    second_line = sys.stdin.readline().strip()\n    elements = list(map(int, second_line.split()))\n\n    # Ensure all elements are distinct and within the constraints\n    if len(elements) != N or len(set(elements)) != N:\n        print(\"Invalid input: elements must be distinct and within the specified range.\")\n        return\n\n    for num in elements:\n        if not (1 <= num <= 10**9):\n            print(\"Invalid element value.\")\n            return\n\n    # Find the second largest element\n    unique_elements = sorted(set(elements), reverse=True)\n    if len(unique_elements) < 2:\n        print(\"Not enough unique elements to determine the second largest.\")\n        return\n\n    second_largest = unique_elements[1]\n\n    # Find the index of the second largest element\n    index_of_second_largest = elements.index(second_largest) + 1\n\n    print(index_of_second_largest)\n\n# Call the function\nfind_second_largest()\n"}
{"task_id": "abc367_b", "code": "def format_number():\n    import sys\n    try:\n        X = float(sys.stdin.readline().strip())\n        if X == int(X):\n            print(int(X))\n        else:\n            # Remove trailing zeros after the decimal point\n            X_str = str(X).rstrip('0').rstrip('.')\n            if X_str[-1] == '.':\n                X_str = X_str[:-1]\n            print(X_str)\n    except ValueError:\n        print(\"Invalid input. Please enter a valid real number.\")\n\n# Call the function\nformat_number()\n", "passed": true, "raw_code": "def format_number():\n    import sys\n    try:\n        X = float(sys.stdin.readline().strip())\n        if X == int(X):\n            print(int(X))\n        else:\n            # Remove trailing zeros after the decimal point\n            X_str = str(X).rstrip('0').rstrip('.')\n            if X_str[-1] == '.':\n                X_str = X_str[:-1]\n            print(X_str)\n    except ValueError:\n        print(\"Invalid input. Please enter a valid real number.\")\n\n# Call the function\nformat_number()\n"}
{"task_id": "abc370_b", "code": "def solve():\n    import sys\n    input = sys.stdin.read().splitlines\n    lines = input()\n    N = int(lines[0])\n    A = []\n    for i in range(1, N+1):\n        row = list(map(int, lines[i].split()))\n        A.append(row)\n    \n    current_element = 1\n    for i in range(1, N+1):\n        current_element = A[i-1][current_element-1]\n    \n    print(current_element)\n\nsolve()\n", "passed": false, "raw_code": "def solve():\n    import sys\n    input = sys.stdin.read().splitlines\n    lines = input()\n    N = int(lines[0])\n    A = []\n    for i in range(1, N+1):\n        row = list(map(int, lines[i].split()))\n        A.append(row)\n    \n    current_element = 1\n    for i in range(1, N+1):\n        current_element = A[i-1][current_element-1]\n    \n    print(current_element)\n\nsolve()\n"}
{"task_id": "abc365_a", "code": "def count_days_in_year():\n    import sys\n\n    # Read input from standard input\n    Y = int(sys.stdin.readline().strip())\n\n    # Validate that Y is within the specified range\n    if not (1583 <= Y <= 2023):\n        print(\"Invalid year. Please enter a year between 1583 and 2023.\")\n        return\n\n    # Determine the number of days in the year based on the Gregorian calendar rules\n    if Y % 400 == 0:\n        days = 366\n    elif Y % 100 == 0:\n        days = 365\n    elif Y % 4 == 0:\n        days = 366\n    else:\n        days = 365\n\n    # Print the result\n    print(days)\n\n# Call the function to execute\ncount_days_in_year()\n", "passed": true, "raw_code": "def count_days_in_year():\n    import sys\n\n    # Read input from standard input\n    Y = int(sys.stdin.readline().strip())\n\n    # Validate that Y is within the specified range\n    if not (1583 <= Y <= 2023):\n        print(\"Invalid year. Please enter a year between 1583 and 2023.\")\n        return\n\n    # Determine the number of days in the year based on the Gregorian calendar rules\n    if Y % 400 == 0:\n        days = 366\n    elif Y % 100 == 0:\n        days = 365\n    elif Y % 4 == 0:\n        days = 366\n    else:\n        days = 365\n\n    # Print the result\n    print(days)\n\n# Call the function to execute\ncount_days_in_year()\n"}
{"task_id": "abc371_b", "code": "def determine_taro_names():\n    import sys\n\n    # Read input\n    N, M = map(int, sys.stdin.readline().split())\n    babies = []\n    for _ in range(M):\n        A, B = map(str, sys.stdin.readline().split())\n        babies.append((int(A), B))\n\n    # Initialize a list to keep track of the earliest born boys in each family\n    earliest_boys = [0] * (N + 1)\n\n    # Iterate through each baby\n    for idx, (family, gender) in enumerate(babies, start=1):\n        if gender == 'M':\n            if earliest_boys[family] == 0:\n                earliest_boys[family] = idx\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n\n# Call the function\ndetermine_taro_names()\n", "passed": true, "raw_code": "def determine_taro_names():\n    import sys\n\n    # Read input\n    N, M = map(int, sys.stdin.readline().split())\n    babies = []\n    for _ in range(M):\n        A, B = map(str, sys.stdin.readline().split())\n        babies.append((int(A), B))\n\n    # Initialize a list to keep track of the earliest born boys in each family\n    earliest_boys = [0] * (N + 1)\n\n    # Iterate through each baby\n    for idx, (family, gender) in enumerate(babies, start=1):\n        if gender == 'M':\n            if earliest_boys[family] == 0:\n                earliest_boys[family] = idx\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n\n# Call the function\ndetermine_taro_names()\n"}
{"task_id": "abc369_b", "code": "def min_fatigue_level():\n    import sys\n\n    # Read the number of presses\n    N = int(sys.stdin.readline())\n\n    # Initialize hands positions and fatigue\n    left_hand = 0\n    right_hand = 0\n    fatigue = 0\n\n    # Dictionary to map hand to position\n    hands = {'L': left_hand, 'R': right_hand}\n\n    # Read each press\n    for _ in range(N):\n        line = sys.stdin.readline().split()\n        key = int(line[0])\n        hand = line[1]\n\n        # If the hand is already on the key, no move needed\n        if hands[hand] == key:\n            continue\n\n        # Move the hand to the key\n        fatigue += abs(key - hands[hand])\n        hands[hand] = key\n\n    # Print the total fatigue\n    print(fatigue)\n\n# Call the function\nmin_fatigue_level()\n", "passed": false, "raw_code": "def min_fatigue_level():\n    import sys\n\n    # Read the number of presses\n    N = int(sys.stdin.readline())\n\n    # Initialize hands positions and fatigue\n    left_hand = 0\n    right_hand = 0\n    fatigue = 0\n\n    # Dictionary to map hand to position\n    hands = {'L': left_hand, 'R': right_hand}\n\n    # Read each press\n    for _ in range(N):\n        line = sys.stdin.readline().split()\n        key = int(line[0])\n        hand = line[1]\n\n        # If the hand is already on the key, no move needed\n        if hands[hand] == key:\n            continue\n\n        # Move the hand to the key\n        fatigue += abs(key - hands[hand])\n        hands[hand] = key\n\n    # Print the total fatigue\n    print(fatigue)\n\n# Call the function\nmin_fatigue_level()\n"}
{"task_id": "abc366_b", "code": "def convert_to_vertical():\n    import sys\n    # Read input from stdin\n    lines = sys.stdin.read().splitlines()\n    N = int(lines[0])\n    strings = lines[1:]\n    \n    # Find the maximum length among all strings\n    M = max(len(s) for s in strings)\n    \n    # Initialize the result list with empty strings\n    result = [''] * M\n    \n    for i in range(M):\n        chars = []\n        for s in strings:\n            if i < len(s):\n                chars.append(s[i])\n            else:\n                chars.append('*')\n        # Ensure that no string ends with '*'\n        for j in range(len(chars)):\n            if chars[j] == '*':\n                chars[j] = ''\n        # Concatenate the characters to form T_i\n        result[i] = ''.join(chars)\n    \n    # Print the result\n    for line in result:\n        print(line)\n\n# Call the function after its definition\nconvert_to_vertical()\n", "passed": false, "raw_code": "def convert_to_vertical():\n    import sys\n    # Read input from stdin\n    lines = sys.stdin.read().splitlines()\n    N = int(lines[0])\n    strings = lines[1:]\n    \n    # Find the maximum length among all strings\n    M = max(len(s) for s in strings)\n    \n    # Initialize the result list with empty strings\n    result = [''] * M\n    \n    for i in range(M):\n        chars = []\n        for s in strings:\n            if i < len(s):\n                chars.append(s[i])\n            else:\n                chars.append('*')\n        # Ensure that no string ends with '*'\n        for j in range(len(chars)):\n            if chars[j] == '*':\n                chars[j] = ''\n        # Concatenate the characters to form T_i\n        result[i] = ''.join(chars)\n    \n    # Print the result\n    for line in result:\n        print(line)\n\n# Call the function after its definition\nconvert_to_vertical()\n"}
{"task_id": "abc369_a", "code": "def count_valid_x():\n    import sys\n\n    # Read input from stdin\n    line = sys.stdin.readline().strip()\n    A, B = map(int, line.split())\n\n    # Calculate the difference between A and B\n    diff = B - A\n\n    # Determine the range of x based on the difference\n    if diff == 0:\n        # If A and B are the same, x must be equal to A/B to maintain the arithmetic sequence\n        valid_x = [A]\n    elif diff > 0:\n        # If B > A, x can be A + diff or A + 2*diff\n        valid_x = [A + diff, A + 2 * diff]\n    else:\n        # If B < A, x can be A - diff or A - 2*diff\n        valid_x = [A - diff, A - 2 * diff]\n\n    # Ensure x is within the range of 1 to 100\n    valid_x = [x for x in valid_x if 1 <= x <= 100]\n\n    # Print the number of valid x\n    print(len(valid_x))\n\n# Call the function\ncount_valid_x()\n", "passed": false, "raw_code": "def count_valid_x():\n    import sys\n\n    # Read input from stdin\n    line = sys.stdin.readline().strip()\n    A, B = map(int, line.split())\n\n    # Calculate the difference between A and B\n    diff = B - A\n\n    # Determine the range of x based on the difference\n    if diff == 0:\n        # If A and B are the same, x must be equal to A/B to maintain the arithmetic sequence\n        valid_x = [A]\n    elif diff > 0:\n        # If B > A, x can be A + diff or A + 2*diff\n        valid_x = [A + diff, A + 2 * diff]\n    else:\n        # If B < A, x can be A - diff or A - 2*diff\n        valid_x = [A - diff, A - 2 * diff]\n\n    # Ensure x is within the range of 1 to 100\n    valid_x = [x for x in valid_x if 1 <= x <= 100]\n\n    # Print the number of valid x\n    print(len(valid_x))\n\n# Call the function\ncount_valid_x()\n"}
{"task_id": "abc373_b", "code": "def calculate_min_distance(S):\n    # Define the positions of each letter on the number line\n    positions = {char: idx for idx, char in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n    \n    # Initialize the starting position\n    current_position = positions['A']\n    total_distance = 0\n    \n    # Iterate through the string S and calculate the distance for each move\n    for char in S:\n        next_position = positions[char]\n        distance = abs(next_position - current_position)\n        total_distance += distance\n        current_position = next_position\n    \n    return total_distance\n\n# Example usage:\nif __name__ == \"__main__\":\n    import sys\n    S = sys.stdin.readline().strip()\n    print(calculate_min_distance(S))\n", "passed": false, "raw_code": "def calculate_min_distance(S):\n    # Define the positions of each letter on the number line\n    positions = {char: idx for idx, char in enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZ')}\n    \n    # Initialize the starting position\n    current_position = positions['A']\n    total_distance = 0\n    \n    # Iterate through the string S and calculate the distance for each move\n    for char in S:\n        next_position = positions[char]\n        distance = abs(next_position - current_position)\n        total_distance += distance\n        current_position = next_position\n    \n    return total_distance\n\n# Example usage:\nif __name__ == \"__main__\":\n    import sys\n    S = sys.stdin.readline().strip()\n    print(calculate_min_distance(S))\n"}
{"task_id": "abc368_b", "code": "def count_operations():\n    import sys\n    input = sys.stdin.read().split()\n    N = int(input[0])\n    A = list(map(int, input[1:]))\n    \n    operations = 0\n    while len([x for x in A if x > 0]) > 1:\n        # Sort A in descending order\n        A_sorted = sorted(A, reverse=True)\n        # Decrease A_1 and A_2 by 1\n        A_sorted[0] -= 1\n        if len(A_sorted) > 1:\n            A_sorted[1] -= 1\n        # Update A with the sorted values\n        A = A_sorted\n        operations += 1\n    \n    print(operations)\n\ncount_operations()\n", "passed": true, "raw_code": "def count_operations():\n    import sys\n    input = sys.stdin.read().split()\n    N = int(input[0])\n    A = list(map(int, input[1:]))\n    \n    operations = 0\n    while len([x for x in A if x > 0]) > 1:\n        # Sort A in descending order\n        A_sorted = sorted(A, reverse=True)\n        # Decrease A_1 and A_2 by 1\n        A_sorted[0] -= 1\n        if len(A_sorted) > 1:\n            A_sorted[1] -= 1\n        # Update A with the sorted values\n        A = A_sorted\n        operations += 1\n    \n    print(operations)\n\ncount_operations()\n"}
{"task_id": "abc371_a", "code": "def determine_middle_brother():\n    import sys\n\n    # Read input from stdin\n    input_line = sys.stdin.readline().strip()\n    \n    # Split the input into S_AB, S_AC, S_BC\n    S_AB, S_AC, S_BC = input_line.split()\n    \n    # Determine the relationships\n    if S_AB == '<':\n        A_younger_than_B = True\n    else:\n        A_younger_than_B = False\n    \n    if S_AC == '<':\n        A_younger_than_C = True\n    else:\n        A_younger_than_C = False\n    \n    if S_BC == '<':\n        B_younger_than_C = True\n    else:\n        B_younger_than_C = False\n    \n    # Determine who is the middle brother\n    if A_younger_than_B and A_younger_than_C:\n        if B_younger_than_C:\n            middle_brother = 'B'\n        else:\n            middle_brother = 'C'\n    elif A_younger_than_B and not A_younger_than_C:\n        if B_younger_than_C:\n            middle_brother = 'A'\n        else:\n            middle_brother = 'B'\n    elif not A_younger_than_B and A_younger_than_C:\n        if B_younger_than_C:\n            middle_brother = 'C'\n        else:\n            middle_brother = 'A'\n    else:\n        if B_younger_than_C:\n            middle_brother = 'B'\n        else:\n            middle_brother = 'C'\n    \n    # Print the result\n    print(middle_brother)\n\n# Call the function\ndetermine_middle_brother()\n", "passed": false, "raw_code": "def determine_middle_brother():\n    import sys\n\n    # Read input from stdin\n    input_line = sys.stdin.readline().strip()\n    \n    # Split the input into S_AB, S_AC, S_BC\n    S_AB, S_AC, S_BC = input_line.split()\n    \n    # Determine the relationships\n    if S_AB == '<':\n        A_younger_than_B = True\n    else:\n        A_younger_than_B = False\n    \n    if S_AC == '<':\n        A_younger_than_C = True\n    else:\n        A_younger_than_C = False\n    \n    if S_BC == '<':\n        B_younger_than_C = True\n    else:\n        B_younger_than_C = False\n    \n    # Determine who is the middle brother\n    if A_younger_than_B and A_younger_than_C:\n        if B_younger_than_C:\n            middle_brother = 'B'\n        else:\n            middle_brother = 'C'\n    elif A_younger_than_B and not A_younger_than_C:\n        if B_younger_than_C:\n            middle_brother = 'A'\n        else:\n            middle_brother = 'B'\n    elif not A_younger_than_B and A_younger_than_C:\n        if B_younger_than_C:\n            middle_brother = 'C'\n        else:\n            middle_brother = 'A'\n    else:\n        if B_younger_than_C:\n            middle_brother = 'B'\n        else:\n            middle_brother = 'C'\n    \n    # Print the result\n    print(middle_brother)\n\n# Call the function\ndetermine_middle_brother()\n"}
{"final_accuracy": "57.69%"}
