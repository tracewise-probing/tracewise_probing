"{\"difficulty\": \"hard\", \"num_threads\": 16, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"generated_tests_majority_no_public_tests\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"meta-llama/Llama-3.1-8B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/majoritybug_trace_TPL_CODEEXECUTOR_llama8b_n_16_hard.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"meta-llama/Llama-3.1-8B-Instruct\", \"api_base\": \"http://10.96.183.224:63019/8004/v1\", \"no_refine\": false, \"no_dspy_gen\": true, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3532", "code": "from collections import deque\n\ndef amountOfTime(edges, n):\n    # Create adjacency list\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Initialize visited set and queue\n    visited = set()\n    queue = deque([(i, 0) for i in range(n)])\n\n    # Initialize result array\n    times = [0] * n\n\n    while queue:\n        node, time = queue.popleft()\n        if time > times[node]:\n            times[node] = time\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, time + 1))\n\n    # Find the maximum time for each node\n    for i in range(n):\n        if i % 2 == 0:\n            times[i] = max(times[j] for j in graph[i])\n        else:\n            times[i] = max(times[j] for j in graph[i]) + 1\n\n    return times\n\n# Example usage:\nedges = [[0,1],[0,2]]\nprint(amountOfTime(edges, 3))  # Output: [2,4,3]\n\nedges = [[0,1]]\nprint(amountOfTime(edges, 2))  # Output: [1,2]\n\nedges = [[2,4],[0,1],[2,3],[0,2]]\nprint(amountOfTime(edges, 5))  # Output: [4,6,3,5,5]\n", "passed": false, "raw_code": "from collections import deque\n\ndef amountOfTime(edges, n):\n    # Create adjacency list\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Initialize visited set and queue\n    visited = set()\n    queue = deque([(i, 0) for i in range(n)])\n\n    # Initialize result array\n    times = [0] * n\n\n    while queue:\n        node, time = queue.popleft()\n        if time > times[node]:\n            times[node] = time\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, time + 1))\n\n    # Find the maximum time for each node\n    for i in range(n):\n        if i % 2 == 0:\n            times[i] = max(times[j] for j in graph[i])\n        else:\n            times[i] = max(times[j] for j in graph[i]) + 1\n\n    return times\n\n# Example usage:\nedges = [[0,1],[0,2]]\nprint(amountOfTime(edges, 3))  # Output: [2,4,3]\n\nedges = [[0,1]]\nprint(amountOfTime(edges, 2))  # Output: [1,2]\n\nedges = [[2,4],[0,1],[2,3],[0,2]]\nprint(amountOfTime(edges, 5))  # Output: [4,6,3,5,5]\n"}
{"task_id": "3563", "code": "def maximumScore(grid):\n    m, n = len(grid), len(grid[0])\n    rows = set()\n    selected_values = set()\n    max_score = 0\n\n    def backtrack(row=0, score=0):\n        nonlocal max_score\n        if score > max_score:\n            max_score = score\n        if row == m:\n            return\n        for col in range(n):\n            if grid[row][col] not in selected_values and row not in rows:\n                selected_values.add(grid[row][col])\n                rows.add(row)\n                backtrack(row + 1, score + grid[row][col])\n                selected_values.remove(grid[row][col])\n                rows.remove(row)\n\n    backtrack()\n    return max_score\n", "passed": false, "raw_code": "def maximumScore(grid):\n    m, n = len(grid), len(grid[0])\n    rows = set()\n    selected_values = set()\n    max_score = 0\n\n    def backtrack(row=0, score=0):\n        nonlocal max_score\n        if score > max_score:\n            max_score = score\n        if row == m:\n            return\n        for col in range(n):\n            if grid[row][col] not in selected_values and row not in rows:\n                selected_values.add(grid[row][col])\n                rows.add(row)\n                backtrack(row + 1, score + grid[row][col])\n                selected_values.remove(grid[row][col])\n                rows.remove(row)\n\n    backtrack()\n    return max_score\n"}
{"task_id": "3531", "code": "", "passed": false, "raw_code": ""}
{"task_id": "3527", "code": "from collections import defaultdict\n\ndef get_color_count(colors):\n    color_count = defaultdict(int)\n    for color in colors:\n        color_count[color] += 1\n    return color_count\n\ndef get_alternating_group_count(colors, color_count):\n    total_count = 0\n    for size in color_count:\n        if size % 2 == 0:\n            total_count += (len(colors) - 1) // size\n        else:\n            total_count += len(colors) // size\n    return total_count\n\ndef process_queries(colors, queries):\n    color_count = get_color_count(colors)\n    alternating_group_count = get_alternating_group_count(colors, color_count)\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            if size % 2 == 0:\n                alternating_group_count -= (len(colors) - 1) // size\n            else:\n                alternating_group_count -= len(colors) // size\n            color_count[size] += 1\n            if size % 2 == 0:\n                alternating_group_count += (len(colors) - 1) // size\n            else:\n                alternating_group_count += len(colors) // size\n            result.append(alternating_group_count)\n        else:\n            index, color = query[1], query[2]\n            colors[index] = color\n            color_count[colors[index]] += 1\n            color_count[colors[(index - 1) % len(colors)]] -= 1\n            color_count[colors[(index + 1) % len(colors)]] -= 1\n            if colors[index] != colors[(index - 1) % len(colors)] and colors[index] != colors[(index + 1) % len(colors)]:\n                if len(colors) % 2 == 1 and index == 0:\n                    alternating_group_count += 1\n                elif len(colors) % 2 == 0 and (index == 0 or index == len(colors) - 1):\n                    alternating_group_count += 1\n                else:\n                    alternating_group_count += 2\n            elif colors[index] == colors[(index - 1) % len(colors)] and colors[index] == colors[(index + 1) % len(colors)]:\n                if len(colors) % 2 == 1 and index == 0:\n                    alternating_group_count -= 1\n                elif len(colors) % 2 == 0 and (index == 0 or index == len(colors) - 1):\n                    alternating_group_count -= 1\n                else:\n                    alternating_group_count -= 2\n    return result\n", "passed": false, "raw_code": "from collections import defaultdict\n\ndef get_color_count(colors):\n    color_count = defaultdict(int)\n    for color in colors:\n        color_count[color] += 1\n    return color_count\n\ndef get_alternating_group_count(colors, color_count):\n    total_count = 0\n    for size in color_count:\n        if size % 2 == 0:\n            total_count += (len(colors) - 1) // size\n        else:\n            total_count += len(colors) // size\n    return total_count\n\ndef process_queries(colors, queries):\n    color_count = get_color_count(colors)\n    alternating_group_count = get_alternating_group_count(colors, color_count)\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            if size % 2 == 0:\n                alternating_group_count -= (len(colors) - 1) // size\n            else:\n                alternating_group_count -= len(colors) // size\n            color_count[size] += 1\n            if size % 2 == 0:\n                alternating_group_count += (len(colors) - 1) // size\n            else:\n                alternating_group_count += len(colors) // size\n            result.append(alternating_group_count)\n        else:\n            index, color = query[1], query[2]\n            colors[index] = color\n            color_count[colors[index]] += 1\n            color_count[colors[(index - 1) % len(colors)]] -= 1\n            color_count[colors[(index + 1) % len(colors)]] -= 1\n            if colors[index] != colors[(index - 1) % len(colors)] and colors[index] != colors[(index + 1) % len(colors)]:\n                if len(colors) % 2 == 1 and index == 0:\n                    alternating_group_count += 1\n                elif len(colors) % 2 == 0 and (index == 0 or index == len(colors) - 1):\n                    alternating_group_count += 1\n                else:\n                    alternating_group_count += 2\n            elif colors[index] == colors[(index - 1) % len(colors)] and colors[index] == colors[(index + 1) % len(colors)]:\n                if len(colors) % 2 == 1 and index == 0:\n                    alternating_group_count -= 1\n                elif len(colors) % 2 == 0 and (index == 0 or index == len(colors) - 1):\n                    alternating_group_count -= 1\n                else:\n                    alternating_group_count -= 2\n    return result\n"}
{"task_id": "3575", "code": "def maximizeXor(nums, k):\n    n = len(nums)\n    max_val = max(nums)\n    max_bits = max_val.bit_length()\n    \n    # Create a Trie and insert all numbers\n    trie = {}\n    for num in nums:\n        node = trie\n        for i in range(max_bits - 1, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n    \n    # Initialize the result and the current node\n    result = 0\n    node = trie\n    \n    # Iterate over the numbers and update the result\n    for i in range(n - 2 * k + 1):\n        for j in range(i + k - 1, i + 2 * k - 1):\n            num = nums[j]\n            # Find the maximum XOR with the current number\n            xor = 0\n            for bit in range(max_bits - 1, -1, -1):\n                bit_val = (num >> bit) & 1\n                opposite_bit = 1 - bit_val\n                if opposite_bit in node:\n                    xor |= 1 << bit\n                    node = node[opposite_bit]\n                else:\n                    node = node[bit_val]\n            # Update the result\n            result = max(result, xor)\n            # Reset the current node\n            node = trie\n    \n    return result\n", "passed": false, "raw_code": "def maximizeXor(nums, k):\n    n = len(nums)\n    max_val = max(nums)\n    max_bits = max_val.bit_length()\n    \n    # Create a Trie and insert all numbers\n    trie = {}\n    for num in nums:\n        node = trie\n        for i in range(max_bits - 1, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n    \n    # Initialize the result and the current node\n    result = 0\n    node = trie\n    \n    # Iterate over the numbers and update the result\n    for i in range(n - 2 * k + 1):\n        for j in range(i + k - 1, i + 2 * k - 1):\n            num = nums[j]\n            # Find the maximum XOR with the current number\n            xor = 0\n            for bit in range(max_bits - 1, -1, -1):\n                bit_val = (num >> bit) & 1\n                opposite_bit = 1 - bit_val\n                if opposite_bit in node:\n                    xor |= 1 << bit\n                    node = node[opposite_bit]\n                else:\n                    node = node[bit_val]\n            # Update the result\n            result = max(result, xor)\n            # Reset the current node\n            node = trie\n    \n    return result\n"}
{"task_id": "3550", "code": "def maxSumOfThreeSubarray(board):\n    m, n = len(board), len(board[0])\n    max_sum = float('-inf')\n    \n    def place_rooks(row1, col1, row2, col2, row3, col3):\n        nonlocal max_sum\n        max_sum = max(max_sum, board[row1][col1] + board[row2][col2] + board[row3][col3])\n        \n    for i in range(m):\n        row1 = i\n        for j in range(n):\n            col1 = j\n            for k in range(i + 1, m):\n                row2 = k\n                for col2 in range(n):\n                    if col2 == j:\n                        continue\n                    for last_row in range(k + 1, m):\n                        row3 = last_row\n                        for col3 in range(n):\n                            if col3 == j or col3 == col2:\n                                continue\n                            place_rooks(row1, col1, row2, col2, row3, col3)\n    \n    return max_sum\n", "passed": false, "raw_code": "def maxSumOfThreeSubarray(board):\n    m, n = len(board), len(board[0])\n    max_sum = float('-inf')\n    \n    def place_rooks(row1, col1, row2, col2, row3, col3):\n        nonlocal max_sum\n        max_sum = max(max_sum, board[row1][col1] + board[row2][col2] + board[row3][col3])\n        \n    for i in range(m):\n        row1 = i\n        for j in range(n):\n            col1 = j\n            for k in range(i + 1, m):\n                row2 = k\n                for col2 in range(n):\n                    if col2 == j:\n                        continue\n                    for last_row in range(k + 1, m):\n                        row3 = last_row\n                        for col3 in range(n):\n                            if col3 == j or col3 == col2:\n                                continue\n                            place_rooks(row1, col1, row2, col2, row3, col3)\n    \n    return max_sum\n"}
{"task_id": "3580", "code": "def smallest_almost_equal(s: str, pattern: str) -> int:\n    \"\"\"\n    Returns the smallest starting index of a substring in s that is almost equal to pattern.\n    \n    A string x is called almost equal to y if you can change at most one character in x to make it identical to y.\n    \n    Args:\n    s (str): The string to search in.\n    pattern (str): The pattern string.\n    \n    Returns:\n    int: The smallest starting index of a substring in s that is almost equal to pattern. If no such index exists, returns -1.\n    \"\"\"\n    \n    def count_diff(i: int) -> int:\n        \"\"\"\n        Counts the number of different characters between s[i:] and pattern.\n        \n        Args:\n        i (int): The starting index of the substring in s.\n        \n        Returns:\n        int: The number of different characters between s[i:] and pattern.\n        \"\"\"\n        diff_count = 0\n        for j in range(len(pattern)):\n            if i + j >= len(s) or s[i + j] != pattern[j]:\n                diff_count += 1\n        return diff_count\n    \n    min_diff = float('inf')\n    min_index = -1\n    \n    for i in range(len(s) - len(pattern) + 1):\n        diff = count_diff(i)\n        if diff == 0:\n            return i\n        if diff == 1 and diff < min_diff:\n            min_diff = diff\n            min_index = i\n    \n    return min_index\n", "passed": false, "raw_code": "def smallest_almost_equal(s: str, pattern: str) -> int:\n    \"\"\"\n    Returns the smallest starting index of a substring in s that is almost equal to pattern.\n    \n    A string x is called almost equal to y if you can change at most one character in x to make it identical to y.\n    \n    Args:\n    s (str): The string to search in.\n    pattern (str): The pattern string.\n    \n    Returns:\n    int: The smallest starting index of a substring in s that is almost equal to pattern. If no such index exists, returns -1.\n    \"\"\"\n    \n    def count_diff(i: int) -> int:\n        \"\"\"\n        Counts the number of different characters between s[i:] and pattern.\n        \n        Args:\n        i (int): The starting index of the substring in s.\n        \n        Returns:\n        int: The number of different characters between s[i:] and pattern.\n        \"\"\"\n        diff_count = 0\n        for j in range(len(pattern)):\n            if i + j >= len(s) or s[i + j] != pattern[j]:\n                diff_count += 1\n        return diff_count\n    \n    min_diff = float('inf')\n    min_index = -1\n    \n    for i in range(len(s) - len(pattern) + 1):\n        diff = count_diff(i)\n        if diff == 0:\n            return i\n        if diff == 1 and diff < min_diff:\n            min_diff = diff\n            min_index = i\n    \n    return min_index\n"}
{"task_id": "3552", "code": "def largest_k_palindrome(n: int, k: int) -> str:\n    # Start from the largest possible number with n digits\n    for i in range(10**(n-1), 10**n):\n        # Convert the number to a string for easy manipulation\n        num_str = str(i)\n        \n        # Check if the number is a palindrome\n        if num_str == num_str[::-1]:\n            # Check if the number is divisible by k\n            if i % k == 0:\n                return num_str\n\n    # If no k-palindromic number is found, return an empty string\n    return \"\"\n", "passed": false, "raw_code": "def largest_k_palindrome(n: int, k: int) -> str:\n    # Start from the largest possible number with n digits\n    for i in range(10**(n-1), 10**n):\n        # Convert the number to a string for easy manipulation\n        num_str = str(i)\n        \n        # Check if the number is a palindrome\n        if num_str == num_str[::-1]:\n            # Check if the number is divisible by k\n            if i % k == 0:\n                return num_str\n\n    # If no k-palindromic number is found, return an empty string\n    return \"\"\n"}
{"task_id": "3571", "code": "class UnionFind:\n    def __init__(self):\n        self.parent = {}\n        self.rank = {}\n        self.max_len = {}\n\n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n            self.rank[x] = 0\n            self.max_len[x] = 1\n            return x\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            if self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n                self.max_len[root_y] = max(self.max_len[root_y], self.max_len[root_x] + 1)\n            elif self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n                self.max_len[root_x] = max(self.max_len[root_x], self.max_len[root_y] + 1)\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n                self.max_len[root_x] = max(self.max_len[root_x], self.max_len[root_y] + 1)\n\n\nclass Solution:\n    def longestIncreasingPath(self, coordinates, k):\n        uf = UnionFind()\n        for i, (x, y) in enumerate(coordinates):\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 10**9 and 0 <= ny < 10**9 and (nx, ny) in coordinates:\n                    j = coordinates.index((nx, ny))\n                    uf.union(i, j)\n        return uf.max_len[self.find(k)]\n", "passed": false, "raw_code": "class UnionFind:\n    def __init__(self):\n        self.parent = {}\n        self.rank = {}\n        self.max_len = {}\n\n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n            self.rank[x] = 0\n            self.max_len[x] = 1\n            return x\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            if self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n                self.max_len[root_y] = max(self.max_len[root_y], self.max_len[root_x] + 1)\n            elif self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n                self.max_len[root_x] = max(self.max_len[root_x], self.max_len[root_y] + 1)\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n                self.max_len[root_x] = max(self.max_len[root_x], self.max_len[root_y] + 1)\n\n\nclass Solution:\n    def longestIncreasingPath(self, coordinates, k):\n        uf = UnionFind()\n        for i, (x, y) in enumerate(coordinates):\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 10**9 and 0 <= ny < 10**9 and (nx, ny) in coordinates:\n                    j = coordinates.index((nx, ny))\n                    uf.union(i, j)\n        return uf.max_len[self.find(k)]\n"}
{"task_id": "3583", "code": "import math\nfrom typing import List\n\ndef gcdPairs(nums: List[int]) -> List[int]:\n    \"\"\"\n    Calculate GCD of all possible pairs of numbers in the input list.\n    \n    Args:\n    nums (List[int]): A list of integers.\n    \n    Returns:\n    List[int]: A list of GCD values in ascending order.\n    \"\"\"\n    n = len(nums)\n    gcd_pairs = set()\n    \n    # Generate all possible pairs and calculate their GCD\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_pairs.add(math.gcd(nums[i], nums[j]))\n    \n    # Convert the set to a list and sort it in ascending order\n    gcd_pairs = sorted(list(gcd_pairs))\n    \n    return gcd_pairs\n\ndef processQueries(nums: List[int], queries: List[int]) -> List[int]:\n    \"\"\"\n    Process queries on the GCD pairs of numbers in the input list.\n    \n    Args:\n    nums (List[int]): A list of integers.\n    queries (List[int]): A list of query indices.\n    \n    Returns:\n    List[int]: A list of values at the query indices in the sorted GCD pairs list.\n    \"\"\"\n    gcd_pairs = gcdPairs(nums)\n    n = len(gcd_pairs)\n    answer = []\n    \n    # Process each query\n    for query in queries:\n        answer.append(gcd_pairs[query])\n    \n    return answer\n\n# Example usage:\nnums = [2, 3, 4]\nqueries = [0, 2, 2]\nprint(processQueries(nums, queries))  # Output: [1, 2, 2]\n\nnums = [4, 4, 2, 1]\nqueries = [5, 3, 1, 0]\nprint(processQueries(nums, queries))  # Output: [4, 2, 1, 1]\n\nnums = [2, 2]\nqueries = [0, 0]\nprint(processQueries(nums, queries))  # Output: [2, 2]\n", "passed": false, "raw_code": "import math\nfrom typing import List\n\ndef gcdPairs(nums: List[int]) -> List[int]:\n    \"\"\"\n    Calculate GCD of all possible pairs of numbers in the input list.\n    \n    Args:\n    nums (List[int]): A list of integers.\n    \n    Returns:\n    List[int]: A list of GCD values in ascending order.\n    \"\"\"\n    n = len(nums)\n    gcd_pairs = set()\n    \n    # Generate all possible pairs and calculate their GCD\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_pairs.add(math.gcd(nums[i], nums[j]))\n    \n    # Convert the set to a list and sort it in ascending order\n    gcd_pairs = sorted(list(gcd_pairs))\n    \n    return gcd_pairs\n\ndef processQueries(nums: List[int], queries: List[int]) -> List[int]:\n    \"\"\"\n    Process queries on the GCD pairs of numbers in the input list.\n    \n    Args:\n    nums (List[int]): A list of integers.\n    queries (List[int]): A list of query indices.\n    \n    Returns:\n    List[int]: A list of values at the query indices in the sorted GCD pairs list.\n    \"\"\"\n    gcd_pairs = gcdPairs(nums)\n    n = len(gcd_pairs)\n    answer = []\n    \n    # Process each query\n    for query in queries:\n        answer.append(gcd_pairs[query])\n    \n    return answer\n\n# Example usage:\nnums = [2, 3, 4]\nqueries = [0, 2, 2]\nprint(processQueries(nums, queries))  # Output: [1, 2, 2]\n\nnums = [4, 4, 2, 1]\nqueries = [5, 3, 1, 0]\nprint(processQueries(nums, queries))  # Output: [4, 2, 1, 1]\n\nnums = [2, 2]\nqueries = [0, 0]\nprint(processQueries(nums, queries))  # Output: [2, 2]\n"}
{"task_id": "3551", "code": "class TrieNode:\n    \"\"\"Trie node class.\"\"\"\n    \n    def __init__(self):\n        # Initialize a Trie node with an empty dictionary to store children nodes.\n        self.children = {}\n        # Initialize the value of the Trie node to None.\n        self.value = None\n\n\nclass Trie:\n    \"\"\"Trie class.\"\"\"\n    \n    def __init__(self):\n        # Initialize a Trie with a root node.\n        self.root = TrieNode()\n\n\n    def insert(self, num):\n        \"\"\"Insert a number into the Trie.\"\"\"\n        \n        # Start from the root node.\n        node = self.root\n        # Iterate over each bit of the number from right to left.\n        for i in range(31, -1, -1):\n            # Get the current bit.\n            bit = (num >> i) & 1\n            # If the bit is not in the current node's children, add it.\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            # Move to the child node.\n            node = node.children[bit]\n        # Store the number in the Trie node.\n        node.value = num\n\n\n    def query(self, num):\n        \"\"\"Query the Trie to find the maximum XOR number.\"\"\"\n        \n        # Start from the root node.\n        node = self.root\n        # Initialize the maximum XOR number to 0.\n        max_xor = 0\n        # Iterate over each bit of the number from right to left.\n        for i in range(31, -1, -1):\n            # Get the current bit.\n            bit = (num >> i) & 1\n            # If the opposite bit is in the current node's children, move to it.\n            if 1 - bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[1 - bit]\n            # Otherwise, move to the child node with the current bit.\n            else:\n                node = node.children[bit]\n        # Return the maximum XOR number.\n        return max_xor\n\n\ndef findMaximumXOR(nums, queries):\n    \"\"\"\n    Find the maximum XOR score of any subarray for each query.\n\n    Args:\n    nums (list): A list of integers.\n    queries (list): A list of queries, where each query is a list of two integers.\n\n    Returns:\n    list: A list of maximum XOR scores for each query.\n    \"\"\"\n    \n    # Initialize a Trie.\n    trie = Trie()\n    # Insert all numbers into the Trie.\n    for num in nums:\n        trie.insert(num)\n    # Initialize a list to store the results.\n    result = []\n    # Iterate over each query.\n    for left, right in queries:\n        # Calculate the maximum XOR number for the subarray from left to right.\n        max_xor = trie.query(nums[right]) ^ nums[right]\n        # Find the maximum XOR number for the subarray from left to right.\n        for i in range(right - 1, left - 1, -1):\n            max_xor = max(max_xor, trie.query(nums[i]) ^ nums[i])\n        # Append the result to the list.\n        result.append(max_xor)\n    # Return the list of results.\n    return result\n\n\n# Example usage:\nnums = [2, 8, 4, 32, 16, 1]\nqueries = [[0, 2], [1, 4], [0, 5]]\nprint(findMaximumXOR(nums, queries))  # Output: [12, 60, 60]\n\nnums = [0, 7, 3, 2, 8, 5, 1]\nqueries = [[0, 3], [1, 5], [2, 4], [2, 6], [5, 6]]\nprint(findMaximumXOR(nums, queries))  # Output: [7, 14, 11, 14, 5]\n", "passed": false, "raw_code": "class TrieNode:\n    \"\"\"Trie node class.\"\"\"\n    \n    def __init__(self):\n        # Initialize a Trie node with an empty dictionary to store children nodes.\n        self.children = {}\n        # Initialize the value of the Trie node to None.\n        self.value = None\n\n\nclass Trie:\n    \"\"\"Trie class.\"\"\"\n    \n    def __init__(self):\n        # Initialize a Trie with a root node.\n        self.root = TrieNode()\n\n\n    def insert(self, num):\n        \"\"\"Insert a number into the Trie.\"\"\"\n        \n        # Start from the root node.\n        node = self.root\n        # Iterate over each bit of the number from right to left.\n        for i in range(31, -1, -1):\n            # Get the current bit.\n            bit = (num >> i) & 1\n            # If the bit is not in the current node's children, add it.\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            # Move to the child node.\n            node = node.children[bit]\n        # Store the number in the Trie node.\n        node.value = num\n\n\n    def query(self, num):\n        \"\"\"Query the Trie to find the maximum XOR number.\"\"\"\n        \n        # Start from the root node.\n        node = self.root\n        # Initialize the maximum XOR number to 0.\n        max_xor = 0\n        # Iterate over each bit of the number from right to left.\n        for i in range(31, -1, -1):\n            # Get the current bit.\n            bit = (num >> i) & 1\n            # If the opposite bit is in the current node's children, move to it.\n            if 1 - bit in node.children:\n                max_xor |= (1 << i)\n                node = node.children[1 - bit]\n            # Otherwise, move to the child node with the current bit.\n            else:\n                node = node.children[bit]\n        # Return the maximum XOR number.\n        return max_xor\n\n\ndef findMaximumXOR(nums, queries):\n    \"\"\"\n    Find the maximum XOR score of any subarray for each query.\n\n    Args:\n    nums (list): A list of integers.\n    queries (list): A list of queries, where each query is a list of two integers.\n\n    Returns:\n    list: A list of maximum XOR scores for each query.\n    \"\"\"\n    \n    # Initialize a Trie.\n    trie = Trie()\n    # Insert all numbers into the Trie.\n    for num in nums:\n        trie.insert(num)\n    # Initialize a list to store the results.\n    result = []\n    # Iterate over each query.\n    for left, right in queries:\n        # Calculate the maximum XOR number for the subarray from left to right.\n        max_xor = trie.query(nums[right]) ^ nums[right]\n        # Find the maximum XOR number for the subarray from left to right.\n        for i in range(right - 1, left - 1, -1):\n            max_xor = max(max_xor, trie.query(nums[i]) ^ nums[i])\n        # Append the result to the list.\n        result.append(max_xor)\n    # Return the list of results.\n    return result\n\n\n# Example usage:\nnums = [2, 8, 4, 32, 16, 1]\nqueries = [[0, 2], [1, 4], [0, 5]]\nprint(findMaximumXOR(nums, queries))  # Output: [12, 60, 60]\n\nnums = [0, 7, 3, 2, 8, 5, 1]\nqueries = [[0, 3], [1, 5], [2, 4], [2, 6], [5, 6]]\nprint(findMaximumXOR(nums, queries))  # Output: [7, 14, 11, 14, 5]\n"}
{"task_id": "3535", "code": "", "passed": false, "raw_code": ""}
{"task_id": "3560", "code": "def knightDialer(kx, ky, positions):\n    def get_moves(kx, ky):\n        moves = set()\n        for dx, dy in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            nx, ny = kx + dx, ky + dy\n            if 0 <= nx < 50 and 0 <= ny < 50:\n                moves.add((nx, ny))\n        return moves\n\n    moves = get_moves(kx, ky)\n    positions = set((x, y) for x, y in positions)\n    moves = moves - positions\n    if not moves:\n        return 0\n    max_moves = 0\n    while positions:\n        new_positions = set()\n        for x, y in positions:\n            for nx, ny in get_moves(x, y):\n                if (nx, ny) in positions:\n                    new_positions.add((nx, ny))\n        max_moves = max(max_moves, len(moves) + len(new_positions))\n        positions = new_positions\n        moves = moves - new_positions\n    return max_moves\n", "passed": false, "raw_code": "def knightDialer(kx, ky, positions):\n    def get_moves(kx, ky):\n        moves = set()\n        for dx, dy in [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]:\n            nx, ny = kx + dx, ky + dy\n            if 0 <= nx < 50 and 0 <= ny < 50:\n                moves.add((nx, ny))\n        return moves\n\n    moves = get_moves(kx, ky)\n    positions = set((x, y) for x, y in positions)\n    moves = moves - positions\n    if not moves:\n        return 0\n    max_moves = 0\n    while positions:\n        new_positions = set()\n        for x, y in positions:\n            for nx, ny in get_moves(x, y):\n                if (nx, ny) in positions:\n                    new_positions.add((nx, ny))\n        max_moves = max(max_moves, len(moves) + len(new_positions))\n        positions = new_positions\n        moves = moves - new_positions\n    return max_moves\n"}
