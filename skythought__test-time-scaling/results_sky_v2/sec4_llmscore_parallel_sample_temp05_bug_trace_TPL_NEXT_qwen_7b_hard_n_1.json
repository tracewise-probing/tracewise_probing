{"difficulty": "hard", "num_threads": 32, "temperature": 0.5, "n": 1, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp05_bug_trace_TPL_NEXT_qwen_7b_hard_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc366_e", "code": "d", "passed": false, "raw_code": "```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    D = int(data[1])\n    \n    x_coords = []\n    y_coords = []\n    \n    for i in range(N):\n        x = int(data[2 + 2 * i])\n        y = int(data[3 + 2 * i])\n        x_coords.append(x)\n        y_coords.append(y)\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points_in_range(coords, D):\n        left = 0\n        right = 0\n        count = 0\n        while right < len(coords):\n            while right < len(coords) and coords[right] - coords[left] <= D:\n                right += 1\n            count += right - left\n            left += 1\n        return count\n    \n    x_count = count_points_in_range(x_coords, D)\n    y_count = count_points_in_range(y_coords, D)\n    \n    print(x_count * y_count)\n\ncount_valid_pairs()"}
{"task_id": "abc366_f", "code": "d", "passed": false, "raw_code": "```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    functions = []\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(1, min(i, K) + 1):\n            dp[i][j] = max(dp[i - 1][j], functions[i - 1][0] * dp[i - 1][j - 1] + functions[i - 1][1])\n    \n    # Find the maximum value for K functions\n    max_value = max(max(dp[i][K] for i in range(1, N + 1)))\n    \n    print(max_value)\n\nmax_nested_function_value()"}
{"task_id": "abc370_f", "code": "d", "passed": false, "raw_code": "```python\ndef max_min_mass_and_cut_lines(N, K, A):\n    A.sort(reverse=True)\n    total_mass = sum(A)\n    min_mass = total_mass // K\n    cut_lines = 0\n    \n    current_sum = 0\n    for i in range(N):\n        current_sum += A[i]\n        if current_sum >= min_mass:\n            current_sum = 0\n            cut_lines += 1\n    \n    return min_mass, cut_lines\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Get the result\nmin_mass, cut_lines = max_min_mass_and_cut_lines(N, K, A)\n\n# Print the result\nprint(min_mass, cut_lines)"}
{"task_id": "3532", "code": "def minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start_node):\n        queue = deque([start_node])\n        visited = set([start_node])\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    if current % 2 == 0:\n                        times[neighbor] = times[current] + 2\n                    else:\n                        times[neighbor] = times[current] + 1\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    times = [float('inf')] * n\n    leaves = [node for node in range(n) if len(graph[node]) == 1]\n    \n    for leaf in leaves:\n        times[leaf] = 1\n        bfs(leaf)\n    \n    return times", "passed": false, "raw_code": "```python\ndef minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start_node):\n        queue = deque([start_node])\n        visited = set([start_node])\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    if current % 2 == 0:\n                        times[neighbor] = times[current] + 2\n                    else:\n                        times[neighbor] = times[current] + 1\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    times = [float('inf')] * n\n    leaves = [node for node in range(n) if len(graph[node]) == 1]\n    \n    for leaf in leaves:\n        times[leaf] = 1\n        bfs(leaf)\n    \n    return times\n```"}
{"task_id": "abc368_f", "code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef determine_winner(N, A):\n    prime_count = sum(is_prime(a) for a in A)\n    if prime_count % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\nprint(determine_winner(N, A))", "passed": false, "raw_code": "```python\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef determine_winner(N, A):\n    prime_count = sum(is_prime(a) for a in A)\n    if prime_count % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\nprint(determine_winner(N, A))\n```"}
{"task_id": "abc371_f", "code": "d", "passed": false, "raw_code": "```python\ndef min_movements():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    X = list(map(int, data[index:index + N]))\n    index += N\n    Q = int(data[index])\n    index += 1\n    tasks = []\n    for _ in range(Q):\n        T = int(data[index])\n        index += 1\n        G = int(data[index])\n        index += 1\n        tasks.append((T, G))\n    \n    # Sort the people by their initial positions\n    X.sort()\n    \n    total_moves = 0\n    for T, G in tasks:\n        # Find the position of the person T\n        pos = X[T - 1]\n        # Calculate the absolute difference between the current position and the target position\n        moves = abs(pos - G)\n        total_moves += moves\n    \n    print(total_moves)\n\nmin_movements()"}
{"task_id": "abc368_g", "code": "d", "passed": false, "raw_code": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    A = list(map(int, data[index:index + N]))\n    index += N\n    \n    B = list(map(int, data[index:index + N]))\n    index += N\n    \n    Q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        if query_type == 1:\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            queries.append((query_type, i, x))\n        elif query_type == 2:\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            queries.append((query_type, i, x))\n        elif query_type == 3:\n            l = int(data[index]) - 1\n            index += 1\n            r = int(data[index]) - 1\n            index += 1\n            queries.append((query_type, l, r))\n    \n    results = []\n    for query in queries:\n        if query[0] == 1:\n            A[query[1]] = query[2]\n        elif query[0] == 2:\n            B[query[1]] = query[2]\n        elif query[0] == 3:\n            l, r = query[1], query[2]\n            v = 0\n            for i in range(l, r + 1):\n                if v == 0 or v + A[i] > v * B[i]:\n                    v += A[i]\n                else:\n                    v *= B[i]\n            results.append(v)\n    \n    for result in results:\n        print(result)\n\nsolve()"}
{"task_id": "abc372_f", "code": "d", "passed": false, "raw_code": "```python\ndef count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    # Fill DP table\n    for k in range(1, K + 1):\n        for u in range(1, N + 1):\n            for v, _ in edges:\n                if v == u:\n                    dp[v][k] = (dp[v][k] + dp[u][k - 1]) % MOD\n    \n    # Sum up the ways to reach any vertex in K moves\n    result = sum(dp[v][K] for v in range(1, N + 1)) % MOD\n    \n    print(result)\n\ncount_ways()"}
{"task_id": "arc182_e", "code": "d", "passed": false, "raw_code": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    prefix_min = [float('inf')] * M\n    for a in A:\n        prefix_min[a] = min(prefix_min[a], a)\n    \n    for k in range(1, K):\n        new_prefix_min = [float('inf')] * M\n        for i in range(M):\n            new_prefix_min[(C * k + i) % M] = min(new_prefix_min[(C * k + i) % M], prefix_min[i])\n        prefix_min = new_prefix_min\n    \n    result = sum(prefix_min)\n    print(result)\n\nsolve()"}
{"task_id": "abc370_e", "code": "def count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            prefix_sum += A[i - 1]\n            if prefix_sum <= K:\n                dp[i][prefix_sum] += dp[i - 1][j]\n                dp[i][prefix_sum] %= MOD\n            dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= MOD\n\n    total_ways = sum(dp[N][j] for j in range(K + 1)) % MOD\n    invalid_ways = dp[N][K] if K in range(K + 1) else 0\n    valid_ways = (total_ways - invalid_ways + MOD) % MOD\n\n    return valid_ways\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Output the result\nprint(count_partitions(N, K, A))", "passed": false, "raw_code": "```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(K + 1):\n            prefix_sum += A[i - 1]\n            if prefix_sum <= K:\n                dp[i][prefix_sum] += dp[i - 1][j]\n                dp[i][prefix_sum] %= MOD\n            dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= MOD\n\n    total_ways = sum(dp[N][j] for j in range(K + 1)) % MOD\n    invalid_ways = dp[N][K] if K in range(K + 1) else 0\n    valid_ways = (total_ways - invalid_ways + MOD) % MOD\n\n    return valid_ways\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Output the result\nprint(count_partitions(N, K, A))\n```"}
{"task_id": "abc366_g", "code": "d", "passed": false, "raw_code": "```python\ndef is_valid_assignment(graph, assignments):\n    for v in range(1, len(assignments)):\n        if v in graph:\n            neighbors = graph[v]\n            xor_sum = 0\n            for neighbor in neighbors:\n                if neighbor != v:\n                    xor_sum ^= assignments[neighbor]\n            if xor_sum != 0:\n                return False\n    return True\n\ndef assign_numbers(graph, assignments, vertex, used):\n    if vertex == len(assignments):\n        return is_valid_assignment(graph, assignments)\n    \n    for num in range(1, 2**60):\n        if num not in used:\n            used.add(num)\n            assignments[vertex] = num\n            if assign_numbers(graph, assignments, vertex + 1, used):\n                return True\n            used.remove(num)\n            assignments[vertex] = None\n    \n    return False\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    graph = [[] for _ in range(N + 1)]\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        graph[u].append(v)\n        graph[v].append(u)\n        index += 2\n    \n    assignments = [None] * (N + 1)\n    used = set()\n    \n    if assign_numbers(graph, assignments, 1, used):\n        print(\"Yes\")\n        for i in range(1, N + 1):\n            print(assignments[i], end=\" \")\n        print()\n    else:\n        print(\"No\")\n\nsolve()"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    dp = {}\n    \n    for num in nums:\n        new_dp = {num: 0}\n        for val, count in dp.items():\n            new_dp[val] += count\n            new_dp[num] += count\n        \n        dp = new_dp\n    \n    return sum(dp.values()) % MOD", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    dp = {}\n    \n    for num in nums:\n        new_dp = {num: 0}\n        for val, count in dp.items():\n            new_dp[val] += count\n            new_dp[num] += count\n        \n        dp = new_dp\n    \n    return sum(dp.values()) % MOD\n```"}
{"task_id": "abc373_f", "code": "d", "passed": false, "raw_code": "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    \n    items = []\n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [-float('inf')] * (W + 1)\n    dp[0] = 0\n    \n    for w, v in items:\n        for j in range(W, w - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j >= k * w:\n                    dp[j] = max(dp[j], dp[j - k * w] + k * v - k**2)\n                else:\n                    break\n    \n    print(max(dp))\n\nmax_happiness()"}
{"task_id": "arc181_c", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom itertools import product\n\ndef generate_grid(N, P, Q):\n    def is_valid(grid):\n        # Check row-wise lexicographical order\n        for i in range(1, N):\n            if grid[P[i]] <= grid[P[i - 1]]:\n                return False\n        # Check column-wise lexicographical order\n        for j in range(N):\n            col = ''.join(grid[P[i]][j] for i in range(N))\n            if col != ''.join(sorted(col)):\n                return False\n        return True\n\n    for first_row in product('01', repeat=N):\n        grid = [first_row]\n        for i in range(1, N):\n            prev_row = grid[-1]\n            next_row = []\n            for j in range(N):\n                if prev_row[j] == '0':\n                    next_row.append('1')\n                else:\n                    next_row.append('0')\n            grid.append(next_row)\n        \n        if is_valid(grid):\n            return '\\n'.join(''.join(row) for row in grid)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))"}
{"task_id": "abc368_e", "code": "def calculate_delays(N, M, X1, trains):\n    delays = [0] * M\n    delays[0] = X1\n    \n    for i in range(1, M):\n        for j in range(i):\n            if trains[i][0] == trains[j][1] and trains[i][2] <= trains[j][3]:\n                delays[i] = max(delays[i], trains[j][3] - trains[i][2] + delays[j])\n    \n    return delays\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    X1 = int(data[index])\n    index += 1\n    \n    trains = []\n    for _ in range(M):\n        trains.append((int(data[index]), int(data[index + 1]), int(data[index + 2]), int(data[index + 3])))\n        index += 4\n    \n    delays = calculate_delays(N, M, X1, trains)\n    \n    for delay in delays[1:]:\n        print(delay, end=' ')\n    print()\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef calculate_delays(N, M, X1, trains):\n    delays = [0] * M\n    delays[0] = X1\n    \n    for i in range(1, M):\n        for j in range(i):\n            if trains[i][0] == trains[j][1] and trains[i][2] <= trains[j][3]:\n                delays[i] = max(delays[i], trains[j][3] - trains[i][2] + delays[j])\n    \n    return delays\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    X1 = int(data[index])\n    index += 1\n    \n    trains = []\n    for _ in range(M):\n        trains.append((int(data[index]), int(data[index + 1]), int(data[index + 2]), int(data[index + 3])))\n        index += 4\n    \n    delays = calculate_delays(N, M, X1, trains)\n    \n    for delay in delays[1:]:\n        print(delay, end=' ')\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3552", "code": "def largestKPalindromic(n, k):\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    half = '9' * (n // 2)\n    while True:\n        if n % 2 == 0:\n            palindrome = half + half[::-1]\n        else:\n            palindrome = half + half[-2::-1]\n        \n        if int(palindrome) % k == 0:\n            return palindrome\n        \n        half = str(int(half) - 1).ljust(n // 2, '9')", "passed": false, "raw_code": "```python\ndef largestKPalindromic(n, k):\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    half = '9' * (n // 2)\n    while True:\n        if n % 2 == 0:\n            palindrome = half + half[::-1]\n        else:\n            palindrome = half + half[-2::-1]\n        \n        if int(palindrome) % k == 0:\n            return palindrome\n        \n        half = str(int(half) - 1).ljust(n // 2, '9')\n```"}
{"task_id": "arc181_b", "code": "def f(S, T, X):\n    return ''.join(S if x == '0' else T for x in X)\n\ndef check_f(S, X, Y):\n    count_X_0 = X.count('0')\n    count_X_1 = X.count('1')\n    count_Y_0 = Y.count('0')\n    count_Y_1 = Y.count('1')\n    \n    if count_X_0 != count_Y_0 or count_X_1 != count_Y_1:\n        return \"No\"\n    else:\n        return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        \n        result = check_f(S, X, Y)\n        results.append(result)\n        \n        index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    return ''.join(S if x == '0' else T for x in X)\n\ndef check_f(S, X, Y):\n    count_X_0 = X.count('0')\n    count_X_1 = X.count('1')\n    count_Y_0 = Y.count('0')\n    count_Y_1 = Y.count('1')\n    \n    if count_X_0 != count_Y_0 or count_X_1 != count_Y_1:\n        return \"No\"\n    else:\n        return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        \n        result = check_f(S, X, Y)\n        results.append(result)\n        \n        index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_d", "code": "d", "passed": false, "raw_code": "```python\ndef min_operations_to_transform():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:]))\n    \n    def is_feasible(a, b):\n        if a == b:\n            return False\n        if a == (b + 1) % M or a == (b - 1) % M:\n            return False\n        return True\n    \n    total_operations = 0\n    \n    for i in range(N):\n        if not is_feasible(A[i], B[i]):\n            print(-1)\n            return\n        \n        # Calculate the minimum operations needed\n        ops = abs(B[i] - A[i]) % M\n        total_operations += min(ops, M - ops)\n    \n    print(total_operations)\n\nmin_operations_to_transform()"}
{"task_id": "abc373_g", "code": "d", "passed": false, "raw_code": "```python\ndef find_non_intersecting_permutation(N, P, Q):\n    # Sort points P based on x-coordinates, and by y-coordinates if x-coordinates are the same\n    P.sort(key=lambda p: (p[0], p[1]))\n    \n    # Function to check if two segments intersect\n    def do_intersect(p1, q1, p2, q2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0  # collinear\n            elif val > 0:\n                return 1  # clockwise\n            else:\n                return 2  # counterclockwise\n        \n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n        return False\n    \n    # Try to find a non-intersecting permutation using backtracking\n    def backtrack(i):\n        if i == N:\n            return True\n        for j in range(1, N + 1):\n            if not used[j]:\n                if all(not do_intersect(P[i], Q[j], P[k], Q[R[k]]) for k in range(i)):\n                    R[i] = j\n                    used[j] = True\n                    if backtrack(i + 1):\n                        return True\n                    used[j] = False\n        return False\n    \n    R = [0] * N\n    used = [False] * (N + 1)\n    \n    if backtrack(0):\n        return ' '.join(map(str, R))\n    else:\n        return '-1'\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = []\nQ = []\n\nfor i in range(N):\n    P.append((int(data[2 * i + 1]), int(data[2 * i + 2])))\n\nfor i in range(N):\n    Q.append((int(data[N * 2 + 2 * i + 1]), int(data[N * 2 + 2 * i + 2])))\n\n# Find and print the result\nresult = find_non_intersecting_permutation(N, P, Q)\nprint(result)"}
{"task_id": "3563", "code": "def maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    # Set to keep track of selected values\n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through the rows\n    for row in grid:\n        # Find the largest value not already selected\n        for value in reversed(row):\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    # Set to keep track of selected values\n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through the rows\n    for row in grid:\n        # Find the largest value not already selected\n        for value in reversed(row):\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score\n```"}
{"task_id": "abc369_g", "code": "from collections import defaultdict, deque\nimport sys\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = set([start])\n    distance = {start: 0}\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n    return max(distance.values()), max(distance, key=distance.get)\n\ndef min_path_length(graph, n):\n    farthest, _ = bfs(graph, 1)\n    _, farthest_vertex = bfs(graph, farthest)\n    return bfs(graph, farthest_vertex)[0]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    diameter = min_path_length(graph, n)\n    \n    for k in range(1, n + 1):\n        if k == 1:\n            result = 2 * sum(l for _, _, l in edges)\n        elif k == 2:\n            result = sum(l for _, _, l in edges) + diameter\n        else:\n            result = 2 * sum(l for _, _, l in edges) + diameter\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nfrom collections import defaultdict, deque\nimport sys\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = set([start])\n    distance = {start: 0}\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                distance[neighbor] = distance[current] + 1\n                queue.append(neighbor)\n    return max(distance.values()), max(distance, key=distance.get)\n\ndef min_path_length(graph, n):\n    farthest, _ = bfs(graph, 1)\n    _, farthest_vertex = bfs(graph, farthest)\n    return bfs(graph, farthest_vertex)[0]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    diameter = min_path_length(graph, n)\n    \n    for k in range(1, n + 1):\n        if k == 1:\n            result = 2 * sum(l for _, _, l in edges)\n        elif k == 2:\n            result = sum(l for _, _, l in edges) + diameter\n        else:\n            result = 2 * sum(l for _, _, l in edges) + diameter\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc183_b", "code": "def can_transform(A, B, K):\n    n = len(A)\n    pos_B = {}\n    \n    # Map each value in B to its positions\n    for i, b in enumerate(B):\n        if b not in pos_B:\n            pos_B[b] = []\n        pos_B[b].append(i)\n    \n    visited = set()\n    \n    def dfs(current, target):\n        if current == target:\n            return True\n        if current in visited:\n            return False\n        visited.add(current)\n        \n        for next_pos in range(max(0, current - K), min(n, current + K + 1)):\n            if B[next_pos] == target:\n                if dfs(next_pos, target):\n                    return True\n        \n        return False\n    \n    for i, a in enumerate(A):\n        if a not in pos_B:\n            return \"No\"\n        found = False\n        for target_pos in pos_B[a]:\n            if dfs(i, target_pos):\n                found = True\n                break\n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_transform(A, B, K):\n    n = len(A)\n    pos_B = {}\n    \n    # Map each value in B to its positions\n    for i, b in enumerate(B):\n        if b not in pos_B:\n            pos_B[b] = []\n        pos_B[b].append(i)\n    \n    visited = set()\n    \n    def dfs(current, target):\n        if current == target:\n            return True\n        if current in visited:\n            return False\n        visited.add(current)\n        \n        for next_pos in range(max(0, current - K), min(n, current + K + 1)):\n            if B[next_pos] == target:\n                if dfs(next_pos, target):\n                    return True\n        \n        return False\n    \n    for i, a in enumerate(A):\n        if a not in pos_B:\n            return \"No\"\n        found = False\n        for target_pos in pos_B[a]:\n            if dfs(i, target_pos):\n                found = True\n                break\n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        result = can_transform(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc367_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        if sorted(subseq_A) == sorted(subseq_B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        if sorted(subseq_A) == sorted(subseq_B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nmain()\n```"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    death_times = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by their death times\n    sorted_enemies = sorted(zip(death_times, damage, health))\n    \n    total_damage = 0\n    \n    # Iterate through the sorted list and calculate total damage\n    for dt, d, h in sorted_enemies:\n        if h > 0:\n            attacks = int(dt // power)\n            remaining_time = dt % power\n            total_damage += attacks * d + (d if remaining_time > 0 else 0)\n            h -= attacks * d + (d if remaining_time > 0 else 0)\n    \n    return total_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    death_times = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies by their death times\n    sorted_enemies = sorted(zip(death_times, damage, health))\n    \n    total_damage = 0\n    \n    # Iterate through the sorted list and calculate total damage\n    for dt, d, h in sorted_enemies:\n        if h > 0:\n            attacks = int(dt // power)\n            remaining_time = dt % power\n            total_damage += attacks * d + (d if remaining_time > 0 else 0)\n            h -= attacks * d + (d if remaining_time > 0 else 0)\n    \n    return total_damage\n```"}
{"task_id": "arc183_d", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import deque, defaultdict\n\ndef find_leaves(n, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    leaves = []\n    degree = [0] * (n + 1)\n    \n    for a, b in edges:\n        degree[a] += 1\n        degree[b] += 1\n    \n    q = deque()\n    for i in range(1, n + 1):\n        if degree[i] == 1:\n            q.append(i)\n    \n    while q:\n        leaf = q.popleft()\n        leaves.append(leaf)\n        degree[leaf] = 0\n        for neighbor in graph[leaf]:\n            degree[neighbor] -= 1\n            if degree[neighbor] == 1:\n                q.append(neighbor)\n    \n    return leaves\n\ndef find_farthest_leaves(n, edges, leaves):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([(start, 0)])\n        visited[start] = True\n        farthest = (start, 0)\n        while queue:\n            current, dist = queue.popleft()\n            farthest = (current, dist)\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + 1))\n        return farthest\n    \n    farthest1 = bfs(leaves[0])\n    farthest2 = bfs(farthest1[0])\n    return farthest1[0], farthest2[0]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    for i in range(n - 1):\n        a = int(data[2 * i + 1])\n        b = int(data[2 * i + 2])\n        edges.append((a, b))\n    \n    leaves = find_leaves(n, edges)\n    operations = []\n    \n    while len(leaves) >= 2:\n        leaf1, leaf2 = find_farthest_leaves(n, edges, leaves)\n        operations.append((leaf1, leaf2))\n        leaves.remove(leaf1)\n        leaves.remove(leaf2)\n    \n    for op in operations:\n        print(op[0], op[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "3583", "code": "def getGCD(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    from collections import defaultdict\n    \n    gcd_count = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    sorted_gcds = sorted(gcd_count.items())\n    \n    result = []\n    for q in queries:\n        total_pairs = 0\n        for gcd_val, count in sorted_gcds:\n            if total_pairs + count > q:\n                result.append(gcd_val)\n                break\n            total_pairs += count\n    \n    return result", "passed": false, "raw_code": "```python\ndef getGCD(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    from collections import defaultdict\n    \n    gcd_count = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    sorted_gcds = sorted(gcd_count.items())\n    \n    result = []\n    for q in queries:\n        total_pairs = 0\n        for gcd_val, count in sorted_gcds:\n            if total_pairs + count > q:\n                result.append(gcd_val)\n                break\n            total_pairs += count\n    \n    return result\n```"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits, target_sum, length):\n        if length == 0:\n            return 1 if target_sum == 0 else 0\n        total = 0\n        for i in range(10):\n            if digits[i] > 0:\n                digits[i] -= 1\n                total += count_combinations(digits, target_sum - i * length // 10, length - 1)\n                digits[i] += 1\n        return total\n    \n    def count_valid_numbers(digits, target_sum, length):\n        if length == 0:\n            return 1 if target_sum == 0 else 0\n        total = 0\n        for i in range(10):\n            if digits[i] > 0:\n                digits[i] -= 1\n                if is_palindrome(str(i) * (length // 2) + str(target_sum % 10) * (length % 2)):\n                    total += count_valid_numbers(digits, target_sum - i * length // 10, length - 1)\n                digits[i] += 1\n        return total\n    \n    digits = [0] * 10\n    for i in range(1, 10):\n        if i % k == 0:\n            digits[i] = 1\n    \n    return count_valid_numbers(digits, n, n)", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits, target_sum, length):\n        if length == 0:\n            return 1 if target_sum == 0 else 0\n        total = 0\n        for i in range(10):\n            if digits[i] > 0:\n                digits[i] -= 1\n                total += count_combinations(digits, target_sum - i * length // 10, length - 1)\n                digits[i] += 1\n        return total\n    \n    def count_valid_numbers(digits, target_sum, length):\n        if length == 0:\n            return 1 if target_sum == 0 else 0\n        total = 0\n        for i in range(10):\n            if digits[i] > 0:\n                digits[i] -= 1\n                if is_palindrome(str(i) * (length // 2) + str(target_sum % 10) * (length % 2)):\n                    total += count_valid_numbers(digits, target_sum - i * length // 10, length - 1)\n                digits[i] += 1\n        return total\n    \n    digits = [0] * 10\n    for i in range(1, 10):\n        if i % k == 0:\n            digits[i] = 1\n    \n    return count_valid_numbers(digits, n, n)\n```"}
{"task_id": "abc367_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * 2**20 for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Process each element in the sequence\n    for i in range(1, N + 1):\n        new_dp = [0] * 2**20\n        for j in range(2**20):\n            new_dp[j] = dp[i-1][j]\n            new_dp[j ^ A[i-1]] += dp[i-1][j]\n        dp = new_dp\n    \n    # Calculate the sum of scores\n    total_score = 0\n    for length in range(1, N + 1):\n        if length % M == 0:\n            for xor_val in range(2**20):\n                total_score += pow(xor_val, K, MOD) * dp[length][xor_val]\n                total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * 2**20 for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    # Process each element in the sequence\n    for i in range(1, N + 1):\n        new_dp = [0] * 2**20\n        for j in range(2**20):\n            new_dp[j] = dp[i-1][j]\n            new_dp[j ^ A[i-1]] += dp[i-1][j]\n        dp = new_dp\n    \n    # Calculate the sum of scores\n    total_score = 0\n    for length in range(1, N + 1):\n        if length % M == 0:\n            for xor_val in range(2**20):\n                total_score += pow(xor_val, K, MOD) * dp[length][xor_val]\n                total_score %= MOD\n    \n    print(total_score)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3550", "code": "from itertools import combinations\n\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero values\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure we have enough non-zero rows and columns\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Generate all combinations of 3 rows and 3 columns\n    row_combinations = combinations(non_zero_rows, 3)\n    col_combinations = combinations(non_zero_cols, 3)\n    \n    max_sum = float('-inf')\n    \n    # Iterate over all combinations of rows and columns\n    for rows in row_combinations:\n        for cols in col_combinations:\n            current_sum = sum(board[r][c] for r in rows for c in cols)\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "passed": false, "raw_code": "```python\nfrom itertools import combinations\n\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with non-zero values\n    non_zero_rows = [i for i in range(m) if any(board[i][j] != 0 for j in range(n))]\n    non_zero_cols = [j for j in range(n) if any(board[i][j] != 0 for i in range(m))]\n    \n    # Ensure we have enough non-zero rows and columns\n    if len(non_zero_rows) < 3 or len(non_zero_cols) < 3:\n        return 0\n    \n    # Generate all combinations of 3 rows and 3 columns\n    row_combinations = combinations(non_zero_rows, 3)\n    col_combinations = combinations(non_zero_cols, 3)\n    \n    max_sum = float('-inf')\n    \n    # Iterate over all combinations of rows and columns\n    for rows in row_combinations:\n        for cols in col_combinations:\n            current_sum = sum(board[r][c] for r in rows for c in cols)\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```"}
{"task_id": "abc367_e", "code": "def apply_operations(N, K, X, A):\n    # Step 1: Detect the cycle\n    visited = set()\n    current = 0\n    while current not in visited:\n        visited.add(current)\n        current = X[current] - 1\n    \n    # Step 2: Find the start of the cycle and its length\n    cycle_start = current\n    cycle_length = 0\n    while True:\n        current = X[current] - 1\n        cycle_length += 1\n        if current == cycle_start:\n            break\n    \n    # Step 3: Calculate effective number of operations\n    effective_k = K % cycle_length\n    \n    # Step 4: Apply the effective number of operations\n    result = A[:]\n    for _ in range(effective_k):\n        result = [A[X[i] - 1] for i in range(N)]\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Get the result\nresult = apply_operations(N, K, X, A)\n\n# Print the result\nprint(\" \".join(map(str, result)))", "passed": false, "raw_code": "```python\ndef apply_operations(N, K, X, A):\n    # Step 1: Detect the cycle\n    visited = set()\n    current = 0\n    while current not in visited:\n        visited.add(current)\n        current = X[current] - 1\n    \n    # Step 2: Find the start of the cycle and its length\n    cycle_start = current\n    cycle_length = 0\n    while True:\n        current = X[current] - 1\n        cycle_length += 1\n        if current == cycle_start:\n            break\n    \n    # Step 3: Calculate effective number of operations\n    effective_k = K % cycle_length\n    \n    # Step 4: Apply the effective number of operations\n    result = A[:]\n    for _ in range(effective_k):\n        result = [A[X[i] - 1] for i in range(N)]\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Get the result\nresult = apply_operations(N, K, X, A)\n\n# Print the result\nprint(\" \".join(map(str, result)))\n```"}
{"task_id": "abc368_d", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef dfs(node, parent):\n    stack = [(node, parent)]\n    while stack:\n        current, p = stack.pop()\n        visited[current] = True\n        parent_map[current] = p\n        for neighbor in adj_list[current]:\n            if not visited[neighbor]:\n                stack.append((neighbor, current))\n\ndef lca(u, v):\n    while u != v:\n        if level[u] > level[v]:\n            u = parent_map[u]\n        elif level[v] > level[u]:\n            v = parent_map[v]\n        else:\n            u = parent_map[u]\n            v = parent_map[v]\n    return u\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    rootX = find(x)\n    rootY = find(y)\n    if rootX != rootY:\n        parent[rootX] = rootY\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nedges = []\nfor i in range(N - 1):\n    A = int(data[2 + 2 * i]) - 1\n    B = int(data[3 + 2 * i]) - 1\n    edges.append((A, B))\n\nvertices = list(map(int, data[2 * N + 1:]))\n\nadj_list = defaultdict(list)\nfor A, B in edges:\n    adj_list[A].append(B)\n    adj_list[B].append(A)\n\nvisited = [False] * N\nparent_map = [-1] * N\nlevel = [0] * N\nparent = list(range(N))\n\ndfs(0, -1)\n\n# Compute LCA for pairs of vertices\nlca_values = {}\nfor i in range(K):\n    for j in range(i + 1, K):\n        u = vertices[i] - 1\n        v = vertices[j] - 1\n        if (u, v) not in lca_values and (v, u) not in lca_values:\n            lca_values[(u, v)] = lca(u, v)\n\n# Union-Find to merge connected components\ncomponents = set(vertices)\nfor u, v in edges:\n    if (u, v) in lca_values or (v, u) in lca_values:\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            union(root_u, root_v)\n            components.remove(root_u)\n            components.remove(root_v)\n\nprint(len(components))", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef dfs(node, parent):\n    stack = [(node, parent)]\n    while stack:\n        current, p = stack.pop()\n        visited[current] = True\n        parent_map[current] = p\n        for neighbor in adj_list[current]:\n            if not visited[neighbor]:\n                stack.append((neighbor, current))\n\ndef lca(u, v):\n    while u != v:\n        if level[u] > level[v]:\n            u = parent_map[u]\n        elif level[v] > level[u]:\n            v = parent_map[v]\n        else:\n            u = parent_map[u]\n            v = parent_map[v]\n    return u\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    rootX = find(x)\n    rootY = find(y)\n    if rootX != rootY:\n        parent[rootX] = rootY\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\n\nedges = []\nfor i in range(N - 1):\n    A = int(data[2 + 2 * i]) - 1\n    B = int(data[3 + 2 * i]) - 1\n    edges.append((A, B))\n\nvertices = list(map(int, data[2 * N + 1:]))\n\nadj_list = defaultdict(list)\nfor A, B in edges:\n    adj_list[A].append(B)\n    adj_list[B].append(A)\n\nvisited = [False] * N\nparent_map = [-1] * N\nlevel = [0] * N\nparent = list(range(N))\n\ndfs(0, -1)\n\n# Compute LCA for pairs of vertices\nlca_values = {}\nfor i in range(K):\n    for j in range(i + 1, K):\n        u = vertices[i] - 1\n        v = vertices[j] - 1\n        if (u, v) not in lca_values and (v, u) not in lca_values:\n            lca_values[(u, v)] = lca(u, v)\n\n# Union-Find to merge connected components\ncomponents = set(vertices)\nfor u, v in edges:\n    if (u, v) in lca_values or (v, u) in lca_values:\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            union(root_u, root_v)\n            components.remove(root_u)\n            components.remove(root_v)\n\nprint(len(components))\n```"}
{"task_id": "arc181_d", "code": "def update(bit, i, delta):\n    while i < len(bit):\n        bit[i] += delta\n        i += i & -i\n\ndef query(bit, i):\n    result = 0\n    while i > 0:\n        result += bit[i]\n        i -= i & -i\n    return result\n\ndef count_inversions(p):\n    n = len(p)\n    bit = [0] * (n + 1)\n    inversions = 0\n    for i in range(n - 1, -1, -1):\n        inversions += query(bit, p[i])\n        update(bit, p[i], 1)\n    return inversions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    inversions = count_inversions(P)\n    print(inversions)\n    \n    for a in A:\n        index = P.index(a)\n        if index > 0:\n            inversions -= query(bit, P[index-1])\n            inversions += query(bit, a-1)\n            update(bit, P[index-1], -1)\n            update(bit, a, 1)\n        P[index] = a\n        print(inversions)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef update(bit, i, delta):\n    while i < len(bit):\n        bit[i] += delta\n        i += i & -i\n\ndef query(bit, i):\n    result = 0\n    while i > 0:\n        result += bit[i]\n        i -= i & -i\n    return result\n\ndef count_inversions(p):\n    n = len(p)\n    bit = [0] * (n + 1)\n    inversions = 0\n    for i in range(n - 1, -1, -1):\n        inversions += query(bit, p[i])\n        update(bit, p[i], 1)\n    return inversions\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    inversions = count_inversions(P)\n    print(inversions)\n    \n    for a in A:\n        index = P.index(a)\n        if index > 0:\n            inversions -= query(bit, P[index-1])\n            inversions += query(bit, a-1)\n            update(bit, P[index-1], -1)\n            update(bit, a, 1)\n        P[index] = a\n        print(inversions)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc373_e", "code": "def min_additional_votes(N, M, K, A):\n    total_votes = sum(A)\n    remaining_votes = K - total_votes\n    sorted_votes = sorted(A, reverse=True)\n    results = []\n    for i in range(N):\n        if sorted_votes[i] >= sorted_votes[0] + 1:\n            results.append(-1)\n        elif i < M - 1 and sorted_votes[i] + remaining_votes <= sorted_votes[M - 1]:\n            results.append(-1)\n        else:\n            needed_votes = max(0, sorted_votes[0] - sorted_votes[i] + 1)\n            results.append(needed_votes)\n    return ' '.join(map(str, results))\n\n# Example usage:\nprint(min_additional_votes(5, 2, 16, [3, 1, 4, 1, 5]))  # Output: 2 -1 1 -1 0\nprint(min_additional_votes(12, 1, 570, [81, 62, 17, 5, 5, 86, 15, 7, 79, 26, 6, 28]))  # Output: 79 89 111 117 117 74 112 116 80 107 117 106", "passed": false, "raw_code": "def min_additional_votes(N, M, K, A):\n    total_votes = sum(A)\n    remaining_votes = K - total_votes\n    sorted_votes = sorted(A, reverse=True)\n    results = []\n    for i in range(N):\n        if sorted_votes[i] >= sorted_votes[0] + 1:\n            results.append(-1)\n        elif i < M - 1 and sorted_votes[i] + remaining_votes <= sorted_votes[M - 1]:\n            results.append(-1)\n        else:\n            needed_votes = max(0, sorted_votes[0] - sorted_votes[i] + 1)\n            results.append(needed_votes)\n    return ' '.join(map(str, results))\n\n# Example usage:\nprint(min_additional_votes(5, 2, 16, [3, 1, 4, 1, 5]))  # Output: 2 -1 1 -1 0\nprint(min_additional_votes(12, 1, 570, [81, 62, 17, 5, 5, 86, 15, 7, 79, 26, 6, 28]))  # Output: 79 89 111 117 117 74 112 116 80 107 117 106"}
{"task_id": "abc372_g", "code": "def count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    for x in range(1, 10**9 + 1):\n        max_y = 0\n        for i in range(N):\n            if A[i] * x < C[i]:\n                max_y = max(max_y, (C[i] - A[i] * x - 1) // B[i])\n        if max_y > 0:\n            count += max_y\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        results.append(count_valid_pairs(A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef count_valid_pairs(A, B, C):\n    N = len(A)\n    count = 0\n    for x in range(1, 10**9 + 1):\n        max_y = 0\n        for i in range(N):\n            if A[i] * x < C[i]:\n                max_y = max(max_y, (C[i] - A[i] * x - 1) // B[i])\n        if max_y > 0:\n            count += max_y\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        results.append(count_valid_pairs(A, B, C))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc369_e", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef find_min_time(N, M, bridges, queries):\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def min_time_to_reach_all_bridges(query_bridges):\n        visited = set()\n        min_time = float('inf')\n        for bridge in query_bridges:\n            u, v, t = bridges[bridge - 1]\n            visited.add(u)\n            visited.add(v)\n            queue = deque([(u, 0)])\n            while queue:\n                node, time = queue.popleft()\n                if node == v:\n                    min_time = min(min_time, time + t)\n                    break\n                for neighbor, weight in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, time + weight))\n        return min_time\n\n    results = []\n    for query_bridges in queries:\n        results.append(min_time_to_reach_all_bridges(query_bridges))\n\n    return results\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n\n    bridges = []\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        bridges.append((u, v, t))\n\n    Q = int(data[index])\n    index += 1\n\n    queries = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        query_bridges = list(map(int, data[index:index + K]))\n        index += K\n        queries.append(query_bridges)\n\n    results = find_min_time(N, M, bridges, queries)\n\n    for result in results:\n        print(result)\n\nfind_min_time(N, M, bridges, queries)", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict, deque\n\ndef find_min_time(N, M, bridges, queries):\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def min_time_to_reach_all_bridges(query_bridges):\n        visited = set()\n        min_time = float('inf')\n        for bridge in query_bridges:\n            u, v, t = bridges[bridge - 1]\n            visited.add(u)\n            visited.add(v)\n            queue = deque([(u, 0)])\n            while queue:\n                node, time = queue.popleft()\n                if node == v:\n                    min_time = min(min_time, time + t)\n                    break\n                for neighbor, weight in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append((neighbor, time + weight))\n        return min_time\n\n    results = []\n    for query_bridges in queries:\n        results.append(min_time_to_reach_all_bridges(query_bridges))\n\n    return results\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n\n    bridges = []\n    for _ in range(M):\n        u = int(data[index])\n        index += 1\n        v = int(data[index])\n        index += 1\n        t = int(data[index])\n        index += 1\n        bridges.append((u, v, t))\n\n    Q = int(data[index])\n    index += 1\n\n    queries = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        query_bridges = list(map(int, data[index:index + K]))\n        index += K\n        queries.append(query_bridges)\n\n    results = find_min_time(N, M, bridges, queries)\n\n    for result in results:\n        print(result)\n\nfind_min_time(N, M, bridges, queries)"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, Q + 1):\n        for j in range(N + 1):\n            if j >= P[i - 1]:\n                dp[i][j] += dp[i - 1][j]\n                dp[i][j] %= MOD\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n                dp[i][j] %= MOD\n    \n    return dp[Q][N]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\nfor k in range(Q):\n    P.append(int(data[2 + 2 * k]))\n    V.append(int(data[3 + 2 * k]))\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)", "passed": false, "raw_code": "```python\ndef count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, Q + 1):\n        for j in range(N + 1):\n            if j >= P[i - 1]:\n                dp[i][j] += dp[i - 1][j]\n                dp[i][j] %= MOD\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n                dp[i][j] %= MOD\n    \n    return dp[Q][N]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nP = []\nV = []\nfor k in range(Q):\n    P.append(int(data[2 + 2 * k]))\n    V.append(int(data[3 + 2 * k]))\n\n# Calculate and print the result\nresult = count_valid_sequences(N, Q, P, V)\nprint(result)\n```"}
{"task_id": "3575", "code": "def max_subsequence_value(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    # Precompute OR values for all possible segments of length k\n    or_values = [[0] * (n - k + 1) for _ in range(k)]\n    for i in range(n - k + 1):\n        current_or = 0\n        for j in range(i, i + k):\n            current_or |= nums[j]\n        or_values[0][i] = current_or\n    \n    for l in range(1, k):\n        for i in range(n - k + 1):\n            or_values[l][i] = or_values[l-1][i] | nums[i+l-1]\n    \n    # Calculate the maximum value of the sequence\n    for i in range(n - 2*k + 1):\n        left_or = or_values[k-1][i]\n        right_or = or_values[k-1][i+k]\n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val", "passed": false, "raw_code": "```python\ndef max_subsequence_value(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    # Precompute OR values for all possible segments of length k\n    or_values = [[0] * (n - k + 1) for _ in range(k)]\n    for i in range(n - k + 1):\n        current_or = 0\n        for j in range(i, i + k):\n            current_or |= nums[j]\n        or_values[0][i] = current_or\n    \n    for l in range(1, k):\n        for i in range(n - k + 1):\n            or_values[l][i] = or_values[l-1][i] | nums[i+l-1]\n    \n    # Calculate the maximum value of the sequence\n    for i in range(n - 2*k + 1):\n        left_or = or_values[k-1][i]\n        right_or = or_values[k-1][i+k]\n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val\n```"}
{"task_id": "3560", "code": "from collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if (cx, cy) == (px, py):\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(positions))\n    if key in memo:\n        return memo[key]\n    \n    max_moves = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        bob_moves = max_moves_alice(px, py, remaining_positions, memo)\n        alice_moves = moves + bob_moves\n        max_moves = max(max_moves, alice_moves)\n    \n    memo[key] = max_moves\n    return max_moves\n\ndef min_moves_bob(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(positions))\n    if key in memo:\n        return memo[key]\n    \n    min_moves = float('inf')\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        alice_moves = min_moves_bob(px, py, remaining_positions, memo)\n        bob_moves = moves + alice_moves\n        min_moves = min(min_moves, bob_moves)\n    \n    memo[key] = min_moves\n    return min_moves\n\ndef max_total_moves(kx, ky, positions):\n    memo = {}\n    alice_moves = max_moves_alice(kx, ky, positions, memo)\n    return alice_moves\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3", "passed": false, "raw_code": "```python\nfrom collections import deque\n\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if (cx, cy) == (px, py):\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(positions))\n    if key in memo:\n        return memo[key]\n    \n    max_moves = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        bob_moves = max_moves_alice(px, py, remaining_positions, memo)\n        alice_moves = moves + bob_moves\n        max_moves = max(max_moves, alice_moves)\n    \n    memo[key] = max_moves\n    return max_moves\n\ndef min_moves_bob(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(positions))\n    if key in memo:\n        return memo[key]\n    \n    min_moves = float('inf')\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        alice_moves = min_moves_bob(px, py, remaining_positions, memo)\n        bob_moves = moves + alice_moves\n        min_moves = min(min_moves, bob_moves)\n    \n    memo[key] = min_moves\n    return min_moves\n\ndef max_total_moves(kx, ky, positions):\n    memo = {}\n    alice_moves = max_moves_alice(kx, ky, positions, memo)\n    return alice_moves\n\n# Example usage:\nprint(max_total_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_total_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_total_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```"}
{"task_id": "arc182_c", "code": "def sum_of_scores(N, M):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [0] * (M + 1)\n    dp[1] = 1\n    \n    # Iterate over all possible sequences\n    for i in range(1, N + 1):\n        new_dp = [0] * (M + 1)\n        for j in range(1, M + 1):\n            for k in range(1, M + 1):\n                if j * k <= M:\n                    new_dp[j * k] += dp[j] * dp[k]\n                    new_dp[j * k] %= MOD\n        dp = new_dp\n    \n    # Calculate the total number of sequences and their scores\n    total_sequences = 0\n    total_score = 0\n    for j in range(1, M + 1):\n        total_sequences += dp[j]\n        total_sequences %= MOD\n        # Calculate the number of divisors of j\n        divisors = 1\n        for p in range(2, j + 1):\n            count = 0\n            while j % p == 0:\n                j //= p\n                count += 1\n            divisors *= (count + 1)\n        total_score += dp[j] * divisors\n        total_score %= MOD\n    \n    return total_score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(sum_of_scores(N, M))", "passed": false, "raw_code": "```python\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [0] * (M + 1)\n    dp[1] = 1\n    \n    # Iterate over all possible sequences\n    for i in range(1, N + 1):\n        new_dp = [0] * (M + 1)\n        for j in range(1, M + 1):\n            for k in range(1, M + 1):\n                if j * k <= M:\n                    new_dp[j * k] += dp[j] * dp[k]\n                    new_dp[j * k] %= MOD\n        dp = new_dp\n    \n    # Calculate the total number of sequences and their scores\n    total_sequences = 0\n    total_score = 0\n    for j in range(1, M + 1):\n        total_sequences += dp[j]\n        total_sequences %= MOD\n        # Calculate the number of divisors of j\n        divisors = 1\n        for p in range(2, j + 1):\n            count = 0\n            while j % p == 0:\n                j //= p\n                count += 1\n            divisors *= (count + 1)\n        total_score += dp[j] * divisors\n        total_score %= MOD\n    \n    return total_score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(sum_of_scores(N, M))\n```"}
{"task_id": "abc372_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    adj_list = [[] for _ in range(N + 1)]\n\n    results = []\n\n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            index += 3\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            neighbors = sorted(set(adj_list[v]))\n            if len(neighbors) >= k:\n                results.append(str(neighbors[-k]))\n            else:\n                results.append('-1')\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n\n    adj_list = [[] for _ in range(N + 1)]\n\n    results = []\n\n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            index += 3\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            neighbors = sorted(set(adj_list[v]))\n            if len(neighbors) >= k:\n                results.append(str(neighbors[-k]))\n            else:\n                results.append('-1')\n            index += 3\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc183_c", "code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            dp[i][j] = dp[i][j - 1]\n            for l, r, x in conditions:\n                if l <= i and j <= r and x == i:\n                    dp[i][j] = (dp[i][j] - dp[l - 1][j - 1] + MOD) % MOD\n    \n    return dp[N][N]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = []\n    index = 2\n    for _ in range(M):\n        L = int(data[index])\n        R = int(data[index + 1])\n        X = int(data[index + 2])\n        conditions.append((L, R, X))\n        index += 3\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            dp[i][j] = dp[i][j - 1]\n            for l, r, x in conditions:\n                if l <= i and j <= r and x == i:\n                    dp[i][j] = (dp[i][j] - dp[l - 1][j - 1] + MOD) % MOD\n    \n    return dp[N][N]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = []\n    index = 2\n    for _ in range(M):\n        L = int(data[index])\n        R = int(data[index + 1])\n        X = int(data[index + 2])\n        conditions.append((L, R, X))\n        index += 3\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3551", "code": "def max_xor_subarray(nums, queries):\n    def add(num, trie):\n        node = trie\n        for bit in reversed(range(32)):\n            b = (num >> bit) & 1\n            if b not in node:\n                node[b] = {}\n            node = node[b]\n\n    def maxXOR(num, trie):\n        node = trie\n        xor_val = 0\n        for bit in reversed(range(32)):\n            b = (num >> bit) & 1\n            if 1 - b in node:\n                xor_val |= 1 << bit\n                node = node[1 - b]\n            else:\n                node = node[b]\n        return xor_val\n\n    trie = {}\n    prefixXor = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefixXor[i + 1] = prefixXor[i] ^ nums[i]\n        add(prefixXor[i + 1], trie)\n\n    result = []\n    for l, r in queries:\n        max_xor = maxXOR(prefixXor[r + 1] ^ prefixXor[l], trie)\n        result.append(max_xor)\n\n    return result", "passed": false, "raw_code": "def max_xor_subarray(nums, queries):\n    def add(num, trie):\n        node = trie\n        for bit in reversed(range(32)):\n            b = (num >> bit) & 1\n            if b not in node:\n                node[b] = {}\n            node = node[b]\n\n    def maxXOR(num, trie):\n        node = trie\n        xor_val = 0\n        for bit in reversed(range(32)):\n            b = (num >> bit) & 1\n            if 1 - b in node:\n                xor_val |= 1 << bit\n                node = node[1 - b]\n            else:\n                node = node[b]\n        return xor_val\n\n    trie = {}\n    prefixXor = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefixXor[i + 1] = prefixXor[i] ^ nums[i]\n        add(prefixXor[i + 1], trie)\n\n    result = []\n    for l, r in queries:\n        max_xor = maxXOR(prefixXor[r + 1] ^ prefixXor[l], trie)\n        result.append(max_xor)\n\n    return result"}
{"task_id": "abc370_g", "code": "def sum_of_divisors(n):\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            count = 0\n            current_sum = 1\n            current_term = 1\n            while n % i == 0:\n                n //= i\n                count += 1\n                current_term *= i\n                current_sum += current_term\n            divisors_sum *= current_sum\n    if n > 1:\n        divisors_sum *= (1 + n)\n    return divisors_sum\n\nMOD = 998244353\n\ndef count_good_sequences(N, M):\n    max_product = 10**10\n    dp = [[[0] * 3 for _ in range(max_product + 1)] for _ in range(M + 1)]\n    dp[0][1][0] = 1\n\n    for i in range(1, M + 1):\n        for j in range(1, max_product + 1):\n            for k in range(3):\n                for divisor in range(1, j + 1):\n                    if j % divisor == 0:\n                        new_product = j // divisor\n                        new_sum_divisors = (sum_of_divisors(divisor) * dp[i - 1][new_product][k]) % MOD\n                        new_k = (k + sum_of_divisors(divisor)) % 3\n                        dp[i][j][new_k] = (dp[i][j][new_k] + new_sum_divisors) % MOD\n\n    result = 0\n    for j in range(1, max_product + 1):\n        if dp[M][j][0] != 0:\n            result = (result + dp[M][j][0]) % MOD\n\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Output the result\nprint(count_good_sequences(N, M))", "passed": false, "raw_code": "```python\ndef sum_of_divisors(n):\n    divisors_sum = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            count = 0\n            current_sum = 1\n            current_term = 1\n            while n % i == 0:\n                n //= i\n                count += 1\n                current_term *= i\n                current_sum += current_term\n            divisors_sum *= current_sum\n    if n > 1:\n        divisors_sum *= (1 + n)\n    return divisors_sum\n\nMOD = 998244353\n\ndef count_good_sequences(N, M):\n    max_product = 10**10\n    dp = [[[0] * 3 for _ in range(max_product + 1)] for _ in range(M + 1)]\n    dp[0][1][0] = 1\n\n    for i in range(1, M + 1):\n        for j in range(1, max_product + 1):\n            for k in range(3):\n                for divisor in range(1, j + 1):\n                    if j % divisor == 0:\n                        new_product = j // divisor\n                        new_sum_divisors = (sum_of_divisors(divisor) * dp[i - 1][new_product][k]) % MOD\n                        new_k = (k + sum_of_divisors(divisor)) % 3\n                        dp[i][j][new_k] = (dp[i][j][new_k] + new_sum_divisors) % MOD\n\n    result = 0\n    for j in range(1, max_product + 1):\n        if dp[M][j][0] != 0:\n            result = (result + dp[M][j][0]) % MOD\n\n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Output the result\nprint(count_good_sequences(N, M))\n```"}
{"task_id": "3527", "code": "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors[:2]  # Extend the list to handle circular nature\n    group_counts = {}\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i + size]\n            if all(group[j] != group[j + 1] for j in range(size - 1)):\n                count += 1\n        return count\n    \n    def update_color(index, new_color):\n        nonlocal colors\n        colors[index] = new_color\n        for size in range(3, n + 1):\n            if size in group_counts:\n                group_counts[size] -= 1\n                if count_alternating_groups(size) > 0:\n                    group_counts[size] += 1\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            if size not in group_counts:\n                group_counts[size] = count_alternating_groups(size)\n            result.append(group_counts[size])\n        elif query[0] == 2:\n            index = query[1]\n            new_color = query[2]\n            update_color(index, new_color)\n    \n    return result", "passed": false, "raw_code": "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors = colors + colors[:2]  # Extend the list to handle circular nature\n    group_counts = {}\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > 2 * n:\n                break\n            group = colors[i:i + size]\n            if all(group[j] != group[j + 1] for j in range(size - 1)):\n                count += 1\n        return count\n    \n    def update_color(index, new_color):\n        nonlocal colors\n        colors[index] = new_color\n        for size in range(3, n + 1):\n            if size in group_counts:\n                group_counts[size] -= 1\n                if count_alternating_groups(size) > 0:\n                    group_counts[size] += 1\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            if size not in group_counts:\n                group_counts[size] = count_alternating_groups(size)\n            result.append(group_counts[size])\n        elif query[0] == 2:\n            index = query[1]\n            new_color = query[2]\n            update_color(index, new_color)\n    \n    return result\n```"}
{"task_id": "abc365_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    total_sum = 0\n    \n    # Calculate the contribution of each element\n    for i in range(N):\n        left_contributions = prefix_xor[i]\n        right_contributions = prefix_xor[N] ^ prefix_xor[i + 1]\n        total_sum += (left_contributions + right_contributions) * (N - i)\n    \n    print(total_sum)\n\n# Call the function to execute\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Compute prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    total_sum = 0\n    \n    # Calculate the contribution of each element\n    for i in range(N):\n        left_contributions = prefix_xor[i]\n        right_contributions = prefix_xor[N] ^ prefix_xor[i + 1]\n        total_sum += (left_contributions + right_contributions) * (N - i)\n    \n    print(total_sum)\n\n# Call the function to execute\nmain()\n```"}
{"task_id": "abc371_e", "code": "def calculate_sum_of_f():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Dictionary to store the last seen index of each element\n    last_seen = {}\n    # Set to store distinct elements in the current window\n    current_distinct = set()\n    # Variable to store the total count of distinct values\n    total_count = 0\n    \n    for i in range(N):\n        if A[i] not in current_distinct:\n            current_distinct.add(A[i])\n            total_count += len(current_distinct)\n        \n        for j in range(i + 1, N):\n            if A[j] not in current_distinct:\n                current_distinct.add(A[j])\n                total_count += len(current_distinct)\n            else:\n                break\n    \n    print(total_count)\n\ncalculate_sum_of_f()", "passed": false, "raw_code": "```python\ndef calculate_sum_of_f():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Dictionary to store the last seen index of each element\n    last_seen = {}\n    # Set to store distinct elements in the current window\n    current_distinct = set()\n    # Variable to store the total count of distinct values\n    total_count = 0\n    \n    for i in range(N):\n        if A[i] not in current_distinct:\n            current_distinct.add(A[i])\n            total_count += len(current_distinct)\n        \n        for j in range(i + 1, N):\n            if A[j] not in current_distinct:\n                current_distinct.add(A[j])\n                total_count += len(current_distinct)\n            else:\n                break\n    \n    print(total_count)\n\ncalculate_sum_of_f()\n```"}
{"task_id": "abc371_g", "code": "def min_lexicographical_array():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:]))\n\n    # Create a mapping from each element to its position in the permutation\n    pos = {A[i]: i for i in range(N)}\n\n    # Sort elements of A based on their positions in the permutation\n    sorted_A = sorted(A, key=lambda x: pos[x])\n\n    # Print the sorted array\n    print(' '.join(map(str, sorted_A)))\n\nmin_lexicographical_array()", "passed": false, "raw_code": "def min_lexicographical_array():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:]))\n\n    # Create a mapping from each element to its position in the permutation\n    pos = {A[i]: i for i in range(N)}\n\n    # Sort elements of A based on their positions in the permutation\n    sorted_A = sorted(A, key=lambda x: pos[x])\n\n    # Print the sorted array\n    print(' '.join(map(str, sorted_A)))\n\nmin_lexicographical_array()"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    def dfs(i, j):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        \n        dp[i][j] = 1\n        for dx, dy in [(0, 1), (1, 0)]:\n            ni, nj = i + dx, j + dy\n            if 0 <= ni < len(coords) and 0 <= nj < len(coords[0]) and coords[ni][nj] > coords[i][j]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(ni, nj))\n        \n        return dp[i][j]\n    \n    coords = sorted(coordinates)\n    n = len(coords)\n    dp = [[-1] * n for _ in range(n)]\n    \n    max_path = 0\n    for i in range(n):\n        for j in range(n):\n            if coords[j] == coordinates[k]:\n                max_path = max(max_path, dfs(j, i))\n    \n    return max_path", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    def dfs(i, j):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        \n        dp[i][j] = 1\n        for dx, dy in [(0, 1), (1, 0)]:\n            ni, nj = i + dx, j + dy\n            if 0 <= ni < len(coords) and 0 <= nj < len(coords[0]) and coords[ni][nj] > coords[i][j]:\n                dp[i][j] = max(dp[i][j], 1 + dfs(ni, nj))\n        \n        return dp[i][j]\n    \n    coords = sorted(coordinates)\n    n = len(coords)\n    dp = [[-1] * n for _ in range(n)]\n    \n    max_path = 0\n    for i in range(n):\n        for j in range(n):\n            if coords[j] == coordinates[k]:\n                max_path = max(max_path, dfs(j, i))\n    \n    return max_path\n```"}
{"task_id": "3580", "code": "def smallest_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    min_index = float('inf')\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            min_index = min(min_index, i)\n    \n    return min_index if min_index != float('inf') else -1\n\n# Example usage:\nprint(smallest_almost_equal_substring(\"abcdefg\", \"bcdffg\"))  # Output: 1\nprint(smallest_almost_equal_substring(\"ababbababa\", \"bacaba\"))  # Output: 4\nprint(smallest_almost_equal_substring(\"abcd\", \"dba\"))  # Output: -1\nprint(smallest_almost_equal_substring(\"dde\", \"d\"))  # Output: 0", "passed": false, "raw_code": "```python\ndef smallest_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    min_index = float('inf')\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            min_index = min(min_index, i)\n    \n    return min_index if min_index != float('inf') else -1\n\n# Example usage:\nprint(smallest_almost_equal_substring(\"abcdefg\", \"bcdffg\"))  # Output: 1\nprint(smallest_almost_equal_substring(\"ababbababa\", \"bacaba\"))  # Output: 4\nprint(smallest_almost_equal_substring(\"abcd\", \"dba\"))  # Output: -1\nprint(smallest_almost_equal_substring(\"dde\", \"d\"))  # Output: 0\n```"}
{"final_accuracy": "0.00%"}
