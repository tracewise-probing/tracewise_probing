"{\"difficulty\": \"medium\", \"num_threads\": 32, \"temperature\": 0.7, \"n\": 16, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_vanilla_bug_trace_TPL_NEXT_qwen_7b_medium_n_16.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3579", "codes": ["def max_concatenated_number(nums):\n    # Sort the numbers in descending order\n    nums.sort(reverse=True)\n    \n    # Convert each number to binary and remove the '0b' prefix\n    binary_strings = [bin(num)[2:] for num in nums]\n    \n    # Concatenate the binary strings\n    concatenated_binary = ''.join(binary_strings)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def maxNumber(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Generate all possible permutations of the binary strings\n    from itertools import permutations\n    perms = permutations(binary_nums)\n    \n    # Convert concatenated binary strings back to integers and find the maximum\n    max_val = max(int(''.join(p), 2) for p in perms)\n    \n    return max_val", "def max_possible_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their numerical value\n    sorted_binary_nums = sorted(binary_nums, key=lambda x: int(x, 2), reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(sorted_binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def max_binary_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order\n    binary_nums.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def maximumNumber(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_representations = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary representations based on a custom comparator\n    # This comparator ensures that the most significant bits come first\n    binary_representations.sort(key=lambda x: x.zfill(8))\n    \n    # Reverse the sorted list to get the largest possible number\n    binary_representations.reverse()\n    \n    # Concatenate the binary representations\n    concatenated_binary = ''.join(binary_representations)\n    \n    # Convert the concatenated binary string to an integer\n    result = int(concatenated_binary, 2)\n    \n    return result", "def max_concatenated_binary(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order\n    binary_nums.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def maximum_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their integer value\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    max_number = int(concatenated_binary, 2)\n    \n    return max_number", "def max_concatenated_number(nums):\n    # Convert each number to its binary representation and sort them in descending order\n    binary_nums = sorted([bin(num)[2:] for num in nums], reverse=True)\n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def max_number(nums):\n    # Convert each number to its binary representation without the '0b' prefix\n    bin_nums = [bin(num)[2:] for num in nums]\n    \n    # Define a custom comparator to sort the binary strings\n    def compare(x, y):\n        return int(y + x) - int(x + y)\n    \n    # Sort the binary strings using the custom comparator\n    bin_nums.sort(key=functools.cmp_to_key(compare))\n    \n    # Concatenate the sorted binary strings\n    result_bin = ''.join(bin_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    result_num = int(result_bin, 2)\n    \n    return result_num", "def max_possible_number(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_representations = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary representations by length in descending order\n    binary_representations.sort(key=len, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_representations)\n    \n    # Convert the concatenated binary string back to a decimal number\n    return int(concatenated_binary, 2)", "def max_concatenated_number(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their numeric value\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def max_possible_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Generate all permutations of the binary strings\n    from itertools import permutations\n    permuted_binaries = [''.join(p) for p in permutations(binary_nums)]\n    \n    # Convert each concatenated binary string back to a decimal number\n    decimal_values = [int(b, 2) for b in permuted_binaries]\n    \n    # Return the maximum decimal number\n    return max(decimal_values)", "def max_concatenated_number(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings based on their numerical value in descending order\n    binary_nums.sort(key=lambda x: int(x, 2), reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    result = int(concatenated_binary, 2)\n    \n    return result", "def maximumNumber(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Define a custom comparison function\n    def compare(x, y):\n        return (x + y) > (y + x)\n    \n    # Sort the binary numbers using the custom comparison function\n    binary_nums.sort(key=functools.cmp_to_key(compare), reverse=True)\n    \n    # Concatenate the sorted binary numbers\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to a decimal number\n    return int(concatenated_binary, 2)", "def max_concatenated_binary(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_representations = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary representations in descending order\n    binary_representations.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_representations)\n    \n    # Convert the concatenated binary string back to a decimal number\n    return int(concatenated_binary, 2)", "def max_binary_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their first character\n    binary_nums.sort(key=lambda x: x[0], reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)"], "passed": [false, true, false, false, false, false, false, false, false, false, false, true, false, false, false, false], "raw_code": ["```python\ndef max_concatenated_number(nums):\n    # Sort the numbers in descending order\n    nums.sort(reverse=True)\n    \n    # Convert each number to binary and remove the '0b' prefix\n    binary_strings = [bin(num)[2:] for num in nums]\n    \n    # Concatenate the binary strings\n    concatenated_binary = ''.join(binary_strings)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef maxNumber(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Generate all possible permutations of the binary strings\n    from itertools import permutations\n    perms = permutations(binary_nums)\n    \n    # Convert concatenated binary strings back to integers and find the maximum\n    max_val = max(int(''.join(p), 2) for p in perms)\n    \n    return max_val\n```", "```python\ndef max_possible_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their numerical value\n    sorted_binary_nums = sorted(binary_nums, key=lambda x: int(x, 2), reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(sorted_binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef max_binary_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order\n    binary_nums.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef maximumNumber(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_representations = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary representations based on a custom comparator\n    # This comparator ensures that the most significant bits come first\n    binary_representations.sort(key=lambda x: x.zfill(8))\n    \n    # Reverse the sorted list to get the largest possible number\n    binary_representations.reverse()\n    \n    # Concatenate the binary representations\n    concatenated_binary = ''.join(binary_representations)\n    \n    # Convert the concatenated binary string to an integer\n    result = int(concatenated_binary, 2)\n    \n    return result\n```", "```python\ndef max_concatenated_binary(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order\n    binary_nums.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef maximum_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their integer value\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    max_number = int(concatenated_binary, 2)\n    \n    return max_number\n```", "```python\ndef max_concatenated_number(nums):\n    # Convert each number to its binary representation and sort them in descending order\n    binary_nums = sorted([bin(num)[2:] for num in nums], reverse=True)\n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef max_number(nums):\n    # Convert each number to its binary representation without the '0b' prefix\n    bin_nums = [bin(num)[2:] for num in nums]\n    \n    # Define a custom comparator to sort the binary strings\n    def compare(x, y):\n        return int(y + x) - int(x + y)\n    \n    # Sort the binary strings using the custom comparator\n    bin_nums.sort(key=functools.cmp_to_key(compare))\n    \n    # Concatenate the sorted binary strings\n    result_bin = ''.join(bin_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    result_num = int(result_bin, 2)\n    \n    return result_num\n```", "```python\ndef max_possible_number(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_representations = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary representations by length in descending order\n    binary_representations.sort(key=len, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_representations)\n    \n    # Convert the concatenated binary string back to a decimal number\n    return int(concatenated_binary, 2)\n```", "```python\ndef max_concatenated_number(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their numeric value\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef max_possible_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Generate all permutations of the binary strings\n    from itertools import permutations\n    permuted_binaries = [''.join(p) for p in permutations(binary_nums)]\n    \n    # Convert each concatenated binary string back to a decimal number\n    decimal_values = [int(b, 2) for b in permuted_binaries]\n    \n    # Return the maximum decimal number\n    return max(decimal_values)\n```", "```python\ndef max_concatenated_number(nums):\n    # Convert each number to its binary representation without '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings based on their numerical value in descending order\n    binary_nums.sort(key=lambda x: int(x, 2), reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    result = int(concatenated_binary, 2)\n    \n    return result\n```", "```python\ndef maximumNumber(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Define a custom comparison function\n    def compare(x, y):\n        return (x + y) > (y + x)\n    \n    # Sort the binary numbers using the custom comparison function\n    binary_nums.sort(key=functools.cmp_to_key(compare), reverse=True)\n    \n    # Concatenate the sorted binary numbers\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to a decimal number\n    return int(concatenated_binary, 2)\n```", "```python\ndef max_concatenated_binary(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_representations = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary representations in descending order\n    binary_representations.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_representations)\n    \n    # Convert the concatenated binary string back to a decimal number\n    return int(concatenated_binary, 2)\n```", "```python\ndef max_binary_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their first character\n    binary_nums.sort(key=lambda x: x[0], reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```"]}
{"task_id": "3518", "codes": ["def maxScore(a, b):\n    # Sort array b in descending order\n    b_sorted = sorted(b, reverse=True)\n    \n    # Calculate the score by multiplying corresponding elements of a and the sorted b\n    score = sum(x * y for x, y in zip(a, b_sorted))\n    \n    return score", "def maxScore(a, b):\n    a.sort()\n    b.sort()\n    return sum(a[i] * b[-i-1] for i in range(4))", "def maxScore(a, b):\n    # Sort b into two lists: one for positive and one for negative numbers\n    pos_b = sorted([x for x in b if x > 0])\n    neg_b = sorted([x for x in b if x < 0])\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate over each element in a\n    for i, val in enumerate(a):\n        if val > 0:\n            # Add the product of the current element in a and the largest positive element in b\n            result += val * pos_b.pop()\n        else:\n            # Add the product of the current element in a and the smallest negative element in b\n            result += val * neg_b.pop(0)\n    \n    return result", "def maxScore(a, b):\n    # Sort the array b\n    b.sort()\n    \n    # Calculate the score using the sorted elements of b and the fixed elements of a\n    score = a[0] * b[-1] + a[1] * b[-2] + a[2] * b[-3] + a[3] * b[-4]\n    \n    return score", "def maxScore(a, b):\n    b_sorted = sorted(b)\n    score = 0\n    for i in range(4):\n        if a[i] > 0:\n            score += a[i] * b_sorted[-(i + 1)]\n        else:\n            score += a[i] * b_sorted[i]\n    return score", "def max_score(a, b):\n    # Sort array b in ascending order\n    b_sorted = sorted(b)\n    \n    # Initialize the score to zero\n    score = 0\n    \n    # Iterate over the first four elements of the sorted array b\n    for i in range(4):\n        # Multiply the corresponding element of a with the largest element of b\n        score += a[i] * b_sorted[-(i+1)]\n    \n    return score", "def maxScore(a, b):\n    b.sort(reverse=True)\n    return sum(a[i] * b[i] for i in range(4))", "def maxScore(a, b):\n    b.sort()\n    return sum(a[i] * b[-i-1] for i in range(4))", "def maxScore(a, b):\n    # Calculate all possible products of elements from a and b\n    products = sorted([x * y for x in a for y in b], reverse=True)\n    \n    # Select the top 4 products and sum them up\n    return sum(products[:4])", "def maxScore(a, b):\n    # Create a list of tuples where each tuple is (a_i * b_j, j)\n    products = [(a[i] * b[j], j) for i in range(4) for j in range(len(b))]\n    \n    # Sort the products based on the product value in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Extract the top 4 indices\n    top_indices = set()\n    for _, j in sorted_products[:4]:\n        if len(top_indices) < 4:\n            top_indices.add(j)\n    \n    # Ensure the indices are in ascending order\n    top_indices = sorted(list(top_indices))\n    \n    # Calculate the score using the top 4 indices\n    score = sum(a[i] * b[top_indices[i]] for i in range(4))\n    \n    return score", "def maxScore(a, b):\n    # Create a list of tuples (product, index_a, index_b)\n    products = [(a[i] * b[j], i, j) for i in range(4) for j in range(len(b))]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Select the top four products\n    top_four_products = products[:4]\n    \n    # Calculate the sum of the top four products\n    max_score = sum(product for product, _, _ in top_four_products)\n    \n    return max_score", "def max_score(a, b):\n    b.sort()\n    return sum(a[i] * b[-(i+1)] for i in range(4))", "def maxScore(a, b):\n    # Calculate the product of each element in a with each element in b\n    products = sorted([x * y for x, y in zip(a, b)], reverse=True)\n    \n    # Sum the top 4 products to get the maximum score\n    return sum(products[:4])", "def max_score(a, b):\n    b_sorted = sorted(b, reverse=True)\n    top_4 = b_sorted[:4]\n    return a[0] * top_4[0] + a[1] * top_4[1] + a[2] * top_4[2] + a[3] * top_4[3]", "def maxScore(a, b):\n    a.sort()\n    b.sort()\n    return sum(x * y for x, y in zip(a, b))", "def max_score(a, b):\n    b_sorted = sorted(b, reverse=True)\n    return sum(a[i] * b_sorted[i] for i in range(4))"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef maxScore(a, b):\n    # Sort array b in descending order\n    b_sorted = sorted(b, reverse=True)\n    \n    # Calculate the score by multiplying corresponding elements of a and the sorted b\n    score = sum(x * y for x, y in zip(a, b_sorted))\n    \n    return score\n```", "```python\ndef maxScore(a, b):\n    a.sort()\n    b.sort()\n    return sum(a[i] * b[-i-1] for i in range(4))\n```", "```python\ndef maxScore(a, b):\n    # Sort b into two lists: one for positive and one for negative numbers\n    pos_b = sorted([x for x in b if x > 0])\n    neg_b = sorted([x for x in b if x < 0])\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate over each element in a\n    for i, val in enumerate(a):\n        if val > 0:\n            # Add the product of the current element in a and the largest positive element in b\n            result += val * pos_b.pop()\n        else:\n            # Add the product of the current element in a and the smallest negative element in b\n            result += val * neg_b.pop(0)\n    \n    return result\n```", "```python\ndef maxScore(a, b):\n    # Sort the array b\n    b.sort()\n    \n    # Calculate the score using the sorted elements of b and the fixed elements of a\n    score = a[0] * b[-1] + a[1] * b[-2] + a[2] * b[-3] + a[3] * b[-4]\n    \n    return score\n```", "```python\ndef maxScore(a, b):\n    b_sorted = sorted(b)\n    score = 0\n    for i in range(4):\n        if a[i] > 0:\n            score += a[i] * b_sorted[-(i + 1)]\n        else:\n            score += a[i] * b_sorted[i]\n    return score\n```", "```python\ndef max_score(a, b):\n    # Sort array b in ascending order\n    b_sorted = sorted(b)\n    \n    # Initialize the score to zero\n    score = 0\n    \n    # Iterate over the first four elements of the sorted array b\n    for i in range(4):\n        # Multiply the corresponding element of a with the largest element of b\n        score += a[i] * b_sorted[-(i+1)]\n    \n    return score\n```", "```python\ndef maxScore(a, b):\n    b.sort(reverse=True)\n    return sum(a[i] * b[i] for i in range(4))\n```", "```python\ndef maxScore(a, b):\n    b.sort()\n    return sum(a[i] * b[-i-1] for i in range(4))\n```", "```python\ndef maxScore(a, b):\n    # Calculate all possible products of elements from a and b\n    products = sorted([x * y for x in a for y in b], reverse=True)\n    \n    # Select the top 4 products and sum them up\n    return sum(products[:4])\n```", "```python\ndef maxScore(a, b):\n    # Create a list of tuples where each tuple is (a_i * b_j, j)\n    products = [(a[i] * b[j], j) for i in range(4) for j in range(len(b))]\n    \n    # Sort the products based on the product value in descending order\n    sorted_products = sorted(products, reverse=True)\n    \n    # Extract the top 4 indices\n    top_indices = set()\n    for _, j in sorted_products[:4]:\n        if len(top_indices) < 4:\n            top_indices.add(j)\n    \n    # Ensure the indices are in ascending order\n    top_indices = sorted(list(top_indices))\n    \n    # Calculate the score using the top 4 indices\n    score = sum(a[i] * b[top_indices[i]] for i in range(4))\n    \n    return score\n```", "```python\ndef maxScore(a, b):\n    # Create a list of tuples (product, index_a, index_b)\n    products = [(a[i] * b[j], i, j) for i in range(4) for j in range(len(b))]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Select the top four products\n    top_four_products = products[:4]\n    \n    # Calculate the sum of the top four products\n    max_score = sum(product for product, _, _ in top_four_products)\n    \n    return max_score\n```", "```python\ndef max_score(a, b):\n    b.sort()\n    return sum(a[i] * b[-(i+1)] for i in range(4))\n```", "```python\ndef maxScore(a, b):\n    # Calculate the product of each element in a with each element in b\n    products = sorted([x * y for x, y in zip(a, b)], reverse=True)\n    \n    # Sum the top 4 products to get the maximum score\n    return sum(products[:4])\n```", "```python\ndef max_score(a, b):\n    b_sorted = sorted(b, reverse=True)\n    top_4 = b_sorted[:4]\n    return a[0] * top_4[0] + a[1] * top_4[1] + a[2] * top_4[2] + a[3] * top_4[3]\n```", "```python\ndef maxScore(a, b):\n    a.sort()\n    b.sort()\n    return sum(x * y for x, y in zip(a, b))\n```", "```python\ndef max_score(a, b):\n    b_sorted = sorted(b, reverse=True)\n    return sum(a[i] * b_sorted[i] for i in range(4))\n```"]}
{"task_id": "3573", "codes": ["def countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    m, n = len(word1), len(word2)\n    target = Counter(word2)\n    count = 0\n    \n    for i in range(n - 1, m):\n        window = word1[i - n + 1:i + 1]\n        if Counter(window) == target:\n            count += 1\n            \n    return count", "def countValidSubstrings(word1, word2):\n    n, m = len(word1), len(word2)\n    target_count = {}\n    for char in word2:\n        target_count[char] = target_count.get(char, 0) + 1\n    \n    prefix_count = {}\n    result = 0\n    \n    for i in range(n):\n        # Add current character to prefix_count\n        prefix_count[word1[i]] = prefix_count.get(word1[i], 0) + 1\n        \n        # Remove characters from prefix_count that are not needed\n        while prefix_count[word1[i - m + 1]] > target_count.get(word1[i - m + 1], 0):\n            prefix_count[word1[i - m + 1]] -= 1\n            i += 1\n        \n        # Check if the current prefix matches the target prefix\n        if prefix_count == target_count:\n            result += n - i\n    \n    return result", "def countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    target = Counter(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        window = Counter(word1[i:i+m])\n        if window == target:\n            count += 1\n            \n    return count", "def countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    count_w1 = Counter(word1)\n    count_w2 = Counter(word2)\n    \n    valid_count = 0\n    \n    for i in range(n - m + 1):\n        sub_str = word1[i:i+m]\n        count_sub_str = Counter(sub_str)\n        \n        if count_sub_str >= count_w2:\n            valid_count += 1\n            \n    return valid_count", "def countValidSubstrings(word1, word2):\n    n1, n2 = len(word1), len(word2)\n    if n1 < n2:\n        return 0\n    \n    prefix_count = {}\n    for char in word2:\n        prefix_count[char] = prefix_count.get(char, 0) + 1\n    \n    valid_substrings = 0\n    current_count = {}\n    \n    for i in range(n2 - 1, n1):\n        current_count[word1[i]] = current_count.get(word1[i], 0) + 1\n        \n        if i >= n2:\n            left_char = word1[i - n2]\n            if current_count[left_char] == 1:\n                del current_count[left_char]\n            else:\n                current_count[left_char] -= 1\n        \n        if current_count == prefix_count:\n            valid_substrings += n1 - i\n    \n    return valid_substrings", "def countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    count_w2 = Counter(word2)\n    count_ws = Counter()\n    n, m = len(word1), len(word2)\n    valid_count = 0\n    \n    for i in range(n):\n        count_ws[word1[i]] += 1\n        if i >= m:\n            count_ws[word1[i - m]] -= 1\n            if count_ws[word1[i - m]] == 0:\n                del count_ws[word1[i - m]]\n        \n        if count_ws == count_w2[:i + 1]:\n            valid_count += n - i\n    \n    return valid_count", "from collections import Counter\n\ndef count_valid_substrings(word1, word2):\n    count = 0\n    word2_count = Counter(word2)\n    length = len(word2)\n    \n    for i in range(len(word1) - length + 1):\n        substring = word1[i:i + length]\n        substring_count = Counter(substring)\n        if substring_count == word2_count:\n            count += 1\n    \n    return count", "def count_valid_substrings(word1: str, word2: str) -> int:\n    from collections import Counter\n\n    count = 0\n    n, m = len(word1), len(word2)\n\n    for i in range(n - m + 1):\n        substring = word1[i:i + m]\n        if Counter(substring) >= Counter(word2):\n            count += 1\n\n    return count", "def countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    count_w2 = Counter(word2)\n    n, m = len(word1), len(word2)\n    result = 0\n    \n    for i in range(n - m + 1):\n        if all(word1[i + j] in count_w2 and word1[i + j].count(word1[i + j]) <= count_w2[word1[i + j]] for j in range(m)):\n            result += 1\n            \n    return result", "from collections import Counter\n\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    # Count frequency of characters in word2\n    word2_counter = Counter(word2)\n    \n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    # Iterate over each starting position of the substring in word1\n    for i in range(n - m + 1):\n        # Get the current substring of length m starting at i\n        current_substring = word1[i:i + m]\n        # Count frequency of characters in the current substring\n        current_counter = Counter(current_substring)\n        \n        # Check if the current substring can be rearranged to have word2 as a prefix\n        if current_counter & word2_counter == word2_counter:\n            count += 1\n    \n    return count", "def countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    m, n = len(word1), len(word2)\n    if m < n:\n        return 0\n    \n    count_w2 = Counter(word2)\n    count_window = Counter()\n    valid_count = 0\n    \n    for i in range(m):\n        if i < n:\n            count_window[word1[i]] += 1\n        else:\n            if count_window == count_w2:\n                valid_count += m - i\n            count_window[word1[i]] += 1\n            count_window[word1[i - n]] -= 1\n            if count_window[word1[i - n]] == 0:\n                del count_window[word1[i - n]]\n    \n    if count_window == count_w2:\n        valid_count += m - n + 1\n    \n    return valid_count", "def countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    m, n = len(word1), len(word2)\n    target_count = Counter(word2)\n    window_count = Counter()\n    \n    valid_substrings = 0\n    \n    left = 0\n    for right in range(m):\n        window_count[word1[right]] += 1\n        \n        # Shrink the window from the left if necessary\n        while left <= right and any(window_count[char] < target_count[char] for char in target_count):\n            window_count[word1[left]] -= 1\n            left += 1\n        \n        # Check if the current window is a valid substring\n        if all(window_count[char] >= target_count[char] for char in target_count):\n            valid_substrings += max(0, right - left + 1 - n + 1)\n    \n    return valid_substrings", "def countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        if word1[i:i+m] == word2[:m]:\n            remaining_word1 = word1[i+m:]\n            remaining_word2 = word2[m:]\n            if Counter(remaining_word1) >= Counter(remaining_word2):\n                count += 1\n                \n    return count", "def countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    # Count character frequencies in word2\n    target_count = Counter(word2)\n    \n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        # Extract the substring of length m starting at index i\n        substring = word1[i:i+m]\n        \n        # Count character frequencies in the current substring\n        current_count = Counter(substring)\n        \n        # Check if the current substring contains at least the same number of characters as word2\n        if all(current_count[char] >= target_count[char] for char in target_count):\n            count += 1\n    \n    return count", "from collections import Counter\n\ndef countValidSubstrings(word1, word2):\n    n, m = len(word1), len(word2)\n    if m > n:\n        return 0\n    \n    target_count = Counter(word2)\n    current_count = Counter()\n    \n    left = 0\n    result = 0\n    \n    for right in range(n):\n        current_count[word1[right]] += 1\n        \n        while current_count >= target_count:\n            if right - left + 1 == m:\n                result += n - right\n            current_count[word1[left]] -= 1\n            if current_count[word1[left]] == 0:\n                del current_count[word1[left]]\n            left += 1\n    \n    return result", "def countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    count = 0\n    target_counter = Counter(word2)\n    \n    for i in range(n - m + 1):\n        current_counter = Counter(word1[i:i+m])\n        if current_counter == target_counter:\n            count += 1\n    \n    return count"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    m, n = len(word1), len(word2)\n    target = Counter(word2)\n    count = 0\n    \n    for i in range(n - 1, m):\n        window = word1[i - n + 1:i + 1]\n        if Counter(window) == target:\n            count += 1\n            \n    return count\n```", "```python\ndef countValidSubstrings(word1, word2):\n    n, m = len(word1), len(word2)\n    target_count = {}\n    for char in word2:\n        target_count[char] = target_count.get(char, 0) + 1\n    \n    prefix_count = {}\n    result = 0\n    \n    for i in range(n):\n        # Add current character to prefix_count\n        prefix_count[word1[i]] = prefix_count.get(word1[i], 0) + 1\n        \n        # Remove characters from prefix_count that are not needed\n        while prefix_count[word1[i - m + 1]] > target_count.get(word1[i - m + 1], 0):\n            prefix_count[word1[i - m + 1]] -= 1\n            i += 1\n        \n        # Check if the current prefix matches the target prefix\n        if prefix_count == target_count:\n            result += n - i\n    \n    return result\n```", "```python\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    target = Counter(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        window = Counter(word1[i:i+m])\n        if window == target:\n            count += 1\n            \n    return count\n```", "```python\ndef countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    count_w1 = Counter(word1)\n    count_w2 = Counter(word2)\n    \n    valid_count = 0\n    \n    for i in range(n - m + 1):\n        sub_str = word1[i:i+m]\n        count_sub_str = Counter(sub_str)\n        \n        if count_sub_str >= count_w2:\n            valid_count += 1\n            \n    return valid_count\n```", "```python\ndef countValidSubstrings(word1, word2):\n    n1, n2 = len(word1), len(word2)\n    if n1 < n2:\n        return 0\n    \n    prefix_count = {}\n    for char in word2:\n        prefix_count[char] = prefix_count.get(char, 0) + 1\n    \n    valid_substrings = 0\n    current_count = {}\n    \n    for i in range(n2 - 1, n1):\n        current_count[word1[i]] = current_count.get(word1[i], 0) + 1\n        \n        if i >= n2:\n            left_char = word1[i - n2]\n            if current_count[left_char] == 1:\n                del current_count[left_char]\n            else:\n                current_count[left_char] -= 1\n        \n        if current_count == prefix_count:\n            valid_substrings += n1 - i\n    \n    return valid_substrings\n```", "```python\ndef countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    count_w2 = Counter(word2)\n    count_ws = Counter()\n    n, m = len(word1), len(word2)\n    valid_count = 0\n    \n    for i in range(n):\n        count_ws[word1[i]] += 1\n        if i >= m:\n            count_ws[word1[i - m]] -= 1\n            if count_ws[word1[i - m]] == 0:\n                del count_ws[word1[i - m]]\n        \n        if count_ws == count_w2[:i + 1]:\n            valid_count += n - i\n    \n    return valid_count\n```", "```python\nfrom collections import Counter\n\ndef count_valid_substrings(word1, word2):\n    count = 0\n    word2_count = Counter(word2)\n    length = len(word2)\n    \n    for i in range(len(word1) - length + 1):\n        substring = word1[i:i + length]\n        substring_count = Counter(substring)\n        if substring_count == word2_count:\n            count += 1\n    \n    return count\n```", "```python\ndef count_valid_substrings(word1: str, word2: str) -> int:\n    from collections import Counter\n\n    count = 0\n    n, m = len(word1), len(word2)\n\n    for i in range(n - m + 1):\n        substring = word1[i:i + m]\n        if Counter(substring) >= Counter(word2):\n            count += 1\n\n    return count\n```", "```python\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    count_w2 = Counter(word2)\n    n, m = len(word1), len(word2)\n    result = 0\n    \n    for i in range(n - m + 1):\n        if all(word1[i + j] in count_w2 and word1[i + j].count(word1[i + j]) <= count_w2[word1[i + j]] for j in range(m)):\n            result += 1\n            \n    return result\n```", "```python\nfrom collections import Counter\n\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    # Count frequency of characters in word2\n    word2_counter = Counter(word2)\n    \n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    # Iterate over each starting position of the substring in word1\n    for i in range(n - m + 1):\n        # Get the current substring of length m starting at i\n        current_substring = word1[i:i + m]\n        # Count frequency of characters in the current substring\n        current_counter = Counter(current_substring)\n        \n        # Check if the current substring can be rearranged to have word2 as a prefix\n        if current_counter & word2_counter == word2_counter:\n            count += 1\n    \n    return count\n```", "```python\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    m, n = len(word1), len(word2)\n    if m < n:\n        return 0\n    \n    count_w2 = Counter(word2)\n    count_window = Counter()\n    valid_count = 0\n    \n    for i in range(m):\n        if i < n:\n            count_window[word1[i]] += 1\n        else:\n            if count_window == count_w2:\n                valid_count += m - i\n            count_window[word1[i]] += 1\n            count_window[word1[i - n]] -= 1\n            if count_window[word1[i - n]] == 0:\n                del count_window[word1[i - n]]\n    \n    if count_window == count_w2:\n        valid_count += m - n + 1\n    \n    return valid_count\n```", "```python\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    m, n = len(word1), len(word2)\n    target_count = Counter(word2)\n    window_count = Counter()\n    \n    valid_substrings = 0\n    \n    left = 0\n    for right in range(m):\n        window_count[word1[right]] += 1\n        \n        # Shrink the window from the left if necessary\n        while left <= right and any(window_count[char] < target_count[char] for char in target_count):\n            window_count[word1[left]] -= 1\n            left += 1\n        \n        # Check if the current window is a valid substring\n        if all(window_count[char] >= target_count[char] for char in target_count):\n            valid_substrings += max(0, right - left + 1 - n + 1)\n    \n    return valid_substrings\n```", "```python\ndef countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        if word1[i:i+m] == word2[:m]:\n            remaining_word1 = word1[i+m:]\n            remaining_word2 = word2[m:]\n            if Counter(remaining_word1) >= Counter(remaining_word2):\n                count += 1\n                \n    return count\n```", "```python\ndef countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    # Count character frequencies in word2\n    target_count = Counter(word2)\n    \n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        # Extract the substring of length m starting at index i\n        substring = word1[i:i+m]\n        \n        # Count character frequencies in the current substring\n        current_count = Counter(substring)\n        \n        # Check if the current substring contains at least the same number of characters as word2\n        if all(current_count[char] >= target_count[char] for char in target_count):\n            count += 1\n    \n    return count\n```", "```python\nfrom collections import Counter\n\ndef countValidSubstrings(word1, word2):\n    n, m = len(word1), len(word2)\n    if m > n:\n        return 0\n    \n    target_count = Counter(word2)\n    current_count = Counter()\n    \n    left = 0\n    result = 0\n    \n    for right in range(n):\n        current_count[word1[right]] += 1\n        \n        while current_count >= target_count:\n            if right - left + 1 == m:\n                result += n - right\n            current_count[word1[left]] -= 1\n            if current_count[word1[left]] == 0:\n                del current_count[word1[left]]\n            left += 1\n    \n    return result\n```", "```python\ndef countValidSubstrings(word1, word2):\n    from collections import Counter\n    \n    n, m = len(word1), len(word2)\n    count = 0\n    target_counter = Counter(word2)\n    \n    for i in range(n - m + 1):\n        current_counter = Counter(word1[i:i+m])\n        if current_counter == target_counter:\n            count += 1\n    \n    return count\n```"]}
{"task_id": "3540", "codes": ["def hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result += hashed_char\n    return result", "def hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s, k):\n    result = []\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s, k):\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result += hashed_char\n    return result", "def hash_string(s, k):\n    result = []\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s, k):\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result", "def hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s, k):\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result", "def hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result", "def hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        total_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = total_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result", "def hash_string(s, k):\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result.append(hashed_char)\n    return ''.join(result)", "def hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result", "def hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)", "def hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result.append(hashed_char)\n    return ''.join(result)"], "passed": [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true], "raw_code": ["```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result += hashed_char\n    return result\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s, k):\n    result = []\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s, k):\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result += hashed_char\n    return result\n```", "```python\ndef hash_string(s, k):\n    result = []\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s, k):\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s, k):\n    result = \"\"\n    n = len(s)\n    for i in range(0, n, k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```", "```python\ndef hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```", "```python\ndef hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        total_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = total_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```", "```python\ndef hash_string(s, k):\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result.append(hashed_char)\n    return ''.join(result)\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result.append(chr(hashed_char + ord('a')))\n    return ''.join(result)\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = []\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = chr((char_sum % 26) + ord('a'))\n        result.append(hashed_char)\n    return ''.join(result)\n```"]}
{"task_id": "3496", "codes": ["def minimumTime(mountainHeight, workerTimes):\n    workerTimes.sort()\n    n = len(workerTimes)\n    x = 1\n    totalReduction = 0\n    \n    while totalReduction < mountainHeight:\n        totalReduction = 0\n        for i in range(n):\n            totalReduction += workerTimes[i] * (x * (x + 1)) // 2\n        if totalReduction >= mountainHeight:\n            return x\n        x += 1", "def minMountainReductionTime(mountainHeight, workerTimes):\n    def totalWorkDone(time):\n        total = 0\n        for t in range(1, time + 1):\n            for workerTime in workerTimes:\n                total += workerTime * t\n        return total\n    \n    left, right = 1, mountainHeight * max(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if totalWorkDone(mid) >= mountainHeight:\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def minTimeToReduceMountainHeight(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum(workTime * (i + 1) for workTime in workerTimes) <= time\n    \n    left, right = 1, sum(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, mid):\n        totalWork = 0\n        for time in workerTimes:\n            x = 1\n            while time * x <= mid:\n                totalWork += time * x\n                x += 1\n            if totalWork >= height:\n                return True\n        return False\n\n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, timeLimit):\n        totalWork = 0\n        for time in workerTimes:\n            x = 1\n            while True:\n                work = time * x\n                if work > timeLimit:\n                    break\n                totalWork += work\n                x += 1\n                if totalWork >= height:\n                    break\n            if totalWork >= height:\n                break\n        return totalWork >= height\n    \n    low = max(workerTimes)\n    high = sum(time * (time + 1) // 2 for time in workerTimes)\n    \n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    \n    return low", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, timeLimit):\n        remainingHeight = height\n        for wt in sorted(workerTimes, reverse=True):\n            reduction = 0\n            for x in range(1, remainingHeight // wt + 1):\n                if reduction + wt * (x * (x + 1)) // 2 > timeLimit:\n                    break\n                reduction += wt * (x * (x + 1)) // 2\n                remainingHeight -= x\n                if remainingHeight == 0:\n                    return True\n            if reduction == 0:\n                return False\n        return False\n\n    left, right = 0, sum(wt * (wt * (wt + 1)) // 2 for wt in workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, mid):\n        total_time = 0\n        for time in workerTimes:\n            x = 1\n            while time * x <= mid:\n                total_time += time * x\n                if total_time > mid:\n                    break\n                x += 1\n            if total_time >= mid:\n                return True\n        return False\n\n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum((time // wt) * (time // wt + 1) // 2 for wt in workerTimes) >= height\n    \n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum(worker * (worker + 1) // 2 * (height // worker) for worker in workerTimes) <= time\n    \n    low = max(workerTimes)\n    high = 10**18  # A sufficiently large upper bound\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, targetTime):\n        workDone = 0\n        for time in sorted(workerTimes, reverse=True):\n            reduction = 1\n            while reduction <= height and time * reduction <= targetTime:\n                workDone += reduction\n                reduction += 1\n            if workDone >= height:\n                return True\n        return False\n    \n    left, right = 1, sum(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, k):\n        return sum(worker * (k * (k + 1)) // 2 for worker in workerTimes) >= height\n    \n    workerTimes.sort()\n    left, right = 1, mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return canReduce(mountainHeight, left) and left or -1", "def minimumTime(mountainHeight, workerTimes):\n    workerTimes.sort(reverse=True)\n    left, right = 1, mountainHeight * max(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if canReduceHeight(mountainHeight, workerTimes, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef canReduceHeight(mountainHeight, workerTimes, time):\n    totalWork = 0\n    for time_i in workerTimes:\n        x = 1\n        while time_i * (x * (x + 1)) // 2 <= time:\n            totalWork += time_i * (x * (x + 1)) // 2\n            x += 1\n        if totalWork >= mountainHeight:\n            return True\n    return False", "def min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def time_to_reduce(height, workerTime):\n        return sum((height - i) * workerTime for i in range(1, height + 1))\n    \n    left, right = 1, mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if sum(time_to_reduce(mid, wt) for wt in workerTimes) >= mountainHeight:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left", "def minimumTime(mountainHeight, workerTimes):\n    def canReduce(targetTime):\n        totalReduction = 0\n        for time in workerTimes:\n            x = 1\n            while True:\n                requiredTime = time * (x * (x + 1)) // 2\n                if requiredTime > targetTime:\n                    break\n                totalReduction += x\n                x += 1\n            if totalReduction >= mountainHeight:\n                return True\n        return False\n\n    left, right = 0, max(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def can_reduce(height, time):\n        total_work = 0\n        for workerTime in workerTimes:\n            # Calculate the maximum height that can be reduced in the given time\n            x = ((-1 + (1 + 8 * workerTime * time)) ** 0.5 - 1) / (2 * workerTime)\n            total_work += int(x)\n        return total_work >= height\n    \n    left, right = 0, sum(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if can_reduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left", "def minTime(mountainHeight, workerTimes):\n    def canReduceWithinTime(totalTime):\n        remainingHeight = mountainHeight\n        for time in workerTimes:\n            # Calculate the maximum reduction the worker can achieve within totalTime\n            n = int((totalTime / time - 1) ** 0.5)\n            if n > 0:\n                remainingHeight -= n\n                if remainingHeight <= 0:\n                    return True\n        return False\n    \n    left, right = 0, mountainHeight * max(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if canReduceWithinTime(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef minimumTime(mountainHeight, workerTimes):\n    workerTimes.sort()\n    n = len(workerTimes)\n    x = 1\n    totalReduction = 0\n    \n    while totalReduction < mountainHeight:\n        totalReduction = 0\n        for i in range(n):\n            totalReduction += workerTimes[i] * (x * (x + 1)) // 2\n        if totalReduction >= mountainHeight:\n            return x\n        x += 1\n```", "```python\ndef minMountainReductionTime(mountainHeight, workerTimes):\n    def totalWorkDone(time):\n        total = 0\n        for t in range(1, time + 1):\n            for workerTime in workerTimes:\n                total += workerTime * t\n        return total\n    \n    left, right = 1, mountainHeight * max(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if totalWorkDone(mid) >= mountainHeight:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```", "```python\ndef minTimeToReduceMountainHeight(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum(workTime * (i + 1) for workTime in workerTimes) <= time\n    \n    left, right = 1, sum(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, mid):\n        totalWork = 0\n        for time in workerTimes:\n            x = 1\n            while time * x <= mid:\n                totalWork += time * x\n                x += 1\n            if totalWork >= height:\n                return True\n        return False\n\n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, timeLimit):\n        totalWork = 0\n        for time in workerTimes:\n            x = 1\n            while True:\n                work = time * x\n                if work > timeLimit:\n                    break\n                totalWork += work\n                x += 1\n                if totalWork >= height:\n                    break\n            if totalWork >= height:\n                break\n        return totalWork >= height\n    \n    low = max(workerTimes)\n    high = sum(time * (time + 1) // 2 for time in workerTimes)\n    \n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    \n    return low\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, timeLimit):\n        remainingHeight = height\n        for wt in sorted(workerTimes, reverse=True):\n            reduction = 0\n            for x in range(1, remainingHeight // wt + 1):\n                if reduction + wt * (x * (x + 1)) // 2 > timeLimit:\n                    break\n                reduction += wt * (x * (x + 1)) // 2\n                remainingHeight -= x\n                if remainingHeight == 0:\n                    return True\n            if reduction == 0:\n                return False\n        return False\n\n    left, right = 0, sum(wt * (wt * (wt + 1)) // 2 for wt in workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, mid):\n        total_time = 0\n        for time in workerTimes:\n            x = 1\n            while time * x <= mid:\n                total_time += time * x\n                if total_time > mid:\n                    break\n                x += 1\n            if total_time >= mid:\n                return True\n        return False\n\n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum((time // wt) * (time // wt + 1) // 2 for wt in workerTimes) >= height\n    \n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        return sum(worker * (worker + 1) // 2 * (height // worker) for worker in workerTimes) <= time\n    \n    low = max(workerTimes)\n    high = 10**18  # A sufficiently large upper bound\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, targetTime):\n        workDone = 0\n        for time in sorted(workerTimes, reverse=True):\n            reduction = 1\n            while reduction <= height and time * reduction <= targetTime:\n                workDone += reduction\n                reduction += 1\n            if workDone >= height:\n                return True\n        return False\n    \n    left, right = 1, sum(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, k):\n        return sum(worker * (k * (k + 1)) // 2 for worker in workerTimes) >= height\n    \n    workerTimes.sort()\n    left, right = 1, mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return canReduce(mountainHeight, left) and left or -1\n```", "```python\ndef minimumTime(mountainHeight, workerTimes):\n    workerTimes.sort(reverse=True)\n    left, right = 1, mountainHeight * max(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if canReduceHeight(mountainHeight, workerTimes, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef canReduceHeight(mountainHeight, workerTimes, time):\n    totalWork = 0\n    for time_i in workerTimes:\n        x = 1\n        while time_i * (x * (x + 1)) // 2 <= time:\n            totalWork += time_i * (x * (x + 1)) // 2\n            x += 1\n        if totalWork >= mountainHeight:\n            return True\n    return False\n```", "```python\ndef min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def time_to_reduce(height, workerTime):\n        return sum((height - i) * workerTime for i in range(1, height + 1))\n    \n    left, right = 1, mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if sum(time_to_reduce(mid, wt) for wt in workerTimes) >= mountainHeight:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n```", "```python\ndef minimumTime(mountainHeight, workerTimes):\n    def canReduce(targetTime):\n        totalReduction = 0\n        for time in workerTimes:\n            x = 1\n            while True:\n                requiredTime = time * (x * (x + 1)) // 2\n                if requiredTime > targetTime:\n                    break\n                totalReduction += x\n                x += 1\n            if totalReduction >= mountainHeight:\n                return True\n        return False\n\n    left, right = 0, max(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if canReduce(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```", "```python\ndef min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def can_reduce(height, time):\n        total_work = 0\n        for workerTime in workerTimes:\n            # Calculate the maximum height that can be reduced in the given time\n            x = ((-1 + (1 + 8 * workerTime * time)) ** 0.5 - 1) / (2 * workerTime)\n            total_work += int(x)\n        return total_work >= height\n    \n    left, right = 0, sum(workerTimes) * mountainHeight\n    while left < right:\n        mid = (left + right) // 2\n        if can_reduce(mountainHeight, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduceWithinTime(totalTime):\n        remainingHeight = mountainHeight\n        for time in workerTimes:\n            # Calculate the maximum reduction the worker can achieve within totalTime\n            n = int((totalTime / time - 1) ** 0.5)\n            if n > 0:\n                remainingHeight -= n\n                if remainingHeight <= 0:\n                    return True\n        return False\n    \n    left, right = 0, mountainHeight * max(workerTimes)\n    while left < right:\n        mid = (left + right) // 2\n        if canReduceWithinTime(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n```"]}
{"task_id": "3522", "codes": ["def find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if subarray == sorted(subarray) and len(set(subarray)) == k:\n            results[i] = max(subarray)\n    \n    return results", "def findPowerOfSubarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        unique_elements = set(subarray)\n        \n        if len(unique_elements) == k and subarray == sorted(subarray):\n            results[i] = max(subarray)\n    \n    return results", "def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if subarray == sorted(subarray) and len(set(subarray)) == len(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if subarray == sorted(subarray) and len(set(subarray)) == len(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if all(subarray[j] == subarray[j+1] - 1 for j in range(k-1)) and subarray == sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if subarray == sorted_subarray and len(set(subarray)) == k:\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def find_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if subarray == sorted(subarray) and len(set(subarray)) == k:\n            results.append(subarray[-1])\n        else:\n            results.append(-1)\n    \n    return results", "def findPowerOfSubarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if sorted_subarray == list(range(sorted_subarray[0], sorted_subarray[-1] + 1)):\n            results[i] = max(subarray)\n    \n    return results", "def find_subarray_power(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = sorted(nums[i:i + k])\n        if all(subarray[j] + 1 == subarray[j + 1] for j in range(k - 1)):\n            results[i] = subarray[-1]\n    \n    return results", "def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if sorted(subarray) == subarray and all(subarray[j] + 1 == subarray[j+1] for j in range(k-1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if all(subarray[j] < subarray[j + 1] for j in range(k - 1)) and subarray == sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if subarray == sorted(subarray) and all(subarray[j] + 1 == subarray[j + 1] for j in range(k - 1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results", "def find_subarray_powers(nums, k):\n    def is_consecutive_and_sorted(subarray):\n        return sorted(subarray) == list(range(min(subarray), max(subarray) + 1))\n    \n    n = len(nums)\n    results = []\n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if is_consecutive_and_sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    return results", "def find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        start, end = i, i + k - 1\n        is_consecutive_sorted = True\n        \n        for j in range(start, end):\n            if nums[j] >= nums[j + 1]:\n                is_consecutive_sorted = False\n                break\n        \n        if is_consecutive_sorted:\n            results[i] = max(nums[start:end + 1])\n    \n    return results", "def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if len(set(subarray)) == len(subarray) and subarray == sorted(subarray):\n            results[i] = max(subarray)\n    \n    return results", "def find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if is_consecutive_and_sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n\ndef is_consecutive_and_sorted(arr):\n    return arr == sorted(set(arr)) and len(arr) == len(set(arr))\n\n# Example usage:\nnums = [1, 2, 3, 4, 3, 2, 5]\nk = 3\nprint(find_power_of_subarrays(nums, k))  # Output: [3, 4, -1, -1, -1]\n\nnums = [2, 2, 2, 2, 2]\nk = 4\nprint(find_power_of_subarrays(nums, k))  # Output: [-1, -1]\n\nnums = [3, 2, 3, 2, 3, 2]\nk = 2\nprint(find_power_of_subarrays(nums, k))  # Output: [-1, 3, -1, 3, -1]"], "passed": [false, false, false, false, true, false, false, false, false, true, false, true, false, false, false, false], "raw_code": ["```python\ndef find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if subarray == sorted(subarray) and len(set(subarray)) == k:\n            results[i] = max(subarray)\n    \n    return results\n```", "```python\ndef findPowerOfSubarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        unique_elements = set(subarray)\n        \n        if len(unique_elements) == k and subarray == sorted(subarray):\n            results[i] = max(subarray)\n    \n    return results\n```", "```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if subarray == sorted(subarray) and len(set(subarray)) == len(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if subarray == sorted(subarray) and len(set(subarray)) == len(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if all(subarray[j] == subarray[j+1] - 1 for j in range(k-1)) and subarray == sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if subarray == sorted_subarray and len(set(subarray)) == k:\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef find_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if subarray == sorted(subarray) and len(set(subarray)) == k:\n            results.append(subarray[-1])\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef findPowerOfSubarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if sorted_subarray == list(range(sorted_subarray[0], sorted_subarray[-1] + 1)):\n            results[i] = max(subarray)\n    \n    return results\n```", "```python\ndef find_subarray_power(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = sorted(nums[i:i + k])\n        if all(subarray[j] + 1 == subarray[j + 1] for j in range(k - 1)):\n            results[i] = subarray[-1]\n    \n    return results\n```", "```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if sorted(subarray) == subarray and all(subarray[j] + 1 == subarray[j+1] for j in range(k-1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if all(subarray[j] < subarray[j + 1] for j in range(k - 1)) and subarray == sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if subarray == sorted(subarray) and all(subarray[j] + 1 == subarray[j + 1] for j in range(k - 1)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```", "```python\ndef find_subarray_powers(nums, k):\n    def is_consecutive_and_sorted(subarray):\n        return sorted(subarray) == list(range(min(subarray), max(subarray) + 1))\n    \n    n = len(nums)\n    results = []\n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if is_consecutive_and_sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    return results\n```", "```python\ndef find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        start, end = i, i + k - 1\n        is_consecutive_sorted = True\n        \n        for j in range(start, end):\n            if nums[j] >= nums[j + 1]:\n                is_consecutive_sorted = False\n                break\n        \n        if is_consecutive_sorted:\n            results[i] = max(nums[start:end + 1])\n    \n    return results\n```", "```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = [-1] * (n - k + 1)\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i + k]\n        if len(set(subarray)) == len(subarray) and subarray == sorted(subarray):\n            results[i] = max(subarray)\n    \n    return results\n```", "```python\ndef find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if is_consecutive_and_sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n\ndef is_consecutive_and_sorted(arr):\n    return arr == sorted(set(arr)) and len(arr) == len(set(arr))\n\n# Example usage:\nnums = [1, 2, 3, 4, 3, 2, 5]\nk = 3\nprint(find_power_of_subarrays(nums, k))  # Output: [3, 4, -1, -1, -1]\n\nnums = [2, 2, 2, 2, 2]\nk = 4\nprint(find_power_of_subarrays(nums, k))  # Output: [-1, -1]\n\nnums = [3, 2, 3, 2, 3, 2]\nk = 2\nprint(find_power_of_subarrays(nums, k))  # Output: [-1, 3, -1, 3, -1]\n```"]}
{"task_id": "3584", "codes": ["def almost_equal_sequence(word1, word2):\n    n = len(word2)\n    m = len(word1)\n    result = []\n    \n    i = 0\n    j = 0\n    mismatches = 0\n    \n    while i < n and j < m:\n        if word1[j] != word2[i]:\n            if mismatches == 1:\n                return []\n            result.append(j)\n            mismatches += 1\n        i += 1\n        j += 1\n    \n    # If there are remaining characters in word1, check if they match the rest of word2\n    while j < m:\n        if word1[j] != word2[n - 1]:\n            return []\n        j += 1\n    \n    return result", "def findAlmostEqualSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    for i in range(m):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if any single change makes word1 almost equal to word2\n    for idx in diff_indices:\n        temp_word1 = list(word1)\n        temp_word1[idx] = word2[idx]\n        temp_word1_str = ''.join(temp_word1)\n        if sum(c1 != c2 for c1, c2 in zip(temp_word1_str, word2)) <= 1:\n            return [idx]\n\n    return []", "def smallestSequence(word1, word2):\n    m, n = len(word1), len(word2)\n    mismatches = []\n\n    # Identify mismatched positions\n    for i in range(n):\n        if word1[i] != word2[i]:\n            mismatches.append(i)\n\n    def is_almost_equal(seq):\n        temp = list(word1)\n        for idx in seq:\n            temp[idx] = word2[idx]\n        return sum(temp[i] != word2[i] for i in range(n)) <= 1\n\n    min_seq = None\n\n    # Generate all possible sequences and find the lexicographically smallest valid one\n    for i in range(1 << len(mismatches)):\n        seq = [mismatches[j] for j in range(len(mismatches)) if i & (1 << j)]\n        if is_almost_equal(seq):\n            if min_seq is None or seq < min_seq:\n                min_seq = seq\n\n    return min_seq if min_seq else []", "def almost_equal_sequence(word1: str, word2: str) -> List[int]:\n    m, n = len(word1), len(word2)\n    i, j = 0, 0\n    indices = []\n    \n    while i < m and j < n:\n        if word1[i] != word2[j]:\n            indices.append(j)\n            if len(indices) > 1:\n                return []\n            i += 1\n        else:\n            i += 1\n            j += 1\n    \n    # Check if there are remaining unmatched characters in word2\n    while j < n:\n        indices.append(j)\n        if len(indices) > 1:\n            return []\n        j += 1\n    \n    return indices", "def smallestSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    indices = []\n    changes = 0\n    \n    while i < n and j < m:\n        if word1[i] == word2[j]:\n            indices.append(i)\n            i += 1\n            j += 1\n        else:\n            if changes == 0:\n                changes += 1\n                if i + 1 < n and word1[i + 1] == word2[j]:\n                    indices.append(i + 1)\n                    i += 2\n                    j += 1\n                else:\n                    indices.append(i)\n                    i += 1\n            else:\n                return []\n    \n    while i < n and changes == 0:\n        indices.append(i)\n        i += 1\n    \n    while j < m:\n        return []\n    \n    return indices", "def find_almost_equal_sequence(word1, word2):\n    m, n = len(word2), len(word1)\n    if m == 0:\n        return []\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        start = i\n        while diff_count <= 1 and i < n:\n            if word1[i] != word2[i - start]:\n                diff_count += 1\n            i += 1\n        \n        if diff_count <= 1:\n            return list(range(start, i))\n    \n    return []\n\n# Example usage:\nword1 = \"abc\"\nword2 = \"ab\"\nprint(find_almost_equal_sequence(word1, word2))  # Output: [0, 1]", "def find_valid_sequence(word1, word2):\n    diff_indices = []\n    for i in range(len(word2)):\n        if word1[i] != word2[i]:\n            if len(diff_indices) == 1:\n                return []\n            diff_indices.append(i)\n    if len(diff_indices) > 1:\n        return []\n    return diff_indices", "def findSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    seq = []\n    while i < n and j < m:\n        if word1[i] != word2[j]:\n            seq.append(i)\n            if j + 1 < m and word1[i] == word2[j + 1]:\n                j += 1\n            else:\n                return []\n        i += 1\n        j += 1\n    return seq if j == m else []", "def find_lexicographically_smallest_sequence(word1, word2):\n    mismatches = [i for i in range(len(word1)) if word1[i] != word2[i]]\n    \n    if len(mismatches) > 1:\n        return []\n    \n    return mismatches", "def smallestSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    mismatches = []\n    \n    while i < n and j < m:\n        if word1[i] != word2[j]:\n            mismatches.append(i)\n            if len(mismatches) > 1:\n                return []\n        i += 1\n        j += 1\n    \n    # Check if the remaining part of word1 matches word2\n    while i < n:\n        if word1[i] != word2[j - 1]:\n            return []\n        i += 1\n    \n    return mismatches", "def smallestSequenceOfIndices(word1, word2):\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify the positions where word1 and word2 differ\n    for i in range(n):\n        if i < m and word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if changing one character can make word1 almost equal to word2\n    for i in range(len(diff_indices)):\n        if i + 1 < len(diff_indices):\n            temp_word1 = list(word1)\n            temp_word1[diff_indices[i]] = word2[diff_indices[i]]\n            for j in range(i + 1, len(diff_indices)):\n                temp_word1[diff_indices[j]] = word2[diff_indices[j]]\n            if ''.join(temp_word1[:m]) == word2:\n                return diff_indices[:i+1]\n\n    return []", "def smallestSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    changes = 0\n    result = []\n    \n    while i < n and j < m:\n        if word1[i] == word2[j]:\n            result.append(i)\n            j += 1\n        else:\n            if changes > 0:\n                return []\n            changes += 1\n        i += 1\n    \n    if j < m or changes > 0:\n        return []\n    \n    return result", "def smallestSequence(word1: str, word2: str) -> List[int]:\n    m, n = len(word1), len(word2)\n    i, j = 0, 0\n    mismatches = 0\n    result = []\n\n    while i < m and j < n:\n        if word1[i] != word2[j]:\n            if mismatches == 1:\n                break\n            if word1[i + 1:i + 2] == word2[j:j + 1]:\n                result.append(i)\n                i += 1\n                mismatches += 1\n            else:\n                break\n        else:\n            result.append(i)\n            i += 1\n            j += 1\n\n    return result if j == n else []", "def find_lexicographically_smallest_sequence(word1, word2):\n    n1, n2 = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify the indices where word1 differs from word2\n    for i in range(n2):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if there is any valid sequence\n    if not diff_indices:\n        return []\n\n    # Ensure the sequence is lexicographically smallest\n    return diff_indices", "def smallest_sequence(word1, word2):\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify differing indices\n    for i in range(m):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if changing at most one character makes word1 almost equal to word2\n    if len(diff_indices) > 1:\n        return []\n\n    # Generate the lexicographically smallest sequence of indices\n    if len(diff_indices) == 1:\n        return [diff_indices[0]]\n\n    # If there are no differences, return an empty list\n    return []", "def smallestSequenceOfIndices(word1: str, word2: str) -> List[int]:\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    changes = 0\n    result = []\n    \n    while i < n and j < m:\n        if word1[i] == word2[j] or (ord(word1[i]) + 1 == ord(word2[j])) or (ord(word1[i]) - 1 == ord(word2[j])):\n            result.append(i)\n            i += 1\n            j += 1\n        else:\n            if changes == 0:\n                if abs(ord(word1[i]) - ord(word2[j])) > 1:\n                    return []\n                changes += 1\n                result.append(i)\n                i += 1\n            else:\n                return []\n    \n    if j < m:\n        return []\n    \n    return result"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef almost_equal_sequence(word1, word2):\n    n = len(word2)\n    m = len(word1)\n    result = []\n    \n    i = 0\n    j = 0\n    mismatches = 0\n    \n    while i < n and j < m:\n        if word1[j] != word2[i]:\n            if mismatches == 1:\n                return []\n            result.append(j)\n            mismatches += 1\n        i += 1\n        j += 1\n    \n    # If there are remaining characters in word1, check if they match the rest of word2\n    while j < m:\n        if word1[j] != word2[n - 1]:\n            return []\n        j += 1\n    \n    return result\n```", "```python\ndef findAlmostEqualSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    for i in range(m):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if any single change makes word1 almost equal to word2\n    for idx in diff_indices:\n        temp_word1 = list(word1)\n        temp_word1[idx] = word2[idx]\n        temp_word1_str = ''.join(temp_word1)\n        if sum(c1 != c2 for c1, c2 in zip(temp_word1_str, word2)) <= 1:\n            return [idx]\n\n    return []\n```", "```python\ndef smallestSequence(word1, word2):\n    m, n = len(word1), len(word2)\n    mismatches = []\n\n    # Identify mismatched positions\n    for i in range(n):\n        if word1[i] != word2[i]:\n            mismatches.append(i)\n\n    def is_almost_equal(seq):\n        temp = list(word1)\n        for idx in seq:\n            temp[idx] = word2[idx]\n        return sum(temp[i] != word2[i] for i in range(n)) <= 1\n\n    min_seq = None\n\n    # Generate all possible sequences and find the lexicographically smallest valid one\n    for i in range(1 << len(mismatches)):\n        seq = [mismatches[j] for j in range(len(mismatches)) if i & (1 << j)]\n        if is_almost_equal(seq):\n            if min_seq is None or seq < min_seq:\n                min_seq = seq\n\n    return min_seq if min_seq else []\n```", "```python\ndef almost_equal_sequence(word1: str, word2: str) -> List[int]:\n    m, n = len(word1), len(word2)\n    i, j = 0, 0\n    indices = []\n    \n    while i < m and j < n:\n        if word1[i] != word2[j]:\n            indices.append(j)\n            if len(indices) > 1:\n                return []\n            i += 1\n        else:\n            i += 1\n            j += 1\n    \n    # Check if there are remaining unmatched characters in word2\n    while j < n:\n        indices.append(j)\n        if len(indices) > 1:\n            return []\n        j += 1\n    \n    return indices\n```", "```python\ndef smallestSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    indices = []\n    changes = 0\n    \n    while i < n and j < m:\n        if word1[i] == word2[j]:\n            indices.append(i)\n            i += 1\n            j += 1\n        else:\n            if changes == 0:\n                changes += 1\n                if i + 1 < n and word1[i + 1] == word2[j]:\n                    indices.append(i + 1)\n                    i += 2\n                    j += 1\n                else:\n                    indices.append(i)\n                    i += 1\n            else:\n                return []\n    \n    while i < n and changes == 0:\n        indices.append(i)\n        i += 1\n    \n    while j < m:\n        return []\n    \n    return indices\n```", "```python\ndef find_almost_equal_sequence(word1, word2):\n    m, n = len(word2), len(word1)\n    if m == 0:\n        return []\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        start = i\n        while diff_count <= 1 and i < n:\n            if word1[i] != word2[i - start]:\n                diff_count += 1\n            i += 1\n        \n        if diff_count <= 1:\n            return list(range(start, i))\n    \n    return []\n\n# Example usage:\nword1 = \"abc\"\nword2 = \"ab\"\nprint(find_almost_equal_sequence(word1, word2))  # Output: [0, 1]\n```", "```python\ndef find_valid_sequence(word1, word2):\n    diff_indices = []\n    for i in range(len(word2)):\n        if word1[i] != word2[i]:\n            if len(diff_indices) == 1:\n                return []\n            diff_indices.append(i)\n    if len(diff_indices) > 1:\n        return []\n    return diff_indices\n```", "def findSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    seq = []\n    while i < n and j < m:\n        if word1[i] != word2[j]:\n            seq.append(i)\n            if j + 1 < m and word1[i] == word2[j + 1]:\n                j += 1\n            else:\n                return []\n        i += 1\n        j += 1\n    return seq if j == m else []", "```python\ndef find_lexicographically_smallest_sequence(word1, word2):\n    mismatches = [i for i in range(len(word1)) if word1[i] != word2[i]]\n    \n    if len(mismatches) > 1:\n        return []\n    \n    return mismatches\n```", "```python\ndef smallestSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    mismatches = []\n    \n    while i < n and j < m:\n        if word1[i] != word2[j]:\n            mismatches.append(i)\n            if len(mismatches) > 1:\n                return []\n        i += 1\n        j += 1\n    \n    # Check if the remaining part of word1 matches word2\n    while i < n:\n        if word1[i] != word2[j - 1]:\n            return []\n        i += 1\n    \n    return mismatches\n```", "```python\ndef smallestSequenceOfIndices(word1, word2):\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify the positions where word1 and word2 differ\n    for i in range(n):\n        if i < m and word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if changing one character can make word1 almost equal to word2\n    for i in range(len(diff_indices)):\n        if i + 1 < len(diff_indices):\n            temp_word1 = list(word1)\n            temp_word1[diff_indices[i]] = word2[diff_indices[i]]\n            for j in range(i + 1, len(diff_indices)):\n                temp_word1[diff_indices[j]] = word2[diff_indices[j]]\n            if ''.join(temp_word1[:m]) == word2:\n                return diff_indices[:i+1]\n\n    return []\n```", "```python\ndef smallestSequence(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    changes = 0\n    result = []\n    \n    while i < n and j < m:\n        if word1[i] == word2[j]:\n            result.append(i)\n            j += 1\n        else:\n            if changes > 0:\n                return []\n            changes += 1\n        i += 1\n    \n    if j < m or changes > 0:\n        return []\n    \n    return result\n```", "```python\ndef smallestSequence(word1: str, word2: str) -> List[int]:\n    m, n = len(word1), len(word2)\n    i, j = 0, 0\n    mismatches = 0\n    result = []\n\n    while i < m and j < n:\n        if word1[i] != word2[j]:\n            if mismatches == 1:\n                break\n            if word1[i + 1:i + 2] == word2[j:j + 1]:\n                result.append(i)\n                i += 1\n                mismatches += 1\n            else:\n                break\n        else:\n            result.append(i)\n            i += 1\n            j += 1\n\n    return result if j == n else []\n```", "```python\ndef find_lexicographically_smallest_sequence(word1, word2):\n    n1, n2 = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify the indices where word1 differs from word2\n    for i in range(n2):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if there is any valid sequence\n    if not diff_indices:\n        return []\n\n    # Ensure the sequence is lexicographically smallest\n    return diff_indices\n```", "```python\ndef smallest_sequence(word1, word2):\n    n, m = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify differing indices\n    for i in range(m):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check if changing at most one character makes word1 almost equal to word2\n    if len(diff_indices) > 1:\n        return []\n\n    # Generate the lexicographically smallest sequence of indices\n    if len(diff_indices) == 1:\n        return [diff_indices[0]]\n\n    # If there are no differences, return an empty list\n    return []\n```", "```python\ndef smallestSequenceOfIndices(word1: str, word2: str) -> List[int]:\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    changes = 0\n    result = []\n    \n    while i < n and j < m:\n        if word1[i] == word2[j] or (ord(word1[i]) + 1 == ord(word2[j])) or (ord(word1[i]) - 1 == ord(word2[j])):\n            result.append(i)\n            i += 1\n            j += 1\n        else:\n            if changes == 0:\n                if abs(ord(word1[i]) - ord(word2[j])) > 1:\n                    return []\n                changes += 1\n                result.append(i)\n                i += 1\n            else:\n                return []\n    \n    if j < m:\n        return []\n    \n    return result\n```"]}
{"task_id": "3534", "codes": ["def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    def can_become_equal(num1, num2):\n        s1, s2 = str(num1), str(num2)\n        if s1 == s2:\n            return True\n        for i in range(len(s1)):\n            for j in range(i + 1, len(s1)):\n                s1_swapped = s1[:i] + s1[j] + s1[i+1:j] + s1[i] + s1[j+1:]\n                if s1_swapped == s2:\n                    return True\n        return False\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_become_equal(nums[i], nums[j]):\n                count += 1\n                \n    return count", "def almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    def generate_swapped_numbers(num_str):\n        swapped_numbers = set()\n        num_list = list(num_str)\n        for i in range(len(num_list)):\n            for j in range(i + 1, len(num_list)):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swapped_numbers.add(''.join(num_list))\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swapped_numbers\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            if num1 == num2:\n                count += 1\n                continue\n            swapped_num1 = generate_swapped_numbers(num1)\n            swapped_num2 = generate_swapped_numbers(num2)\n            if num2 in swapped_num1 or num1 in swapped_num2:\n                count += 1\n                \n    return count", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    swapped_num1 = list(num1)\n                    swapped_num1[k], swapped_num1[l] = swapped_num1[l], swapped_num1[k]\n                    \n                    for m in range(len(num2)):\n                        for n in range(m + 1, len(num2)):\n                            swapped_num2 = list(num2)\n                            swapped_num2[m], swapped_num2[n] = swapped_num2[n], swapped_num2[m]\n                            \n                            if ''.join(swapped_num1) == ''.join(swapped_num2):\n                                count += 1\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        continue\n                    break\n    \n    return count", "from itertools import permutations\nfrom collections import Counter\n\ndef count_almost_equal_pairs(nums):\n    def generate_swaps(s):\n        swaps = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                swap = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                swaps.add(swap)\n        return swaps\n\n    swaps_set = set()\n    count = 0\n\n    for num in nums:\n        swaps = generate_swaps(str(num))\n        for swap in swaps:\n            if swap in swaps_set:\n                count += 1\n        swaps_set.add(str(num))\n\n    return count", "def countAlmostEqualPairs(nums):\n    n = len(nums)\n    count = 0\n    num_set = set()\n    \n    for num in nums:\n        num_str = str(num)\n        length = len(num_str)\n        \n        # Generate all unique swaps\n        swaps = set()\n        for i in range(length):\n            for j in range(i + 1, length):\n                swapped_str = list(num_str)\n                swapped_str[i], swapped_str[j] = swapped_str[j], swapped_str[i]\n                swaps.add(int(''.join(swapped_str)))\n        \n        # Check if any swapped version exists in the set\n        for swapped_num in swaps:\n            if swapped_num in num_set:\n                count += 1\n    \n    # Since each pair is counted twice, divide by 2\n    return count // 2", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    # Helper function to generate all possible swaps of a number\n    def generate_swaps(num_str):\n        swaps = set()\n        num_list = list(num_str)\n        for i in range(len(num_list)):\n            for j in range(i + 1, len(num_list)):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swaps.add(''.join(num_list))\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swaps\n    \n    # Convert all numbers to strings for easy manipulation\n    str_nums = [str(num) for num in nums]\n    \n    # Dictionary to store swaps for each number\n    swaps_dict = {}\n    for i, num_str in enumerate(str_nums):\n        swaps_dict[num_str] = generate_swaps(num_str)\n    \n    # Check for almost equal pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            if str_nums[i] in swaps_dict[str_nums[j]]:\n                count += 1\n    \n    return count", "def count_almost_equal_pairs(nums):\n    def generate_swapped_numbers(num_str):\n        num_list = list(num_str)\n        swapped_numbers = set()\n        n = len(num_list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swapped_number = ''.join(num_list)\n                swapped_numbers.add(swapped_number)\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swapped_numbers\n    \n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            num1_str = str(nums[i])\n            num2_str = str(nums[j])\n            if num1_str == num2_str:\n                count += 1\n                continue\n            swapped_num1 = generate_swapped_numbers(num1_str)\n            if num2_str in swapped_num1:\n                count += 1\n    return count", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            for k in range(len(num1)):\n                for l in range(k + 1, len(num2)):\n                    # Swap digits at positions k and l\n                    swapped_num1 = num1[:k] + num2[l] + num1[k+1:l] + num2[k] + num1[l+1:]\n                    swapped_num2 = num2[:l] + num1[k] + num2[l+1:k] + num1[l] + num2[k+1:]\n                    \n                    if swapped_num1 == num2 or swapped_num2 == num1:\n                        count += 1\n                        break\n                else:\n                    continue\n                break\n    \n    return count", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            # Check if swapping any single digit makes the numbers equal\n            for k in range(len(num1)):\n                for l in range(len(num2)):\n                    if k == l:\n                        continue\n                    \n                    swapped_num1 = num1[:k] + num2[l] + num1[k+1:]\n                    swapped_num2 = num2[:l] + num1[k] + num2[l+1:]\n                    \n                    if swapped_num1 == num2 or swapped_num2 == num1:\n                        count += 1\n                        break\n                else:\n                    continue\n                break\n    \n    return count", "def almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        num_str = str(nums[i])\n        for j in range(i + 1, n):\n            target = str(nums[j])\n            for k in range(len(num_str)):\n                for l in range(k + 1, len(num_str)):\n                    swapped_num_str = list(num_str)\n                    swapped_num_str[k], swapped_num_str[l] = swapped_num_str[l], swapped_num_str[k]\n                    swapped_num = int(''.join(swapped_num_str))\n                    if swapped_num == int(target):\n                        count += 1\n                        \n    return count", "def count_almost_equal_pairs(nums):\n    def generate_swapped_versions(num_str):\n        n = len(num_str)\n        swapped_versions = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                swapped_str = num_str[:i] + num_str[j] + num_str[i+1:j] + num_str[i] + num_str[j+1:]\n                swapped_versions.add(swapped_str)\n        return swapped_versions\n    \n    count = 0\n    num_set = set(map(str, nums))\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            num_i = str(nums[i])\n            num_j = str(nums[j])\n            if num_i == num_j:\n                count += 1\n                continue\n            \n            swapped_i = generate_swapped_versions(num_i)\n            swapped_j = generate_swapped_versions(num_j)\n            \n            if num_j in swapped_i or num_i in swapped_j:\n                count += 1\n                \n    return count", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            # Generate all possible swaps for num1\n            swaps_num1 = set()\n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    swapped_num1 = num1[:k] + num1[l] + num1[k+1:l] + num1[k] + num1[l+1:]\n                    swaps_num1.add(swapped_num1)\n            \n            # Check if any swap of num1 matches num2\n            if num2 in swaps_num1:\n                count += 1\n    \n    return count", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        num_str = str(nums[i])\n        for j in range(len(num_str)):\n            for k in range(j + 1, len(num_str)):\n                swapped_num_str = list(num_str)\n                swapped_num_str[j], swapped_num_str[k] = swapped_num_str[k], swapped_num_str[j]\n                swapped_num = int(''.join(swapped_num_str))\n                \n                if swapped_num in nums and nums.index(swapped_num) > i:\n                    count += 1\n                    \n    return count", "def almost_equal_pairs(nums):\n    def can_be_almost_equal(x, y):\n        str_x, str_y = str(x), str(y)\n        diff_count = 0\n        diff_indices = []\n        \n        for i in range(min(len(str_x), len(str_y))):\n            if str_x[i] != str_y[i]:\n                diff_count += 1\n                diff_indices.append((i, i))\n                \n            if diff_count > 1:\n                return False\n        \n        if diff_count == 0:\n            return True\n        \n        if diff_count == 1:\n            if len(str_x) != len(str_y):\n                return False\n            return True\n        \n        # Check if swapping the differing digits makes them equal\n        if diff_indices[0][0] < len(str_x) - 1 and str_x[diff_indices[0][0]] == str_y[diff_indices[0][0] + 1] and str_x[diff_indices[0][0] + 1] == str_y[diff_indices[0][0]]:\n            return True\n        if diff_indices[0][1] < len(str_y) - 1 and str_y[diff_indices[0][1]] == str_x[diff_indices[0][1] + 1] and str_y[diff_indices[0][1] + 1] == str_x[diff_indices[0][1]]:\n            return True\n        \n        return False\n    \n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_be_almost_equal(nums[i], nums[j]):\n                count += 1\n    \n    return count", "def count_almost_equal_pairs(nums):\n    def generate_swapped_numbers(num_str):\n        swapped_set = set()\n        num_list = list(num_str)\n        n = len(num_list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swapped_set.add(''.join(num_list))\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swapped_set\n    \n    count = 0\n    num_set = {str(num) for num in nums}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            num_i_str = str(nums[i])\n            num_j_str = str(nums[j])\n            if num_j_str in generate_swapped_numbers(num_i_str):\n                count += 1\n                \n    return count", "def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    def can_be_made_equal_by_one_swap(num1, num2):\n        str1 = str(num1)\n        str2 = str(num2)\n        \n        if len(str1) != len(str2):\n            return False\n        \n        diff_indices = []\n        for i in range(len(str1)):\n            if str1[i] != str2[i]:\n                diff_indices.append(i)\n            \n            if len(diff_indices) > 2:\n                return False\n        \n        if len(diff_indices) == 0:\n            return True\n        \n        if len(diff_indices) == 1:\n            return False\n        \n        i, j = diff_indices\n        return str1[:i] + str2[j] + str1[i+1:j] + str2[i] + str1[j+1:]\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_be_made_equal_by_one_swap(nums[i], nums[j]):\n                count += 1\n    \n    return count"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    def can_become_equal(num1, num2):\n        s1, s2 = str(num1), str(num2)\n        if s1 == s2:\n            return True\n        for i in range(len(s1)):\n            for j in range(i + 1, len(s1)):\n                s1_swapped = s1[:i] + s1[j] + s1[i+1:j] + s1[i] + s1[j+1:]\n                if s1_swapped == s2:\n                    return True\n        return False\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_become_equal(nums[i], nums[j]):\n                count += 1\n                \n    return count\n```", "```python\ndef almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    def generate_swapped_numbers(num_str):\n        swapped_numbers = set()\n        num_list = list(num_str)\n        for i in range(len(num_list)):\n            for j in range(i + 1, len(num_list)):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swapped_numbers.add(''.join(num_list))\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swapped_numbers\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            if num1 == num2:\n                count += 1\n                continue\n            swapped_num1 = generate_swapped_numbers(num1)\n            swapped_num2 = generate_swapped_numbers(num2)\n            if num2 in swapped_num1 or num1 in swapped_num2:\n                count += 1\n                \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    swapped_num1 = list(num1)\n                    swapped_num1[k], swapped_num1[l] = swapped_num1[l], swapped_num1[k]\n                    \n                    for m in range(len(num2)):\n                        for n in range(m + 1, len(num2)):\n                            swapped_num2 = list(num2)\n                            swapped_num2[m], swapped_num2[n] = swapped_num2[n], swapped_num2[m]\n                            \n                            if ''.join(swapped_num1) == ''.join(swapped_num2):\n                                count += 1\n                                break\n                        else:\n                            continue\n                        break\n                    else:\n                        continue\n                    break\n    \n    return count\n```", "```python\nfrom itertools import permutations\nfrom collections import Counter\n\ndef count_almost_equal_pairs(nums):\n    def generate_swaps(s):\n        swaps = set()\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                swap = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                swaps.add(swap)\n        return swaps\n\n    swaps_set = set()\n    count = 0\n\n    for num in nums:\n        swaps = generate_swaps(str(num))\n        for swap in swaps:\n            if swap in swaps_set:\n                count += 1\n        swaps_set.add(str(num))\n\n    return count\n```", "```python\ndef countAlmostEqualPairs(nums):\n    n = len(nums)\n    count = 0\n    num_set = set()\n    \n    for num in nums:\n        num_str = str(num)\n        length = len(num_str)\n        \n        # Generate all unique swaps\n        swaps = set()\n        for i in range(length):\n            for j in range(i + 1, length):\n                swapped_str = list(num_str)\n                swapped_str[i], swapped_str[j] = swapped_str[j], swapped_str[i]\n                swaps.add(int(''.join(swapped_str)))\n        \n        # Check if any swapped version exists in the set\n        for swapped_num in swaps:\n            if swapped_num in num_set:\n                count += 1\n    \n    # Since each pair is counted twice, divide by 2\n    return count // 2\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    # Helper function to generate all possible swaps of a number\n    def generate_swaps(num_str):\n        swaps = set()\n        num_list = list(num_str)\n        for i in range(len(num_list)):\n            for j in range(i + 1, len(num_list)):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swaps.add(''.join(num_list))\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swaps\n    \n    # Convert all numbers to strings for easy manipulation\n    str_nums = [str(num) for num in nums]\n    \n    # Dictionary to store swaps for each number\n    swaps_dict = {}\n    for i, num_str in enumerate(str_nums):\n        swaps_dict[num_str] = generate_swaps(num_str)\n    \n    # Check for almost equal pairs\n    for i in range(n):\n        for j in range(i + 1, n):\n            if str_nums[i] in swaps_dict[str_nums[j]]:\n                count += 1\n    \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    def generate_swapped_numbers(num_str):\n        num_list = list(num_str)\n        swapped_numbers = set()\n        n = len(num_list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swapped_number = ''.join(num_list)\n                swapped_numbers.add(swapped_number)\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swapped_numbers\n    \n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            num1_str = str(nums[i])\n            num2_str = str(nums[j])\n            if num1_str == num2_str:\n                count += 1\n                continue\n            swapped_num1 = generate_swapped_numbers(num1_str)\n            if num2_str in swapped_num1:\n                count += 1\n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            for k in range(len(num1)):\n                for l in range(k + 1, len(num2)):\n                    # Swap digits at positions k and l\n                    swapped_num1 = num1[:k] + num2[l] + num1[k+1:l] + num2[k] + num1[l+1:]\n                    swapped_num2 = num2[:l] + num1[k] + num2[l+1:k] + num1[l] + num2[k+1:]\n                    \n                    if swapped_num1 == num2 or swapped_num2 == num1:\n                        count += 1\n                        break\n                else:\n                    continue\n                break\n    \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            # Check if swapping any single digit makes the numbers equal\n            for k in range(len(num1)):\n                for l in range(len(num2)):\n                    if k == l:\n                        continue\n                    \n                    swapped_num1 = num1[:k] + num2[l] + num1[k+1:]\n                    swapped_num2 = num2[:l] + num1[k] + num2[l+1:]\n                    \n                    if swapped_num1 == num2 or swapped_num2 == num1:\n                        count += 1\n                        break\n                else:\n                    continue\n                break\n    \n    return count\n```", "```python\ndef almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        num_str = str(nums[i])\n        for j in range(i + 1, n):\n            target = str(nums[j])\n            for k in range(len(num_str)):\n                for l in range(k + 1, len(num_str)):\n                    swapped_num_str = list(num_str)\n                    swapped_num_str[k], swapped_num_str[l] = swapped_num_str[l], swapped_num_str[k]\n                    swapped_num = int(''.join(swapped_num_str))\n                    if swapped_num == int(target):\n                        count += 1\n                        \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    def generate_swapped_versions(num_str):\n        n = len(num_str)\n        swapped_versions = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                swapped_str = num_str[:i] + num_str[j] + num_str[i+1:j] + num_str[i] + num_str[j+1:]\n                swapped_versions.add(swapped_str)\n        return swapped_versions\n    \n    count = 0\n    num_set = set(map(str, nums))\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            num_i = str(nums[i])\n            num_j = str(nums[j])\n            if num_i == num_j:\n                count += 1\n                continue\n            \n            swapped_i = generate_swapped_versions(num_i)\n            swapped_j = generate_swapped_versions(num_j)\n            \n            if num_j in swapped_i or num_i in swapped_j:\n                count += 1\n                \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            # Generate all possible swaps for num1\n            swaps_num1 = set()\n            for k in range(len(num1)):\n                for l in range(k + 1, len(num1)):\n                    swapped_num1 = num1[:k] + num1[l] + num1[k+1:l] + num1[k] + num1[l+1:]\n                    swaps_num1.add(swapped_num1)\n            \n            # Check if any swap of num1 matches num2\n            if num2 in swaps_num1:\n                count += 1\n    \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        num_str = str(nums[i])\n        for j in range(len(num_str)):\n            for k in range(j + 1, len(num_str)):\n                swapped_num_str = list(num_str)\n                swapped_num_str[j], swapped_num_str[k] = swapped_num_str[k], swapped_num_str[j]\n                swapped_num = int(''.join(swapped_num_str))\n                \n                if swapped_num in nums and nums.index(swapped_num) > i:\n                    count += 1\n                    \n    return count\n```", "```python\ndef almost_equal_pairs(nums):\n    def can_be_almost_equal(x, y):\n        str_x, str_y = str(x), str(y)\n        diff_count = 0\n        diff_indices = []\n        \n        for i in range(min(len(str_x), len(str_y))):\n            if str_x[i] != str_y[i]:\n                diff_count += 1\n                diff_indices.append((i, i))\n                \n            if diff_count > 1:\n                return False\n        \n        if diff_count == 0:\n            return True\n        \n        if diff_count == 1:\n            if len(str_x) != len(str_y):\n                return False\n            return True\n        \n        # Check if swapping the differing digits makes them equal\n        if diff_indices[0][0] < len(str_x) - 1 and str_x[diff_indices[0][0]] == str_y[diff_indices[0][0] + 1] and str_x[diff_indices[0][0] + 1] == str_y[diff_indices[0][0]]:\n            return True\n        if diff_indices[0][1] < len(str_y) - 1 and str_y[diff_indices[0][1]] == str_x[diff_indices[0][1] + 1] and str_y[diff_indices[0][1] + 1] == str_x[diff_indices[0][1]]:\n            return True\n        \n        return False\n    \n    count = 0\n    n = len(nums)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_be_almost_equal(nums[i], nums[j]):\n                count += 1\n    \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    def generate_swapped_numbers(num_str):\n        swapped_set = set()\n        num_list = list(num_str)\n        n = len(num_list)\n        for i in range(n):\n            for j in range(i + 1, n):\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n                swapped_set.add(''.join(num_list))\n                num_list[i], num_list[j] = num_list[j], num_list[i]\n        return swapped_set\n    \n    count = 0\n    num_set = {str(num) for num in nums}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            num_i_str = str(nums[i])\n            num_j_str = str(nums[j])\n            if num_j_str in generate_swapped_numbers(num_i_str):\n                count += 1\n                \n    return count\n```", "```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    def can_be_made_equal_by_one_swap(num1, num2):\n        str1 = str(num1)\n        str2 = str(num2)\n        \n        if len(str1) != len(str2):\n            return False\n        \n        diff_indices = []\n        for i in range(len(str1)):\n            if str1[i] != str2[i]:\n                diff_indices.append(i)\n            \n            if len(diff_indices) > 2:\n                return False\n        \n        if len(diff_indices) == 0:\n            return True\n        \n        if len(diff_indices) == 1:\n            return False\n        \n        i, j = diff_indices\n        return str1[:i] + str2[j] + str1[i+1:j] + str2[i] + str1[j+1:]\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_be_made_equal_by_one_swap(nums[i], nums[j]):\n                count += 1\n    \n    return count\n```"]}
{"task_id": "3558", "codes": ["def hasPath(grid, health):\n    def dfs(x, y, health):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or health <= 0:\n            return False\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1\n        result = dfs(x + 1, y, health - temp) or \\\n                 dfs(x - 1, y, health - temp) or \\\n                 dfs(x, y + 1, health - temp) or \\\n                 dfs(x, y - 1, health - temp)\n        grid[x][y] = temp\n        return result\n    \n    return dfs(0, 0, health)", "from collections import deque\n\ndef can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    queue = deque([(0, 0, health)])\n    visited = set()\n    \n    while queue:\n        x, y, current_health = queue.popleft()\n        \n        if (x, y, current_health) in visited:\n            continue\n        visited.add((x, y, current_health))\n        \n        if x == m - 1 and y == n - 1:\n            return True\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                new_health = current_health - grid[nx][ny]\n                if new_health > 0:\n                    queue.append((nx, ny, new_health))\n    \n    return False", "def can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        if grid[x][y] == 1:\n            health -= 1\n        \n        # Mark the cell as visited\n        grid[x][y] = -1\n        \n        # Explore all four possible directions\n        if dfs(x + 1, y, health) or dfs(x - 1, y, health) or dfs(x, y + 1, health) or dfs(x, y - 1, health):\n            return True\n        \n        # Unmark the cell\n        grid[x][y] = 0\n        \n        return False\n    \n    return dfs(0, 0, health)", "def hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1  # Mark as visited\n        if (dfs(x + 1, y, health - temp) or\n                dfs(x - 1, y, health - temp) or\n                dfs(x, y + 1, health - temp) or\n                dfs(x, y - 1, health - temp)):\n            return True\n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)", "def hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(i, j, health):\n        if i < 0 or i >= m or j < 0 or j >= n or health <= 0:\n            return False\n        if i == m - 1 and j == n - 1:\n            return health >= 1\n        \n        original_health = health\n        health -= grid[i][j]\n        \n        # Mark the cell as visited by setting it to -1\n        grid[i][j] = -1\n        \n        # Explore all four directions\n        if dfs(i + 1, j, health) or dfs(i - 1, j, health) or dfs(i, j + 1, health) or dfs(i, j - 1, health):\n            return True\n        \n        # Unmark the cell\n        grid[i][j] = original_health\n        \n        return False\n    \n    return dfs(0, 0, health)", "def hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        if dfs(x + 1, y, health - grid[x][y]) or \\\n           dfs(x - 1, y, health - grid[x][y]) or \\\n           dfs(x, y + 1, health - grid[x][y]) or \\\n           dfs(x, y - 1, health - grid[x][y]):\n            return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)", "def can_reach_end(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n:\n            return False\n        if health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        if (dfs(x + 1, y, health - grid[x][y]) or\n            dfs(x - 1, y, health - grid[x][y]) or\n            dfs(x, y + 1, health - grid[x][y]) or\n            dfs(x, y - 1, health - grid[x][y])):\n            return True\n        grid[x][y] = 1  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)", "def hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        \n        grid[x][y] = 1  # Mark the cell as visited by setting it to 1\n        \n        if dfs(x + 1, y, health - 1) or dfs(x - 1, y, health - 1) or \\\n           dfs(x, y + 1, health - 1) or dfs(x, y - 1, health - 1):\n            return True\n        \n        grid[x][y] = 0  # Unmark the cell\n        \n        return False\n    \n    return dfs(0, 0, health)", "def can_reach_end(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = 2  # Mark as visited\n        paths = [\n            dfs(x + 1, y, health - 1),\n            dfs(x - 1, y, health - 1),\n            dfs(x, y + 1, health - 1),\n            dfs(x, y - 1, health - 1)\n        ]\n        grid[x][y] = 0  # Unmark\n        return any(paths)\n    \n    return dfs(0, 0, health)", "def can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    @lru_cache(None)\n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] += 1\n        result = any(dfs(dx, dy, health - grid[x][y]) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)])\n        grid[x][y] -= 1\n        return result\n    \n    return dfs(0, 0, health)", "def hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = 1  # Mark the cell as visited\n        if dfs(x + 1, y, health - grid[x][y]) or \\\n           dfs(x - 1, y, health - grid[x][y]) or \\\n           dfs(x, y + 1, health - grid[x][y]) or \\\n           dfs(x, y - 1, health - grid[x][y]):\n            return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)", "def can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        \n        # Mark the cell as visited by setting it to 2\n        original_value = grid[x][y]\n        grid[x][y] = 2\n        \n        # Explore all four directions\n        if dfs(x + 1, y, health - original_value) or \\\n           dfs(x - 1, y, health - original_value) or \\\n           dfs(x, y + 1, health - original_value) or \\\n           dfs(x, y - 1, health - original_value):\n            return True\n        \n        # Backtrack\n        grid[x][y] = original_value\n        return False\n    \n    return dfs(0, 0, health)", "def can_reach_end(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health > 0\n        \n        temp = grid[x][y]\n        grid[x][y] = -1  # Mark as visited\n        \n        if (dfs(x + 1, y, health - temp) or\n            dfs(x - 1, y, health - temp) or\n            dfs(x, y + 1, health - temp) or\n            dfs(x, y - 1, health - temp)):\n            return True\n        \n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)", "def canReach(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dx, dy in directions:\n            if dfs(x + dx, y + dy, health - grid[x + dx][y + dy]):\n                return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)", "def canReach(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1  # Mark the cell as visited\n        if dfs(x + 1, y, health - temp) or dfs(x - 1, y, health - temp) or dfs(x, y + 1, health - temp) or dfs(x, y - 1, health - temp):\n            return True\n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)", "def can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0, health)]\n    visited = set()\n    \n    while stack:\n        x, y, health = stack.pop()\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if health <= 0:\n            continue\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                stack.append((nx, ny, health - grid[nx][ny]))\n    \n    return False"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef hasPath(grid, health):\n    def dfs(x, y, health):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or health <= 0:\n            return False\n        if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1\n        result = dfs(x + 1, y, health - temp) or \\\n                 dfs(x - 1, y, health - temp) or \\\n                 dfs(x, y + 1, health - temp) or \\\n                 dfs(x, y - 1, health - temp)\n        grid[x][y] = temp\n        return result\n    \n    return dfs(0, 0, health)\n```", "```python\nfrom collections import deque\n\ndef can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    queue = deque([(0, 0, health)])\n    visited = set()\n    \n    while queue:\n        x, y, current_health = queue.popleft()\n        \n        if (x, y, current_health) in visited:\n            continue\n        visited.add((x, y, current_health))\n        \n        if x == m - 1 and y == n - 1:\n            return True\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                new_health = current_health - grid[nx][ny]\n                if new_health > 0:\n                    queue.append((nx, ny, new_health))\n    \n    return False\n```", "```python\ndef can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        if grid[x][y] == 1:\n            health -= 1\n        \n        # Mark the cell as visited\n        grid[x][y] = -1\n        \n        # Explore all four possible directions\n        if dfs(x + 1, y, health) or dfs(x - 1, y, health) or dfs(x, y + 1, health) or dfs(x, y - 1, health):\n            return True\n        \n        # Unmark the cell\n        grid[x][y] = 0\n        \n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1  # Mark as visited\n        if (dfs(x + 1, y, health - temp) or\n                dfs(x - 1, y, health - temp) or\n                dfs(x, y + 1, health - temp) or\n                dfs(x, y - 1, health - temp)):\n            return True\n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(i, j, health):\n        if i < 0 or i >= m or j < 0 or j >= n or health <= 0:\n            return False\n        if i == m - 1 and j == n - 1:\n            return health >= 1\n        \n        original_health = health\n        health -= grid[i][j]\n        \n        # Mark the cell as visited by setting it to -1\n        grid[i][j] = -1\n        \n        # Explore all four directions\n        if dfs(i + 1, j, health) or dfs(i - 1, j, health) or dfs(i, j + 1, health) or dfs(i, j - 1, health):\n            return True\n        \n        # Unmark the cell\n        grid[i][j] = original_health\n        \n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        if dfs(x + 1, y, health - grid[x][y]) or \\\n           dfs(x - 1, y, health - grid[x][y]) or \\\n           dfs(x, y + 1, health - grid[x][y]) or \\\n           dfs(x, y - 1, health - grid[x][y]):\n            return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef can_reach_end(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n:\n            return False\n        if health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        if (dfs(x + 1, y, health - grid[x][y]) or\n            dfs(x - 1, y, health - grid[x][y]) or\n            dfs(x, y + 1, health - grid[x][y]) or\n            dfs(x, y - 1, health - grid[x][y])):\n            return True\n        grid[x][y] = 1  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        \n        grid[x][y] = 1  # Mark the cell as visited by setting it to 1\n        \n        if dfs(x + 1, y, health - 1) or dfs(x - 1, y, health - 1) or \\\n           dfs(x, y + 1, health - 1) or dfs(x, y - 1, health - 1):\n            return True\n        \n        grid[x][y] = 0  # Unmark the cell\n        \n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef can_reach_end(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = 2  # Mark as visited\n        paths = [\n            dfs(x + 1, y, health - 1),\n            dfs(x - 1, y, health - 1),\n            dfs(x, y + 1, health - 1),\n            dfs(x, y - 1, health - 1)\n        ]\n        grid[x][y] = 0  # Unmark\n        return any(paths)\n    \n    return dfs(0, 0, health)\n```", "```python\ndef can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    @lru_cache(None)\n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] += 1\n        result = any(dfs(dx, dy, health - grid[x][y]) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)])\n        grid[x][y] -= 1\n        return result\n    \n    return dfs(0, 0, health)\n```", "```python\ndef hasPath(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = 1  # Mark the cell as visited\n        if dfs(x + 1, y, health - grid[x][y]) or \\\n           dfs(x - 1, y, health - grid[x][y]) or \\\n           dfs(x, y + 1, health - grid[x][y]) or \\\n           dfs(x, y - 1, health - grid[x][y]):\n            return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        \n        # Mark the cell as visited by setting it to 2\n        original_value = grid[x][y]\n        grid[x][y] = 2\n        \n        # Explore all four directions\n        if dfs(x + 1, y, health - original_value) or \\\n           dfs(x - 1, y, health - original_value) or \\\n           dfs(x, y + 1, health - original_value) or \\\n           dfs(x, y - 1, health - original_value):\n            return True\n        \n        # Backtrack\n        grid[x][y] = original_value\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef can_reach_end(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health > 0\n        \n        temp = grid[x][y]\n        grid[x][y] = -1  # Mark as visited\n        \n        if (dfs(x + 1, y, health - temp) or\n            dfs(x - 1, y, health - temp) or\n            dfs(x, y + 1, health - temp) or\n            dfs(x, y - 1, health - temp)):\n            return True\n        \n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef canReach(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dx, dy in directions:\n            if dfs(x + dx, y + dy, health - grid[x + dx][y + dy]):\n                return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef canReach(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        temp = grid[x][y]\n        grid[x][y] = -1  # Mark the cell as visited\n        if dfs(x + 1, y, health - temp) or dfs(x - 1, y, health - temp) or dfs(x, y + 1, health - temp) or dfs(x, y - 1, health - temp):\n            return True\n        grid[x][y] = temp  # Backtrack\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    stack = [(0, 0, health)]\n    visited = set()\n    \n    while stack:\n        x, y, health = stack.pop()\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if health <= 0:\n            continue\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                stack.append((nx, ny, health - grid[nx][ny]))\n    \n    return False\n```"]}
{"task_id": "3526", "codes": ["def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flips_for_column(col):\n        return sum(1 for j in range((m + 1) // 2) if grid[j][col] != grid[m - 1 - j][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_columns = sum(flips_for_column(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_columns)", "def min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_to_palindrome(arr):\n        return sum(arr[i] != arr[-i-1] for i in range((len(arr) + 1) // 2))\n    \n    row_flips = sum(flips_to_palindrome(row) for row in grid)\n    col_flips = sum(flips_to_palindrome([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(lst):\n        return sum(x != y for x, y in zip(lst, lst[::-1]))\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flip_count(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flip_count_col(col):\n        return sum(1 for i in range((m + 1) // 2) if grid[i][col] != grid[m - 1 - i][col])\n    \n    total_flip_rows = sum(flip_count(row) for row in grid)\n    total_flip_cols = sum(flip_count_col(col) for col in range(n))\n    \n    return min(total_flip_rows, total_flip_cols)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    # Function to calculate flips needed to make a list palindromic\n    def flips_needed(lst):\n        return sum(x != y for x, y in zip(lst, lst[::-1]))\n    \n    # Calculate flips needed for all rows\n    row_flips = sum(flips_needed(row) for row in grid)\n    \n    # Calculate flips needed for all columns\n    col_flips = sum(flips_needed([grid[i][j] for i in range(m)]) for j in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(x != arr[len(arr) - 1 - i] for i, x in enumerate(arr))\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flips_for_column(col):\n        return sum(1 for j in range((m + 1) // 2) if grid[j][col] != grid[m - 1 - j][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_columns = sum(flips_for_column(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_columns)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def count_flips_for_row(row):\n        return sum(1 for i in range(n // 2) if row[i] != row[n - 1 - i])\n    \n    def count_flips_for_col(col):\n        return sum(1 for i in range(m // 2) if grid[i][col] != grid[m - 1 - i][col])\n    \n    total_rows = sum(count_flips_for_row(row) for row in grid)\n    total_cols = sum(count_flips_for_col(col) for col in range(n))\n    \n    return min(total_rows, total_cols)", "def min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    # Function to count flips needed to make a list palindromic\n    def count_flips(lst):\n        return sum(x != y for x, y in zip(lst, lst[::-1]))\n    \n    # Count flips for all rows\n    row_flips = sum(count_flips(row) for row in grid)\n    \n    # Count flips for all columns\n    col_flips = sum(count_flips([grid[i][j] for i in range(m)]) for j in range(n))\n    \n    # Return the minimum of the two counts\n    return min(row_flips, col_flips)", "def minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_to_palindrome(row):\n        return sum(grid[row][i] != grid[row][n-1-i] for i in range(n // 2))\n    \n    def flips_to_palindrome_col(col):\n        return sum(grid[i][col] != grid[m-1-i][col] for i in range(m // 2))\n    \n    row_flips = sum(flips_to_palindrome(row) for row in range(m))\n    col_flips = sum(flips_to_palindrome_col(col) for col in range(n))\n    \n    return min(row_flips, col_flips)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(arr[i] != arr[-i-1] for i in range((len(arr) + 1) // 2))\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)"], "passed": [true, true, false, true, true, true, true, false, false, true, true, true, true, false, true, true], "raw_code": ["```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flips_for_column(col):\n        return sum(1 for j in range((m + 1) // 2) if grid[j][col] != grid[m - 1 - j][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_columns = sum(flips_for_column(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_columns)\n```", "```python\ndef min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_to_palindrome(arr):\n        return sum(arr[i] != arr[-i-1] for i in range((len(arr) + 1) // 2))\n    \n    row_flips = sum(flips_to_palindrome(row) for row in grid)\n    col_flips = sum(flips_to_palindrome([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(lst):\n        return sum(x != y for x, y in zip(lst, lst[::-1]))\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flip_count(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flip_count_col(col):\n        return sum(1 for i in range((m + 1) // 2) if grid[i][col] != grid[m - 1 - i][col])\n    \n    total_flip_rows = sum(flip_count(row) for row in grid)\n    total_flip_cols = sum(flip_count_col(col) for col in range(n))\n    \n    return min(total_flip_rows, total_flip_cols)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    # Function to calculate flips needed to make a list palindromic\n    def flips_needed(lst):\n        return sum(x != y for x, y in zip(lst, lst[::-1]))\n    \n    # Calculate flips needed for all rows\n    row_flips = sum(flips_needed(row) for row in grid)\n    \n    # Calculate flips needed for all columns\n    col_flips = sum(flips_needed([grid[i][j] for i in range(m)]) for j in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(x != arr[len(arr) - 1 - i] for i, x in enumerate(arr))\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flips_for_column(col):\n        return sum(1 for j in range((m + 1) // 2) if grid[j][col] != grid[m - 1 - j][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_columns = sum(flips_for_column(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_columns)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def count_flips_for_row(row):\n        return sum(1 for i in range(n // 2) if row[i] != row[n - 1 - i])\n    \n    def count_flips_for_col(col):\n        return sum(1 for i in range(m // 2) if grid[i][col] != grid[m - 1 - i][col])\n    \n    total_rows = sum(count_flips_for_row(row) for row in grid)\n    total_cols = sum(count_flips_for_col(col) for col in range(n))\n    \n    return min(total_rows, total_cols)\n```", "```python\ndef min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    # Function to count flips needed to make a list palindromic\n    def count_flips(lst):\n        return sum(x != y for x, y in zip(lst, lst[::-1]))\n    \n    # Count flips for all rows\n    row_flips = sum(count_flips(row) for row in grid)\n    \n    # Count flips for all columns\n    col_flips = sum(count_flips([grid[i][j] for i in range(m)]) for j in range(n))\n    \n    # Return the minimum of the two counts\n    return min(row_flips, col_flips)\n```", "```python\ndef minFlips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_to_palindrome(row):\n        return sum(grid[row][i] != grid[row][n-1-i] for i in range(n // 2))\n    \n    def flips_to_palindrome_col(col):\n        return sum(grid[i][col] != grid[m-1-i][col] for i in range(m // 2))\n    \n    row_flips = sum(flips_to_palindrome(row) for row in range(m))\n    col_flips = sum(flips_to_palindrome_col(col) for col in range(n))\n    \n    return min(row_flips, col_flips)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(arr[i] != arr[-i-1] for i in range((len(arr) + 1) // 2))\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```"]}
{"task_id": "3570", "codes": ["def count_substrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    # Iterate over all possible starting points of the substring\n    for i in range(n):\n        vowel_set = set()\n        consonant_count = 0\n        \n        # Iterate over all possible ending points of the substring\n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_set.add(char)\n            elif char.isalpha():\n                consonant_count += 1\n            \n            # Check if the current substring has all vowels and exactly k consonants\n            if len(vowel_set) == 5 and consonant_count == k:\n                count += 1\n    \n    return count", "def count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    \n    def has_all_vowels(substring):\n        return all(vowel in substring for vowel in vowels)\n    \n    def count_consonants(substring):\n        return sum(1 for char in substring if char not in vowels)\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 5, n + 1):  # Minimum length of substring is 5 (length of the shortest possible word)\n            substring = word[i:j]\n            if has_all_vowels(substring) and count_consonants(substring) == k:\n                count += 1\n                \n    return count", "def count_substrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    consonants = set('bcdfghjklmnpqrstvwxyz')\n    vowel_positions = {v: [] for v in vowels}\n    consonant_positions = {c: [] for c in consonants}\n    result = 0\n    start = 0\n    \n    for i, char in enumerate(word):\n        if char in vowels:\n            vowel_positions[char].append(i)\n            while len(vowel_positions[char]) > 1 and len(set(vowel_positions[char])) == 5:\n                start = vowel_positions[char].pop(0)\n            if len(vowel_positions[char]) == 5:\n                for c, pos in consonant_positions.items():\n                    if pos and pos[-1] < start:\n                        pos.pop()\n                if len([p for p in consonant_positions.values() if p]) == k:\n                    result += 1\n        elif char in consonants:\n            consonant_positions[char].append(i)\n            while len(consonant_positions[char]) > k + 1:\n                consonant_positions[char].pop(0)\n    \n    return result", "def countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        char_count = {}\n        vowel_count = 0\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count += 1\n            else:\n                consonant_count += 1\n            \n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n            \n            if vowel_count == 5 and consonant_count == k:\n                count += 1\n                \n                # Shrink the window from the left\n                while True:\n                    left_char = word[i]\n                    i += 1\n                    \n                    if left_char in vowels:\n                        vowel_count -= 1\n                    else:\n                        consonant_count -= 1\n                    \n                    char_count[left_char] -= 1\n                    if char_count[left_char] == 0:\n                        del char_count[left_char]\n                    \n                    if vowel_count == 5 and consonant_count == k:\n                        count += 1\n                    else:\n                        break\n    \n    return count", "def countSubstrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    vowel_count = [0] * (n + 1)\n    consonant_count = [0] * (n + 1)\n    \n    for i in range(n):\n        if word[i] in vowels:\n            vowel_count[i + 1] = vowel_count[i] + 1\n        else:\n            vowel_count[i + 1] = vowel_count[i]\n            consonant_count[i + 1] = consonant_count[i] + 1\n    \n    total_count = 0\n    \n    for end in range(5, n + 1):\n        for start in range(end - 5, end - k + 1):\n            if vowel_count[end] - vowel_count[start] == 5 and consonant_count[end] - consonant_count[start] == k:\n                total_count += 1\n    \n    return total_count", "def countSubstrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    \n    def has_all_vowels(counts):\n        return all(counts[vowel] > 0 for vowel in vowels)\n    \n    result = 0\n    left = 0\n    consonant_count = 0\n    vowel_counts = {vowel: 0 for vowel in vowels}\n    \n    for right in range(n):\n        char = word[right]\n        if char in vowels:\n            vowel_counts[char] += 1\n        else:\n            consonant_count += 1\n        \n        while left <= right and (consonant_count > k or not has_all_vowels(vowel_counts)):\n            left_char = word[left]\n            if left_char in vowels:\n                vowel_counts[left_char] -= 1\n            else:\n                consonant_count -= 1\n            left += 1\n        \n        if consonant_count == k and has_all_vowels(vowel_counts):\n            result += left\n    \n    return result", "def count_substrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        current_vowels = set()\n        \n        for j in range(i, n):\n            if word[j] in vowels:\n                vowel_count += 1\n                current_vowels.add(word[j])\n            else:\n                consonant_count += 1\n            \n            if len(current_vowels) == 5 and consonant_count == k:\n                count += 1\n    \n    return count", "def countSubstrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = [0] * 5\n        consonant_count = 0\n        \n        for j in range(i, n):\n            if word[j] in vowels:\n                vowel_count[vowels.index(word[j])] += 1\n            else:\n                consonant_count += 1\n            \n            if min(vowel_count) > 0 and consonant_count == k:\n                count += 1\n    \n    return count", "def countSubstrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    vowel_count = {v: 0 for v in vowels}\n    consonant_count = 0\n    left = 0\n    result = 0\n    \n    for right in range(len(word)):\n        if word[right] in vowels:\n            vowel_count[word[right]] += 1\n        elif word[right] != ' ':\n            consonant_count += 1\n        \n        while consonant_count > k:\n            if word[left] in vowels:\n                vowel_count[word[left]] -= 1\n            elif word[left] != ' ':\n                consonant_count -= 1\n            left += 1\n        \n        if consonant_count == k and all(count > 0 for count in vowel_count.values()):\n            result += left + 1\n    \n    return result", "def count_substrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = {}\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count[char] = vowel_count.get(char, 0) + 1\n                if len(vowel_count) == 5:\n                    while consonant_count > k:\n                        left_char = word[i]\n                        if left_char not in vowels:\n                            consonant_count -= 1\n                        i += 1\n                        if left_char in vowel_count:\n                            vowel_count[left_char] -= 1\n                            if vowel_count[left_char] == 0:\n                                del vowel_count[left_char]\n                    if consonant_count == k:\n                        count += 1\n            else:\n                consonant_count += 1\n    \n    return count", "def count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n\n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        char_count = {}\n\n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count += 1\n            else:\n                consonant_count += 1\n\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n\n            if vowel_count == 5 and consonant_count == k:\n                count += 1\n\n    return count", "def count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        vowel_set = set()\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count += 1\n                vowel_set.add(char)\n            else:\n                consonant_count += 1\n            \n            if vowel_count == 5 and consonant_count == k:\n                count += 1\n    \n    return count", "def count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for start in range(n):\n        char_count = {}\n        num_consonants = 0\n        \n        for end in range(start, n):\n            char = word[end]\n            if char in vowels:\n                char_count[char] = char_count.get(char, 0) + 1\n            else:\n                num_consonants += 1\n            \n            while num_consonants > k:\n                left_char = word[start]\n                if left_char in vowels:\n                    char_count[left_char] -= 1\n                    if char_count[left_char] == 0:\n                        del char_count[left_char]\n                else:\n                    num_consonants -= 1\n                start += 1\n            \n            if num_consonants == k and all(count > 0 for count in char_count.values()):\n                count += 1\n    \n    return count", "def countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    vowel_count = [0] * (n + 1)\n    \n    # Count the number of vowels up to each index\n    for i in range(n):\n        vowel_count[i + 1] = vowel_count[i] + (1 if word[i] in vowels else 0)\n    \n    if vowel_count[n] <= k:\n        return 0\n    \n    result = 0\n    left = 0\n    \n    for right in range(n):\n        # Adjust the left pointer to maintain exactly 5 vowels\n        while vowel_count[right + 1] - vowel_count[left] > 5:\n            left += 1\n        \n        # Check if the number of consonants is exactly k\n        if vowel_count[right + 1] - vowel_count[left] == 5 and (right - left + 1 - 5) == k:\n            result += 1\n    \n    return result", "def count_substrings_with_vowels_and_k_consonants(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    vowel_positions = [-1] * 5  # Positions of 'a', 'e', 'i', 'o', 'u'\n    consonant_count = 0\n    count = 0\n    \n    for i, char in enumerate(word):\n        if char in vowels:\n            vowel_positions[ord(char) - ord('a')] = i\n        if char not in vowels:\n            consonant_count += 1\n        \n        if i >= 5:\n            if all(pos != -1 for pos in vowel_positions):\n                if consonant_count == 5 + k:\n                    count += 1\n            if word[i - 5] not in vowels:\n                consonant_count -= 1\n            if word[i - 5] in vowels:\n                vowel_positions[ord(word[i - 5]) - ord('a')] = -1\n    \n    return count", "def count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    \n    def has_all_vowels(counts):\n        return all(counts[vowel] > 0 for vowel in vowels)\n    \n    count = 0\n    left = 0\n    consonant_count = 0\n    vowel_counts = {vowel: 0 for vowel in vowels}\n    \n    for right in range(n):\n        char = word[right]\n        if char in vowels:\n            vowel_counts[char] += 1\n        elif char.isalpha():\n            consonant_count += 1\n        \n        while has_all_vowels(vowel_counts) and consonant_count == k + 1:\n            count += n - right\n            char = word[left]\n            if char in vowels:\n                vowel_counts[char] -= 1\n            elif char.isalpha():\n                consonant_count -= 1\n            left += 1\n    \n    return count"], "passed": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef count_substrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    # Iterate over all possible starting points of the substring\n    for i in range(n):\n        vowel_set = set()\n        consonant_count = 0\n        \n        # Iterate over all possible ending points of the substring\n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_set.add(char)\n            elif char.isalpha():\n                consonant_count += 1\n            \n            # Check if the current substring has all vowels and exactly k consonants\n            if len(vowel_set) == 5 and consonant_count == k:\n                count += 1\n    \n    return count\n```", "```python\ndef count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    \n    def has_all_vowels(substring):\n        return all(vowel in substring for vowel in vowels)\n    \n    def count_consonants(substring):\n        return sum(1 for char in substring if char not in vowels)\n    \n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 5, n + 1):  # Minimum length of substring is 5 (length of the shortest possible word)\n            substring = word[i:j]\n            if has_all_vowels(substring) and count_consonants(substring) == k:\n                count += 1\n                \n    return count\n```", "```python\ndef count_substrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    consonants = set('bcdfghjklmnpqrstvwxyz')\n    vowel_positions = {v: [] for v in vowels}\n    consonant_positions = {c: [] for c in consonants}\n    result = 0\n    start = 0\n    \n    for i, char in enumerate(word):\n        if char in vowels:\n            vowel_positions[char].append(i)\n            while len(vowel_positions[char]) > 1 and len(set(vowel_positions[char])) == 5:\n                start = vowel_positions[char].pop(0)\n            if len(vowel_positions[char]) == 5:\n                for c, pos in consonant_positions.items():\n                    if pos and pos[-1] < start:\n                        pos.pop()\n                if len([p for p in consonant_positions.values() if p]) == k:\n                    result += 1\n        elif char in consonants:\n            consonant_positions[char].append(i)\n            while len(consonant_positions[char]) > k + 1:\n                consonant_positions[char].pop(0)\n    \n    return result\n```", "```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        char_count = {}\n        vowel_count = 0\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count += 1\n            else:\n                consonant_count += 1\n            \n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n            \n            if vowel_count == 5 and consonant_count == k:\n                count += 1\n                \n                # Shrink the window from the left\n                while True:\n                    left_char = word[i]\n                    i += 1\n                    \n                    if left_char in vowels:\n                        vowel_count -= 1\n                    else:\n                        consonant_count -= 1\n                    \n                    char_count[left_char] -= 1\n                    if char_count[left_char] == 0:\n                        del char_count[left_char]\n                    \n                    if vowel_count == 5 and consonant_count == k:\n                        count += 1\n                    else:\n                        break\n    \n    return count\n```", "```python\ndef countSubstrings(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    vowel_count = [0] * (n + 1)\n    consonant_count = [0] * (n + 1)\n    \n    for i in range(n):\n        if word[i] in vowels:\n            vowel_count[i + 1] = vowel_count[i] + 1\n        else:\n            vowel_count[i + 1] = vowel_count[i]\n            consonant_count[i + 1] = consonant_count[i] + 1\n    \n    total_count = 0\n    \n    for end in range(5, n + 1):\n        for start in range(end - 5, end - k + 1):\n            if vowel_count[end] - vowel_count[start] == 5 and consonant_count[end] - consonant_count[start] == k:\n                total_count += 1\n    \n    return total_count\n```", "```python\ndef countSubstrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    \n    def has_all_vowels(counts):\n        return all(counts[vowel] > 0 for vowel in vowels)\n    \n    result = 0\n    left = 0\n    consonant_count = 0\n    vowel_counts = {vowel: 0 for vowel in vowels}\n    \n    for right in range(n):\n        char = word[right]\n        if char in vowels:\n            vowel_counts[char] += 1\n        else:\n            consonant_count += 1\n        \n        while left <= right and (consonant_count > k or not has_all_vowels(vowel_counts)):\n            left_char = word[left]\n            if left_char in vowels:\n                vowel_counts[left_char] -= 1\n            else:\n                consonant_count -= 1\n            left += 1\n        \n        if consonant_count == k and has_all_vowels(vowel_counts):\n            result += left\n    \n    return result\n```", "```python\ndef count_substrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        current_vowels = set()\n        \n        for j in range(i, n):\n            if word[j] in vowels:\n                vowel_count += 1\n                current_vowels.add(word[j])\n            else:\n                consonant_count += 1\n            \n            if len(current_vowels) == 5 and consonant_count == k:\n                count += 1\n    \n    return count\n```", "```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = [0] * 5\n        consonant_count = 0\n        \n        for j in range(i, n):\n            if word[j] in vowels:\n                vowel_count[vowels.index(word[j])] += 1\n            else:\n                consonant_count += 1\n            \n            if min(vowel_count) > 0 and consonant_count == k:\n                count += 1\n    \n    return count\n```", "```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    vowel_count = {v: 0 for v in vowels}\n    consonant_count = 0\n    left = 0\n    result = 0\n    \n    for right in range(len(word)):\n        if word[right] in vowels:\n            vowel_count[word[right]] += 1\n        elif word[right] != ' ':\n            consonant_count += 1\n        \n        while consonant_count > k:\n            if word[left] in vowels:\n                vowel_count[word[left]] -= 1\n            elif word[left] != ' ':\n                consonant_count -= 1\n            left += 1\n        \n        if consonant_count == k and all(count > 0 for count in vowel_count.values()):\n            result += left + 1\n    \n    return result\n```", "```python\ndef count_substrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = {}\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count[char] = vowel_count.get(char, 0) + 1\n                if len(vowel_count) == 5:\n                    while consonant_count > k:\n                        left_char = word[i]\n                        if left_char not in vowels:\n                            consonant_count -= 1\n                        i += 1\n                        if left_char in vowel_count:\n                            vowel_count[left_char] -= 1\n                            if vowel_count[left_char] == 0:\n                                del vowel_count[left_char]\n                    if consonant_count == k:\n                        count += 1\n            else:\n                consonant_count += 1\n    \n    return count\n```", "```python\ndef count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n\n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        char_count = {}\n\n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count += 1\n            else:\n                consonant_count += 1\n\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n\n            if vowel_count == 5 and consonant_count == k:\n                count += 1\n\n    return count\n```", "```python\ndef count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        vowel_set = set()\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count += 1\n                vowel_set.add(char)\n            else:\n                consonant_count += 1\n            \n            if vowel_count == 5 and consonant_count == k:\n                count += 1\n    \n    return count\n```", "```python\ndef count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    for start in range(n):\n        char_count = {}\n        num_consonants = 0\n        \n        for end in range(start, n):\n            char = word[end]\n            if char in vowels:\n                char_count[char] = char_count.get(char, 0) + 1\n            else:\n                num_consonants += 1\n            \n            while num_consonants > k:\n                left_char = word[start]\n                if left_char in vowels:\n                    char_count[left_char] -= 1\n                    if char_count[left_char] == 0:\n                        del char_count[left_char]\n                else:\n                    num_consonants -= 1\n                start += 1\n            \n            if num_consonants == k and all(count > 0 for count in char_count.values()):\n                count += 1\n    \n    return count\n```", "```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    vowel_count = [0] * (n + 1)\n    \n    # Count the number of vowels up to each index\n    for i in range(n):\n        vowel_count[i + 1] = vowel_count[i] + (1 if word[i] in vowels else 0)\n    \n    if vowel_count[n] <= k:\n        return 0\n    \n    result = 0\n    left = 0\n    \n    for right in range(n):\n        # Adjust the left pointer to maintain exactly 5 vowels\n        while vowel_count[right + 1] - vowel_count[left] > 5:\n            left += 1\n        \n        # Check if the number of consonants is exactly k\n        if vowel_count[right + 1] - vowel_count[left] == 5 and (right - left + 1 - 5) == k:\n            result += 1\n    \n    return result\n```", "```python\ndef count_substrings_with_vowels_and_k_consonants(word, k):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    n = len(word)\n    vowel_positions = [-1] * 5  # Positions of 'a', 'e', 'i', 'o', 'u'\n    consonant_count = 0\n    count = 0\n    \n    for i, char in enumerate(word):\n        if char in vowels:\n            vowel_positions[ord(char) - ord('a')] = i\n        if char not in vowels:\n            consonant_count += 1\n        \n        if i >= 5:\n            if all(pos != -1 for pos in vowel_positions):\n                if consonant_count == 5 + k:\n                    count += 1\n            if word[i - 5] not in vowels:\n                consonant_count -= 1\n            if word[i - 5] in vowels:\n                vowel_positions[ord(word[i - 5]) - ord('a')] = -1\n    \n    return count\n```", "```python\ndef count_substrings(word, k):\n    vowels = set('aeiou')\n    n = len(word)\n    \n    def has_all_vowels(counts):\n        return all(counts[vowel] > 0 for vowel in vowels)\n    \n    count = 0\n    left = 0\n    consonant_count = 0\n    vowel_counts = {vowel: 0 for vowel in vowels}\n    \n    for right in range(n):\n        char = word[right]\n        if char in vowels:\n            vowel_counts[char] += 1\n        elif char.isalpha():\n            consonant_count += 1\n        \n        while has_all_vowels(vowel_counts) and consonant_count == k + 1:\n            count += n - right\n            char = word[left]\n            if char in vowels:\n                vowel_counts[char] -= 1\n            elif char.isalpha():\n                consonant_count -= 1\n            left += 1\n    \n    return count\n```"]}
