"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.7, \"n\": 8, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_vanilla_bug_trace_TPL_NEXT_qwen_7b_hard_n_8.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42}"
{"task_id": "3563", "codes": ["def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score", "def max_score(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Select the first element from each row and sum them\n    max_sum = sum(row[0] for row in grid)\n    \n    return max_sum", "def maxSum(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    # Initialize DP table\n    dp = [0] * (1 << m)\n    \n    for mask in range(1 << m):\n        count_ones = bin(mask).count('1')\n        if count_ones > n:\n            continue\n        \n        for j in range(m):\n            if mask & (1 << j):\n                prev_mask = mask ^ (1 << j)\n                dp[mask] = max(dp[mask], dp[prev_mask] + grid[count_ones - 1][j])\n    \n    return max(dp)", "def maxScore(grid):\n    for row in grid:\n        row.sort()\n    selected_values = set()\n    max_score = 0\n    for row in grid:\n        for value in row[::-1]:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    return max_score", "def maxScore(grid):\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each column from right to left\n    for j in range(m-1, -1, -1):\n        for i in range(n):\n            if grid[i][j] not in selected_values:\n                selected_values.add(grid[i][j])\n                max_score += grid[i][j]\n                break\n    \n    return max_score", "def maxScore(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each column\n    for col in range(cols):\n        for row in range(rows):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score", "def maxScore(grid):\n    for row in grid:\n        row.sort()\n    selected_columns = set()\n    score = 0\n    for row in grid:\n        for j in range(len(row) - 1, -1, -1):\n            if j not in selected_columns:\n                score += row[j]\n                selected_columns.add(j)\n                break\n    return score", "def maxScore(grid):\n    for row in grid:\n        row.sort()\n    selected = set()\n    score = 0\n    for row in grid:\n        for value in row[::-1]:\n            if value not in selected:\n                selected.add(value)\n                score += value\n                break\n    return score"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    \n    return max_score\n```", "```python\ndef max_score(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Select the first element from each row and sum them\n    max_sum = sum(row[0] for row in grid)\n    \n    return max_sum\n```", "```python\ndef maxSum(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row in ascending order\n    for i in range(n):\n        grid[i].sort()\n    \n    # Initialize DP table\n    dp = [0] * (1 << m)\n    \n    for mask in range(1 << m):\n        count_ones = bin(mask).count('1')\n        if count_ones > n:\n            continue\n        \n        for j in range(m):\n            if mask & (1 << j):\n                prev_mask = mask ^ (1 << j)\n                dp[mask] = max(dp[mask], dp[prev_mask] + grid[count_ones - 1][j])\n    \n    return max(dp)\n```", "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort()\n    selected_values = set()\n    max_score = 0\n    for row in grid:\n        for value in row[::-1]:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_score += value\n                break\n    return max_score\n```", "```python\ndef maxScore(grid):\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each column from right to left\n    for j in range(m-1, -1, -1):\n        for i in range(n):\n            if grid[i][j] not in selected_values:\n                selected_values.add(grid[i][j])\n                max_score += grid[i][j]\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Sort each row in ascending order\n    for row in grid:\n        row.sort()\n    \n    selected_values = set()\n    max_score = 0\n    \n    # Iterate through each column\n    for col in range(cols):\n        for row in range(rows):\n            if grid[row][col] not in selected_values:\n                selected_values.add(grid[row][col])\n                max_score += grid[row][col]\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort()\n    selected_columns = set()\n    score = 0\n    for row in grid:\n        for j in range(len(row) - 1, -1, -1):\n            if j not in selected_columns:\n                score += row[j]\n                selected_columns.add(j)\n                break\n    return score\n```", "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort()\n    selected = set()\n    score = 0\n    for row in grid:\n        for value in row[::-1]:\n            if value not in selected:\n                selected.add(value)\n                score += value\n                break\n    return score\n```"]}
{"task_id": "3531", "codes": ["def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict on Bob\n    total_damage = [d * h for d, h in zip(damage, health)]\n    \n    # Sort enemies by health in descending order\n    enemies = sorted(zip(health, damage, total_damage), reverse=True)\n    \n    bob_damage = 0\n    for h, d, td in enemies:\n        if h > 0:\n            # Calculate the number of full attacks needed to kill the enemy\n            full_attacks = (h - 1) // power + 1\n            # Add the damage taken during these attacks to Bob's total damage\n            bob_damage += full_attacks * d\n    \n    return bob_damage", "def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time each enemy takes to die without any attacks\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    # Sort enemies by their health-to-damage ratio in descending order\n    sorted_indices = sorted(range(n), key=lambda x: times_to_die[x], reverse=True)\n    \n    total_damage = 0\n    remaining_health = health[:]\n    for idx in sorted_indices:\n        t = times_to_die[idx]\n        if t > 0:\n            rounds_needed = int(t) + (1 if t % 1 != 0 else 0)\n            if rounds_needed * power >= remaining_health[idx]:\n                total_damage += remaining_health[idx]\n                remaining_health[idx] = 0\n            else:\n                total_damage += rounds_needed * power\n                remaining_health[idx] -= rounds_needed * power\n    \n    return total_damage", "def minDamage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies based on the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for _, d, h in sorted_enemies:\n        if h > 0:\n            # Calculate the number of seconds to kill the current enemy\n            seconds_needed = h / d\n            \n            # Calculate the damage Bob takes during this time\n            if seconds_needed <= 1:\n                total_damage += d\n            else:\n                full_seconds = int(seconds_needed // 1)\n                remaining_damage = seconds_needed % 1 * d\n                total_damage += full_seconds * power + max(0, remaining_damage - power)\n            \n            # Update the current time\n            current_time += seconds_needed\n    \n    return total_damage", "def min_damage(power: int, damage: List[int], health: List[int]) -> int:\n    n = len(damage)\n    # Calculate the total damage each enemy would deal over its lifetime\n    total_damage = [d * h for d, h in zip(damage, health)]\n    \n    # Sort enemies based on their remaining health\n    sorted_enemies = sorted(range(n), key=lambda x: health[x])\n    \n    total_bob_damage = 0\n    time_passed = 0\n    \n    for enemy in sorted_enemies:\n        current_health = health[enemy]\n        if current_health > 0:\n            # Calculate the number of full attacks needed to defeat the enemy\n            full_attacks = -(-current_health // power)  # Equivalent to ceil(current_health / power)\n            time_passed += full_attacks\n            total_bob_damage += full_attacks * power\n    \n    return total_bob_damage", "def min_damage(power, damage, health):\n    n = len(damage)\n    total_damage = 0\n    \n    # Calculate the initial damage dealt by Bob in one second to each enemy\n    for d, h in zip(damage, health):\n        if d >= power:\n            total_damage += h // d * power\n            if h % d != 0:\n                total_damage += power\n        else:\n            total_damage += h\n    \n    return total_damage", "def min_damage(power, damage, health):\n    import math\n    \n    # Calculate the time it will take to kill each enemy\n    time_to_kill = [math.ceil(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies based on the time it will take to kill them\n    sorted_enemies = sorted(zip(time_to_kill, damage, health))\n    \n    total_damage = 0\n    for time, d, h in sorted_enemies:\n        # Calculate the number of attacks needed to kill the enemy\n        attacks = time\n        # Calculate the damage Bob will take\n        total_damage += attacks * power\n    \n    return total_damage", "def min_damage(power: int, damage: List[int], health: List[int]) -> int:\n    # Calculate the health-to-damage ratio for each enemy\n    ratios = [(h / d, d, h) for d, h in zip(damage, health)]\n    \n    # Sort the enemies based on the health-to-damage ratio\n    ratios.sort()\n    \n    total_damage = 0\n    current_time = 0\n    \n    # Simulate the attacks\n    for ratio, d, h in ratios:\n        if h > 0:\n            # Calculate the number of seconds needed to defeat the enemy\n            seconds_needed = -(-h // power)  # Equivalent to math.ceil(h / power)\n            \n            # Update the total damage dealt to Bob\n            total_damage += d * seconds_needed\n            \n            # Update the current time\n            current_time += seconds_needed\n    \n    return total_damage", "def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time it takes for each enemy to die\n    time_to_die = [(health[i] - 1) // damage[i] for i in range(n)]\n    \n    # Sort enemies by their time to die\n    sorted_enemies = sorted(range(n), key=lambda x: time_to_die[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for enemy in sorted_enemies:\n        # Calculate the remaining health of the enemy\n        remaining_health = health[enemy] - current_time * damage[enemy]\n        if remaining_health > 0:\n            # Calculate the number of attacks needed to kill the enemy\n            attacks_needed = (remaining_health - 1) // power + 1\n            total_damage += attacks_needed * power\n            current_time += attacks_needed * power // damage[enemy]\n    \n    return total_damage"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the total damage each enemy can inflict on Bob\n    total_damage = [d * h for d, h in zip(damage, health)]\n    \n    # Sort enemies by health in descending order\n    enemies = sorted(zip(health, damage, total_damage), reverse=True)\n    \n    bob_damage = 0\n    for h, d, td in enemies:\n        if h > 0:\n            # Calculate the number of full attacks needed to kill the enemy\n            full_attacks = (h - 1) // power + 1\n            # Add the damage taken during these attacks to Bob's total damage\n            bob_damage += full_attacks * d\n    \n    return bob_damage\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time each enemy takes to die without any attacks\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    # Sort enemies by their health-to-damage ratio in descending order\n    sorted_indices = sorted(range(n), key=lambda x: times_to_die[x], reverse=True)\n    \n    total_damage = 0\n    remaining_health = health[:]\n    for idx in sorted_indices:\n        t = times_to_die[idx]\n        if t > 0:\n            rounds_needed = int(t) + (1 if t % 1 != 0 else 0)\n            if rounds_needed * power >= remaining_health[idx]:\n                total_damage += remaining_health[idx]\n                remaining_health[idx] = 0\n            else:\n                total_damage += rounds_needed * power\n                remaining_health[idx] -= rounds_needed * power\n    \n    return total_damage\n```", "```python\ndef minDamage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies based on the time it takes for them to die in descending order\n    sorted_enemies = sorted(zip(times_to_die, damage, health), reverse=True)\n    \n    total_damage = 0\n    current_time = 0\n    \n    for _, d, h in sorted_enemies:\n        if h > 0:\n            # Calculate the number of seconds to kill the current enemy\n            seconds_needed = h / d\n            \n            # Calculate the damage Bob takes during this time\n            if seconds_needed <= 1:\n                total_damage += d\n            else:\n                full_seconds = int(seconds_needed // 1)\n                remaining_damage = seconds_needed % 1 * d\n                total_damage += full_seconds * power + max(0, remaining_damage - power)\n            \n            # Update the current time\n            current_time += seconds_needed\n    \n    return total_damage\n```", "```python\ndef min_damage(power: int, damage: List[int], health: List[int]) -> int:\n    n = len(damage)\n    # Calculate the total damage each enemy would deal over its lifetime\n    total_damage = [d * h for d, h in zip(damage, health)]\n    \n    # Sort enemies based on their remaining health\n    sorted_enemies = sorted(range(n), key=lambda x: health[x])\n    \n    total_bob_damage = 0\n    time_passed = 0\n    \n    for enemy in sorted_enemies:\n        current_health = health[enemy]\n        if current_health > 0:\n            # Calculate the number of full attacks needed to defeat the enemy\n            full_attacks = -(-current_health // power)  # Equivalent to ceil(current_health / power)\n            time_passed += full_attacks\n            total_bob_damage += full_attacks * power\n    \n    return total_bob_damage\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    total_damage = 0\n    \n    # Calculate the initial damage dealt by Bob in one second to each enemy\n    for d, h in zip(damage, health):\n        if d >= power:\n            total_damage += h // d * power\n            if h % d != 0:\n                total_damage += power\n        else:\n            total_damage += h\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    import math\n    \n    # Calculate the time it will take to kill each enemy\n    time_to_kill = [math.ceil(h / d) for h, d in zip(health, damage)]\n    \n    # Sort enemies based on the time it will take to kill them\n    sorted_enemies = sorted(zip(time_to_kill, damage, health))\n    \n    total_damage = 0\n    for time, d, h in sorted_enemies:\n        # Calculate the number of attacks needed to kill the enemy\n        attacks = time\n        # Calculate the damage Bob will take\n        total_damage += attacks * power\n    \n    return total_damage\n```", "```python\ndef min_damage(power: int, damage: List[int], health: List[int]) -> int:\n    # Calculate the health-to-damage ratio for each enemy\n    ratios = [(h / d, d, h) for d, h in zip(damage, health)]\n    \n    # Sort the enemies based on the health-to-damage ratio\n    ratios.sort()\n    \n    total_damage = 0\n    current_time = 0\n    \n    # Simulate the attacks\n    for ratio, d, h in ratios:\n        if h > 0:\n            # Calculate the number of seconds needed to defeat the enemy\n            seconds_needed = -(-h // power)  # Equivalent to math.ceil(h / power)\n            \n            # Update the total damage dealt to Bob\n            total_damage += d * seconds_needed\n            \n            # Update the current time\n            current_time += seconds_needed\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the time it takes for each enemy to die\n    time_to_die = [(health[i] - 1) // damage[i] for i in range(n)]\n    \n    # Sort enemies by their time to die\n    sorted_enemies = sorted(range(n), key=lambda x: time_to_die[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for enemy in sorted_enemies:\n        # Calculate the remaining health of the enemy\n        remaining_health = health[enemy] - current_time * damage[enemy]\n        if remaining_health > 0:\n            # Calculate the number of attacks needed to kill the enemy\n            attacks_needed = (remaining_health - 1) // power + 1\n            total_damage += attacks_needed * power\n            current_time += attacks_needed * power // damage[enemy]\n    \n    return total_damage\n```"]}
{"task_id": "3550", "codes": ["def maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Find the row with the highest value\n    max_row_value = -float('inf')\n    max_row_index = -1\n    for i in range(m):\n        row_sum = sum(board[i])\n        if row_sum > max_row_value:\n            max_row_value = row_sum\n            max_row_index = i\n    \n    # Remove the chosen row from consideration\n    remaining_board = [row for row in board[:max_row_index] + board[max_row_index+1:]]\n    \n    # Find the column with the highest value in the remaining board\n    max_col_value = -float('inf')\n    max_col_index = -1\n    for j in range(n):\n        col_sum = sum(remaining_board[row][j] for row in range(m-1))\n        if col_sum > max_col_value:\n            max_col_value = col_sum\n            max_col_index = j\n    \n    # The third rook must be placed in the remaining row and column\n    third_rook_value = remaining_board[max_row_index][max_col_index]\n    \n    # Calculate the total sum\n    return max_row_value + max_col_value + third_rook_value", "def max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Find rows and columns with exactly one non-zero cell\n    valid_rows = [i for i, total in enumerate(row_sums) if total > 0]\n    valid_cols = [j for j, total in enumerate(col_sums) if total > 0]\n    \n    # Ensure we have exactly three valid positions\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return 0\n    \n    # Place rooks in the first three valid positions\n    rook_positions = [(valid_rows.pop(0), valid_cols.pop(0)) for _ in range(3)]\n    \n    # Calculate the sum of the cell values at these positions\n    max_sum = sum(board[row][col] for row, col in rook_positions)\n    \n    return max_sum", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Find rows and columns with exactly one non-zero value\n    valid_rows = [i for i, s in enumerate(row_sums) if s != 0 and sum(1 for val in board[i] if val != 0) == 1]\n    valid_cols = [j for j, s in enumerate(col_sums) if s != 0 and sum(1 for val in board[row][j] for row in range(m)) == 1]\n    \n    # Calculate the maximum sum of the cell values where the rooks are placed\n    max_sum = 0\n    for r in valid_rows:\n        for c in valid_cols:\n            max_sum += board[r][c]\n    \n    return max_sum", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find the maximum value in each row and its index\n    row_max_values = [max(row) for row in board]\n    row_indices = [row.index(max_val) for row, max_val in zip(board, row_max_values)]\n    \n    # Find the maximum value in each column and its index\n    col_max_values = [max(col) for col in zip(*board)]\n    col_indices = [col.index(max_val) for col, max_val in zip(zip(*board), col_max_values)]\n    \n    # Check if the chosen cells are unique\n    if len(set(row_indices)) != 3 or len(set(col_indices)) != 3:\n        return -1\n    \n    # Calculate the sum of the chosen cells\n    max_sum = sum(board[row_indices[i]][col_indices[i]] for i in range(3))\n    \n    return max_sum", "def max_sum_of_rooks(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Calculate the sum of values for each row\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate the sum of values for each column\n    col_sums = [sum(board[row][col] for row in range(rows)) for col in range(cols)]\n    \n    # Sort the row sums and column sums in descending order\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    # Select the top three largest sums (one from rows and two from columns)\n    max_sum = row_sums[0] + col_sums[0] + col_sums[1]\n    \n    return max_sum", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows with exactly one non-zero value\n    valid_rows = []\n    for i in range(m):\n        count = 0\n        index = -1\n        for j in range(n):\n            if board[i][j] != 0:\n                count += 1\n                index = j\n        if count == 1:\n            valid_rows.append((i, index))\n    \n    # Find columns with exactly one non-zero value\n    valid_cols = []\n    for j in range(n):\n        count = 0\n        index = -1\n        for i in range(m):\n            if board[i][j] != 0:\n                count += 1\n                index = i\n        if count == 1:\n            valid_cols.append((index, j))\n    \n    # Sort valid rows and columns by their values in descending order\n    valid_rows.sort(key=lambda x: board[x[0]][x[1]], reverse=True)\n    valid_cols.sort(key=lambda x: board[x[0]][x[1]], reverse=True)\n    \n    # Select the top 3 rows and columns\n    selected_rows = valid_rows[:3]\n    selected_cols = valid_cols[:3]\n    \n    # Calculate the sum of the selected cells\n    total_sum = 0\n    for r, c in selected_rows:\n        for sr, sc in selected_cols:\n            if r == sr and c == sc:\n                total_sum += board[r][c]\n    \n    return total_sum", "def max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    max_sum = float('-inf')\n    \n    for i in range(m):\n        if row_sums[i] > 0:\n            for j in range(n):\n                if col_sums[j] > 0:\n                    # Ensure no two rooks are in the same row or column\n                    if i != j:\n                        max_sum = max(max_sum, board[i][j] + row_sums[i] - board[i][i] + col_sums[j] - board[j][j])\n    \n    return max_sum", "def maxRooksSum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(board[i]) for i in range(m)]\n    col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n    \n    # Sort rows and columns by their sums in descending order\n    sorted_rows = sorted(range(m), key=lambda x: row_sums[x], reverse=True)\n    sorted_cols = sorted(range(n), key=lambda y: col_sums[y], reverse=True)\n    \n    # Select the top 3 rows and columns\n    top_3_rows = sorted_rows[:3]\n    top_3_cols = sorted_cols[:3]\n    \n    # Calculate the maximum sum\n    max_sum = sum(board[i][j] for i in top_3_rows for j in top_3_cols)\n    \n    return max_sum"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    \n    # Find the row with the highest value\n    max_row_value = -float('inf')\n    max_row_index = -1\n    for i in range(m):\n        row_sum = sum(board[i])\n        if row_sum > max_row_value:\n            max_row_value = row_sum\n            max_row_index = i\n    \n    # Remove the chosen row from consideration\n    remaining_board = [row for row in board[:max_row_index] + board[max_row_index+1:]]\n    \n    # Find the column with the highest value in the remaining board\n    max_col_value = -float('inf')\n    max_col_index = -1\n    for j in range(n):\n        col_sum = sum(remaining_board[row][j] for row in range(m-1))\n        if col_sum > max_col_value:\n            max_col_value = col_sum\n            max_col_index = j\n    \n    # The third rook must be placed in the remaining row and column\n    third_rook_value = remaining_board[max_row_index][max_col_index]\n    \n    # Calculate the total sum\n    return max_row_value + max_col_value + third_rook_value\n```", "```python\ndef max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Find rows and columns with exactly one non-zero cell\n    valid_rows = [i for i, total in enumerate(row_sums) if total > 0]\n    valid_cols = [j for j, total in enumerate(col_sums) if total > 0]\n    \n    # Ensure we have exactly three valid positions\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return 0\n    \n    # Place rooks in the first three valid positions\n    rook_positions = [(valid_rows.pop(0), valid_cols.pop(0)) for _ in range(3)]\n    \n    # Calculate the sum of the cell values at these positions\n    max_sum = sum(board[row][col] for row, col in rook_positions)\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Find rows and columns with exactly one non-zero value\n    valid_rows = [i for i, s in enumerate(row_sums) if s != 0 and sum(1 for val in board[i] if val != 0) == 1]\n    valid_cols = [j for j, s in enumerate(col_sums) if s != 0 and sum(1 for val in board[row][j] for row in range(m)) == 1]\n    \n    # Calculate the maximum sum of the cell values where the rooks are placed\n    max_sum = 0\n    for r in valid_rows:\n        for c in valid_cols:\n            max_sum += board[r][c]\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find the maximum value in each row and its index\n    row_max_values = [max(row) for row in board]\n    row_indices = [row.index(max_val) for row, max_val in zip(board, row_max_values)]\n    \n    # Find the maximum value in each column and its index\n    col_max_values = [max(col) for col in zip(*board)]\n    col_indices = [col.index(max_val) for col, max_val in zip(zip(*board), col_max_values)]\n    \n    # Check if the chosen cells are unique\n    if len(set(row_indices)) != 3 or len(set(col_indices)) != 3:\n        return -1\n    \n    # Calculate the sum of the chosen cells\n    max_sum = sum(board[row_indices[i]][col_indices[i]] for i in range(3))\n    \n    return max_sum\n```", "```python\ndef max_sum_of_rooks(board):\n    rows = len(board)\n    cols = len(board[0])\n    \n    # Calculate the sum of values for each row\n    row_sums = [sum(row) for row in board]\n    \n    # Calculate the sum of values for each column\n    col_sums = [sum(board[row][col] for row in range(rows)) for col in range(cols)]\n    \n    # Sort the row sums and column sums in descending order\n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    # Select the top three largest sums (one from rows and two from columns)\n    max_sum = row_sums[0] + col_sums[0] + col_sums[1]\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows with exactly one non-zero value\n    valid_rows = []\n    for i in range(m):\n        count = 0\n        index = -1\n        for j in range(n):\n            if board[i][j] != 0:\n                count += 1\n                index = j\n        if count == 1:\n            valid_rows.append((i, index))\n    \n    # Find columns with exactly one non-zero value\n    valid_cols = []\n    for j in range(n):\n        count = 0\n        index = -1\n        for i in range(m):\n            if board[i][j] != 0:\n                count += 1\n                index = i\n        if count == 1:\n            valid_cols.append((index, j))\n    \n    # Sort valid rows and columns by their values in descending order\n    valid_rows.sort(key=lambda x: board[x[0]][x[1]], reverse=True)\n    valid_cols.sort(key=lambda x: board[x[0]][x[1]], reverse=True)\n    \n    # Select the top 3 rows and columns\n    selected_rows = valid_rows[:3]\n    selected_cols = valid_cols[:3]\n    \n    # Calculate the sum of the selected cells\n    total_sum = 0\n    for r, c in selected_rows:\n        for sr, sc in selected_cols:\n            if r == sr and c == sc:\n                total_sum += board[r][c]\n    \n    return total_sum\n```", "```python\ndef max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    max_sum = float('-inf')\n    \n    for i in range(m):\n        if row_sums[i] > 0:\n            for j in range(n):\n                if col_sums[j] > 0:\n                    # Ensure no two rooks are in the same row or column\n                    if i != j:\n                        max_sum = max(max_sum, board[i][j] + row_sums[i] - board[i][i] + col_sums[j] - board[j][j])\n    \n    return max_sum\n```", "```python\ndef maxRooksSum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(board[i]) for i in range(m)]\n    col_sums = [sum(board[i][j] for i in range(m)) for j in range(n)]\n    \n    # Sort rows and columns by their sums in descending order\n    sorted_rows = sorted(range(m), key=lambda x: row_sums[x], reverse=True)\n    sorted_cols = sorted(range(n), key=lambda y: col_sums[y], reverse=True)\n    \n    # Select the top 3 rows and columns\n    top_3_rows = sorted_rows[:3]\n    top_3_cols = sorted_cols[:3]\n    \n    # Calculate the maximum sum\n    max_sum = sum(board[i][j] for i in top_3_rows for j in top_3_cols)\n    \n    return max_sum\n```"]}
{"task_id": "3583", "codes": ["def getGCD(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef processQueries(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    gcd_counts = [0] * (max_val + 1)\n    \n    # Count occurrences of each gcd value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            gcd_counts[gcd_val] += 1\n    \n    # Prefix sum to get cumulative counts\n    prefix_sum = [0] * (max_val + 1)\n    for i in range(1, max_val + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + gcd_counts[i]\n    \n    # Process each query\n    result = []\n    for q in queries:\n        result.append(prefix_sum[-1] - prefix_sum[q])\n    \n    return result", "def getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    max_val = max(nums)\n    gcd_freq = {}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in gcd_freq:\n                gcd_freq[gcd_val] = 0\n            gcd_freq[gcd_val] += 1\n    \n    sorted_gcds = sorted(gcd_freq.keys())\n    prefix_sum = [0]\n    current_sum = 0\n    \n    for gcd_val in sorted_gcds:\n        current_sum += gcd_freq[gcd_val]\n        prefix_sum.append(current_sum)\n    \n    result = []\n    for query in queries:\n        idx = bisect.bisect_right(prefix_sum, query + 1) - 1\n        result.append(sorted_gcds[idx])\n    \n    return result", "def gcd_pairs(nums, queries):\n    max_val = max(nums)\n    gcd_count = {}\n    \n    # Function to add GCD counts\n    def add_gcd(a, b):\n        if a > b:\n            a, b = b, a\n        if a not in gcd_count:\n            gcd_count[a] = 0\n        gcd_count[a] += 1\n    \n    # Populate gcd_count with all possible GCDs\n    for num in nums:\n        for i in range(1, num + 1):\n            if num % i == 0:\n                add_gcd(i, num // i)\n    \n    # Extract sorted unique GCDs\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Answer each query\n    answer = []\n    for q in queries:\n        idx = sum(gcd_count[g] for g in sorted_gcds[:q])\n        answer.append(sorted_gcds[idx])\n    \n    return answer", "from math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    def get_gcd(x, y):\n        return gcd(x, y)\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count the frequency of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = get_gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    # Extract unique GCD values and sort them by frequency and value\n    gcd_values = sorted(gcd_count.items(), key=lambda x: (x[1], x[0]))\n    \n    # Function to get the GCD at the specified index\n    def get_value(index):\n        current_index = 0\n        for g, freq in gcd_values:\n            if current_index + freq > index:\n                return g\n            current_index += freq\n    \n    # Process each query\n    result = [get_value(q) for q in queries]\n    \n    return result", "def getGCDs(nums):\n    n = len(nums)\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                for other_num in nums:\n                    if other_num % d == 0:\n                        count[d] += 1\n    \n    gcds = []\n    for i in range(1, max_val + 1):\n        if count[i] > 0:\n            gcds.extend([i] * count[i])\n    \n    gcds.sort()\n    return gcds\n\ndef answerQueries(nums, queries):\n    gcds = getGCDs(nums)\n    result = []\n    for q in queries:\n        result.append(gcds[q])\n    return result", "def getGCD(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\ndef solve(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    gcd_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in gcd_count:\n                gcd_count[gcd_val] = 0\n            gcd_count[gcd_val] += 1\n    \n    gcd_pairs = sorted(gcd_count.keys())\n    prefix_sum = [0]\n    for val in gcd_pairs:\n        prefix_sum.append(prefix_sum[-1] + gcd_count[val])\n    \n    result = []\n    for q in queries:\n        idx = bisect.bisect_right(prefix_sum, q + 1) - 1\n        result.append(gcd_pairs[idx])\n    \n    return result", "from collections import defaultdict\nfrom math import gcd\nfrom typing import List\n\ndef getGCDs(nums: List[int]) -> List[int]:\n    max_num = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Count multiples of each number up to max_num\n    for num in nums:\n        for i in range(1, num + 1):\n            if num % i == 0:\n                gcd_counts[i] += 1\n    \n    gcd_list = []\n    # Calculate the number of pairs with each gcd\n    for divisor in range(1, max_num + 1):\n        total_pairs = 0\n        for num in nums:\n            if num % divisor == 0:\n                total_pairs += gcd_counts[num // divisor] - 1\n        gcd_list.extend([divisor] * total_pairs)\n    \n    return sorted(gcd_list)\n\ndef answerQueries(nums: List[int], queries: List[int]) -> List[int]:\n    gcd_pairs = getGCDs(nums)\n    return [gcd_pairs[q] for q in queries]", "from collections import defaultdict\nimport math\n\ndef minNonZeroProduct(p):\n    MOD = 1_000_000_007\n    return pow(2, p) - 1\n\ndef maxNonZeroDivisor(p):\n    MOD = 1_000_000_007\n    return (pow(2, p - 1) - 1 + MOD) % MOD\n\ndef numberOfGCDs(n, m):\n    return math.gcd(n, m)\n\ndef getAnswer(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    max_p = int(math.log2(max_val))\n    \n    gcd_count = defaultdict(int)\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd = numberOfGCDs(nums[i], nums[j])\n            gcd_count[gcd] += 1\n    \n    gcd_list = sorted(gcd_count.keys())\n    gcd_index = {gcd: idx for idx, gcd in enumerate(gcd_list)}\n    \n    result = []\n    for query in queries:\n        target_gcd = gcd_list[bisect.bisect_right(list(gcd_index.values()), query) - 1]\n        result.append(target_gcd)\n    \n    return result"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef getGCD(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef processQueries(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    gcd_counts = [0] * (max_val + 1)\n    \n    # Count occurrences of each gcd value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            gcd_counts[gcd_val] += 1\n    \n    # Prefix sum to get cumulative counts\n    prefix_sum = [0] * (max_val + 1)\n    for i in range(1, max_val + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + gcd_counts[i]\n    \n    # Process each query\n    result = []\n    for q in queries:\n        result.append(prefix_sum[-1] - prefix_sum[q])\n    \n    return result\n```", "```python\ndef getGCD(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(nums, queries):\n    max_val = max(nums)\n    gcd_freq = {}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in gcd_freq:\n                gcd_freq[gcd_val] = 0\n            gcd_freq[gcd_val] += 1\n    \n    sorted_gcds = sorted(gcd_freq.keys())\n    prefix_sum = [0]\n    current_sum = 0\n    \n    for gcd_val in sorted_gcds:\n        current_sum += gcd_freq[gcd_val]\n        prefix_sum.append(current_sum)\n    \n    result = []\n    for query in queries:\n        idx = bisect.bisect_right(prefix_sum, query + 1) - 1\n        result.append(sorted_gcds[idx])\n    \n    return result\n```", "```python\ndef gcd_pairs(nums, queries):\n    max_val = max(nums)\n    gcd_count = {}\n    \n    # Function to add GCD counts\n    def add_gcd(a, b):\n        if a > b:\n            a, b = b, a\n        if a not in gcd_count:\n            gcd_count[a] = 0\n        gcd_count[a] += 1\n    \n    # Populate gcd_count with all possible GCDs\n    for num in nums:\n        for i in range(1, num + 1):\n            if num % i == 0:\n                add_gcd(i, num // i)\n    \n    # Extract sorted unique GCDs\n    sorted_gcds = sorted(gcd_count.keys())\n    \n    # Answer each query\n    answer = []\n    for q in queries:\n        idx = sum(gcd_count[g] for g in sorted_gcds[:q])\n        answer.append(sorted_gcds[idx])\n    \n    return answer\n```", "```python\nfrom math import gcd\nfrom collections import defaultdict\n\ndef getGCDPairs(nums, queries):\n    def get_gcd(x, y):\n        return gcd(x, y)\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count the frequency of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = get_gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    # Extract unique GCD values and sort them by frequency and value\n    gcd_values = sorted(gcd_count.items(), key=lambda x: (x[1], x[0]))\n    \n    # Function to get the GCD at the specified index\n    def get_value(index):\n        current_index = 0\n        for g, freq in gcd_values:\n            if current_index + freq > index:\n                return g\n            current_index += freq\n    \n    # Process each query\n    result = [get_value(q) for q in queries]\n    \n    return result\n```", "```python\ndef getGCDs(nums):\n    n = len(nums)\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                for other_num in nums:\n                    if other_num % d == 0:\n                        count[d] += 1\n    \n    gcds = []\n    for i in range(1, max_val + 1):\n        if count[i] > 0:\n            gcds.extend([i] * count[i])\n    \n    gcds.sort()\n    return gcds\n\ndef answerQueries(nums, queries):\n    gcds = getGCDs(nums)\n    result = []\n    for q in queries:\n        result.append(gcds[q])\n    return result\n```", "```python\ndef getGCD(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\ndef solve(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    gcd_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in gcd_count:\n                gcd_count[gcd_val] = 0\n            gcd_count[gcd_val] += 1\n    \n    gcd_pairs = sorted(gcd_count.keys())\n    prefix_sum = [0]\n    for val in gcd_pairs:\n        prefix_sum.append(prefix_sum[-1] + gcd_count[val])\n    \n    result = []\n    for q in queries:\n        idx = bisect.bisect_right(prefix_sum, q + 1) - 1\n        result.append(gcd_pairs[idx])\n    \n    return result\n```", "```python\nfrom collections import defaultdict\nfrom math import gcd\nfrom typing import List\n\ndef getGCDs(nums: List[int]) -> List[int]:\n    max_num = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Count multiples of each number up to max_num\n    for num in nums:\n        for i in range(1, num + 1):\n            if num % i == 0:\n                gcd_counts[i] += 1\n    \n    gcd_list = []\n    # Calculate the number of pairs with each gcd\n    for divisor in range(1, max_num + 1):\n        total_pairs = 0\n        for num in nums:\n            if num % divisor == 0:\n                total_pairs += gcd_counts[num // divisor] - 1\n        gcd_list.extend([divisor] * total_pairs)\n    \n    return sorted(gcd_list)\n\ndef answerQueries(nums: List[int], queries: List[int]) -> List[int]:\n    gcd_pairs = getGCDs(nums)\n    return [gcd_pairs[q] for q in queries]\n```", "```python\nfrom collections import defaultdict\nimport math\n\ndef minNonZeroProduct(p):\n    MOD = 1_000_000_007\n    return pow(2, p) - 1\n\ndef maxNonZeroDivisor(p):\n    MOD = 1_000_000_007\n    return (pow(2, p - 1) - 1 + MOD) % MOD\n\ndef numberOfGCDs(n, m):\n    return math.gcd(n, m)\n\ndef getAnswer(nums, queries):\n    n = len(nums)\n    max_val = max(nums)\n    max_p = int(math.log2(max_val))\n    \n    gcd_count = defaultdict(int)\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd = numberOfGCDs(nums[i], nums[j])\n            gcd_count[gcd] += 1\n    \n    gcd_list = sorted(gcd_count.keys())\n    gcd_index = {gcd: idx for idx, gcd in enumerate(gcd_list)}\n    \n    result = []\n    for query in queries:\n        target_gcd = gcd_list[bisect.bisect_right(list(gcd_index.values()), query) - 1]\n        result.append(target_gcd)\n    \n    return result\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp1 = {0: 1}\n    dp2 = {0: 1}\n    total_pairs = 0\n    \n    for num in nums:\n        new_dp1 = {}\n        new_dp2 = {}\n        \n        for val in dp1:\n            new_val = num - val\n            if new_val not in new_dp2:\n                new_dp2[new_val] = 0\n            new_dp2[new_val] += dp1[val]\n            new_dp2[new_val] %= MOD\n        \n        for val in dp2:\n            new_val = num - val\n            if new_val not in new_dp1:\n                new_dp1[new_val] = 0\n            new_dp1[new_val] += dp2[val]\n            new_dp1[new_val] %= MOD\n        \n        dp1 = new_dp1\n        dp2 = new_dp2\n        total_pairs += sum(dp1.values())\n        total_pairs %= MOD\n    \n    return total_pairs", "def countMonotonicPairs(nums):\n    n = len(nums)\n    mod = 10**9 + 7\n    count = 0\n    \n    for i in range(n):\n        left = 1\n        right = 1\n        \n        for j in range(i):\n            if nums[j] <= nums[i]:\n                left += 1\n            if nums[j] >= nums[i]:\n                right += 1\n        \n        count = (count + left * right) % mod\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp1 = [1] * (nums[0] + 1)\n    dp2 = [1] * (nums[0] + 1)\n    \n    # Fill DP tables\n    for num in nums[1:]:\n        new_dp1 = [0] * (num + 1)\n        new_dp2 = [0] * (num + 1)\n        for j in range(num + 1):\n            if j > 0:\n                new_dp1[j] = (new_dp1[j] + dp1[j - 1]) % MOD\n            new_dp1[j] = (new_dp1[j] + dp1[j]) % MOD\n            if j < num:\n                new_dp2[num - j] = (new_dp2[num - j] + dp2[num - j + 1]) % MOD\n            new_dp2[num - j] = (new_dp2[num - j] + dp2[num - j]) % MOD\n        dp1 = new_dp1\n        dp2 = new_dp2\n    \n    # Count the total number of valid pairs\n    total_pairs = 0\n    for j in range(nums[-1] + 1):\n        total_pairs = (total_pairs + dp1[j] * dp2[j]) % MOD\n    \n    return total_pairs", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # DP table for non-decreasing sequences\n    dp_nondecreasing = [[0] * 51 for _ in range(n)]\n    dp_nondecreasing[0][nums[0]] = 1\n    \n    # DP table for non-increasing sequences\n    dp_nonincreasing = [[0] * 51 for _ in range(n)]\n    dp_nonincreasing[0][nums[0]] = 1\n    \n    # Fill the DP tables\n    for i in range(1, n):\n        for j in range(nums[i] + 1):\n            dp_nondecreasing[i][j] = dp_nondecreasing[i - 1][j] + dp_nondecreasing[i - 1][j - 1] if j > 0 else dp_nondecreasing[i - 1][j]\n            dp_nonincreasing[i][j] = dp_nonincreasing[i - 1][j] + dp_nonincreasing[i - 1][j + 1] if j < 50 else dp_nonincreasing[i - 1][j]\n    \n    # Count the valid pairs\n    count = 0\n    for j in range(51):\n        count = (count + dp_nondecreasing[n - 1][j] * dp_nonincreasing[n - 1][j]) % MOD\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for arr1 in range(2**n):\n        for arr2 in range(2**n):\n            valid = True\n            for i in range(n):\n                bit1 = (arr1 >> i) & 1\n                bit2 = (arr2 >> i) & 1\n                if bit1 > bit2 or bit1 < bit2:\n                    valid = False\n                    break\n                if bit1 + bit2 != nums[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n    \n    return count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    dp_non_decr[0][nums[0]] = 1\n    dp_non_incr[-1][nums[-1]] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j <= nums[i]:\n                dp_non_decr[i][j] = dp_non_decr[i-1][j] + dp_non_decr[i-1][j-1]\n            else:\n                dp_non_decr[i][j] = dp_non_decr[i-1][j-1]\n    \n    for i in range(n-2, -1, -1):\n        for j in range(51):\n            if j >= nums[i]:\n                dp_non_incr[i][j] = dp_non_incr[i+1][j] + dp_non_incr[i+1][j+1]\n            else:\n                dp_non_incr[i][j] = dp_non_incr[i+1][j+1]\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_non_decr[i][nums[i]]\n        result %= MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(101)]\n    dp_non_incr = [[0] * 51 for _ in range(101)]\n    \n    # Base cases\n    dp_non_decr[0][0] = 1\n    dp_non_incr[0][0] = 1\n    \n    # Fill DP tables\n    for i in range(n):\n        for j in range(1, 101):\n            dp_non_decr[j][nums[i]] += dp_non_decr[j-1][nums[i]]\n            dp_non_incr[j][nums[i]] += dp_non_incr[j-1][nums[i]]\n            dp_non_decr[j][nums[i]] %= MOD\n            dp_non_incr[j][nums[i]] %= MOD\n    \n    # Calculate the total number of valid pairs\n    total_pairs = 0\n    for j in range(1, 101):\n        total_pairs += dp_non_decr[j][j] * dp_non_incr[j][j]\n        total_pairs %= MOD\n    \n    return total_pairs", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    max_sum = sum(nums)\n    dp_inc = [[0] * (max_sum + 1) for _ in range(n)]\n    dp_dec = [[0] * (max_sum + 1) for _ in range(n)]\n    \n    dp_inc[0][nums[0]] = 1\n    dp_dec[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        for j in range(max_sum + 1):\n            if j >= nums[i]:\n                dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i-1][j]) % MOD\n            if j <= nums[i]:\n                dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i-1][j]) % MOD\n    \n    result = 0\n    for j in range(max_sum + 1):\n        result = (result + dp_inc[-1][j] * dp_dec[-1][j]) % MOD\n    \n    return result"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp1 = {0: 1}\n    dp2 = {0: 1}\n    total_pairs = 0\n    \n    for num in nums:\n        new_dp1 = {}\n        new_dp2 = {}\n        \n        for val in dp1:\n            new_val = num - val\n            if new_val not in new_dp2:\n                new_dp2[new_val] = 0\n            new_dp2[new_val] += dp1[val]\n            new_dp2[new_val] %= MOD\n        \n        for val in dp2:\n            new_val = num - val\n            if new_val not in new_dp1:\n                new_dp1[new_val] = 0\n            new_dp1[new_val] += dp2[val]\n            new_dp1[new_val] %= MOD\n        \n        dp1 = new_dp1\n        dp2 = new_dp2\n        total_pairs += sum(dp1.values())\n        total_pairs %= MOD\n    \n    return total_pairs\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    mod = 10**9 + 7\n    count = 0\n    \n    for i in range(n):\n        left = 1\n        right = 1\n        \n        for j in range(i):\n            if nums[j] <= nums[i]:\n                left += 1\n            if nums[j] >= nums[i]:\n                right += 1\n        \n        count = (count + left * right) % mod\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp1 = [1] * (nums[0] + 1)\n    dp2 = [1] * (nums[0] + 1)\n    \n    # Fill DP tables\n    for num in nums[1:]:\n        new_dp1 = [0] * (num + 1)\n        new_dp2 = [0] * (num + 1)\n        for j in range(num + 1):\n            if j > 0:\n                new_dp1[j] = (new_dp1[j] + dp1[j - 1]) % MOD\n            new_dp1[j] = (new_dp1[j] + dp1[j]) % MOD\n            if j < num:\n                new_dp2[num - j] = (new_dp2[num - j] + dp2[num - j + 1]) % MOD\n            new_dp2[num - j] = (new_dp2[num - j] + dp2[num - j]) % MOD\n        dp1 = new_dp1\n        dp2 = new_dp2\n    \n    # Count the total number of valid pairs\n    total_pairs = 0\n    for j in range(nums[-1] + 1):\n        total_pairs = (total_pairs + dp1[j] * dp2[j]) % MOD\n    \n    return total_pairs\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    # DP table for non-decreasing sequences\n    dp_nondecreasing = [[0] * 51 for _ in range(n)]\n    dp_nondecreasing[0][nums[0]] = 1\n    \n    # DP table for non-increasing sequences\n    dp_nonincreasing = [[0] * 51 for _ in range(n)]\n    dp_nonincreasing[0][nums[0]] = 1\n    \n    # Fill the DP tables\n    for i in range(1, n):\n        for j in range(nums[i] + 1):\n            dp_nondecreasing[i][j] = dp_nondecreasing[i - 1][j] + dp_nondecreasing[i - 1][j - 1] if j > 0 else dp_nondecreasing[i - 1][j]\n            dp_nonincreasing[i][j] = dp_nonincreasing[i - 1][j] + dp_nonincreasing[i - 1][j + 1] if j < 50 else dp_nonincreasing[i - 1][j]\n    \n    # Count the valid pairs\n    count = 0\n    for j in range(51):\n        count = (count + dp_nondecreasing[n - 1][j] * dp_nonincreasing[n - 1][j]) % MOD\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for arr1 in range(2**n):\n        for arr2 in range(2**n):\n            valid = True\n            for i in range(n):\n                bit1 = (arr1 >> i) & 1\n                bit2 = (arr2 >> i) & 1\n                if bit1 > bit2 or bit1 < bit2:\n                    valid = False\n                    break\n                if bit1 + bit2 != nums[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n    \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(n)]\n    dp_non_incr = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    dp_non_decr[0][nums[0]] = 1\n    dp_non_incr[-1][nums[-1]] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            if j <= nums[i]:\n                dp_non_decr[i][j] = dp_non_decr[i-1][j] + dp_non_decr[i-1][j-1]\n            else:\n                dp_non_decr[i][j] = dp_non_decr[i-1][j-1]\n    \n    for i in range(n-2, -1, -1):\n        for j in range(51):\n            if j >= nums[i]:\n                dp_non_incr[i][j] = dp_non_incr[i+1][j] + dp_non_incr[i+1][j+1]\n            else:\n                dp_non_incr[i][j] = dp_non_incr[i+1][j+1]\n    \n    # Calculate the result\n    result = 0\n    for i in range(n):\n        result += dp_non_decr[i][nums[i]]\n        result %= MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_non_decr = [[0] * 51 for _ in range(101)]\n    dp_non_incr = [[0] * 51 for _ in range(101)]\n    \n    # Base cases\n    dp_non_decr[0][0] = 1\n    dp_non_incr[0][0] = 1\n    \n    # Fill DP tables\n    for i in range(n):\n        for j in range(1, 101):\n            dp_non_decr[j][nums[i]] += dp_non_decr[j-1][nums[i]]\n            dp_non_incr[j][nums[i]] += dp_non_incr[j-1][nums[i]]\n            dp_non_decr[j][nums[i]] %= MOD\n            dp_non_incr[j][nums[i]] %= MOD\n    \n    # Calculate the total number of valid pairs\n    total_pairs = 0\n    for j in range(1, 101):\n        total_pairs += dp_non_decr[j][j] * dp_non_incr[j][j]\n        total_pairs %= MOD\n    \n    return total_pairs\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    max_sum = sum(nums)\n    dp_inc = [[0] * (max_sum + 1) for _ in range(n)]\n    dp_dec = [[0] * (max_sum + 1) for _ in range(n)]\n    \n    dp_inc[0][nums[0]] = 1\n    dp_dec[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        for j in range(max_sum + 1):\n            if j >= nums[i]:\n                dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i-1][j]) % MOD\n            if j <= nums[i]:\n                dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i-1][j]) % MOD\n    \n    result = 0\n    for j in range(max_sum + 1):\n        result = (result + dp_inc[-1][j] * dp_dec[-1][j]) % MOD\n    \n    return result\n```"]}
{"task_id": "3580", "codes": ["def findAlmostEqualSubstring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1", "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    n = len(pattern)\n    m = len(s)\n    \n    for i in range(m - n + 1):\n        diff_count = 0\n        for j in range(n):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n            if diff_count > 1:\n                break\n        if diff_count == 1:\n            return i\n    \n    return -1", "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count == 1:\n            return i\n    return -1", "def smallest_almost_equal_index(s, pattern):\n    n = len(pattern)\n    for i in range(len(s) - n + 1):\n        diff_count = sum(1 for j in range(n) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    return -1", "def find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n            if diff_count > 1:\n                break\n        if diff_count == 1:\n            return i\n    \n    return -1\n\n# Example usage:\nprint(find_almost_equal_substring(\"abcdefg\", \"bcdffg\"))  # Output: 1\nprint(find_almost_equal_substring(\"ababbababa\", \"bacaba\"))  # Output: 4\nprint(find_almost_equal_substring(\"abcd\", \"dba\"))  # Output: -1\nprint(find_almost_equal_substring(\"dde\", \"d\"))  # Output: 0", "def find_almost_equal_substring(s, pattern):\n    n, m = len(s), len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n\ndef find_at_most_k_consecutive_changes_substring(s, pattern, k):\n    n, m = len(s), len(pattern)\n    \n    left = 0\n    diff_count = 0\n    \n    for right in range(n):\n        if s[right] != pattern[right % m]:\n            diff_count += 1\n        \n        while diff_count > k:\n            if s[left] != pattern[left % m]:\n                diff_count -= 1\n            left += 1\n        \n        if right - left + 1 == m:\n            return left\n    \n    return -1", "def find_almost_equal_substring(s, pattern):\n    n, m = len(s), len(pattern)\n    min_index = -1\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            min_index = i\n            break\n    \n    return min_index", "def smallestAlmostEqualSubstring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef findAlmostEqualSubstring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```", "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    n = len(pattern)\n    m = len(s)\n    \n    for i in range(m - n + 1):\n        diff_count = 0\n        for j in range(n):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n            if diff_count > 1:\n                break\n        if diff_count == 1:\n            return i\n    \n    return -1\n```", "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count == 1:\n            return i\n    return -1\n```", "```python\ndef smallest_almost_equal_index(s, pattern):\n    n = len(pattern)\n    for i in range(len(s) - n + 1):\n        diff_count = sum(1 for j in range(n) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    return -1\n```", "```python\ndef find_almost_equal_substring(s, pattern):\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n            if diff_count > 1:\n                break\n        if diff_count == 1:\n            return i\n    \n    return -1\n\n# Example usage:\nprint(find_almost_equal_substring(\"abcdefg\", \"bcdffg\"))  # Output: 1\nprint(find_almost_equal_substring(\"ababbababa\", \"bacaba\"))  # Output: 4\nprint(find_almost_equal_substring(\"abcd\", \"dba\"))  # Output: -1\nprint(find_almost_equal_substring(\"dde\", \"d\"))  # Output: 0\n```", "```python\ndef find_almost_equal_substring(s, pattern):\n    n, m = len(s), len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    \n    return -1\n\ndef find_at_most_k_consecutive_changes_substring(s, pattern, k):\n    n, m = len(s), len(pattern)\n    \n    left = 0\n    diff_count = 0\n    \n    for right in range(n):\n        if s[right] != pattern[right % m]:\n            diff_count += 1\n        \n        while diff_count > k:\n            if s[left] != pattern[left % m]:\n                diff_count -= 1\n            left += 1\n        \n        if right - left + 1 == m:\n            return left\n    \n    return -1\n```", "```python\ndef find_almost_equal_substring(s, pattern):\n    n, m = len(s), len(pattern)\n    min_index = -1\n    \n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            min_index = i\n            break\n    \n    return min_index\n```", "```python\ndef smallestAlmostEqualSubstring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"]}
{"task_id": "3575", "codes": ["def max_value_of_subsequence(nums, k):\n    n = len(nums)\n    prefix_or = [0] * (n + 1)\n    \n    # Compute prefix OR array\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    max_val = 0\n    \n    # Iterate over all possible starting points of the first half\n    for i in range(k):\n        left_or = prefix_or[i + 1]\n        right_or = prefix_or[n] ^ prefix_or[i + k + 1]\n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if n == 0 or k == 0:\n        return 0\n    \n    # Create prefix XOR arrays\n    prefix_xor_1 = [0] * (n + 1)\n    prefix_xor_2 = [0] * (n + 1)\n    \n    for i in range(n):\n        prefix_xor_1[i + 1] = prefix_xor_1[i] | nums[i]\n    \n    for i in range(n - 1, -1, -1):\n        prefix_xor_2[i] = prefix_xor_2[i + 1] | nums[i]\n    \n    # Initialize DP table\n    dp = [[0] * (n + 1) for _ in range(1 << 7)]\n    \n    # Fill DP table\n    for mask in range(1 << 7):\n        for i in range(n):\n            if dp[mask][i] > 0:\n                bit_pos = 0\n                while bit_pos < 7:\n                    if not (mask & (1 << bit_pos)):\n                        new_mask = mask | (1 << bit_pos)\n                        if i + k < n:\n                            dp[new_mask][i + k] = max(dp[new_mask][i + k], dp[mask][i] ^ (prefix_xor_2[i + k + 1] ^ prefix_xor_2[i]))\n                    bit_pos += 1\n    \n    return max(max(row) for row in dp)", "def max_xor_subsequence(nums, k):\n    n = len(nums)\n    max_xor = 0\n    \n    for i in range(1 << (n // 2)):\n        or_first_half = 0\n        or_second_half = 0\n        count = 0\n        for j in range(n):\n            if count < k:\n                if i & (1 << count):\n                    or_first_half |= nums[j]\n                else:\n                    or_second_half |= nums[j]\n            else:\n                or_second_half |= nums[j]\n            count += 1\n        max_xor = max(max_xor, or_first_half ^ or_second_half)\n    \n    return max_xor", "def max_value_of_subsequence(nums, k):\n    n = len(nums)\n    if n == 2 * k:\n        return nums[0] | nums[1]\n    \n    max_xor = 0\n    \n    # Precompute prefix ORs\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    # Precompute suffix ORs\n    suffix_or = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_or[i] = suffix_or[i + 1] | nums[i]\n    \n    # Iterate over all possible pairs of indices\n    for i in range(k):\n        for j in range(i + 1, k + 1):\n            xor_value = (prefix_or[j] ^ prefix_or[i]) ^ (suffix_or[n - k + i] ^ suffix_or[n - k + j])\n            max_xor = max(max_xor, xor_value)\n    \n    return max_xor", "def max_subsequence_value(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    # Iterate over all possible starting points for the first half\n    for i in range(n - 2 * k + 1):\n        first_half_or = 0\n        second_half_or = 0\n        \n        # Compute the OR of the first half\n        for j in range(i, i + k):\n            first_half_or |= nums[j]\n        \n        # Compute the OR of the second half\n        for j in range(i + k, i + 2 * k):\n            second_half_or |= nums[j]\n        \n        # Compute the value of the current subsequence\n        current_val = first_half_or ^ second_half_or\n        \n        # Update the maximum value\n        if current_val > max_val:\n            max_val = current_val\n    \n    return max_val", "def maximum_value(nums, k):\n    from heapq import nlargest\n    \n    n = len(nums)\n    max_value = 0\n    \n    for i in range(k, n - k + 1):\n        first_half = nlargest(k, nums[:i])\n        second_half = nlargest(k, nums[i:])\n        \n        xor_first_half = 0\n        xor_second_half = 0\n        \n        for num in first_half:\n            xor_first_half |= num\n        \n        for num in second_half:\n            xor_second_half |= num\n        \n        max_value = max(max_value, xor_first_half ^ xor_second_half)\n    \n    return max_value", "def max_value_of_subsequence(nums, k):\n    def max_xor_with_k_bits(arr, k):\n        # Sort the array based on the most significant bit first\n        arr.sort(key=lambda x: bin(x)[2:].zfill(7), reverse=True)\n        \n        # Select the top k elements\n        selected = arr[:k]\n        \n        # Compute the XOR of the selected elements\n        xor_result = 0\n        for num in selected:\n            xor_result ^= num\n        \n        return xor_result\n    \n    n = len(nums)\n    max_val = 0\n    \n    # Try all possible bit positions for the first half\n    for i in range(7):\n        mask = 1 << i\n        first_half = [num for num in nums if num & mask]\n        second_half = [num for num in nums if not (num & mask)]\n        \n        if len(first_half) >= k and len(second_half) >= k:\n            xor_first_half = max_xor_with_k_bits(first_half, k)\n            xor_second_half = max_xor_with_k_bits(second_half, k)\n            max_val = max(max_val, xor_first_half ^ xor_second_half)\n    \n    return max_val", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if n % 2 != 0 or k == 0:\n        return 0\n    \n    # Precompute prefix OR values\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    # Precompute suffix OR values\n    suffix_or = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_or[i] = suffix_or[i + 1] | nums[i]\n    \n    # Find the maximum value of the subsequence\n    max_value = 0\n    for i in range(k):\n        max_value = max(max_value, (prefix_or[i + 1] ^ suffix_or[k + i + 1]))\n    \n    return max_value"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef max_value_of_subsequence(nums, k):\n    n = len(nums)\n    prefix_or = [0] * (n + 1)\n    \n    # Compute prefix OR array\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    max_val = 0\n    \n    # Iterate over all possible starting points of the first half\n    for i in range(k):\n        left_or = prefix_or[i + 1]\n        right_or = prefix_or[n] ^ prefix_or[i + k + 1]\n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if n == 0 or k == 0:\n        return 0\n    \n    # Create prefix XOR arrays\n    prefix_xor_1 = [0] * (n + 1)\n    prefix_xor_2 = [0] * (n + 1)\n    \n    for i in range(n):\n        prefix_xor_1[i + 1] = prefix_xor_1[i] | nums[i]\n    \n    for i in range(n - 1, -1, -1):\n        prefix_xor_2[i] = prefix_xor_2[i + 1] | nums[i]\n    \n    # Initialize DP table\n    dp = [[0] * (n + 1) for _ in range(1 << 7)]\n    \n    # Fill DP table\n    for mask in range(1 << 7):\n        for i in range(n):\n            if dp[mask][i] > 0:\n                bit_pos = 0\n                while bit_pos < 7:\n                    if not (mask & (1 << bit_pos)):\n                        new_mask = mask | (1 << bit_pos)\n                        if i + k < n:\n                            dp[new_mask][i + k] = max(dp[new_mask][i + k], dp[mask][i] ^ (prefix_xor_2[i + k + 1] ^ prefix_xor_2[i]))\n                    bit_pos += 1\n    \n    return max(max(row) for row in dp)\n```", "```python\ndef max_xor_subsequence(nums, k):\n    n = len(nums)\n    max_xor = 0\n    \n    for i in range(1 << (n // 2)):\n        or_first_half = 0\n        or_second_half = 0\n        count = 0\n        for j in range(n):\n            if count < k:\n                if i & (1 << count):\n                    or_first_half |= nums[j]\n                else:\n                    or_second_half |= nums[j]\n            else:\n                or_second_half |= nums[j]\n            count += 1\n        max_xor = max(max_xor, or_first_half ^ or_second_half)\n    \n    return max_xor\n```", "```python\ndef max_value_of_subsequence(nums, k):\n    n = len(nums)\n    if n == 2 * k:\n        return nums[0] | nums[1]\n    \n    max_xor = 0\n    \n    # Precompute prefix ORs\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    # Precompute suffix ORs\n    suffix_or = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_or[i] = suffix_or[i + 1] | nums[i]\n    \n    # Iterate over all possible pairs of indices\n    for i in range(k):\n        for j in range(i + 1, k + 1):\n            xor_value = (prefix_or[j] ^ prefix_or[i]) ^ (suffix_or[n - k + i] ^ suffix_or[n - k + j])\n            max_xor = max(max_xor, xor_value)\n    \n    return max_xor\n```", "```python\ndef max_subsequence_value(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    # Iterate over all possible starting points for the first half\n    for i in range(n - 2 * k + 1):\n        first_half_or = 0\n        second_half_or = 0\n        \n        # Compute the OR of the first half\n        for j in range(i, i + k):\n            first_half_or |= nums[j]\n        \n        # Compute the OR of the second half\n        for j in range(i + k, i + 2 * k):\n            second_half_or |= nums[j]\n        \n        # Compute the value of the current subsequence\n        current_val = first_half_or ^ second_half_or\n        \n        # Update the maximum value\n        if current_val > max_val:\n            max_val = current_val\n    \n    return max_val\n```", "```python\ndef maximum_value(nums, k):\n    from heapq import nlargest\n    \n    n = len(nums)\n    max_value = 0\n    \n    for i in range(k, n - k + 1):\n        first_half = nlargest(k, nums[:i])\n        second_half = nlargest(k, nums[i:])\n        \n        xor_first_half = 0\n        xor_second_half = 0\n        \n        for num in first_half:\n            xor_first_half |= num\n        \n        for num in second_half:\n            xor_second_half |= num\n        \n        max_value = max(max_value, xor_first_half ^ xor_second_half)\n    \n    return max_value\n```", "```python\ndef max_value_of_subsequence(nums, k):\n    def max_xor_with_k_bits(arr, k):\n        # Sort the array based on the most significant bit first\n        arr.sort(key=lambda x: bin(x)[2:].zfill(7), reverse=True)\n        \n        # Select the top k elements\n        selected = arr[:k]\n        \n        # Compute the XOR of the selected elements\n        xor_result = 0\n        for num in selected:\n            xor_result ^= num\n        \n        return xor_result\n    \n    n = len(nums)\n    max_val = 0\n    \n    # Try all possible bit positions for the first half\n    for i in range(7):\n        mask = 1 << i\n        first_half = [num for num in nums if num & mask]\n        second_half = [num for num in nums if not (num & mask)]\n        \n        if len(first_half) >= k and len(second_half) >= k:\n            xor_first_half = max_xor_with_k_bits(first_half, k)\n            xor_second_half = max_xor_with_k_bits(second_half, k)\n            max_val = max(max_val, xor_first_half ^ xor_second_half)\n    \n    return max_val\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    if n % 2 != 0 or k == 0:\n        return 0\n    \n    # Precompute prefix OR values\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | nums[i]\n    \n    # Precompute suffix OR values\n    suffix_or = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_or[i] = suffix_or[i + 1] | nums[i]\n    \n    # Find the maximum value of the subsequence\n    max_value = 0\n    for i in range(k):\n        max_value = max(max_value, (prefix_or[i + 1] ^ suffix_or[k + i + 1]))\n    \n    return max_value\n```"]}
{"task_id": "3552", "codes": ["def largest_k_palindrome(n, k):\n    def is_divisible_by_k(num_str, k):\n        return int(num_str) % k == 0\n    \n    max_palindrome = \"\"\n    \n    # Generate half prefixes from large to small\n    for i in range(10**(n//2), 10**((n//2)-1), -1):\n        half_prefix = str(i)\n        if n % 2 == 0:\n            full_palindrome = half_prefix + half_prefix[::-1]\n        else:\n            full_palindrome = half_prefix[:-1] + half_prefix[::-1]\n        \n        if is_divisible_by_k(full_palindrome, k):\n            max_palindrome = full_palindrome\n            break\n    \n    return max_palindrome", "def largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    def is_palindrome(num):\n        return num == int(str(num)[::-1])\n    \n    for i in range(10**(n-1), 10**n):\n        candidate = int(str(i) + str(i)[::-1] if n % 2 == 0 else str(i)[:-1][::-1] + str(i)[-1:])\n        if candidate % k == 0:\n            return str(candidate)", "def largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num_str: str) -> bool:\n        return int(num_str) % k == 0\n    \n    def generate_palindrome(prefix: str) -> str:\n        if len(prefix) == n // 2:\n            suffix = prefix[::-1] if n % 2 == 0 else prefix[-2::-1]\n            return prefix + suffix\n        elif len(prefix) < n // 2:\n            return generate_palindrome(prefix[:-1])\n    \n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n    \n    max_num = '9' * n\n    min_num = '1' + '0' * (n - 2) + '1'\n    \n    for num in range(int(max_num), int(min_num) - 1, -1):\n        num_str = str(num)\n        if num_str[0] != '0':\n            if is_divisible_by_k(generate_palindrome(num_str[:len(num_str)//2])):\n                return generate_palindrome(num_str[:len(num_str)//2])", "def largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k * (k // 2) * 2) if k % 2 == 0 else str(k)\n    \n    half_n = (n + 1) // 2\n    for i in range(10**(half_n) - 1, 10**(half_n - 1) - 1, -1):\n        half = str(i)\n        if n % 2 == 0:\n            candidate = int(half + half[::-1])\n        else:\n            for digit in range(9, -1, -1):\n                candidate = int(half + str(digit) + half[::-1])\n                if candidate % k == 0:\n                    return str(candidate)\n        if candidate % k == 0:\n            return str(candidate)\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"", "def largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    # Start with the largest n-digit number\n    max_num = int('9' * n)\n    min_num = int('1' + '0' * (n - 1))\n    \n    for num in range(max_num, min_num - 1, -1):\n        str_num = str(num)\n        if is_palindrome(str_num) and num % k == 0:\n            return str_num\n    \n    return \"-1\"  # In case no such number exists\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"", "def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def generate_palindromes(length):\n        if length == 1:\n            return range(9, -1, -1)\n        mid = length // 2\n        for i in range(10**(mid-1), 10**mid):\n            s = str(i)\n            if length % 2 == 0:\n                yield int(s + s[::-1])\n            else:\n                for j in range(10):\n                    yield int(s + str(j) + s[::-1])\n\n    for length in range(n, 0, -1):\n        for num in generate_palindromes(length):\n            if num % k == 0:\n                return str(num)", "def largest_k_palindrome(n: int, k: int) -> str:\n    # Helper function to check if a string is a palindrome\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    # Generate the largest possible n-digit number\n    max_num = int('9' * n)\n    \n    # Start from the largest n-digit palindrome and go downwards\n    for i in range(max_num, 0, -1):\n        # Convert number to string\n        num_str = str(i)\n        # Create the palindrome by mirroring the first half\n        palindrome = num_str + num_str[:-1][::-1]\n        # Check if the palindrome is divisible by k\n        if int(palindrome) % k == 0:\n            return str(palindrome)", "def largest_k_palindrome(n, k):\n    def is_divisible_by_k(num_str):\n        return int(num_str) % k == 0\n    \n    def generate_half(s):\n        length = len(s)\n        half = s[:length // 2]\n        if length % 2 == 0:\n            return half\n        else:\n            return half[:-1]\n    \n    def generate_palindrome(half):\n        length = len(half)\n        if length == 0:\n            return \"\"\n        elif length == 1:\n            return half + half[::-1][1:]\n        else:\n            return half + half[-2::-1]\n    \n    max_palindrome = \"\"\n    for i in range(10**(n//2), 0, -1):\n        half = str(i)\n        if is_divisible_by_k(generate_palindrome(half)):\n            max_palindrome = generate_palindrome(half)\n            break\n    \n    return max_palindrome"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef largest_k_palindrome(n, k):\n    def is_divisible_by_k(num_str, k):\n        return int(num_str) % k == 0\n    \n    max_palindrome = \"\"\n    \n    # Generate half prefixes from large to small\n    for i in range(10**(n//2), 10**((n//2)-1), -1):\n        half_prefix = str(i)\n        if n % 2 == 0:\n            full_palindrome = half_prefix + half_prefix[::-1]\n        else:\n            full_palindrome = half_prefix[:-1] + half_prefix[::-1]\n        \n        if is_divisible_by_k(full_palindrome, k):\n            max_palindrome = full_palindrome\n            break\n    \n    return max_palindrome\n```", "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    def is_palindrome(num):\n        return num == int(str(num)[::-1])\n    \n    for i in range(10**(n-1), 10**n):\n        candidate = int(str(i) + str(i)[::-1] if n % 2 == 0 else str(i)[:-1][::-1] + str(i)[-1:])\n        if candidate % k == 0:\n            return str(candidate)\n```", "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num_str: str) -> bool:\n        return int(num_str) % k == 0\n    \n    def generate_palindrome(prefix: str) -> str:\n        if len(prefix) == n // 2:\n            suffix = prefix[::-1] if n % 2 == 0 else prefix[-2::-1]\n            return prefix + suffix\n        elif len(prefix) < n // 2:\n            return generate_palindrome(prefix[:-1])\n    \n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n    \n    max_num = '9' * n\n    min_num = '1' + '0' * (n - 2) + '1'\n    \n    for num in range(int(max_num), int(min_num) - 1, -1):\n        num_str = str(num)\n        if num_str[0] != '0':\n            if is_divisible_by_k(generate_palindrome(num_str[:len(num_str)//2])):\n                return generate_palindrome(num_str[:len(num_str)//2])\n```", "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(k * (k // 2) * 2) if k % 2 == 0 else str(k)\n    \n    half_n = (n + 1) // 2\n    for i in range(10**(half_n) - 1, 10**(half_n - 1) - 1, -1):\n        half = str(i)\n        if n % 2 == 0:\n            candidate = int(half + half[::-1])\n        else:\n            for digit in range(9, -1, -1):\n                candidate = int(half + str(digit) + half[::-1])\n                if candidate % k == 0:\n                    return str(candidate)\n        if candidate % k == 0:\n            return str(candidate)\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```", "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    # Start with the largest n-digit number\n    max_num = int('9' * n)\n    min_num = int('1' + '0' * (n - 1))\n    \n    for num in range(max_num, min_num - 1, -1):\n        str_num = str(num)\n        if is_palindrome(str_num) and num % k == 0:\n            return str_num\n    \n    return \"-1\"  # In case no such number exists\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```", "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def generate_palindromes(length):\n        if length == 1:\n            return range(9, -1, -1)\n        mid = length // 2\n        for i in range(10**(mid-1), 10**mid):\n            s = str(i)\n            if length % 2 == 0:\n                yield int(s + s[::-1])\n            else:\n                for j in range(10):\n                    yield int(s + str(j) + s[::-1])\n\n    for length in range(n, 0, -1):\n        for num in generate_palindromes(length):\n            if num % k == 0:\n                return str(num)\n```", "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    # Helper function to check if a string is a palindrome\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    # Generate the largest possible n-digit number\n    max_num = int('9' * n)\n    \n    # Start from the largest n-digit palindrome and go downwards\n    for i in range(max_num, 0, -1):\n        # Convert number to string\n        num_str = str(i)\n        # Create the palindrome by mirroring the first half\n        palindrome = num_str + num_str[:-1][::-1]\n        # Check if the palindrome is divisible by k\n        if int(palindrome) % k == 0:\n            return str(palindrome)\n```", "```python\ndef largest_k_palindrome(n, k):\n    def is_divisible_by_k(num_str):\n        return int(num_str) % k == 0\n    \n    def generate_half(s):\n        length = len(s)\n        half = s[:length // 2]\n        if length % 2 == 0:\n            return half\n        else:\n            return half[:-1]\n    \n    def generate_palindrome(half):\n        length = len(half)\n        if length == 0:\n            return \"\"\n        elif length == 1:\n            return half + half[::-1][1:]\n        else:\n            return half + half[-2::-1]\n    \n    max_palindrome = \"\"\n    for i in range(10**(n//2), 0, -1):\n        half = str(i)\n        if is_divisible_by_k(generate_palindrome(half)):\n            max_palindrome = generate_palindrome(half)\n            break\n    \n    return max_palindrome\n```"]}
{"task_id": "3548", "codes": ["from math import factorial\nfrom collections import Counter\n\ndef count_good_integers(n, k):\n    def count_permutations(freqs):\n        total = factorial(sum(freqs))\n        for freq in freqs.values():\n            total //= factorial(freq)\n        return total\n    \n    def is_valid_k_palindrome(freqs):\n        odd_count = sum(1 for freq in freqs.values() if freq % 2 != 0)\n        return odd_count <= 1\n    \n    def count_divisible_by_k(freqs, k):\n        if sum(freqs.values()) == 0:\n            return 0\n        \n        total = 0\n        for i in range(k, 10**n, k):\n            current_freqs = Counter(str(i))\n            if current_freqs == freqs:\n                total += 1\n        return total\n    \n    freqs = [0] * 10\n    for _ in range(n):\n        freqs[0] += 1\n    \n    if not is_valid_k_palindrome(freqs):\n        return 0\n    \n    return count_divisible_by_k(dict(Counter(''.join(str(i) for i in range(1, 10))) + Counter(''.join(str(i) for i in range(1, 10)))), k)\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468", "def count_good_integers(n, k):\n    def can_form_palindrome(digit_count):\n        odd_count = sum(1 for count in digit_count if count % 2 != 0)\n        return odd_count <= 1\n\n    def is_divisible_by_k(number):\n        return number % k == 0\n\n    count = 0\n    for i in range(10**(n-1), 10**n):\n        digit_count = [0] * 10\n        for digit in str(i):\n            digit_count[int(digit)] += 1\n        if can_form_palindrome(digit_count):\n            if is_divisible_by_k(i):\n                count += 1\n    return count", "def count_good_integers(n, k):\n    from collections import Counter\n    from math import factorial\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digit_counts, remaining_digits):\n        if remaining_digits == 0:\n            num = int(''.join(str(digit) * count for digit, count in sorted(digit_counts.items())))\n            if is_palindrome(str(num)) and is_divisible_by_k(num):\n                return 1\n            return 0\n        \n        total = 0\n        for digit in digit_counts:\n            if digit_counts[digit] > 0:\n                digit_counts[digit] -= 1\n                total += count_combinations(digit_counts, remaining_digits - 1)\n                digit_counts[digit] += 1\n        return total\n    \n    digit_counts = Counter(range(1, 10))\n    return count_combinations(digit_counts, n)", "def count_good_integers(n, k):\n    def count_palindromes_with_digit_sum(sum_val, length):\n        dp = [[0] * (length + 1) for _ in range(sum_val + 1)]\n        dp[0][0] = 1\n        \n        for s in range(1, sum_val + 1):\n            for l in range(1, length + 1):\n                dp[s][l] = dp[s-1][l-1] + dp[s][l-1]\n        \n        return dp[sum_val][length]\n    \n    def is_divisible_by_k(num_str, k):\n        return int(num_str) % k == 0\n    \n    count = 0\n    half_length = (n + 1) // 2\n    \n    for d1 in range(1, 10):\n        for d2 in range(0, 10):\n            for d3 in range(0, 10):\n                for d4 in range(0, 10):\n                    for d5 in range(0, 10):\n                        for d6 in range(0, 10):\n                            for d7 in range(0, 10):\n                                for d8 in range(0, 10):\n                                    for d9 in range(0, 10):\n                                        digits = [d1, d2, d3, d4, d5, d6, d7, d8, d9]\n                                        if len(digits) > n:\n                                            continue\n                                        if sum(digits) % k != 0:\n                                            continue\n                                        \n                                        # Form palindromes\n                                        if n % 2 == 1:\n                                            palindromes = [\n                                                ''.join(map(str, digits[:half_length] + [digits[half_length]] + digits[:half_length][::-1])),\n                                                ''.join(map(str, digits[:half_length] + [digits[half_length]] + digits[:half_length][::-1][1:])),\n                                                ''.join(map(str, digits[:half_length+1] + digits[:half_length][::-1]))\n                                            ]\n                                        else:\n                                            palindromes = [\n                                                ''.join(map(str, digits[:half_length] + digits[:half_length][::-1])),\n                                                ''.join(map(str, digits[:half_length] + digits[:half_length][::-1][1:]))\n                                            ]\n                                        \n                                        for p in palindromes:\n                                            if is_divisible_by_k(p, k):\n                                                count += 1\n    \n    return count", "def countGoodIntegers(n: int, k: int) -> int:\n    def count_palindromes(digit_sum):\n        dp = [0] * (digit_sum + 1)\n        dp[0] = 1\n        MOD = 10**9 + 7\n        \n        for i in range(1, digit_sum + 1):\n            for j in range(i, -1, -1):\n                dp[j] += dp[j - 1]\n                dp[j] %= MOD\n        \n        return dp[digit_sum]\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    total_count = 0\n    \n    for i in range(1, n + 1):\n        if i % 2 == 1:\n            # Odd length palindrome\n            mid_digit = n // 2\n            remaining_digits = n // 2\n            for d in range(1, 10):\n                if (d * (remaining_digits + 1)) % k == 0:\n                    total_count += count_palindromes(remaining_digits)\n        else:\n            # Even length palindrome\n            half_length = n // 2\n            for d in range(1, 10):\n                if (d * half_length) % k == 0:\n                    total_count += count_palindromes(half_length - 1)\n    \n    return total_count", "def count_good_integers(n, k):\n    def count_divisible_by_k_with_digits(digits, k):\n        from collections import Counter\n        digit_count = Counter(digits)\n        total_ways = 1\n        half_length = (len(digits) + 1) // 2\n        \n        # Calculate the number of ways to arrange the first half of the digits\n        for digit, count in digit_count.items():\n            if count % 2 == 1:\n                half_length -= 1\n            total_ways *= factorial(count) // (factorial(count // 2) * factorial((count + 1) // 2))\n        \n        # Check if the number formed is divisible by k\n        return total_ways % k == 0\n    \n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n    \n    if n == 1:\n        return len([i for i in range(k, 10) if i % k == 0])\n    \n    good_count = 0\n    digits = '1' + ''.join(str(i) for i in range(2, 10)) * (n - 1)\n    \n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits) + 1):\n            sub_digits = digits[i:j]\n            if count_divisible_by_k_with_digits(sub_digits, k):\n                good_count += 1\n                \n    return good_count", "def count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_divisible_by_k(digits, target):\n        from itertools import permutations\n        count = 0\n        for perm in set(permutations(digits)):\n            num = int(''.join(map(str, perm)))\n            if num > 0 and num % target == 0 and is_palindrome(num):\n                count += 1\n        return count\n    \n    digits = [i for i in range(1, 10)] * (n // 2)\n    if n % 2 == 1:\n        digits.append(0)\n    \n    return count_divisible_by_k(digits, k)", "def countGoodIntegers(n, k):\n    from collections import Counter\n    from math import factorial\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits):\n        total_count = 0\n        for i in range(1 << len(digits)):\n            comb = [digits[j] for j in range(len(digits)) if i & (1 << j)]\n            if sum(comb) % k == 0:\n                count = factorial(sum(comb))\n                for d in set(comb):\n                    count //= factorial(comb.count(d))\n                total_count += count\n        return total_count\n    \n    digits = list(range(1, 10)) * (n // 9) + list(range(1, n % 9 + 1))\n    return count_combinations(digits)"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nfrom math import factorial\nfrom collections import Counter\n\ndef count_good_integers(n, k):\n    def count_permutations(freqs):\n        total = factorial(sum(freqs))\n        for freq in freqs.values():\n            total //= factorial(freq)\n        return total\n    \n    def is_valid_k_palindrome(freqs):\n        odd_count = sum(1 for freq in freqs.values() if freq % 2 != 0)\n        return odd_count <= 1\n    \n    def count_divisible_by_k(freqs, k):\n        if sum(freqs.values()) == 0:\n            return 0\n        \n        total = 0\n        for i in range(k, 10**n, k):\n            current_freqs = Counter(str(i))\n            if current_freqs == freqs:\n                total += 1\n        return total\n    \n    freqs = [0] * 10\n    for _ in range(n):\n        freqs[0] += 1\n    \n    if not is_valid_k_palindrome(freqs):\n        return 0\n    \n    return count_divisible_by_k(dict(Counter(''.join(str(i) for i in range(1, 10))) + Counter(''.join(str(i) for i in range(1, 10)))), k)\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468\n```", "```python\ndef count_good_integers(n, k):\n    def can_form_palindrome(digit_count):\n        odd_count = sum(1 for count in digit_count if count % 2 != 0)\n        return odd_count <= 1\n\n    def is_divisible_by_k(number):\n        return number % k == 0\n\n    count = 0\n    for i in range(10**(n-1), 10**n):\n        digit_count = [0] * 10\n        for digit in str(i):\n            digit_count[int(digit)] += 1\n        if can_form_palindrome(digit_count):\n            if is_divisible_by_k(i):\n                count += 1\n    return count\n```", "```python\ndef count_good_integers(n, k):\n    from collections import Counter\n    from math import factorial\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digit_counts, remaining_digits):\n        if remaining_digits == 0:\n            num = int(''.join(str(digit) * count for digit, count in sorted(digit_counts.items())))\n            if is_palindrome(str(num)) and is_divisible_by_k(num):\n                return 1\n            return 0\n        \n        total = 0\n        for digit in digit_counts:\n            if digit_counts[digit] > 0:\n                digit_counts[digit] -= 1\n                total += count_combinations(digit_counts, remaining_digits - 1)\n                digit_counts[digit] += 1\n        return total\n    \n    digit_counts = Counter(range(1, 10))\n    return count_combinations(digit_counts, n)\n```", "```python\ndef count_good_integers(n, k):\n    def count_palindromes_with_digit_sum(sum_val, length):\n        dp = [[0] * (length + 1) for _ in range(sum_val + 1)]\n        dp[0][0] = 1\n        \n        for s in range(1, sum_val + 1):\n            for l in range(1, length + 1):\n                dp[s][l] = dp[s-1][l-1] + dp[s][l-1]\n        \n        return dp[sum_val][length]\n    \n    def is_divisible_by_k(num_str, k):\n        return int(num_str) % k == 0\n    \n    count = 0\n    half_length = (n + 1) // 2\n    \n    for d1 in range(1, 10):\n        for d2 in range(0, 10):\n            for d3 in range(0, 10):\n                for d4 in range(0, 10):\n                    for d5 in range(0, 10):\n                        for d6 in range(0, 10):\n                            for d7 in range(0, 10):\n                                for d8 in range(0, 10):\n                                    for d9 in range(0, 10):\n                                        digits = [d1, d2, d3, d4, d5, d6, d7, d8, d9]\n                                        if len(digits) > n:\n                                            continue\n                                        if sum(digits) % k != 0:\n                                            continue\n                                        \n                                        # Form palindromes\n                                        if n % 2 == 1:\n                                            palindromes = [\n                                                ''.join(map(str, digits[:half_length] + [digits[half_length]] + digits[:half_length][::-1])),\n                                                ''.join(map(str, digits[:half_length] + [digits[half_length]] + digits[:half_length][::-1][1:])),\n                                                ''.join(map(str, digits[:half_length+1] + digits[:half_length][::-1]))\n                                            ]\n                                        else:\n                                            palindromes = [\n                                                ''.join(map(str, digits[:half_length] + digits[:half_length][::-1])),\n                                                ''.join(map(str, digits[:half_length] + digits[:half_length][::-1][1:]))\n                                            ]\n                                        \n                                        for p in palindromes:\n                                            if is_divisible_by_k(p, k):\n                                                count += 1\n    \n    return count\n```", "```python\ndef countGoodIntegers(n: int, k: int) -> int:\n    def count_palindromes(digit_sum):\n        dp = [0] * (digit_sum + 1)\n        dp[0] = 1\n        MOD = 10**9 + 7\n        \n        for i in range(1, digit_sum + 1):\n            for j in range(i, -1, -1):\n                dp[j] += dp[j - 1]\n                dp[j] %= MOD\n        \n        return dp[digit_sum]\n    \n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    total_count = 0\n    \n    for i in range(1, n + 1):\n        if i % 2 == 1:\n            # Odd length palindrome\n            mid_digit = n // 2\n            remaining_digits = n // 2\n            for d in range(1, 10):\n                if (d * (remaining_digits + 1)) % k == 0:\n                    total_count += count_palindromes(remaining_digits)\n        else:\n            # Even length palindrome\n            half_length = n // 2\n            for d in range(1, 10):\n                if (d * half_length) % k == 0:\n                    total_count += count_palindromes(half_length - 1)\n    \n    return total_count\n```", "```python\ndef count_good_integers(n, k):\n    def count_divisible_by_k_with_digits(digits, k):\n        from collections import Counter\n        digit_count = Counter(digits)\n        total_ways = 1\n        half_length = (len(digits) + 1) // 2\n        \n        # Calculate the number of ways to arrange the first half of the digits\n        for digit, count in digit_count.items():\n            if count % 2 == 1:\n                half_length -= 1\n            total_ways *= factorial(count) // (factorial(count // 2) * factorial((count + 1) // 2))\n        \n        # Check if the number formed is divisible by k\n        return total_ways % k == 0\n    \n    def factorial(num):\n        if num == 0 or num == 1:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n    \n    if n == 1:\n        return len([i for i in range(k, 10) if i % k == 0])\n    \n    good_count = 0\n    digits = '1' + ''.join(str(i) for i in range(2, 10)) * (n - 1)\n    \n    for i in range(len(digits)):\n        for j in range(i + 1, len(digits) + 1):\n            sub_digits = digits[i:j]\n            if count_divisible_by_k_with_digits(sub_digits, k):\n                good_count += 1\n                \n    return good_count\n```", "```python\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_divisible_by_k(digits, target):\n        from itertools import permutations\n        count = 0\n        for perm in set(permutations(digits)):\n            num = int(''.join(map(str, perm)))\n            if num > 0 and num % target == 0 and is_palindrome(num):\n                count += 1\n        return count\n    \n    digits = [i for i in range(1, 10)] * (n // 2)\n    if n % 2 == 1:\n        digits.append(0)\n    \n    return count_divisible_by_k(digits, k)\n```", "```python\ndef countGoodIntegers(n, k):\n    from collections import Counter\n    from math import factorial\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits):\n        total_count = 0\n        for i in range(1 << len(digits)):\n            comb = [digits[j] for j in range(len(digits)) if i & (1 << j)]\n            if sum(comb) % k == 0:\n                count = factorial(sum(comb))\n                for d in set(comb):\n                    count //= factorial(comb.count(d))\n                total_count += count\n        return total_count\n    \n    digits = list(range(1, 10)) * (n // 9) + list(range(1, n % 9 + 1))\n    return count_combinations(digits)\n```"]}
{"task_id": "3532", "codes": ["def timeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    def mark_node(node):\n        marked = [False] * n\n        marked[node] = True\n        queue = deque([node])\n        time = 0\n        \n        while queue:\n            time += 1\n            for _ in range(len(queue)):\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if not marked[neighbor]:\n                        if current % 2 == 1:\n                            marked[neighbor] = True\n                            queue.append(neighbor)\n                        elif current % 2 == 0:\n                            marked[neighbor] = True\n                            queue.append(neighbor)\n        \n        times[node] = time\n    \n    times = [0] * n\n    for i in range(n):\n        mark_node(i)\n    \n    return times", "def timeWhenAllNodesAreMarked(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start_time, start_node):\n        visited = set()\n        queue = deque([(start_node, start_time)])\n        max_time = 0\n        \n        while queue:\n            current_node, current_time = queue.popleft()\n            if current_node not in visited:\n                visited.add(current_node)\n                max_time = max(max_time, current_time)\n                for neighbor in graph[current_node]:\n                    if neighbor not in visited:\n                        next_time = current_time + 2 if current_node % 2 == 0 else current_time + 1\n                        queue.append((neighbor, next_time))\n        \n        return max_time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = []\n    \n    for i in range(n):\n        if i % 2 == 0:\n            result.append(bfs(0, i))\n        else:\n            result.append(bfs(1, i))\n    \n    return result", "def minTimes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize marking times and visited set\n    marking_times = [float('inf')] * n\n    visited = set()\n    queue = deque([0])\n    marking_times[0] = 0\n    \n    while queue:\n        current = queue.popleft()\n        visited.add(current)\n        \n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                if current % 2 == 0:\n                    marking_times[neighbor] = max(marking_times[neighbor], marking_times[current] + 2)\n                else:\n                    marking_times[neighbor] = max(marking_times[neighbor], marking_times[current] + 1)\n                queue.append(neighbor)\n    \n    return marking_times", "from collections import deque, defaultdict\n\ndef minTimeToMarkNodes(edges):\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    \n    # Build the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Function to perform BFS and mark nodes\n    def bfs(start_node):\n        queue = deque([start_node])\n        visited = set([start_node])\n        times = [float('inf')] * n\n        times[start_node] = 0\n        \n        while queue:\n            current = queue.popleft()\n            current_time = times[current]\n            \n            for neighbor in adj_list[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if current % 2 == 0:\n                        times[neighbor] = max(times[neighbor], current_time + 2)\n                    else:\n                        times[neighbor] = max(times[neighbor], current_time + 1)\n                    queue.append(neighbor)\n        \n        return times\n    \n    # Mark nodes starting from each node\n    results = []\n    for i in range(n):\n        times = bfs(i)\n        results.append(max(times))\n    \n    return results", "def minTimeToMarkNodes(n, edges):\n    # Step 1: Build the adjacency list\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Find the longest path in the tree\n    def bfs_longest_path(start):\n        visited = [-1] * n\n        queue = [(start, 0)]\n        max_time = 0\n        while queue:\n            node, time = queue.pop(0)\n            if visited[node] != -1:\n                continue\n            visited[node] = time\n            max_time = max(max_time, time)\n            for neighbor in adj_list[node]:\n                if visited[neighbor] == -1:\n                    queue.append((neighbor, time + 1))\n        return max_time\n    \n    # Step 3: Simulate the marking process\n    def simulate_marking():\n        times = [0] * n\n        for start in range(n):\n            visited = [-1] * n\n            queue = [(start, 0)]\n            while queue:\n                node, time = queue.pop(0)\n                if visited[node] != -1:\n                    continue\n                visited[node] = time\n                times[node] = max(times[node], time)\n                for neighbor in adj_list[node]:\n                    if visited[neighbor] == -1:\n                        if node % 2 == 0:\n                            queue.append((neighbor, time + 2))\n                        else:\n                            queue.append((neighbor, time + 1))\n        return times\n    \n    return simulate_marking()", "def minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize the times array\n    times = [0] * n\n    \n    # Find all leaf nodes (nodes with only one neighbor)\n    leaves = [i for i in range(n) if len(adj_list[i]) == 1]\n    \n    # Queue for BFS\n    queue = deque(leaves)\n    \n    # Perform BFS to propagate marking times\n    while queue:\n        node = queue.popleft()\n        parent = None\n        \n        # Get the parent node of the current leaf node\n        for nei in adj_list[node]:\n            if nei != times.index(0):\n                parent = nei\n                break\n        \n        # Update the parent node's marking time based on the current node's marking time\n        if parent is not None:\n            if times[parent] == 0:\n                times[parent] = times[node] + 2 if node % 2 == 0 else times[node] + 1\n                queue.append(parent)\n    \n    return times", "def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start):\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            node, time = queue.popleft()\n            times[node] = max(times[node], time)\n            \n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    if node % 2 == 0:\n                        queue.append((neighbor, time + 2))\n                    else:\n                        queue.append((neighbor, time + 1))\n        \n        return times\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    times = [0] * n\n    \n    for i in range(n):\n        times = bfs(i)\n    \n    return times", "def minTimeToMarkAllNodes(edges):\n    from collections import deque, defaultdict\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize data structures\n    n = len(graph)\n    marked_time = [-1] * n\n    parent = [-1] * n\n    queue = deque([0])\n    marked_time[0] = 0\n    \n    # BFS traversal\n    while queue:\n        current = queue.popleft()\n        \n        for neighbor in graph[current]:\n            if neighbor != parent[current]:\n                if current % 2 == 0:\n                    if marked_time[neighbor] == -1 or marked_time[neighbor] >= marked_time[current] + 2:\n                        marked_time[neighbor] = marked_time[current] + 2\n                        queue.append(neighbor)\n                else:\n                    if marked_time[neighbor] == -1 or marked_time[neighbor] >= marked_time[current] + 1:\n                        marked_time[neighbor] = marked_time[current] + 1\n                        queue.append(neighbor)\n                parent[neighbor] = current\n    \n    return marked_time"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef timeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    def mark_node(node):\n        marked = [False] * n\n        marked[node] = True\n        queue = deque([node])\n        time = 0\n        \n        while queue:\n            time += 1\n            for _ in range(len(queue)):\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if not marked[neighbor]:\n                        if current % 2 == 1:\n                            marked[neighbor] = True\n                            queue.append(neighbor)\n                        elif current % 2 == 0:\n                            marked[neighbor] = True\n                            queue.append(neighbor)\n        \n        times[node] = time\n    \n    times = [0] * n\n    for i in range(n):\n        mark_node(i)\n    \n    return times\n```", "```python\ndef timeWhenAllNodesAreMarked(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start_time, start_node):\n        visited = set()\n        queue = deque([(start_node, start_time)])\n        max_time = 0\n        \n        while queue:\n            current_node, current_time = queue.popleft()\n            if current_node not in visited:\n                visited.add(current_node)\n                max_time = max(max_time, current_time)\n                for neighbor in graph[current_node]:\n                    if neighbor not in visited:\n                        next_time = current_time + 2 if current_node % 2 == 0 else current_time + 1\n                        queue.append((neighbor, next_time))\n        \n        return max_time\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = []\n    \n    for i in range(n):\n        if i % 2 == 0:\n            result.append(bfs(0, i))\n        else:\n            result.append(bfs(1, i))\n    \n    return result\n```", "```python\ndef minTimes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize marking times and visited set\n    marking_times = [float('inf')] * n\n    visited = set()\n    queue = deque([0])\n    marking_times[0] = 0\n    \n    while queue:\n        current = queue.popleft()\n        visited.add(current)\n        \n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                if current % 2 == 0:\n                    marking_times[neighbor] = max(marking_times[neighbor], marking_times[current] + 2)\n                else:\n                    marking_times[neighbor] = max(marking_times[neighbor], marking_times[current] + 1)\n                queue.append(neighbor)\n    \n    return marking_times\n```", "```python\nfrom collections import deque, defaultdict\n\ndef minTimeToMarkNodes(edges):\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    \n    # Build the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Function to perform BFS and mark nodes\n    def bfs(start_node):\n        queue = deque([start_node])\n        visited = set([start_node])\n        times = [float('inf')] * n\n        times[start_node] = 0\n        \n        while queue:\n            current = queue.popleft()\n            current_time = times[current]\n            \n            for neighbor in adj_list[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if current % 2 == 0:\n                        times[neighbor] = max(times[neighbor], current_time + 2)\n                    else:\n                        times[neighbor] = max(times[neighbor], current_time + 1)\n                    queue.append(neighbor)\n        \n        return times\n    \n    # Mark nodes starting from each node\n    results = []\n    for i in range(n):\n        times = bfs(i)\n        results.append(max(times))\n    \n    return results\n```", "```python\ndef minTimeToMarkNodes(n, edges):\n    # Step 1: Build the adjacency list\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Find the longest path in the tree\n    def bfs_longest_path(start):\n        visited = [-1] * n\n        queue = [(start, 0)]\n        max_time = 0\n        while queue:\n            node, time = queue.pop(0)\n            if visited[node] != -1:\n                continue\n            visited[node] = time\n            max_time = max(max_time, time)\n            for neighbor in adj_list[node]:\n                if visited[neighbor] == -1:\n                    queue.append((neighbor, time + 1))\n        return max_time\n    \n    # Step 3: Simulate the marking process\n    def simulate_marking():\n        times = [0] * n\n        for start in range(n):\n            visited = [-1] * n\n            queue = [(start, 0)]\n            while queue:\n                node, time = queue.pop(0)\n                if visited[node] != -1:\n                    continue\n                visited[node] = time\n                times[node] = max(times[node], time)\n                for neighbor in adj_list[node]:\n                    if visited[neighbor] == -1:\n                        if node % 2 == 0:\n                            queue.append((neighbor, time + 2))\n                        else:\n                            queue.append((neighbor, time + 1))\n        return times\n    \n    return simulate_marking()\n```", "```python\ndef minTimeToMarkNodes(n, edges):\n    from collections import defaultdict, deque\n    \n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize the times array\n    times = [0] * n\n    \n    # Find all leaf nodes (nodes with only one neighbor)\n    leaves = [i for i in range(n) if len(adj_list[i]) == 1]\n    \n    # Queue for BFS\n    queue = deque(leaves)\n    \n    # Perform BFS to propagate marking times\n    while queue:\n        node = queue.popleft()\n        parent = None\n        \n        # Get the parent node of the current leaf node\n        for nei in adj_list[node]:\n            if nei != times.index(0):\n                parent = nei\n                break\n        \n        # Update the parent node's marking time based on the current node's marking time\n        if parent is not None:\n            if times[parent] == 0:\n                times[parent] = times[node] + 2 if node % 2 == 0 else times[node] + 1\n                queue.append(parent)\n    \n    return times\n```", "```python\ndef minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    def bfs(start):\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        \n        while queue:\n            node, time = queue.popleft()\n            times[node] = max(times[node], time)\n            \n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    if node % 2 == 0:\n                        queue.append((neighbor, time + 2))\n                    else:\n                        queue.append((neighbor, time + 1))\n        \n        return times\n    \n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    times = [0] * n\n    \n    for i in range(n):\n        times = bfs(i)\n    \n    return times\n```", "```python\ndef minTimeToMarkAllNodes(edges):\n    from collections import deque, defaultdict\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Initialize data structures\n    n = len(graph)\n    marked_time = [-1] * n\n    parent = [-1] * n\n    queue = deque([0])\n    marked_time[0] = 0\n    \n    # BFS traversal\n    while queue:\n        current = queue.popleft()\n        \n        for neighbor in graph[current]:\n            if neighbor != parent[current]:\n                if current % 2 == 0:\n                    if marked_time[neighbor] == -1 or marked_time[neighbor] >= marked_time[current] + 2:\n                        marked_time[neighbor] = marked_time[current] + 2\n                        queue.append(neighbor)\n                else:\n                    if marked_time[neighbor] == -1 or marked_time[neighbor] >= marked_time[current] + 1:\n                        marked_time[neighbor] = marked_time[current] + 1\n                        queue.append(neighbor)\n                parent[neighbor] = current\n    \n    return marked_time\n```"]}
{"task_id": "3560", "codes": ["def minmax(kx, ky, positions):\n    n = len(positions)\n    if n == 0:\n        return 0\n    dp = [[[-1] * n for _ in range(n)] for _ in range(2)]\n\n    def get_moves(x, y):\n        moves = []\n        directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50:\n                moves.append((nx, ny))\n        return moves\n\n    def helper(turn, knight_pos, pawns):\n        if dp[turn][knight_pos][pawns] != -1:\n            return dp[turn][knight_pos][pawns]\n        if len(pawns) == 0:\n            return 0\n        max_moves = float('-inf') if turn == 0 else float('inf')\n        for i, (px, py) in enumerate(pawns):\n            new_pawns = pawns[:i] + pawns[i+1:]\n            knight_moves = get_moves(px, py)\n            for nx, ny in knight_moves:\n                if (nx, ny) == knight_pos:\n                    continue\n                new_knight_pos = (nx, ny)\n                new_moves = 1 + helper(1 - turn, new_knight_pos, new_pawns)\n                if turn == 0:\n                    max_moves = max(max_moves, new_moves)\n                else:\n                    max_moves = min(max_moves, new_moves)\n        dp[turn][knight_pos][pawns] = max_moves\n        return max_moves\n\n    return helper(0, (kx, ky), tuple(sorted(positions)))", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance between the knight and the pawn\n    return abs(kx - px) + abs(ky - py)\n\ndef max_minimax(kx, ky, positions, alice_turn=True):\n    if not positions:\n        return 0\n\n    min_moves = float('inf')\n    for pos in positions:\n        moves = min_moves_to_capture(kx, ky, pos[0], pos[1])\n        remaining_positions = [p for p in positions if p != pos]\n        if alice_turn:\n            result = max_minimax(pos[0], pos[1], remaining_positions, False)\n        else:\n            result = max_minimax(pos[0], pos[1], remaining_positions, True)\n        min_moves = min(min_moves, moves + result)\n\n    return min_moves\n\ndef max_alice_moves(kx, ky, positions):\n    return max_minimax(kx, ky, positions)", "def min_moves_to_reach(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, d = queue.pop(0)\n        if x == px and y == py:\n            return d\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, d + 1))\n    return float('inf')\n\ndef minimax(board, positions, turn, alpha, beta):\n    if not positions:\n        return 0\n    \n    if turn == 'Alice':\n        max_moves = float('-inf')\n        for pos in positions:\n            moves = min_moves_to_reach(board[0], board[1], pos[0], pos[1])\n            new_positions = [p for p in positions if p != pos]\n            max_moves = max(max_moves, minimax((pos[0], pos[1]), new_positions, 'Bob', alpha, beta))\n            alpha = max(alpha, max_moves)\n            if beta <= alpha:\n                break\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for pos in positions:\n            moves = min_moves_to_reach(board[0], board[1], pos[0], pos[1])\n            new_positions = [p for p in positions if p != pos]\n            min_moves = min(min_moves, minimax((pos[0], pos[1]), new_positions, 'Alice', alpha, beta))\n            beta = min(beta, min_moves)\n            if beta <= alpha:\n                break\n        return min_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    return minimax((kx, ky), positions, 'Alice', float('-inf'), float('inf'))", "def min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if (cx, cy) == (px, py):\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves(kx, ky, positions):\n    n = len(positions)\n    dp = {}\n    \n    def dfs(pawns):\n        if not pawns:\n            return 0\n        \n        key = tuple(sorted(pawns))\n        if key in dp:\n            return dp[key]\n        \n        alice_max = float('-inf')\n        for i, (px, py) in enumerate(pawns):\n            min_move_to_capture = min_moves(kx, ky, px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            \n            bob_min = float('inf')\n            for j, (bx, by) in enumerate(remaining_pawns):\n                min_move_for_bob = min_moves(px, py, bx, by)\n                new_remaining_pawns = remaining_pawns[:j] + remaining_pawns[j+1:]\n                bob_min = min(bob_min, dfs(new_remaining_pawns))\n            \n            alice_total_moves = min_move_to_capture + bob_min\n            alice_max = max(alice_max, alice_total_moves)\n        \n        dp[key] = alice_max\n        return alice_max\n    \n    return dfs(tuple(positions))\n\ndef solution(kx, ky, positions):\n    return max_moves(kx, ky, positions)", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [[-1] * n for _ in range(n)]\n    \n    def dfs(i, j):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        px, py = positions[i]\n        min_moves = min_moves_to_capture(kx, ky, px, py)\n        if i == j:\n            dp[i][j] = min_moves\n        else:\n            dp[i][j] = min_moves + dfs(j, i)\n        return dp[i][j]", "def min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if (cx, cy) == (px, py):\n            return moves + 1\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    memo = {}\n    \n    def dp(i, alice_turn):\n        if i >= n:\n            return 0\n        \n        key = (i, alice_turn)\n        if key in memo:\n            return memo[key]\n        \n        total_moves = 0\n        for j in range(n):\n            if positions[j]:\n                moves = min_moves_to_capture(kx, ky, positions[j][0], positions[j][1])\n                positions[j] = None\n                if alice_turn:\n                    total_moves = max(total_moves, moves + dp(j + 1, False))\n                else:\n                    total_moves = min(total_moves, moves + dp(j + 1, True))\n                positions[j] = [positions[j][0], positions[j][1]]\n        \n        memo[key] = total_moves\n        return total_moves\n    \n    return dp(0, True)\n\n# Example usage:\nprint(max_moves_alice(1, 1, [[0, 0]]))  # Output: 4\nprint(max_moves_alice(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_moves_alice(0, 0, [[1, 2], [2, 4]]))  # Output: 3", "```python\nfrom collections import deque\nfrom functools import lru_cache\n\ndef min_moves(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)", "def min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    while queue:\n        x, y, moves = queue.pop(0)\n        if x == px and y == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef dfs(positions, kx, ky, moves, turn, alpha, beta):\n    if not positions:\n        return moves\n    if turn == 'Alice':\n        max_moves = float('-inf')\n        for px, py in positions:\n            new_positions = [pos for pos in positions if pos != (px, py)]\n            new_moves = moves + min_moves(kx, ky, px, py)\n            max_moves = max(max_moves, dfs(new_positions, px, py, new_moves, 'Bob', alpha, beta))\n            alpha = max(alpha, max_moves)\n            if beta <= alpha:\n                break\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for px, py in positions:\n            new_positions = [pos for pos in positions if pos != (px, py)]\n            new_moves = moves + min_moves(kx, ky, px, py)\n            min_moves = min(min_moves, dfs(new_positions, px, py, new_moves, 'Alice', alpha, beta))\n            beta = min(beta, min_moves)\n            if beta <= alpha:\n                break\n        return min_moves\n\ndef knight_game(kx, ky, positions):\n    return dfs(positions, kx, ky, 0, 'Alice', float('-inf'), float('inf'))"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["def minmax(kx, ky, positions):\n    n = len(positions)\n    if n == 0:\n        return 0\n    dp = [[[-1] * n for _ in range(n)] for _ in range(2)]\n\n    def get_moves(x, y):\n        moves = []\n        directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50:\n                moves.append((nx, ny))\n        return moves\n\n    def helper(turn, knight_pos, pawns):\n        if dp[turn][knight_pos][pawns] != -1:\n            return dp[turn][knight_pos][pawns]\n        if len(pawns) == 0:\n            return 0\n        max_moves = float('-inf') if turn == 0 else float('inf')\n        for i, (px, py) in enumerate(pawns):\n            new_pawns = pawns[:i] + pawns[i+1:]\n            knight_moves = get_moves(px, py)\n            for nx, ny in knight_moves:\n                if (nx, ny) == knight_pos:\n                    continue\n                new_knight_pos = (nx, ny)\n                new_moves = 1 + helper(1 - turn, new_knight_pos, new_pawns)\n                if turn == 0:\n                    max_moves = max(max_moves, new_moves)\n                else:\n                    max_moves = min(max_moves, new_moves)\n        dp[turn][knight_pos][pawns] = max_moves\n        return max_moves\n\n    return helper(0, (kx, ky), tuple(sorted(positions)))", "def min_moves_to_capture(kx, ky, px, py):\n    # Calculate the Manhattan distance between the knight and the pawn\n    return abs(kx - px) + abs(ky - py)\n\ndef max_minimax(kx, ky, positions, alice_turn=True):\n    if not positions:\n        return 0\n\n    min_moves = float('inf')\n    for pos in positions:\n        moves = min_moves_to_capture(kx, ky, pos[0], pos[1])\n        remaining_positions = [p for p in positions if p != pos]\n        if alice_turn:\n            result = max_minimax(pos[0], pos[1], remaining_positions, False)\n        else:\n            result = max_minimax(pos[0], pos[1], remaining_positions, True)\n        min_moves = min(min_moves, moves + result)\n\n    return min_moves\n\ndef max_alice_moves(kx, ky, positions):\n    return max_minimax(kx, ky, positions)", "```python\ndef min_moves_to_reach(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, d = queue.pop(0)\n        if x == px and y == py:\n            return d\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, d + 1))\n    return float('inf')\n\ndef minimax(board, positions, turn, alpha, beta):\n    if not positions:\n        return 0\n    \n    if turn == 'Alice':\n        max_moves = float('-inf')\n        for pos in positions:\n            moves = min_moves_to_reach(board[0], board[1], pos[0], pos[1])\n            new_positions = [p for p in positions if p != pos]\n            max_moves = max(max_moves, minimax((pos[0], pos[1]), new_positions, 'Bob', alpha, beta))\n            alpha = max(alpha, max_moves)\n            if beta <= alpha:\n                break\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for pos in positions:\n            moves = min_moves_to_reach(board[0], board[1], pos[0], pos[1])\n            new_positions = [p for p in positions if p != pos]\n            min_moves = min(min_moves, minimax((pos[0], pos[1]), new_positions, 'Alice', alpha, beta))\n            beta = min(beta, min_moves)\n            if beta <= alpha:\n                break\n        return min_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    return minimax((kx, ky), positions, 'Alice', float('-inf'), float('inf'))\n```", "```python\ndef min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        \n        if (cx, cy) == (px, py):\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves(kx, ky, positions):\n    n = len(positions)\n    dp = {}\n    \n    def dfs(pawns):\n        if not pawns:\n            return 0\n        \n        key = tuple(sorted(pawns))\n        if key in dp:\n            return dp[key]\n        \n        alice_max = float('-inf')\n        for i, (px, py) in enumerate(pawns):\n            min_move_to_capture = min_moves(kx, ky, px, py)\n            remaining_pawns = pawns[:i] + pawns[i+1:]\n            \n            bob_min = float('inf')\n            for j, (bx, by) in enumerate(remaining_pawns):\n                min_move_for_bob = min_moves(px, py, bx, by)\n                new_remaining_pawns = remaining_pawns[:j] + remaining_pawns[j+1:]\n                bob_min = min(bob_min, dfs(new_remaining_pawns))\n            \n            alice_total_moves = min_move_to_capture + bob_min\n            alice_max = max(alice_max, alice_total_moves)\n        \n        dp[key] = alice_max\n        return alice_max\n    \n    return dfs(tuple(positions))\n\ndef solution(kx, ky, positions):\n    return max_moves(kx, ky, positions)\n```", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = deque([(kx, ky, 0)])\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.popleft()\n        if cx == px and cy == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [[-1] * n for _ in range(n)]\n    \n    def dfs(i, j):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        px, py = positions[i]\n        min_moves = min_moves_to_capture(kx, ky, px, py)\n        if i == j:\n            dp[i][j] = min_moves\n        else:\n            dp[i][j] = min_moves + dfs(j, i)\n        return dp[i][j]", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if (cx, cy) == (px, py):\n            return moves + 1\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    memo = {}\n    \n    def dp(i, alice_turn):\n        if i >= n:\n            return 0\n        \n        key = (i, alice_turn)\n        if key in memo:\n            return memo[key]\n        \n        total_moves = 0\n        for j in range(n):\n            if positions[j]:\n                moves = min_moves_to_capture(kx, ky, positions[j][0], positions[j][1])\n                positions[j] = None\n                if alice_turn:\n                    total_moves = max(total_moves, moves + dp(j + 1, False))\n                else:\n                    total_moves = min(total_moves, moves + dp(j + 1, True))\n                positions[j] = [positions[j][0], positions[j][1]]\n        \n        memo[key] = total_moves\n        return total_moves\n    \n    return dp(0, True)\n\n# Example usage:\nprint(max_moves_alice(1, 1, [[0, 0]]))  # Output: 4\nprint(max_moves_alice(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_moves_alice(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```", "```python\nfrom collections import deque\nfrom functools import lru_cache\n\ndef min_moves(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)", "```python\ndef min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set((kx, ky))\n    while queue:\n        x, y, moves = queue.pop(0)\n        if x == px and y == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef dfs(positions, kx, ky, moves, turn, alpha, beta):\n    if not positions:\n        return moves\n    if turn == 'Alice':\n        max_moves = float('-inf')\n        for px, py in positions:\n            new_positions = [pos for pos in positions if pos != (px, py)]\n            new_moves = moves + min_moves(kx, ky, px, py)\n            max_moves = max(max_moves, dfs(new_positions, px, py, new_moves, 'Bob', alpha, beta))\n            alpha = max(alpha, max_moves)\n            if beta <= alpha:\n                break\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for px, py in positions:\n            new_positions = [pos for pos in positions if pos != (px, py)]\n            new_moves = moves + min_moves(kx, ky, px, py)\n            min_moves = min(min_moves, dfs(new_positions, px, py, new_moves, 'Alice', alpha, beta))\n            beta = min(beta, min_moves)\n            if beta <= alpha:\n                break\n        return min_moves\n\ndef knight_game(kx, ky, positions):\n    return dfs(positions, kx, ky, 0, 'Alice', float('-inf'), float('inf'))\n```"]}
