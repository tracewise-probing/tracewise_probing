{"difficulty": "hard", "num_threads": 32, "temperature": 0.9, "n": 32, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp09_bug_trace_TPL_NEXT_qwen_7b_hard_n_32.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "def determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "passed": false, "raw_code": "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count_greater_than_one = sum(1 for num in A if num > 1)\n    \n    if count_greater_than_one % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()\n```"}
{"task_id": "abc366_f", "code": "from itertools import permutations\n\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Precompute f_i(1) for all i\n    f_1_values = [B for A, B in functions]\n    \n    # Compute the result for each permutation of p\n    max_value = float('-inf')\n    for perm in permutations(range(1, N + 1)):\n        current_value = 1\n        for pi in perm[:K]:\n            A, B = functions[pi - 1]\n            current_value = A * current_value + B\n        max_value = max(max_value, current_value)\n    \n    print(max_value)\n\nmax_nested_function_value()", "passed": false, "raw_code": "```python\nfrom itertools import permutations\n\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Precompute f_i(1) for all i\n    f_1_values = [B for A, B in functions]\n    \n    # Compute the result for each permutation of p\n    max_value = float('-inf')\n    for perm in permutations(range(1, N + 1)):\n        current_value = 1\n        for pi in perm[:K]:\n            A, B = functions[pi - 1]\n            current_value = A * current_value + B\n        max_value = max(max_value, current_value)\n    \n    print(max_value)\n\nmax_nested_function_value()\n```"}
{"task_id": "arc181_b", "code": "def f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef check_t_exists(S, X, Y):\n    num_ones_X = X.count('1')\n    num_ones_Y = Y.count('1')\n    num_zeros_X = X.count('0')\n    num_zeros_Y = Y.count('0')\n    \n    if num_ones_X != num_ones_Y:\n        length_diff = abs(len(Y) * num_zeros_Y - len(X) * num_zeros_X)\n        num_ones_diff = abs(num_ones_X - num_ones_Y)\n        if length_diff % num_ones_diff == 0:\n            return \"Yes\"\n    else:\n        return \"Yes\"\n    \n    return \"No\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        results.append(check_t_exists(S, X, Y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef check_t_exists(S, X, Y):\n    num_ones_X = X.count('1')\n    num_ones_Y = Y.count('1')\n    num_zeros_X = X.count('0')\n    num_zeros_Y = Y.count('0')\n    \n    if num_ones_X != num_ones_Y:\n        length_diff = abs(len(Y) * num_zeros_Y - len(X) * num_zeros_X)\n        num_ones_diff = abs(num_ones_X - num_ones_Y)\n        if length_diff % num_ones_diff == 0:\n            return \"Yes\"\n    else:\n        return \"Yes\"\n    \n    return \"No\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        results.append(check_t_exists(S, X, Y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc181_c", "code": "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    Q = list(map(int, data[N+1:2*N+1]))\n    \n    # Create an N-by-N grid initialized with 0s\n    grid = [['0'] * N for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(N):\n            if (P.index(i+1) < P.index(j+1) if i < j else j < i):\n                if (Q.index(i+1) < Q.index(j+1) if i < j else j < i):\n                    grid[i][j] = '1'\n    \n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    Q = list(map(int, data[N+1:2*N+1]))\n    \n    # Create an N-by-N grid initialized with 0s\n    grid = [['0'] * N for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(N):\n            if (P.index(i+1) < P.index(j+1) if i < j else j < i):\n                if (Q.index(i+1) < Q.index(j+1) if i < j else j < i):\n                    grid[i][j] = '1'\n    \n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc367_f", "code": "def can_rearrange_subsequences(N, Q, A, B, queries):\n    results = []\n    \n    for l_i, r_i, L_i, R_i in queries:\n        subseq_A = A[l_i - 1:r_i]\n        subseq_B = B[L_i - 1:R_i]\n        \n        # Check if the frequency of elements matches\n        if sorted(subseq_A) == sorted(subseq_B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nQ = int(data[1])\n\nA = list(map(int, data[2:N + 2]))\nB = list(map(int, data[N + 2:2 * N + 2]))\n\nqueries = []\nindex = 2 * N + 2\nfor _ in range(Q):\n    l_i = int(data[index])\n    r_i = int(data[index + 1])\n    L_i = int(data[index + 2])\n    R_i = int(data[index + 3])\n    queries.append((l_i, r_i, L_i, R_i))\n    index += 4\n\n# Process queries and print results\nresults = can_rearrange_subsequences(N, Q, A, B, queries)\nfor result in results:\n    print(result)", "passed": false, "raw_code": "```python\ndef can_rearrange_subsequences(N, Q, A, B, queries):\n    results = []\n    \n    for l_i, r_i, L_i, R_i in queries:\n        subseq_A = A[l_i - 1:r_i]\n        subseq_B = B[L_i - 1:R_i]\n        \n        # Check if the frequency of elements matches\n        if sorted(subseq_A) == sorted(subseq_B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    return results\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nQ = int(data[1])\n\nA = list(map(int, data[2:N + 2]))\nB = list(map(int, data[N + 2:2 * N + 2]))\n\nqueries = []\nindex = 2 * N + 2\nfor _ in range(Q):\n    l_i = int(data[index])\n    r_i = int(data[index + 1])\n    L_i = int(data[index + 2])\n    R_i = int(data[index + 3])\n    queries.append((l_i, r_i, L_i, R_i))\n    index += 4\n\n# Process queries and print results\nresults = can_rearrange_subsequences(N, Q, A, B, queries)\nfor result in results:\n    print(result)\n```"}
{"task_id": "abc365_e", "code": "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Compute cumulative XOR array\nB = [0] * (N + 1)\nfor i in range(1, N + 1):\n    B[i] = B[i - 1] ^ A[i - 1]\n\n# Compute the result\nresult = 0\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        result += B[j] ^ B[i - 1]\n\nprint(result)", "passed": false, "raw_code": "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Compute cumulative XOR array\nB = [0] * (N + 1)\nfor i in range(1, N + 1):\n    B[i] = B[i - 1] ^ A[i - 1]\n\n# Compute the result\nresult = 0\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        result += B[j] ^ B[i - 1]\n\nprint(result)\n```"}
{"task_id": "arc182_d", "code": "def min_operations_to_transform():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:]))\n    \n    # Check if A is already equal to B\n    if A == B:\n        print(0)\n        return\n    \n    total_operations = 0\n    \n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        if diff > M // 2:\n            diff = M - diff\n        \n        total_operations += diff\n    \n    print(total_operations)\n\nmin_operations_to_transform()", "passed": false, "raw_code": "```python\ndef min_operations_to_transform():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    A = list(map(int, data[2:N+2]))\n    B = list(map(int, data[N+2:]))\n    \n    # Check if A is already equal to B\n    if A == B:\n        print(0)\n        return\n    \n    total_operations = 0\n    \n    for i in range(N):\n        diff = abs(A[i] - B[i])\n        if diff > M // 2:\n            diff = M - diff\n        \n        total_operations += diff\n    \n    print(total_operations)\n\nmin_operations_to_transform()\n```"}
{"task_id": "abc367_e", "code": "def transform_sequence(N, K, X, A):\n    # Function to perform one operation\n    def apply_x(sequence, x):\n        return [sequence[x[i] - 1] for i in range(N)]\n    \n    # Detect cycles\n    seen_states = {}\n    current = A\n    for k in range(K):\n        if tuple(current) in seen_states:\n            cycle_start = seen_states[tuple(current)]\n            cycle_length = k - cycle_start\n            effective_k = K - cycle_start\n            effective_k %= cycle_length\n            if effective_k == 0:\n                break\n            k = cycle_start + effective_k\n        seen_states[tuple(current)] = k\n        current = apply_x(current, X)\n    \n    return current\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Transform the sequence\nresult = transform_sequence(N, K, X, A)\n\n# Print the result\nprint(' '.join(map(str, result)))", "passed": false, "raw_code": "```python\ndef transform_sequence(N, K, X, A):\n    # Function to perform one operation\n    def apply_x(sequence, x):\n        return [sequence[x[i] - 1] for i in range(N)]\n    \n    # Detect cycles\n    seen_states = {}\n    current = A\n    for k in range(K):\n        if tuple(current) in seen_states:\n            cycle_start = seen_states[tuple(current)]\n            cycle_length = k - cycle_start\n            effective_k = K - cycle_start\n            effective_k %= cycle_length\n            if effective_k == 0:\n                break\n            k = cycle_start + effective_k\n        seen_states[tuple(current)] = k\n        current = apply_x(current, X)\n    \n    return current\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Transform the sequence\nresult = transform_sequence(N, K, X, A)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```"}
{"task_id": "3532", "code": "def minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    tree = defaultdict(list)\n    \n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_mark_times(node, parent, time):\n        queue = deque([(node, 0)])\n        marked = [False] * n\n        marked[node] = True\n        times[node] = 0\n        \n        while queue:\n            current, t = queue.popleft()\n            for neighbor in tree[current]:\n                if neighbor == parent:\n                    continue\n                if not marked[neighbor]:\n                    marked[neighbor] = True\n                    if current % 2 == 1:\n                        times[neighbor] = t + 1\n                    else:\n                        times[neighbor] = t + 2\n                    queue.append((neighbor, times[neighbor]))\n    \n    times = [0] * n\n    visited = [False] * n\n    \n    for i in range(n):\n        if not visited[i]:\n            bfs_mark_times(i, -1, 0)\n            visited[i] = True\n    \n    return times", "passed": false, "raw_code": "```python\ndef minTimeToMarkAllNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    tree = defaultdict(list)\n    \n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def bfs_mark_times(node, parent, time):\n        queue = deque([(node, 0)])\n        marked = [False] * n\n        marked[node] = True\n        times[node] = 0\n        \n        while queue:\n            current, t = queue.popleft()\n            for neighbor in tree[current]:\n                if neighbor == parent:\n                    continue\n                if not marked[neighbor]:\n                    marked[neighbor] = True\n                    if current % 2 == 1:\n                        times[neighbor] = t + 1\n                    else:\n                        times[neighbor] = t + 2\n                    queue.append((neighbor, times[neighbor]))\n    \n    times = [0] * n\n    visited = [False] * n\n    \n    for i in range(n):\n        if not visited[i]:\n            bfs_mark_times(i, -1, 0)\n            visited[i] = True\n    \n    return times\n```"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if i <= j and j <= i + (nums[i] - nums[j]):\n                count += 1\n    \n    return count % MOD", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if i <= j and j <= i + (nums[i] - nums[j]):\n                count += 1\n    \n    return count % MOD\n```"}
{"task_id": "abc370_e", "code": "def dp(i, j):\n    if i == N:\n        return 1\n    if (i, j) in memo:\n        return memo[(i, j)]\n    total = 0\n    current_sum = 0\n    for k in range(i, j + 1):\n        current_sum += A[k]\n        if current_sum != K:\n            total += dp(k + 1, j)\n    memo[(i, j)] = total % MOD\n    return memo[(i, j)]\n\nMOD = 998244353\nmemo = {}\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nprint(dp(0, N - 1))", "passed": false, "raw_code": "def dp(i, j):\n    if i == N:\n        return 1\n    if (i, j) in memo:\n        return memo[(i, j)]\n    total = 0\n    current_sum = 0\n    for k in range(i, j + 1):\n        current_sum += A[k]\n        if current_sum != K:\n            total += dp(k + 1, j)\n    memo[(i, j)] = total % MOD\n    return memo[(i, j)]\n\nMOD = 998244353\nmemo = {}\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nprint(dp(0, N - 1))"}
{"task_id": "abc371_g", "code": "def find_smallest_array():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:]))\n\n    def permute(arr, perm):\n        return [arr[i-1] for i in perm]\n\n    def find_next_state(arr, perm):\n        states = [arr]\n        while True:\n            arr = permute(arr, perm)\n            if arr in states:\n                break\n            states.append(arr)\n        return min(states)\n\n    smallest_array = find_next_state(A, P)\n    print(' '.join(map(str, smallest_array)))\n\nfind_smallest_array()", "passed": false, "raw_code": "def find_smallest_array():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:]))\n\n    def permute(arr, perm):\n        return [arr[i-1] for i in perm]\n\n    def find_next_state(arr, perm):\n        states = [arr]\n        while True:\n            arr = permute(arr, perm)\n            if arr in states:\n                break\n            states.append(arr)\n        return min(states)\n\n    smallest_array = find_next_state(A, P)\n    print(' '.join(map(str, smallest_array)))\n\nfind_smallest_array()"}
{"task_id": "abc366_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    D = int(data[1])\n    points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\n    \n    count = 0\n    for x in range(-D, D + 1):\n        for y in range(-D, D + 1):\n            total_distance = sum(abs(x - px) + abs(y - py) for px, py in points)\n            if total_distance <= D:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    D = int(data[1])\n    points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\n    \n    count = 0\n    for x in range(-D, D + 1):\n        for y in range(-D, D + 1):\n            total_distance = sum(abs(x - px) + abs(y - py) for px, py in points)\n            if total_distance <= D:\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc372_e", "code": "import heapq\nimport sys\n\ndef process_queries():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    heap = [[] for _ in range(N + 1)]\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            graph[u].append(v)\n            graph[v].append(u)\n            \n            if v not in heap[u]:\n                heapq.heappush(heap[u], v)\n                if len(heap[u]) > 1:\n                    heapq.heappop(heap[u])\n            if u not in heap[v]:\n                heapq.heappush(heap[v], u)\n                if len(heap[v]) > 1:\n                    heapq.heappop(heap[v])\n        else:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            if k > len(heap[v]):\n                print(-1)\n            else:\n                print(heap[v][0] + 1)\n\nprocess_queries()", "passed": false, "raw_code": "```python\nimport heapq\nimport sys\n\ndef process_queries():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(N + 1)]\n    heap = [[] for _ in range(N + 1)]\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            graph[u].append(v)\n            graph[v].append(u)\n            \n            if v not in heap[u]:\n                heapq.heappush(heap[u], v)\n                if len(heap[u]) > 1:\n                    heapq.heappop(heap[u])\n            if u not in heap[v]:\n                heapq.heappush(heap[v], u)\n                if len(heap[v]) > 1:\n                    heapq.heappop(heap[v])\n        else:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            if k > len(heap[v]):\n                print(-1)\n            else:\n                print(heap[v][0] + 1)\n\nprocess_queries()\n```"}
{"task_id": "abc371_f", "code": "def min_movements(N, X, Q, T, G):\n    # Initialize total movements counter\n    total_moves = 0\n    \n    # Iterate through each task\n    for t, g in zip(T, G):\n        # Calculate the absolute difference between the current position and the target position\n        moves = abs(X[t - 1] - g)\n        # Add the moves to the total\n        total_moves += moves\n    \n    # Print the total number of movements\n    print(total_moves)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nX = list(map(int, data[1:N + 1]))\nQ = int(data[N + 1])\nT = list(map(int, data[N + 2:N + Q + 2]))\nG = list(map(int, data[N + Q + 2:]))\n\n# Call the function with parsed input\nmin_movements(N, X, Q, T, G)", "passed": false, "raw_code": "```python\ndef min_movements(N, X, Q, T, G):\n    # Initialize total movements counter\n    total_moves = 0\n    \n    # Iterate through each task\n    for t, g in zip(T, G):\n        # Calculate the absolute difference between the current position and the target position\n        moves = abs(X[t - 1] - g)\n        # Add the moves to the total\n        total_moves += moves\n    \n    # Print the total number of movements\n    print(total_moves)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nX = list(map(int, data[1:N + 1]))\nQ = int(data[N + 1])\nT = list(map(int, data[N + 2:N + Q + 2]))\nG = list(map(int, data[N + Q + 2:]))\n\n# Call the function with parsed input\nmin_movements(N, X, Q, T, G)\n```"}
{"task_id": "abc373_e", "code": "i", "passed": false, "raw_code": "```python\nimport sys\n\ndef solve=N, M, K, A):\n    A.sort()\n    C = [-1] * N\n    for i in range(N):\n        if A[i] > sum(A[i+1:]) + M - 1:\n            C[i] = 0\n        else:\n            needed = sum(A[:i]) + M - 1 - A[i]\n            if needed <= K - sum(A):\n                C[i] = needed\n    print(' '.join(map(str, C)))\n\n# Read input\nN, M, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nsolve(N, M, K, A)"}
{"task_id": "abc368_e", "code": "def min_delays(N, M, X1, trains):\n    # Initialize the list of delays with X1 for the first train\n    delays = [X1] + [0] * (M - 1)\n    \n    # Process each train to determine the necessary delays\n    for i in range(M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(M):\n            if j != i:\n                A_j, B_j, S_j, T_j = trains[j]\n                if B_i == A_j and T_i <= S_j:\n                    necessary_delay = max(0, T_i + delays[i] - S_j)\n                    if necessary_delay > delays[j]:\n                        delays[j] = necessary_delay\n    \n    # Print the delays for trains 2 to M\n    print(' '.join(map(str, delays[1:])))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = [(int(data[3 + 4 * i]), int(data[4 + 4 * i]), int(data[5 + 4 * i]), int(data[6 + 4 * i])) for i in range(M)]\n\n# Call the function with the parsed data\nmin_delays(N, M, X1, trains)", "passed": false, "raw_code": "```python\ndef min_delays(N, M, X1, trains):\n    # Initialize the list of delays with X1 for the first train\n    delays = [X1] + [0] * (M - 1)\n    \n    # Process each train to determine the necessary delays\n    for i in range(M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(M):\n            if j != i:\n                A_j, B_j, S_j, T_j = trains[j]\n                if B_i == A_j and T_i <= S_j:\n                    necessary_delay = max(0, T_i + delays[i] - S_j)\n                    if necessary_delay > delays[j]:\n                        delays[j] = necessary_delay\n    \n    # Print the delays for trains 2 to M\n    print(' '.join(map(str, delays[1:])))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nX1 = int(data[2])\ntrains = [(int(data[3 + 4 * i]), int(data[4 + 4 * i]), int(data[5 + 4 * i]), int(data[6 + 4 * i])) for i in range(M)]\n\n# Call the function with the parsed data\nmin_delays(N, M, X1, trains)\n```"}
{"task_id": "abc373_g", "code": "def find_non_intersecting_sequence(N, P, Q):\n    # Calculate slopes with respect to P[0]\n    slopes = [(Q[i][1] - P[0][1]) / (Q[i][0] - P[0][0]) if Q[i][0] != P[0][0] else float('inf') for i in range(N)]\n    \n    # Sort indices based on slopes\n    sorted_indices = sorted(range(N), key=lambda x: slopes[x])\n    \n    # Stack to keep track of non-intersecting sequence\n    stack = []\n    \n    for i in range(N):\n        index = sorted_indices[i]\n        while stack and stack[-1] > index:\n            stack.pop()\n        stack.append(index)\n    \n    # Check if the sequence is valid\n    if len(stack) == N:\n        return \" \".join(map(str, [i + 1 for i in stack]))\n    else:\n        return \"-1\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\nQ = [(int(data[2*N+2*i+1]), int(data[2*N+2*i+2])) for i in range(N)]\n\n# Find and print the result\nresult = find_non_intersecting_sequence(N, P, Q)\nprint(result)", "passed": false, "raw_code": "```python\ndef find_non_intersecting_sequence(N, P, Q):\n    # Calculate slopes with respect to P[0]\n    slopes = [(Q[i][1] - P[0][1]) / (Q[i][0] - P[0][0]) if Q[i][0] != P[0][0] else float('inf') for i in range(N)]\n    \n    # Sort indices based on slopes\n    sorted_indices = sorted(range(N), key=lambda x: slopes[x])\n    \n    # Stack to keep track of non-intersecting sequence\n    stack = []\n    \n    for i in range(N):\n        index = sorted_indices[i]\n        while stack and stack[-1] > index:\n            stack.pop()\n        stack.append(index)\n    \n    # Check if the sequence is valid\n    if len(stack) == N:\n        return \" \".join(map(str, [i + 1 for i in stack]))\n    else:\n        return \"-1\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\nQ = [(int(data[2*N+2*i+1]), int(data[2*N+2*i+2])) for i in range(N)]\n\n# Find and print the result\nresult = find_non_intersecting_sequence(N, P, Q)\nprint(result)\n```"}
{"task_id": "abc366_g", "code": "def solve_graph_xor_assignment():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    M = int(data[1])\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        index += 2\n\n    # Create augmented matrix for the system of linear equations\n    rows = []\n    cols = []\n    for v in range(1, N + 1):\n        if len(adj_list[v]) % 2 == 1:\n            row = [0] * (N + 1)\n            for neighbor in adj_list[v]:\n                row[neighbor] = 1\n            rows.append(row)\n            cols.append(v)\n\n    # Perform Gaussian elimination over GF(2)\n    def gaussian_elimination(matrix, n):\n        for i in range(n):\n            pivot = None\n            for j in range(i, n):\n                if matrix[j][i] == 1:\n                    pivot = j\n                    break\n            if pivot is None:\n                return False\n            for j in range(n):\n                if matrix[i][j] != matrix[pivot][j]:\n                    matrix[i][j] ^= 1\n            for j in range(n):\n                if j != i and matrix[j][i] == 1:\n                    for k in range(n):\n                        matrix[j][k] ^= matrix[i][k]\n        return True\n\n    if not gaussian_elimination(rows, N):\n        print(\"No\")\n        return\n\n    # Assign values to vertices\n    assignment = [0] * (N + 1)\n    for i, col in enumerate(cols):\n        assignment[col] = 1\n\n    # Print the result\n    print(\"Yes\")\n    for val in assignment[1:]:\n        print(val, end=' ')\n    print()\n\n# Call the function to execute\nsolve_graph_xor_assignment()", "passed": false, "raw_code": "```python\ndef solve_graph_xor_assignment():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    M = int(data[1])\n\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    index = 2\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        index += 2\n\n    # Create augmented matrix for the system of linear equations\n    rows = []\n    cols = []\n    for v in range(1, N + 1):\n        if len(adj_list[v]) % 2 == 1:\n            row = [0] * (N + 1)\n            for neighbor in adj_list[v]:\n                row[neighbor] = 1\n            rows.append(row)\n            cols.append(v)\n\n    # Perform Gaussian elimination over GF(2)\n    def gaussian_elimination(matrix, n):\n        for i in range(n):\n            pivot = None\n            for j in range(i, n):\n                if matrix[j][i] == 1:\n                    pivot = j\n                    break\n            if pivot is None:\n                return False\n            for j in range(n):\n                if matrix[i][j] != matrix[pivot][j]:\n                    matrix[i][j] ^= 1\n            for j in range(n):\n                if j != i and matrix[j][i] == 1:\n                    for k in range(n):\n                        matrix[j][k] ^= matrix[i][k]\n        return True\n\n    if not gaussian_elimination(rows, N):\n        print(\"No\")\n        return\n\n    # Assign values to vertices\n    assignment = [0] * (N + 1)\n    for i, col in enumerate(cols):\n        assignment[col] = 1\n\n    # Print the result\n    print(\"Yes\")\n    for val in assignment[1:]:\n        print(val, end=' ')\n    print()\n\n# Call the function to execute\nsolve_graph_xor_assignment()\n```"}
{"task_id": "abc369_e", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict\nimport heapq\n\ndef min_time(N, M, bridges, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n    \n    # Initialize the dp table\n    dp = [[float('inf')] * (1<<M) for _ in range(N+1)]\n    \n    # Base case: dp[1][0] = 0 (starting at island 1 with no bridges used)\n    dp[1][0] = 0\n    \n    # Fill the dp table\n    for i in range(1, N+1):\n        for mask in range(1<<M):\n            for neighbor, time in graph[i]:\n                new_mask = mask | (1 << bridges.index((i, neighbor, time)))\n                dp[neighbor][new_mask] = min(dp[neighbor][new_mask], dp[i][mask] + time)\n                dp[neighbor][new_mask] = min(dp[neighbor][new_mask], dp[i][mask] + time)\n    \n    # Answer the queries\n    results = []\n    for K, query in queries:\n        query_mask = 0\n        for bridge in query:\n            query_mask |= (1 << (bridge-1))\n        results.append(dp[N][query_mask])\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nbridges = [(int(data[3*i+2]), int(data[3*i+3]), int(data[3*i+4])) for i in range(M)]\nQ = int(data[3*M+2])\nqueries = [[int(data[3*M+4+3*i+2]), int(data[3*M+4+3*i+3]), int(data[3*M+4+3*i+4]), int(data[3*M+4+3*i+5])] for i in range(Q)]\n\n# Get the results\nresults = min_time(N, M, bridges, queries)\n\n# Print the results\nfor result in results:\n    print(result)"}
{"task_id": "abc372_g", "code": "def count_valid_pairs(N, A, B, C):\n    max_x = [0] * N\n    max_y = [0] * N\n    \n    for i in range(N):\n        if A[i] == 0:\n            max_x[i] = float('inf')\n        else:\n            max_x[i] = (C[i] - B[i] * 0) // A[i]\n        \n        if B[i] == 0:\n            max_y[i] = float('inf')\n        else:\n            max_y[i] = (C[i] - A[i] * 0) // B[i]\n    \n    count = 0\n    for y in range(1, max(max_y)):\n        for x in range(1, min(max_x) + 1):\n            valid = True\n            for i in range(N):\n                if A[i] * x + B[i] * y >= C[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n                \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        \n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef count_valid_pairs(N, A, B, C):\n    max_x = [0] * N\n    max_y = [0] * N\n    \n    for i in range(N):\n        if A[i] == 0:\n            max_x[i] = float('inf')\n        else:\n            max_x[i] = (C[i] - B[i] * 0) // A[i]\n        \n        if B[i] == 0:\n            max_y[i] = float('inf')\n        else:\n            max_y[i] = (C[i] - A[i] * 0) // B[i]\n    \n    count = 0\n    for y in range(1, max(max_y)):\n        for x in range(1, min(max_x) + 1):\n            valid = True\n            for i in range(N):\n                if A[i] * x + B[i] * y >= C[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n                \n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        \n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc181_d", "code": "def fenwick_query(bit, index):\n    result = 0\n    while index > 0:\n        result += bit[index]\n        index -= index & (-index)\n    return result\n\ndef fenwick_update(bit, index, value):\n    while index < len(bit):\n        bit[index] += value\n        index += index & (-index)\n\ndef get_inversion_number(n, p):\n    bit = [0] * (n + 1)\n    inversions = 0\n    for i in range(n):\n        inversions += i - fenwick_query(bit, p[i])\n        fenwick_update(bit, p[i], 1)\n    return inversions\n\ndef process_operations(n, p, m, a):\n    results = []\n    for k in a:\n        for i in range(k - 1):\n            if p[i] > p[i + 1]:\n                p[i], p[i + 1] = p[i + 1], p[i]\n        results.append(get_inversion_number(n, p))\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n + 1]))\n    m = int(data[n + 1])\n    a = list(map(int, data[n + 2:n + m + 2]))\n    \n    results = process_operations(n, p, m, a)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef fenwick_query(bit, index):\n    result = 0\n    while index > 0:\n        result += bit[index]\n        index -= index & (-index)\n    return result\n\ndef fenwick_update(bit, index, value):\n    while index < len(bit):\n        bit[index] += value\n        index += index & (-index)\n\ndef get_inversion_number(n, p):\n    bit = [0] * (n + 1)\n    inversions = 0\n    for i in range(n):\n        inversions += i - fenwick_query(bit, p[i])\n        fenwick_update(bit, p[i], 1)\n    return inversions\n\ndef process_operations(n, p, m, a):\n    results = []\n    for k in a:\n        for i in range(k - 1):\n            if p[i] > p[i + 1]:\n                p[i], p[i + 1] = p[i + 1], p[i]\n        results.append(get_inversion_number(n, p))\n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n + 1]))\n    m = int(data[n + 1])\n    a = list(map(int, data[n + 2:n + m + 2]))\n    \n    results = process_operations(n, p, m, a)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    total_sum = 0\n    \n    for i in range(N):\n        seen = set()\n        for j in range(i, N):\n            seen.add(A[j])\n            total_sum += len(seen)\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    total_sum = 0\n    \n    for i in range(N):\n        seen = set()\n        for j in range(i, N):\n            seen.add(A[j])\n            total_sum += len(seen)\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc367_g", "code": "d", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Calculate the total number of subsequences\n    total_subsequences = 2**N\n    \n    # Calculate the sum of powers of 2 modulo MOD\n    pow_of_two = [1]\n    for i in range(1, N):\n        pow_of_two.append((pow_of_two[-1] * 2) % MOD)\n    \n    # Calculate the sum of XORs for subsequences of each length\n    xor_sum = [0] * (N + 1)\n    for a in A:\n        for j in range(N, 0, -1):\n            xor_sum[j] = (xor_sum[j] + a * pow_of_two[j - 1]) % MOD\n    \n    # Calculate the number of subsequences of each length that are multiples of M\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(1, N + 1):\n        dp[i] = (dp[i - 1] * 2) % MOD\n    \n    # Calculate the final result\n    result = 0\n    for i in range(1, N + 1):\n        if i % M == 0:\n            result += pow(xor_sum[i], K, MOD)\n        result %= MOD\n    \n    print(result)\n\nmain()"}
{"task_id": "3527", "code": "def countAlternatingGroups(colors, queries):\n    n = len(colors)\n    def is_alternating_group(start, size):\n        for i in range(1, size):\n            if colors[(start + i) % n] == colors[(start + i - 1) % n]:\n                return False\n        return True\n\n    def count_groups(size):\n        count = 0\n        for i in range(n):\n            if is_alternating_group(i, size):\n                count += 1\n        return count\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_groups(query[1]))\n        elif query[0] == 2:\n            colors[query[1]] = query[2]\n\n    return result", "passed": false, "raw_code": "def countAlternatingGroups(colors, queries):\n    n = len(colors)\n    def is_alternating_group(start, size):\n        for i in range(1, size):\n            if colors[(start + i) % n] == colors[(start + i - 1) % n]:\n                return False\n        return True\n\n    def count_groups(size):\n        count = 0\n        for i in range(n):\n            if is_alternating_group(i, size):\n                count += 1\n        return count\n\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_groups(query[1]))\n        elif query[0] == 2:\n            colors[query[1]] = query[2]\n\n    return result"}
{"task_id": "abc370_f", "code": "def can_divide(masses, K, min_mass):\n    n = len(masses)\n    current_sum = 0\n    cut_count = 0\n\n    for i in range(n):\n        current_sum += masses[i]\n        if current_sum >= min_mass:\n            cut_count += 1\n            current_sum = 0\n\n    return K <= cut_count\n\ndef find_min_mass(masses, K):\n    total_mass = sum(masses)\n    left, right = 1, total_mass\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_divide(masses, K, mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\ndef count_uncut_cut_lines(masses, K, min_mass):\n    n = len(masses)\n    current_sum = 0\n    cut_count = 0\n    last_cut = -1\n\n    for i in range(n):\n        current_sum += masses[i]\n        if current_sum >= min_mass:\n            cut_count += 1\n            last_cut = i\n            current_sum = 0\n\n    return n - last_cut - 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    masses = list(map(int, data[2:]))\n\n    min_mass = find_min_mass(masses, K)\n    uncut_cut_lines = count_uncut_cut_lines(masses, K, min_mass)\n\n    print(min_mass, uncut_cut_lines)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_divide(masses, K, min_mass):\n    n = len(masses)\n    current_sum = 0\n    cut_count = 0\n\n    for i in range(n):\n        current_sum += masses[i]\n        if current_sum >= min_mass:\n            cut_count += 1\n            current_sum = 0\n\n    return K <= cut_count\n\ndef find_min_mass(masses, K):\n    total_mass = sum(masses)\n    left, right = 1, total_mass\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_divide(masses, K, mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\ndef count_uncut_cut_lines(masses, K, min_mass):\n    n = len(masses)\n    current_sum = 0\n    cut_count = 0\n    last_cut = -1\n\n    for i in range(n):\n        current_sum += masses[i]\n        if current_sum >= min_mass:\n            cut_count += 1\n            last_cut = i\n            current_sum = 0\n\n    return n - last_cut - 1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    masses = list(map(int, data[2:]))\n\n    min_mass = find_min_mass(masses, K)\n    uncut_cut_lines = count_uncut_cut_lines(masses, K, min_mass)\n\n    print(min_mass, uncut_cut_lines)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc372_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    # Parse edge connections\n    edges = []\n    index = 3\n    for _ in range(M):\n        x = int(data[index])\n        y = int(data[index + 1])\n        edges.append((x, y))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][1] = 1\n    \n    # Fill DP table\n    for i in range(1, K + 1):\n        for j in range(1, N + 1):\n            if j == 1:\n                dp[i][1] = (dp[i][1] + dp[i-1][N]) % MOD\n            else:\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD\n            for x, y in edges:\n                if x == j:\n                    dp[i][y] = (dp[i][y] + dp[i-1][j]) % MOD\n    \n    # Sum up all ways to be at any vertex after K steps\n    result = sum(dp[K][1:]) % MOD\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    # Parse edge connections\n    edges = []\n    index = 3\n    for _ in range(M):\n        x = int(data[index])\n        y = int(data[index + 1])\n        edges.append((x, y))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][1] = 1\n    \n    # Fill DP table\n    for i in range(1, K + 1):\n        for j in range(1, N + 1):\n            if j == 1:\n                dp[i][1] = (dp[i][1] + dp[i-1][N]) % MOD\n            else:\n                dp[i][j] = (dp[i][j] + dp[i-1][j-1]) % MOD\n            for x, y in edges:\n                if x == j:\n                    dp[i][y] = (dp[i][y] + dp[i-1][j]) % MOD\n    \n    # Sum up all ways to be at any vertex after K steps\n    result = sum(dp[K][1:]) % MOD\n    print(result)\n\nmain()\n```"}
{"task_id": "abc368_d", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    stdin = sys.stdin.read\n    data = stdin().split()\n    index = 0\n\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n\n    edges = []\n    for _ in range(N - 1):\n        A = int(data[index])\n        B = int(data[index + 1])\n        edges.append((A, B))\n        index += 2\n\n    V = list(map(int, data[index:index + K]))\n    index += K\n\n    return N, K, edges, V\n\ndef find_min_vertices(N, K, edges, V):\n    # Step 1: Construct the graph\n    graph = defaultdict(list)\n    for A, B in edges:\n        graph[A].append(B)\n        graph[B].append(A)\n\n    # Step 2: Find the minimum spanning tree (MST) using Kruskal's algorithm\n    edges.sort(key=lambda x: (x[0], x[1]))\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst_edges = []\n    for A, B in edges:\n        if find(A) != find(B):\n            union(A, B)\n            mst_edges.append((A, B))\n\n    # Step 3: Find the minimum number of vertices in the tree including all V\n    visited = set()\n    queue = deque([V[0]])\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n\n    return len(visited)\n\ndef main():\n    N, K, edges, V = read_input()\n    result = find_min_vertices(N, K, edges, V)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    stdin = sys.stdin.read\n    data = stdin().split()\n    index = 0\n\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n\n    edges = []\n    for _ in range(N - 1):\n        A = int(data[index])\n        B = int(data[index + 1])\n        edges.append((A, B))\n        index += 2\n\n    V = list(map(int, data[index:index + K]))\n    index += K\n\n    return N, K, edges, V\n\ndef find_min_vertices(N, K, edges, V):\n    # Step 1: Construct the graph\n    graph = defaultdict(list)\n    for A, B in edges:\n        graph[A].append(B)\n        graph[B].append(A)\n\n    # Step 2: Find the minimum spanning tree (MST) using Kruskal's algorithm\n    edges.sort(key=lambda x: (x[0], x[1]))\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst_edges = []\n    for A, B in edges:\n        if find(A) != find(B):\n            union(A, B)\n            mst_edges.append((A, B))\n\n    # Step 3: Find the minimum number of vertices in the tree including all V\n    visited = set()\n    queue = deque([V[0]])\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n\n    return len(visited)\n\ndef main():\n    N, K, edges, V = read_input()\n    result = find_min_vertices(N, K, edges, V)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc370_g", "code": "from math import gcd\nfrom sys import stdin, stdout\nfrom functools import lru_cache\nMOD = 998244353\n\n@lru_cache(None)\ndef div_sum(n):\n    res = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            res += i\n            if i != n // i:\n                res += n // i\n    return res\n\ndef good(n):\n    return div_sum(n) % 3 == 0\n\n@lru_cache(None)\ndef dp(i, prod, m, k):\n    if i == m:\n        return good(prod)\n    res = 0\n    for j in range(1, min(prod + 1, n) // prod + 1):\n        res = (res + dp(i + 1, prod * j, m, (k * div_sum(j)) % 3)) % MOD\n    return res\n\nN, M = map(int, stdin.readline().split())\nstdout.write(str(dp(0, 1, M, 0)) + '\\n')\n", "passed": false, "raw_code": "from math import gcd\nfrom sys import stdin, stdout\nfrom functools import lru_cache\nMOD = 998244353\n\n@lru_cache(None)\ndef div_sum(n):\n    res = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            res += i\n            if i != n // i:\n                res += n // i\n    return res\n\ndef good(n):\n    return div_sum(n) % 3 == 0\n\n@lru_cache(None)\ndef dp(i, prod, m, k):\n    if i == m:\n        return good(prod)\n    res = 0\n    for j in range(1, min(prod + 1, n) // prod + 1):\n        res = (res + dp(i + 1, prod * j, m, (k * div_sum(j)) % 3)) % MOD\n    return res\n\nN, M = map(int, stdin.readline().split())\nstdout.write(str(dp(0, 1, M, 0)) + '\\n')\n"}
{"task_id": "abc373_f", "code": "def max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for _ in range(N):\n        w_i = int(data[index])\n        v_i = int(data[index + 1])\n        index += 2\n        \n        for w in range(W, w_i - 1, -1):\n            max_k = min(10**10, w // w_i)\n            for k in range(max_k, 0, -1):\n                dp[w] = max(dp[w], dp[w - k * w_i] + k * v_i - k**2)\n    \n    print(dp[W])\n\nmax_happiness()", "passed": false, "raw_code": "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for _ in range(N):\n        w_i = int(data[index])\n        v_i = int(data[index + 1])\n        index += 2\n        \n        for w in range(W, w_i - 1, -1):\n            max_k = min(10**10, w // w_i)\n            for k in range(max_k, 0, -1):\n                dp[w] = max(dp[w], dp[w - k * w_i] + k * v_i - k**2)\n    \n    print(dp[W])\n\nmax_happiness()\n```"}
{"task_id": "abc369_g", "code": "import sys\nfrom typing import List\n\ndef floyd_warshall(n: int, dist: List[List[int]]) -> None:\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\ndef dfs(graph: List[List[int]], node: int, parent: int, dist: List[List[int]]):\n    for neighbor, weight in graph[node]:\n        if neighbor != parent:\n            dist[node][neighbor] = weight\n            dist[neighbor][node] = weight\n            dfs(graph, neighbor, node, dist)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    graph = [[] for _ in range(n)]\n    \n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        l = int(data[index + 2])\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n        index += 3\n    \n    # Initialize distance matrix with infinity\n    dist = [[float('inf')] * n for _ in range(n)]\n    \n    # Set diagonal elements to 0\n    for i in range(n):\n        dist[i][i] = 0\n    \n    # Calculate distances from node 0 to all other nodes\n    dfs(graph, 0, -1, dist)\n    \n    # Floyd-Warshall to find all pairs shortest paths\n    floyd_warshall(n, dist)\n    \n    results = []\n    \n    for k in range(1, n + 1):\n        max_score = float('-inf')\n        \n        def dp(subset):\n            nonlocal max_score\n            if len(subset) == k:\n                score = 0\n                current_node = 0\n                for next_node in subset:\n                    score += dist[current_node][next_node]\n                    current_node = next_node\n                score += dist[current_node][0]\n                max_score = max(max_score, score)\n                return\n            \n            for next_node in range(n):\n                if next_node not in subset:\n                    dp(subset | {next_node})\n        \n        dp(set())\n        results.append(max_score)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom typing import List\n\ndef floyd_warshall(n: int, dist: List[List[int]]) -> None:\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\ndef dfs(graph: List[List[int]], node: int, parent: int, dist: List[List[int]]):\n    for neighbor, weight in graph[node]:\n        if neighbor != parent:\n            dist[node][neighbor] = weight\n            dist[neighbor][node] = weight\n            dfs(graph, neighbor, node, dist)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    graph = [[] for _ in range(n)]\n    \n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        l = int(data[index + 2])\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n        index += 3\n    \n    # Initialize distance matrix with infinity\n    dist = [[float('inf')] * n for _ in range(n)]\n    \n    # Set diagonal elements to 0\n    for i in range(n):\n        dist[i][i] = 0\n    \n    # Calculate distances from node 0 to all other nodes\n    dfs(graph, 0, -1, dist)\n    \n    # Floyd-Warshall to find all pairs shortest paths\n    floyd_warshall(n, dist)\n    \n    results = []\n    \n    for k in range(1, n + 1):\n        max_score = float('-inf')\n        \n        def dp(subset):\n            nonlocal max_score\n            if len(subset) == k:\n                score = 0\n                current_node = 0\n                for next_node in subset:\n                    score += dist[current_node][next_node]\n                    current_node = next_node\n                score += dist[current_node][0]\n                max_score = max(max_score, score)\n                return\n            \n            for next_node in range(n):\n                if next_node not in subset:\n                    dp(subset | {next_node})\n        \n        dp(set())\n        results.append(max_score)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc183_b", "code": "def can_make_identical(A, B, K):\n    from collections import Counter\n    \n    # Count the occurrences of each element in A and B\n    count_A = Counter(A)\n    count_B = Counter(B)\n    \n    # Sort the elements of B\n    sorted_B = sorted(B)\n    \n    # Check if there is a corresponding element in A within the allowed range\n    for b in sorted_B:\n        if count_B[b] == 0:\n            continue\n        \n        # Find the range [b-K, b+K] in A\n        found = False\n        for i, a in enumerate(A):\n            if abs(a - b) <= K and count_A[a] > 0:\n                count_A[a] -= 1\n                count_B[b] -= 1\n                found = True\n                break\n        \n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 + 2 * N\n        \n        result = can_make_identical(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_make_identical(A, B, K):\n    from collections import Counter\n    \n    # Count the occurrences of each element in A and B\n    count_A = Counter(A)\n    count_B = Counter(B)\n    \n    # Sort the elements of B\n    sorted_B = sorted(B)\n    \n    # Check if there is a corresponding element in A within the allowed range\n    for b in sorted_B:\n        if count_B[b] == 0:\n            continue\n        \n        # Find the range [b-K, b+K] in A\n        found = False\n        for i, a in enumerate(A):\n            if abs(a - b) <= K and count_A[a] > 0:\n                count_A[a] -= 1\n                count_B[b] -= 1\n                found = True\n                break\n        \n        if not found:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        A = list(map(int, data[index + 2:index + 2 + N]))\n        B = list(map(int, data[index + 2 + N:index + 2 + 2 * N]))\n        index += 2 + 2 * N\n        \n        result = can_make_identical(A, B, K)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    n = len(damage)\n    enemies = [(d, h) for d, h in zip(damage, health)]\n    enemies.sort(key=lambda x: x[1] / x[0], reverse=True)\n    \n    total_damage = 0\n    time_passed = 0\n    \n    for d, h in enemies:\n        if h > 0:\n            attacks_needed = (h - 1) // power + 1\n            total_damage += attacks_needed * d\n            time_passed += attacks_needed\n    \n    return total_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    enemies = [(d, h) for d, h in zip(damage, health)]\n    enemies.sort(key=lambda x: x[1] / x[0], reverse=True)\n    \n    total_damage = 0\n    time_passed = 0\n    \n    for d, h in enemies:\n        if h > 0:\n            attacks_needed = (h - 1) // power + 1\n            total_damage += attacks_needed * d\n            time_passed += attacks_needed\n    \n    return total_damage\n```"}
{"task_id": "arc182_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Compute the cycle length of C * k % M\n    cycle = []\n    seen = set()\n    current = 0\n    while current not in seen:\n        seen.add(current)\n        cycle.append(current)\n        current = (current + C) % M\n    \n    cycle_length = len(cycle)\n    \n    # Sum the minimum values for each unique value in the cycle\n    total_sum = 0\n    for c in cycle:\n        min_val = min((c + ai) % M for ai in A)\n        total_sum += min_val * ((K // cycle_length) + (1 if K % cycle_length > cycle.index(c) else 0))\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Compute the cycle length of C * k % M\n    cycle = []\n    seen = set()\n    current = 0\n    while current not in seen:\n        seen.add(current)\n        cycle.append(current)\n        current = (current + C) % M\n    \n    cycle_length = len(cycle)\n    \n    # Sum the minimum values for each unique value in the cycle\n    total_sum = 0\n    for c in cycle:\n        min_val = min((c + ai) % M for ai in A)\n        total_sum += min_val * ((K // cycle_length) + (1 if K % cycle_length > cycle.index(c) else 0))\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3563", "code": "def maxScore(grid):\n    def backtrack(row, path, used_values):\n        if row == len(grid):\n            return sum(grid[r][c] for r, c in path)\n        \n        max_score = 0\n        for col in range(len(grid[row])):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                path.append((row, col))\n                max_score = max(max_score, backtrack(row + 1, path, used_values))\n                path.pop()\n                used_values.remove(grid[row][col])\n        \n        return max_score\n    \n    return backtrack(0, [], set())\n\n# Example usage:\ngrid1 = [[1,2,3],[4,3,2],[1,1,1]]\nprint(maxScore(grid1))  # Output: 8\n\ngrid2 = [[8,7,6],[8,3,2]]\nprint(maxScore(grid2))  # Output: 15", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    def backtrack(row, path, used_values):\n        if row == len(grid):\n            return sum(grid[r][c] for r, c in path)\n        \n        max_score = 0\n        for col in range(len(grid[row])):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                path.append((row, col))\n                max_score = max(max_score, backtrack(row + 1, path, used_values))\n                path.pop()\n                used_values.remove(grid[row][col])\n        \n        return max_score\n    \n    return backtrack(0, [], set())\n\n# Example usage:\ngrid1 = [[1,2,3],[4,3,2],[1,1,1]]\nprint(maxScore(grid1))  # Output: 8\n\ngrid2 = [[8,7,6],[8,3,2]]\nprint(maxScore(grid2))  # Output: 15\n```"}
{"task_id": "arc183_d", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_leaves(graph):\n    leaves = []\n    degrees = defaultdict(int)\n    for u, v in graph:\n        degrees[u] += 1\n        degrees[v] += 1\n    for node, deg in degrees.items():\n        if deg == 1:\n            leaves.append(node)\n    return leaves\n\ndef max_score_operations(N, edges):\n    graph = set()\n    for a, b in edges:\n        graph.add((a, b))\n    \n    leaves = find_leaves(graph)\n    result = []\n    \n    while len(leaves) >= 2:\n        # Find the furthest leaves\n        farthest = None\n        max_dist = -1\n        for leaf1 in leaves:\n            for leaf2 in leaves:\n                if leaf1 != leaf2:\n                    dist = bfs_distance(leaf1, leaf2, graph)\n                    if dist > max_dist:\n                        max_dist = dist\n                        farthest = (leaf1, leaf2)\n        \n        # Add the pair to the result\n        result.append(farthest)\n        \n        # Update the graph by removing the selected leaves\n        u, v = farthest\n        graph.remove((u, v))\n        graph.remove((v, u))\n        \n        # Update the leaves list\n        leaves.remove(u)\n        leaves.remove(v)\n        leaves.extend(find_leaves(graph))\n    \n    return result\n\ndef bfs_distance(start, end, graph):\n    visited = set()\n    queue = deque([(start, 0)])\n    visited.add(start)\n    \n    while queue:\n        current, dist = queue.popleft()\n        if current == end:\n            return dist\n        for neighbor in [n for n in range(1, max(current, end) + 1) if (current, n) in graph or (n, current) in graph]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n    \n    return -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(N // 2)]\n\n# Compute and print the result\nresult = max_score_operations(N, edges)\nfor pair in result:\n    print(pair[0], pair[1])"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    n = len(coordinates)\n    coordinates.sort()\n    \n    # Create a graph representation\n    graph = [[] for _ in range(n)]\n    indegree = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    n = len(coordinates)\n    coordinates.sort()\n    \n    # Create a graph representation\n    graph = [[] for _ in range(n)]\n    indegree = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sort using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]\n```"}
{"task_id": "abc368_g", "code": "import sys\nfrom collections import deque\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nQ = int(input())\n\nqueries = deque()\n\nfor _ in range(Q):\n    query = input().split()\n    if query[0] == '1':\n        i = int(query[1]) - 1\n        x = int(query[2])\n        queries.append((1, i, x))\n    elif query[0] == '2':\n        i = int(query[1]) - 1\n        x = int(query[2])\n        queries.append((2, i, x))\n    elif query[0] == '3':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        queries.append((3, l, r))\n\ndef process_queries(A, B, queries):\n    while queries:\n        q_type, l, r = queries.popleft()\n        if q_type == 1:\n            A[l] = r\n        elif q_type == 2:\n            B[l] = r\n        elif q_type == 3:\n            v = 0\n            for i in range(l, r + 1):\n                v = max(v + A[i], v * B[i])\n            print(v)\n\nprocess_queries(A, B, queries)", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import deque\n\nN = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nQ = int(input())\n\nqueries = deque()\n\nfor _ in range(Q):\n    query = input().split()\n    if query[0] == '1':\n        i = int(query[1]) - 1\n        x = int(query[2])\n        queries.append((1, i, x))\n    elif query[0] == '2':\n        i = int(query[1]) - 1\n        x = int(query[2])\n        queries.append((2, i, x))\n    elif query[0] == '3':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        queries.append((3, l, r))\n\ndef process_queries(A, B, queries):\n    while queries:\n        q_type, l, r = queries.popleft()\n        if q_type == 1:\n            A[l] = r\n        elif q_type == 2:\n            B[l] = r\n        elif q_type == 3:\n            v = 0\n            for i in range(l, r + 1):\n                v = max(v + A[i], v * B[i])\n            print(v)\n\nprocess_queries(A, B, queries)\n```"}
{"task_id": "3575", "code": "def max_value_of_subsequence(nums, k):\n    n = len(nums)\n    max_val = float('-inf')\n    \n    # Generate all possible subsequences of size 2*k\n    from itertools import combinations\n    \n    for subseq in combinations(nums, 2 * k):\n        first_half = subseq[:k]\n        second_half = subseq[k:]\n        \n        # Calculate the value of the subsequence\n        value = 0\n        for num in first_half:\n            value |= num\n        \n        xor_value = 0\n        for num in second_half:\n            xor_value |= num\n        \n        result = value ^ xor_value\n        \n        # Update the maximum value\n        if result > max_val:\n            max_val = result\n    \n    return max_val", "passed": false, "raw_code": "```python\ndef max_value_of_subsequence(nums, k):\n    n = len(nums)\n    max_val = float('-inf')\n    \n    # Generate all possible subsequences of size 2*k\n    from itertools import combinations\n    \n    for subseq in combinations(nums, 2 * k):\n        first_half = subseq[:k]\n        second_half = subseq[k:]\n        \n        # Calculate the value of the subsequence\n        value = 0\n        for num in first_half:\n            value |= num\n        \n        xor_value = 0\n        for num in second_half:\n            xor_value |= num\n        \n        result = value ^ xor_value\n        \n        # Update the maximum value\n        if result > max_val:\n            max_val = result\n    \n    return max_val\n```"}
{"task_id": "3552", "code": "def largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    # Start with the largest n-digit number\n    max_num = int('9' * n)\n    \n    while True:\n        if is_divisible_by_k(max_num) and is_palindrome(max_num):\n            return str(max_num)\n        max_num -= 1\n        if len(str(max_num)) < n:\n            break\n    \n    return \"-1\"  # No valid k-palindrome found within the constraints", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num):\n        return num % k == 0\n    \n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    # Start with the largest n-digit number\n    max_num = int('9' * n)\n    \n    while True:\n        if is_divisible_by_k(max_num) and is_palindrome(max_num):\n            return str(max_num)\n        max_num -= 1\n        if len(str(max_num)) < n:\n            break\n    \n    return \"-1\"  # No valid k-palindrome found within the constraints\n```"}
{"task_id": "3550", "code": "def max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    row_occupied = [False] * rows\n    col_occupied = [False] * cols\n    \n    def get_non_zero_positions():\n        non_zero_positions = []\n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] != 0 and not row_occupied[i] and not col_occupied[j]:\n                    non_zero_positions.append((i, j))\n        return non_zero_positions\n    \n    def calculate_max_sum(positions):\n        return sum(board[i][j] for i, j in positions[:3])\n    \n    non_zero_positions = get_non_zero_positions()\n    if len(non_zero_positions) < 3:\n        return 0\n    \n    max_sum = 0\n    for i in range(len(non_zero_positions)):\n        for j in range(i + 1, len(non_zero_positions)):\n            for k in range(j + 1, len(non_zero_positions)):\n                pos1, pos2, pos3 = non_zero_positions[i], non_zero_positions[j], non_zero_positions[k]\n                if pos1[0] != pos2[0] and pos1[0] != pos3[0] and pos2[0] != pos3[0]:\n                    if pos1[1] != pos2[1] and pos1[1] != pos3[1] and pos2[1] != pos3[1]:\n                        max_sum = max(max_sum, calculate_max_sum([pos1, pos2, pos3]))\n    \n    return max_sum", "passed": false, "raw_code": "```python\ndef max_rook_sum(board):\n    rows, cols = len(board), len(board[0])\n    row_occupied = [False] * rows\n    col_occupied = [False] * cols\n    \n    def get_non_zero_positions():\n        non_zero_positions = []\n        for i in range(rows):\n            for j in range(cols):\n                if board[i][j] != 0 and not row_occupied[i] and not col_occupied[j]:\n                    non_zero_positions.append((i, j))\n        return non_zero_positions\n    \n    def calculate_max_sum(positions):\n        return sum(board[i][j] for i, j in positions[:3])\n    \n    non_zero_positions = get_non_zero_positions()\n    if len(non_zero_positions) < 3:\n        return 0\n    \n    max_sum = 0\n    for i in range(len(non_zero_positions)):\n        for j in range(i + 1, len(non_zero_positions)):\n            for k in range(j + 1, len(non_zero_positions)):\n                pos1, pos2, pos3 = non_zero_positions[i], non_zero_positions[j], non_zero_positions[k]\n                if pos1[0] != pos2[0] and pos1[0] != pos3[0] and pos2[0] != pos3[0]:\n                    if pos1[1] != pos2[1] and pos1[1] != pos3[1] and pos2[1] != pos3[1]:\n                        max_sum = max(max_sum, calculate_max_sum([pos1, pos2, pos3]))\n    \n    return max_sum\n```"}
{"task_id": "3551", "code": "def max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        xor_score = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(xor_score)\n    \n    return result", "passed": false, "raw_code": "```python\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    \n    # Compute prefix XOR array\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    result = []\n    \n    # Process each query\n    for l, r in queries:\n        xor_score = prefix_xor[r + 1] ^ prefix_xor[l]\n        result.append(xor_score)\n    \n    return result\n```"}
{"task_id": "3583", "code": "def gcd_pairs(nums, queries):\n    from collections import defaultdict\n    from math import gcd\n    \n    n = len(nums)\n    gcd_map = defaultdict(int)\n    \n    # Calculate GCD for all pairs and store in frequency map\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_map[g] += 1\n    \n    # Get all unique GCDs and sort them\n    unique_gcds = sorted(gcd_map.keys())\n    \n    # Create an index map to quickly look up the position of each GCD value\n    index_map = {g: idx for idx, g in enumerate(unique_gcds)}\n    \n    # Process each query\n    answer = []\n    for query in queries:\n        original_index = 0\n        for g in unique_gcds:\n            if query >= gcd_map[g]:\n                query -= gcd_map[g]\n            else:\n                answer.append(g)\n                break\n    \n    return answer", "passed": false, "raw_code": "```python\ndef gcd_pairs(nums, queries):\n    from collections import defaultdict\n    from math import gcd\n    \n    n = len(nums)\n    gcd_map = defaultdict(int)\n    \n    # Calculate GCD for all pairs and store in frequency map\n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            gcd_map[g] += 1\n    \n    # Get all unique GCDs and sort them\n    unique_gcds = sorted(gcd_map.keys())\n    \n    # Create an index map to quickly look up the position of each GCD value\n    index_map = {g: idx for idx, g in enumerate(unique_gcds)}\n    \n    # Process each query\n    answer = []\n    for query in queries:\n        original_index = 0\n        for g in unique_gcds:\n            if query >= gcd_map[g]:\n                query -= gcd_map[g]\n            else:\n                answer.append(g)\n                break\n    \n    return answer\n```"}
{"task_id": "3560", "code": "d", "passed": false, "raw_code": "```python\ndef minKnightMoves(x: int, y: int) -> int:\n    if (x, y) == (0, 0):\n        return 2\n    if (x, y) == (1, 0) or (x, y) == (0, 1):\n        return 3\n    if (x, y) == (1, 1):\n        return 4\n    if x == 0 and y == 2:\n        return 5\n    if x == 2 and y == 0:\n        return 5\n    if x == 0 and y == 3:\n        return 6\n    if x == 3 and y == 0:\n        return 6\n    if x == 0 and y == 4:\n        return 7\n    if x == 4 and y == 0:\n        return 7\n    if x == 0 and y == 5:\n        return 8\n    if x == 5 and y == 0:\n        return 8\n    if x == 0 and y == 6:\n        return 9\n    if x == 6 and y == 0:\n        return 9\n    if x == 0 and y == 7:\n        return 10\n    if x == 7 and y == 0:\n        return 10\n    if x == 0 and y == 8:\n        return 11\n    if x == 8 and y == 0:\n        return 11\n    if x == 0 and y == 9:\n        return 12\n    if x == 9 and y == 0:\n        return 12\n    if x == 0 and y == 10:\n        return 13\n    if x == 10 and y == 0:\n        return 13\n    if x == 0 and y == 11:\n        return 14\n    if x == 11 and y == 0:\n        return 14\n    if x == 0 and y == 12:\n        return 15\n    if x == 12 and y == 0:\n        return 15\n    if x == 0 and y == 13:\n        return 16\n    if x == 13 and y == 0:\n        return 16\n    if x == 0 and y == 14:\n        return 17\n    if x == 14 and y == 0:\n        return 17\n    if x == 0 and y == 15:\n        return 18\n    if x == 15 and y == 0:\n        return 18\n    if x == 0 and y == 16:\n        return 19\n    if x == 16 and y == 0:\n        return 19\n    if x == 0 and y == 17:\n        return 20\n    if x == 17 and y == 0:\n        return 20\n    if x == 0 and y == 18:\n        return 21\n    if x == 18 and y == 0:\n        return 21\n    if x == 0 and y == 19:\n        return 22\n    if x == 19 and y == 0:\n        return 22\n    if x == 0 and y == 20:\n        return 23\n    if x == 20 and y == 0:\n        return 23\n    if x == 0 and y == 21:\n        return 24\n    if x == 21 and y == 0:\n        return 24\n    if x == 0 and y == 22:\n        return 25\n    if x == 22 and y == 0:\n        return 25"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s, pattern, k=1):\n    m, n = len(s), len(pattern)\n    for i in range(m - n + 1):\n        diff_count = 0\n        consecutive_diffs = 0\n        for j in range(n):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > k:\n                    break\n                consecutive_diffs += 1\n        if diff_count <= k:\n            return i\n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s, pattern, k=1):\n    m, n = len(s), len(pattern)\n    for i in range(m - n + 1):\n        diff_count = 0\n        consecutive_diffs = 0\n        for j in range(n):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > k:\n                    break\n                consecutive_diffs += 1\n        if diff_count <= k:\n            return i\n    return -1\n```"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_combinations(digits, length):\n        from collections import Counter\n        from math import factorial\n        \n        count = 0\n        unique_digits = list(Counter(digits).keys())\n        total_permutations = factorial(length)\n        \n        for i in range(len(unique_digits)):\n            count += total_permutations // (factorial(Counter(digits)[unique_digits[i]]) * factorial(length - len(digits.replace(unique_digits[i], ''))))\n        \n        return count\n    \n    def check_divisibility(combo, k):\n        for perm in permutations(combo):\n            num = int(''.join(map(str, perm)))\n            if num % k == 0:\n                yield num\n    \n    from itertools import permutations\n    \n    if n == 1:\n        return sum(i % k == 0 for i in range(1, 10))\n    \n    digits = '123456789'\n    count = 0\n    \n    for combo in permutations(digits, n-1):\n        full_combo = (combo[0],) + combo + (combo[-1],)\n        if is_palindrome(full_combo):\n            for num in check_divisibility(full_combo, k):\n                count += 1\n    \n    return count", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def count_combinations(digits, length):\n        from collections import Counter\n        from math import factorial\n        \n        count = 0\n        unique_digits = list(Counter(digits).keys())\n        total_permutations = factorial(length)\n        \n        for i in range(len(unique_digits)):\n            count += total_permutations // (factorial(Counter(digits)[unique_digits[i]]) * factorial(length - len(digits.replace(unique_digits[i], ''))))\n        \n        return count\n    \n    def check_divisibility(combo, k):\n        for perm in permutations(combo):\n            num = int(''.join(map(str, perm)))\n            if num % k == 0:\n                yield num\n    \n    from itertools import permutations\n    \n    if n == 1:\n        return sum(i % k == 0 for i in range(1, 10))\n    \n    digits = '123456789'\n    count = 0\n    \n    for combo in permutations(digits, n-1):\n        full_combo = (combo[0],) + combo + (combo[-1],)\n        if is_palindrome(full_combo):\n            for num in check_divisibility(full_combo, k):\n                count += 1\n    \n    return count\n```"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, Q + 1):\n        for j in range(N + 1):\n            dp[i][j] = dp[i - 1][j]  # Skip the current operation\n            if P[i - 1] <= N:\n                dp[i][j] += dp[i - 1][min(j, V[i - 1])]\n                dp[i][j] %= MOD\n    \n    result = 0\n    for j in range(1, N + 1):\n        result += dp[Q][j]\n        result %= MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\nP = [0] * Q\nV = [0] * Q\n\nfor i in range(Q):\n    P[i] = int(data[2 * i + 2])\n    V[i] = int(data[2 * i + 3])\n\n# Output the result\nprint(count_valid_sequences(N, Q, P, V))", "passed": false, "raw_code": "```python\ndef count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(Q + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, Q + 1):\n        for j in range(N + 1):\n            dp[i][j] = dp[i - 1][j]  # Skip the current operation\n            if P[i - 1] <= N:\n                dp[i][j] += dp[i - 1][min(j, V[i - 1])]\n                dp[i][j] %= MOD\n    \n    result = 0\n    for j in range(1, N + 1):\n        result += dp[Q][j]\n        result %= MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\nP = [0] * Q\nV = [0] * Q\n\nfor i in range(Q):\n    P[i] = int(data[2 * i + 2])\n    V[i] = int(data[2 * i + 3])\n\n# Output the result\nprint(count_valid_sequences(N, Q, P, V))\n```"}
{"task_id": "arc183_c", "code": "def count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    from itertools import permutations\n\n    def is_valid(perm, conditions):\n        for L, R, X in conditions:\n            subarray = perm[L-1:R]\n            max_val = max(subarray)\n            if max_val == perm[X-1]:\n                return False\n        return True\n\n    count = 0\n    for perm in permutations(range(1, N+1)):\n        if is_valid(perm, conditions):\n            count = (count + 1) % MOD\n\n    return count\n\n# Example usage:\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = []\n    for i in range(M):\n        L = int(data[2 + 3 * i])\n        R = int(data[3 + 3 * i])\n        X = int(data[4 + 3 * i])\n        conditions.append((L, R, X))\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)", "passed": false, "raw_code": "```python\ndef count_valid_permutations(N, M, conditions):\n    MOD = 998244353\n    from itertools import permutations\n\n    def is_valid(perm, conditions):\n        for L, R, X in conditions:\n            subarray = perm[L-1:R]\n            max_val = max(subarray)\n            if max_val == perm[X-1]:\n                return False\n        return True\n\n    count = 0\n    for perm in permutations(range(1, N+1)):\n        if is_valid(perm, conditions):\n            count = (count + 1) % MOD\n\n    return count\n\n# Example usage:\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = []\n    for i in range(M):\n        L = int(data[2 + 3 * i])\n        R = int(data[3 + 3 * i])\n        X = int(data[4 + 3 * i])\n        conditions.append((L, R, X))\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)\n```"}
{"task_id": "arc182_c", "code": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    dp = [0] * (M + 1)\n    dp[1] = 1\n    for i in range(2, M + 1):\n        dp[i] = dp[i - 1] * i % MOD\n    total_score = 0\n    for k in range(1, N + 1):\n        total_score = (total_score + dp[M]) % MOD\n    return total_score\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nprint(sum_of_scores(N, M))\n", "passed": false, "raw_code": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef sum_of_scores(N, M):\n    MOD = 998244353\n    dp = [0] * (M + 1)\n    dp[1] = 1\n    for i in range(2, M + 1):\n        dp[i] = dp[i - 1] * i % MOD\n    total_score = 0\n    for k in range(1, N + 1):\n        total_score = (total_score + dp[M]) % MOD\n    return total_score\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nprint(sum_of_scores(N, M))\n"}
{"final_accuracy": "0.00%"}
