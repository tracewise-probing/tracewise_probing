{"difficulty": "hard", "num_threads": 32, "temperature": 0.2, "n": 32, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp02_bug_trace_TPL_CONCISETRACE_qwen_7b_hard_n_32.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "def determine_winner(N):\n    if N % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine the winner\nwinner = determine_winner(N)\nprint(winner)", "passed": false, "raw_code": "```python\ndef determine_winner(N):\n    if N % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine the winner\nwinner = determine_winner(N)\nprint(winner)\n```"}
{"task_id": "abc366_f", "code": "import itertools\n\ndef max_nested_function_value(N, K, functions):\n    def apply_functions(sequence):\n        x = 1\n        for func in sequence:\n            A, B = functions[func - 1]\n            x = A * x + B\n        return x\n    \n    max_value = float('-inf')\n    for sequence in itertools.permutations(range(1, N + 1), K):\n        value = apply_functions(sequence)\n        if value > max_value:\n            max_value = value\n    \n    print(max_value)\n\n# Read input\nN, K = map(int, input().split())\nfunctions = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Call the function\nmax_nested_function_value(N, K, functions)", "passed": false, "raw_code": "```python\nimport itertools\n\ndef max_nested_function_value(N, K, functions):\n    def apply_functions(sequence):\n        x = 1\n        for func in sequence:\n            A, B = functions[func - 1]\n            x = A * x + B\n        return x\n    \n    max_value = float('-inf')\n    for sequence in itertools.permutations(range(1, N + 1), K):\n        value = apply_functions(sequence)\n        if value > max_value:\n            max_value = value\n    \n    print(max_value)\n\n# Read input\nN, K = map(int, input().split())\nfunctions = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Call the function\nmax_nested_function_value(N, K, functions)\n```"}
{"task_id": "arc181_b", "code": "def f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        # Try with T being an empty string first\n        T = \"\"\n        if f(S, T, X) == f(S, T, Y):\n            results.append(\"Yes\")\n            continue\n        \n        # If not, try extending T with S and checking again\n        T = S\n        if f(S, T, X) == f(S, T, Y):\n            results.append(\"Yes\")\n            continue\n        \n        # If still not, try extending T with more S and checking again\n        T += S\n        while len(T) < max(len(X), len(Y)):\n            T += S\n        if f(S, T, X) == f(S, T, Y):\n            results.append(\"Yes\")\n            continue\n        \n        # If none of the above works, it's not possible\n        results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nsolve()", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        # Try with T being an empty string first\n        T = \"\"\n        if f(S, T, X) == f(S, T, Y):\n            results.append(\"Yes\")\n            continue\n        \n        # If not, try extending T with S and checking again\n        T = S\n        if f(S, T, X) == f(S, T, Y):\n            results.append(\"Yes\")\n            continue\n        \n        # If still not, try extending T with more S and checking again\n        T += S\n        while len(T) < max(len(X), len(Y)):\n            T += S\n        if f(S, T, X) == f(S, T, Y):\n            results.append(\"Yes\")\n            continue\n        \n        # If none of the above works, it's not possible\n        results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nsolve()\n```"}
{"task_id": "abc367_f", "code": "def can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()", "passed": false, "raw_code": "```python\ndef can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        subseq_A = A[l_i:r_i + 1]\n        subseq_B = B[L_i:R_i + 1]\n        \n        freq_A = [0] * (N + 1)\n        freq_B = [0] * (N + 1)\n        \n        for num in subseq_A:\n            freq_A[num] += 1\n        for num in subseq_B:\n            freq_B[num] += 1\n        \n        if freq_A == freq_B:\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()\n```"}
{"task_id": "3532", "code": "def get_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    def bfs_marking(node):\n        marking_times = [0] * n\n        queue = [(node, 0)]\n        visited = set([node])\n        \n        while queue:\n            current, time = queue.pop(0)\n            for neighbor in adj_list[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if current % 2 == 0:\n                        marking_times[neighbor] = time + 2\n                    else:\n                        marking_times[neighbor] = time + 1\n                    queue.append((neighbor, marking_times[neighbor]))\n        \n        return marking_times\n    \n    result = []\n    for i in range(n):\n        result.append(bfs_marking(i))\n    \n    return result", "passed": false, "raw_code": "```python\ndef get_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    def bfs_marking(node):\n        marking_times = [0] * n\n        queue = [(node, 0)]\n        visited = set([node])\n        \n        while queue:\n            current, time = queue.pop(0)\n            for neighbor in adj_list[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if current % 2 == 0:\n                        marking_times[neighbor] = time + 2\n                    else:\n                        marking_times[neighbor] = time + 1\n                    queue.append((neighbor, marking_times[neighbor]))\n        \n        return marking_times\n    \n    result = []\n    for i in range(n):\n        result.append(bfs_marking(i))\n    \n    return result\n```"}
{"task_id": "abc365_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Calculate prefix XORs\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n\n    result = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            result += prefix_xor[j + 1] ^ prefix_xor[i]\n\n    print(result)\n\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Calculate prefix XORs\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n\n    result = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            result += prefix_xor[j + 1] ^ prefix_xor[i]\n\n    print(result)\n\nmain()"}
{"task_id": "abc373_f", "code": "def max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    dp = [-float('inf')] * (W + 1)\n    dp[0] = 0\n    \n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        \n        for j in range(W, w - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j >= k * w:\n                    dp[j] = max(dp[j], dp[j - k * w] + k * v - k**2)\n                else:\n                    break\n    \n    print(max(dp))\n\nmax_happiness()", "passed": false, "raw_code": "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    dp = [-float('inf')] * (W + 1)\n    dp[0] = 0\n    \n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        \n        for j in range(W, w - 1, -1):\n            for k in range(1, 10**10 + 1):\n                if j >= k * w:\n                    dp[j] = max(dp[j], dp[j - k * w] + k * v - k**2)\n                else:\n                    break\n    \n    print(max(dp))\n\nmax_happiness()\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize variables\n    total_sum = 0\n    \n    # Iterate over all possible starting points of the subsequence\n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        # Iterate over all possible ending points of the subsequence starting from i\n        for j in range(i, N):\n            if A[j] not in seen:\n                distinct_count += 1\n                seen.add(A[j])\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Initialize variables\n    total_sum = 0\n    \n    # Iterate over all possible starting points of the subsequence\n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        # Iterate over all possible ending points of the subsequence starting from i\n        for j in range(i, N):\n            if A[j] not in seen:\n                distinct_count += 1\n                seen.add(A[j])\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "abc372_e", "code": "import heapq\nfrom sys import stdin\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = [[] for _ in range(N + 1)]\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            index += 3\n            \n            if not adj_list[v]:\n                results.append(-1)\n            else:\n                heap = [-x for x in adj_list[v]]\n                heapq.heapify(heap)\n                \n                for _ in range(k - 1):\n                    heapq.heappop(heap)\n                \n                results.append(-heap[0])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport heapq\nfrom sys import stdin\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = [[] for _ in range(N + 1)]\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1])\n            v = int(data[index + 2])\n            index += 3\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        elif query_type == 2:\n            v = int(data[index + 1])\n            k = int(data[index + 2])\n            index += 3\n            \n            if not adj_list[v]:\n                results.append(-1)\n            else:\n                heap = [-x for x in adj_list[v]]\n                heapq.heapify(heap)\n                \n                for _ in range(k - 1):\n                    heapq.heappop(heap)\n                \n                results.append(-heap[0])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc366_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(dim_coords, D):\n        n = len(dim_coords)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + dim_coords[i]\n        \n        count = 0\n        \n        for i in range(n):\n            left = max(0, i - D // 2)\n            right = min(n, i + D // 2 + 1)\n            count += prefix_sum[right] - prefix_sum[left]\n        \n        return count\n    \n    x_count = count_points(x_coords, D)\n    y_count = count_points(y_coords, D)\n    \n    print(x_count * y_count)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    x_coords = []\n    y_coords = []\n    \n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        x_coords.append(x)\n        y_coords.append(y)\n        index += 2\n    \n    x_coords.sort()\n    y_coords.sort()\n    \n    def count_points(dim_coords, D):\n        n = len(dim_coords)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + dim_coords[i]\n        \n        count = 0\n        \n        for i in range(n):\n            left = max(0, i - D // 2)\n            right = min(n, i + D // 2 + 1)\n            count += prefix_sum[right] - prefix_sum[left]\n        \n        return count\n    \n    x_count = count_points(x_coords, D)\n    y_count = count_points(y_coords, D)\n    \n    print(x_count * y_count)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc181_c", "code": "def generate_grid(N, P, Q):\n    grid = [['0'] * N for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(N):\n            if P[i] < Q[j]:\n                grid[i][j] = '0'\n            else:\n                grid[i][j] = '1'\n    \n    return '\\n'.join(''.join(row) for row in grid)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))", "passed": false, "raw_code": "```python\ndef generate_grid(N, P, Q):\n    grid = [['0'] * N for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(N):\n            if P[i] < Q[j]:\n                grid[i][j] = '0'\n            else:\n                grid[i][j] = '1'\n    \n    return '\\n'.join(''.join(row) for row in grid)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Generate and print the grid\nprint(generate_grid(N, P, Q))\n```"}
{"task_id": "abc370_e", "code": "def count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            dp[i][j] = dp[i - 1][j]\n            if prefix_sum[j] - prefix_sum[i - 1] != K:\n                dp[i][j] += dp[i - 1][i - 1]\n                dp[i][j] %= MOD\n    return dp[N][N]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\nprint(count_partitions(N, K, A))", "passed": false, "raw_code": "def count_partitions(N, K, A):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            dp[i][j] = dp[i - 1][j]\n            if prefix_sum[j] - prefix_sum[i - 1] != K:\n                dp[i][j] += dp[i - 1][i - 1]\n                dp[i][j] %= MOD\n    return dp[N][N]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\nprint(count_partitions(N, K, A))"}
{"task_id": "abc372_g", "code": "def count_valid_pairs(N, A, B, C):\n    count = 0\n    for x in range(1, C[0] // A[0] + 1):\n        for y in range(1, C[0] // B[0] + 1):\n            valid = True\n            for i in range(N):\n                if A[i] * x + B[i] * y >= C[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef count_valid_pairs(N, A, B, C):\n    count = 0\n    for x in range(1, C[0] // A[0] + 1):\n        for y in range(1, C[0] // B[0] + 1):\n            valid = True\n            for i in range(N):\n                if A[i] * x + B[i] * y >= C[i]:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(N, A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            arr1 = [0] * n\n            arr2 = [0] * n\n            \n            for k in range(i, j + 1):\n                arr1[k] = k - i\n                arr2[k] = j - k\n            \n            if all(arr1[k] <= arr1[k + 1] for k in range(n - 1)) and \\\n               all(arr2[k] >= arr2[k + 1] for k in range(n - 1)):\n                count += 1\n                \n    return count % MOD", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            arr1 = [0] * n\n            arr2 = [0] * n\n            \n            for k in range(i, j + 1):\n                arr1[k] = k - i\n                arr2[k] = j - k\n            \n            if all(arr1[k] <= arr1[k + 1] for k in range(n - 1)) and \\\n               all(arr2[k] >= arr2[k + 1] for k in range(n - 1)):\n                count += 1\n                \n    return count % MOD\n```"}
{"task_id": "abc373_g", "code": "def read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    P = []\n    Q = []\n    \n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        P.append((A, B))\n        index += 2\n    \n    for _ in range(N):\n        C = int(data[index])\n        D = int(data[index + 1])\n        Q.append((C, D))\n        index += 2\n    \n    return N, P, Q\n\ndef is_valid_permutation(N, P, Q, perm):\n    for i in range(N):\n        for j in range(i + 1, N):\n            if i != j and do_intersect(P[i], Q[perm[i]], P[j], Q[perm[j]]):\n                return False\n    return True\n\ndef do_intersect(p1, q1, p2, q2):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n    \n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    \n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    \n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    \n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    \n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    \n    return False\n\ndef on_segment(p, q, r):\n    if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n        return True\n    return False\n\ndef find_non_crossing_permutation(N, P, Q):\n    from itertools import permutations\n    \n    for perm in permutations(range(1, N + 1)):\n        if is_valid_permutation(N, P, Q, perm):\n            return ' '.join(map(str, perm))\n    \n    return '-1'\n\ndef main():\n    N, P, Q = read_input()\n    result = find_non_crossing_permutation(N, P, Q)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef read_input():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    P = []\n    Q = []\n    \n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        P.append((A, B))\n        index += 2\n    \n    for _ in range(N):\n        C = int(data[index])\n        D = int(data[index + 1])\n        Q.append((C, D))\n        index += 2\n    \n    return N, P, Q\n\ndef is_valid_permutation(N, P, Q, perm):\n    for i in range(N):\n        for j in range(i + 1, N):\n            if i != j and do_intersect(P[i], Q[perm[i]], P[j], Q[perm[j]]):\n                return False\n    return True\n\ndef do_intersect(p1, q1, p2, q2):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n    \n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n    \n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    \n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    \n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    \n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n    \n    return False\n\ndef on_segment(p, q, r):\n    if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n        return True\n    return False\n\ndef find_non_crossing_permutation(N, P, Q):\n    from itertools import permutations\n    \n    for perm in permutations(range(1, N + 1)):\n        if is_valid_permutation(N, P, Q, perm):\n            return ' '.join(map(str, perm))\n    \n    return '-1'\n\ndef main():\n    N, P, Q = read_input()\n    result = find_non_crossing_permutation(N, P, Q)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc367_e", "code": "def perform_operations(N, K, X, A):\n    # Create a list to store the cycle lengths\n    cycle_lengths = [0] * N\n    visited = [False] * N\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle_length = 0\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                x = X[x] - 1\n                cycle_length += 1\n            cycle_lengths[i] = cycle_length\n    \n    # Determine the effective number of operations\n    effective_K = K % sum(cycle_lengths)\n    \n    # Apply the permutation effective_K times\n    for _ in range(effective_K):\n        A = [A[X[i] - 1] for i in range(N)]\n    \n    # Print the resulting sequence\n    print(' '.join(map(str, A)))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nperform_operations(N, K, X, A)", "passed": false, "raw_code": "```python\ndef perform_operations(N, K, X, A):\n    # Create a list to store the cycle lengths\n    cycle_lengths = [0] * N\n    visited = [False] * N\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle_length = 0\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                x = X[x] - 1\n                cycle_length += 1\n            cycle_lengths[i] = cycle_length\n    \n    # Determine the effective number of operations\n    effective_K = K % sum(cycle_lengths)\n    \n    # Apply the permutation effective_K times\n    for _ in range(effective_K):\n        A = [A[X[i] - 1] for i in range(N)]\n    \n    # Print the resulting sequence\n    print(' '.join(map(str, A)))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nperform_operations(N, K, X, A)\n```"}
{"task_id": "3527", "code": "def alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend colors to simulate the circular nature\n    groups = []\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n        return count\n    \n    def update_color(index, new_color):\n        nonlocal colors, groups\n        old_color = colors[index]\n        colors[index] = new_color\n        \n        # Remove old groups that include the updated index\n        groups_to_remove = []\n        for group in groups:\n            if index in group:\n                groups_to_remove.append(group)\n        \n        # Add new groups that include the updated index\n        for group in groups_to_remove:\n            groups.remove(group)\n            start = group[0]\n            end = group[-1]\n            if start < end:\n                for i in range(start, end):\n                    if colors[i] != colors[i+1]:\n                        groups.append(list(range(i, i+size)))\n            else:\n                for i in range(end, start):\n                    if colors[i] != colors[i+1]:\n                        groups.append(list(range(i, i+size)))\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index = query[1]\n            new_color = query[2]\n            update_color(index, new_color)\n    \n    return result", "passed": false, "raw_code": "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    colors += colors[:2]  # Extend colors to simulate the circular nature\n    groups = []\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if i + size > n:\n                break\n            group = colors[i:i+size]\n            if all(group[j] != group[j+1] for j in range(size-1)):\n                count += 1\n        return count\n    \n    def update_color(index, new_color):\n        nonlocal colors, groups\n        old_color = colors[index]\n        colors[index] = new_color\n        \n        # Remove old groups that include the updated index\n        groups_to_remove = []\n        for group in groups:\n            if index in group:\n                groups_to_remove.append(group)\n        \n        # Add new groups that include the updated index\n        for group in groups_to_remove:\n            groups.remove(group)\n            start = group[0]\n            end = group[-1]\n            if start < end:\n                for i in range(start, end):\n                    if colors[i] != colors[i+1]:\n                        groups.append(list(range(i, i+size)))\n            else:\n                for i in range(end, start):\n                    if colors[i] != colors[i+1]:\n                        groups.append(list(range(i, i+size)))\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count_alternating_groups(size))\n        elif query[0] == 2:\n            index = query[1]\n            new_color = query[2]\n            update_color(index, new_color)\n    \n    return result\n```"}
{"task_id": "abc371_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:]))\n    # Sort the array A to get the lexicographically smallest array\n    A.sort()\n    # Print the result\n    print(' '.join(map(str, A)))\n\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    A = list(map(int, data[N+1:]))\n    # Sort the array A to get the lexicographically smallest array\n    A.sort()\n    # Print the result\n    print(' '.join(map(str, A)))\n\nmain()"}
{"task_id": "abc372_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X - 1, Y - 1))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * N for _ in range(K + 1)]\n    dp[0][0] = 1  # Starting point\n    \n    # Fill dp array\n    for k in range(1, K + 1):\n        for j in range(N):\n            if j == 0:\n                dp[k][j] = dp[k-1][N-1]\n            else:\n                dp[k][j] = dp[k-1][j-1]\n            for x, y in edges:\n                if y == j:\n                    dp[k][j] += dp[k-1][x]\n            dp[k][j] %= MOD\n    \n    # Sum up the ways to reach any vertex after K moves\n    result = sum(dp[K]) % MOD\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X - 1, Y - 1))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * N for _ in range(K + 1)]\n    dp[0][0] = 1  # Starting point\n    \n    # Fill dp array\n    for k in range(1, K + 1):\n        for j in range(N):\n            if j == 0:\n                dp[k][j] = dp[k-1][N-1]\n            else:\n                dp[k][j] = dp[k-1][j-1]\n            for x, y in edges:\n                if y == j:\n                    dp[k][j] += dp[k-1][x]\n            dp[k][j] %= MOD\n    \n    # Sum up the ways to reach any vertex after K moves\n    result = sum(dp[K]) % MOD\n    print(result)\n\nmain()\n```"}
{"task_id": "abc373_e", "code": "def min_additional_votes(N, M, K, A):\n    # Calculate the total votes currently counted\n    total_counted_votes = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_counted_votes\n    # Find the second highest vote count\n    sorted_votes = sorted(A)\n    second_highest = sorted_votes[-2] if len(sorted_votes) > 1 else float('-inf')\n    # Initialize the result list\n    results = []\n    # Iterate over each candidate's vote count\n    for votes in A:\n        # If the candidate already has more votes than the second highest, they need no additional votes\n        if votes > second_highest:\n            results.append(0)\n        # Otherwise, calculate the minimum additional votes needed\n        else:\n            additional_votes_needed = second_highest + 1 - votes\n            # Ensure the additional votes do not exceed the remaining votes\n            if additional_votes_needed <= remaining_votes:\n                results.append(additional_votes_needed)\n            else:\n                results.append(-1)\n    # Return the results as a space-separated string\n    return ' '.join(map(str, results))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Call the function and print the result\nprint(min_additional_votes(N, M, K, A))", "passed": false, "raw_code": "def min_additional_votes(N, M, K, A):\n    # Calculate the total votes currently counted\n    total_counted_votes = sum(A)\n    # Calculate the remaining votes\n    remaining_votes = K - total_counted_votes\n    # Find the second highest vote count\n    sorted_votes = sorted(A)\n    second_highest = sorted_votes[-2] if len(sorted_votes) > 1 else float('-inf')\n    # Initialize the result list\n    results = []\n    # Iterate over each candidate's vote count\n    for votes in A:\n        # If the candidate already has more votes than the second highest, they need no additional votes\n        if votes > second_highest:\n            results.append(0)\n        # Otherwise, calculate the minimum additional votes needed\n        else:\n            additional_votes_needed = second_highest + 1 - votes\n            # Ensure the additional votes do not exceed the remaining votes\n            if additional_votes_needed <= remaining_votes:\n                results.append(additional_votes_needed)\n            else:\n                results.append(-1)\n    # Return the results as a space-separated string\n    return ' '.join(map(str, results))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Call the function and print the result\nprint(min_additional_votes(N, M, K, A))"}
{"task_id": "abc371_f", "code": "def min_movements(N, X, Q, T, G):\n    # Sort the persons and their goals\n    persons = sorted(zip(X, T))\n    goals = sorted(zip(G, T))\n\n    # Initialize the current position and total movements\n    current_pos = 0\n    total_movements = 0\n\n    # Iterate through each person and their goal\n    for (x, t), (g, _) in zip(persons, goals):\n        # Calculate the distance to the goal\n        distance = abs(x - g)\n\n        # Calculate the number of movements required\n        movements = distance\n\n        # Update the current position and total movements\n        current_pos += movements\n        total_movements += movements\n\n    # Return the total movements\n    return total_movements\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\ndex = 0\nN = int(data[dex])\ndex += 1\nX = list(map(int, data[dex:dex+N]))\ndex += N\nQ = int(data[dex])\ndex += 1\nT = list(map(int, data[dex:dex+Q]))\ndex += Q\nG = list(map(int, data[dex:dex+Q]))\ndex += Q\n\n# Call the function and print the result\nprint(min_movements(N, X, Q, T, G))", "passed": false, "raw_code": "def min_movements(N, X, Q, T, G):\n    # Sort the persons and their goals\n    persons = sorted(zip(X, T))\n    goals = sorted(zip(G, T))\n\n    # Initialize the current position and total movements\n    current_pos = 0\n    total_movements = 0\n\n    # Iterate through each person and their goal\n    for (x, t), (g, _) in zip(persons, goals):\n        # Calculate the distance to the goal\n        distance = abs(x - g)\n\n        # Calculate the number of movements required\n        movements = distance\n\n        # Update the current position and total movements\n        current_pos += movements\n        total_movements += movements\n\n    # Return the total movements\n    return total_movements\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\ndex = 0\nN = int(data[dex])\ndex += 1\nX = list(map(int, data[dex:dex+N]))\ndex += N\nQ = int(data[dex])\ndex += 1\nT = list(map(int, data[dex:dex+Q]))\ndex += Q\nG = list(map(int, data[dex:dex+Q]))\ndex += Q\n\n# Call the function and print the result\nprint(min_movements(N, X, Q, T, G))"}
{"task_id": "3563", "code": "def maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_columns = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_columns:\n                max_score += value\n                selected_columns.add(value)\n                break\n    \n    return max_score", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_columns = set()\n    max_score = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_columns:\n                max_score += value\n                selected_columns.add(value)\n                break\n    \n    return max_score\n```"}
{"task_id": "abc369_g", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef bfs(graph, start):\n    n = len(graph)\n    dist = [-1] * n\n    dist[start] = 0\n    queue = deque([start])\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                queue.append(v)\n    return dist\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    dist = bfs(graph, 0)\n    \n    for k in range(1, n + 1):\n        if k == 1:\n            print(dist[0] * 2)\n        else:\n            print(n * 2)\n\nsolve()"}
{"task_id": "abc369_e", "code": "i", "passed": false, "raw_code": "```python\nimport heapq\nfrom collections import defaultdict\n\ndef min_time_to_travel(N, M, bridges, Q, queries):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, t in bridges:\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def dijkstra(start, end, used_bridges):\n        dist = [float('inf')] * (N + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, u = heapq.heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            \n            for v, t in graph[u]:\n                new_dist = current_dist + t\n                if new_dist < dist[v] and (used_bridges & (1 << (bridges.index((min(u, v), max(u, v)))))) != 0:\n                    dist[v] = new_dist\n                    heapq.heappush(pq, (new_dist, v))\n        \n        return dist[end]\n    \n    results = []\n    for K, bridges_used in queries:\n        used_bridges = 0\n        for b in bridges_used:\n            used_bridges |= (1 << (b - 1))\n        \n        result = float('inf')\n        for mask in range(1 << K):\n            if mask == 0:\n                continue\n            total_time = 0\n            for i in range(K):\n                if mask & (1 << i):\n                    total_time += dijkstra(1, N, used_bridges)\n                    break\n            result = min(result, total_time)\n        \n        results.append(result)\n    \n    return results\n\n# Read input\nN, M = map(int, input().split())\nbridges = []\nfor _ in range(M):\n    u, v, t = map(int, input().split())\n    bridges.append((u, v, t))\nQ = int(input())\nqueries = []\nfor _ in range(Q):\n    K = int(input())\n    bridges_used = list(map(int, input().split()))\n    queries.append((K, bridges_used))\n\n# Get results\nresults = min_time_to_travel(N, M, bridges, Q, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"task_id": "abc367_g", "code": "def calculate_score(N, M, K, A):\n    MOD = 998244353\n    total_score = 0\n    for i in range(1, 1 << N):\n        subseq = [A[j] for j in range(N) if (i & (1 << j))]\n        if len(subseq) % M == 0:\n            xor_value = 0\n            for num in subseq:\n                xor_value ^= num\n            total_score += pow(xor_value, K, MOD)\n    return total_score % MOD\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Calculate and print the result\nprint(calculate_score(N, M, K, A))", "passed": false, "raw_code": "def calculate_score(N, M, K, A):\n    MOD = 998244353\n    total_score = 0\n    for i in range(1, 1 << N):\n        subseq = [A[j] for j in range(N) if (i & (1 << j))]\n        if len(subseq) % M == 0:\n            xor_value = 0\n            for num in subseq:\n                xor_value ^= num\n            total_score += pow(xor_value, K, MOD)\n    return total_score % MOD\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Calculate and print the result\nprint(calculate_score(N, M, K, A))"}
{"task_id": "arc181_d", "code": "import sys\nfrom bisect import bisect_left\n\ndef fenwick_tree(n):\n    tree = [0] * (n + 1)\n\n    def update(i, delta):\n        while i <= n:\n            tree[i] += delta\n            i += i & -i\n\n    def query(i):\n        result = 0\n        while i > 0:\n            result += tree[i]\n            i -= i & -i\n        return result\n\n    return update, query\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    # Initialize Fenwick Tree\n    update, query = fenwick_tree(N)\n\n    # Calculate initial inversion number\n    inversions = 0\n    for i in range(1, N):\n        inversions += query(P[i]-1)\n        update(P[i], 1)\n\n    # Print initial inversion number\n    print(inversions)\n\n    # Process each operation A_i\n    for a in A:\n        index = bisect_left(P, a)\n        if index > 0:\n            inversions -= query(index)\n        update(a, 1)\n        if index < N:\n            inversions += query(N) - query(index+1)\n        print(inversions)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "import sys\nfrom bisect import bisect_left\n\ndef fenwick_tree(n):\n    tree = [0] * (n + 1)\n\n    def update(i, delta):\n        while i <= n:\n            tree[i] += delta\n            i += i & -i\n\n    def query(i):\n        result = 0\n        while i > 0:\n            result += tree[i]\n            i -= i & -i\n        return result\n\n    return update, query\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n\n    # Initialize Fenwick Tree\n    update, query = fenwick_tree(N)\n\n    # Calculate initial inversion number\n    inversions = 0\n    for i in range(1, N):\n        inversions += query(P[i]-1)\n        update(P[i], 1)\n\n    # Print initial inversion number\n    print(inversions)\n\n    # Process each operation A_i\n    for a in A:\n        index = bisect_left(P, a)\n        if index > 0:\n            inversions -= query(index)\n        update(a, 1)\n        if index < N:\n            inversions += query(N) - query(index+1)\n        print(inversions)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "abc368_e", "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    X1 = int(data[2])\n    trains = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        trains.append((A, B, S, T))\n        index += 4\n    delays = [X1]\n    for i in range(1, M):\n        A, B, S, T = trains[i]\n        prev_A, prev_B, prev_S, prev_T = trains[i - 1]\n        if B == prev_A and T <= prev_S:\n            needed_delay = max(0, prev_S - T)\n            delays.append(needed_delay)\n        else:\n            delays.append(0)\n    print(' '.join(map(str, delays[1:])))\nsolve()", "passed": false, "raw_code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    X1 = int(data[2])\n    trains = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        trains.append((A, B, S, T))\n        index += 4\n    delays = [X1]\n    for i in range(1, M):\n        A, B, S, T = trains[i]\n        prev_A, prev_B, prev_S, prev_T = trains[i - 1]\n        if B == prev_A and T <= prev_S:\n            needed_delay = max(0, prev_S - T)\n            delays.append(needed_delay)\n        else:\n            delays.append(0)\n    print(' '.join(map(str, delays[1:])))\nsolve()"}
{"task_id": "arc182_d", "code": "def min_operations_to_transform(N, M, A, B):\n    # Check feasibility\n    for i in range(N):\n        if (i > 0 and A[i-1] == B[i]) or (i < N-1 and A[i+1] == B[i]):\n            return -1\n    \n    # Calculate minimum operations\n    total_operations = 0\n    for i in range(N):\n        diff = abs(B[i] - A[i])\n        total_operations += min(diff, M - diff)\n    \n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Get result\nresult = min_operations_to_transform(N, M, A, B)\n\n# Print result\nprint(result)", "passed": false, "raw_code": "```python\ndef min_operations_to_transform(N, M, A, B):\n    # Check feasibility\n    for i in range(N):\n        if (i > 0 and A[i-1] == B[i]) or (i < N-1 and A[i+1] == B[i]):\n            return -1\n    \n    # Calculate minimum operations\n    total_operations = 0\n    for i in range(N):\n        diff = abs(B[i] - A[i])\n        total_operations += min(diff, M - diff)\n    \n    return total_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Get result\nresult = min_operations_to_transform(N, M, A, B)\n\n# Print result\nprint(result)\n```"}
{"task_id": "abc366_g", "code": "def can_assign_numbers(N, M, edges):\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # DFS function to try assigning numbers\n    def dfs(node, parent, assigned):\n        if node in assigned:\n            return True\n        for neighbor in adj_list[node]:\n            if neighbor == parent:\n                continue\n            if not dfs(neighbor, node, assigned):\n                return False\n        assigned.add(node)\n        return True\n\n    # Check if we can assign numbers\n    assigned = set()\n    for i in range(1, N + 1):\n        if i not in assigned and not dfs(i, None, assigned):\n            return 'No'\n\n    # Assign numbers to vertices\n    numbers = [0] * (N + 1)\n    for i in range(1, N + 1):\n        if numbers[i] == 0:\n            numbers[i] = 1\n            for neighbor in adj_list[i]:\n                numbers[neighbor] = 1 ^ numbers[i]\n\n    # Verify the assignment\n    for i in range(1, N + 1):\n        xor_sum = 0\n        for neighbor in adj_list[i]:\n            xor_sum ^= numbers[neighbor]\n        if xor_sum != 0:\n            return 'No'\n\n    # Print the result\n    return 'Yes\\n' + ' '.join(map(str, numbers[1:]))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve and print the result\nprint(can_assign_numbers(n, m, edges))", "passed": false, "raw_code": "def can_assign_numbers(N, M, edges):\n    # Create adjacency list\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # DFS function to try assigning numbers\n    def dfs(node, parent, assigned):\n        if node in assigned:\n            return True\n        for neighbor in adj_list[node]:\n            if neighbor == parent:\n                continue\n            if not dfs(neighbor, node, assigned):\n                return False\n        assigned.add(node)\n        return True\n\n    # Check if we can assign numbers\n    assigned = set()\n    for i in range(1, N + 1):\n        if i not in assigned and not dfs(i, None, assigned):\n            return 'No'\n\n    # Assign numbers to vertices\n    numbers = [0] * (N + 1)\n    for i in range(1, N + 1):\n        if numbers[i] == 0:\n            numbers[i] = 1\n            for neighbor in adj_list[i]:\n                numbers[neighbor] = 1 ^ numbers[i]\n\n    # Verify the assignment\n    for i in range(1, N + 1):\n        xor_sum = 0\n        for neighbor in adj_list[i]:\n            xor_sum ^= numbers[neighbor]\n        if xor_sum != 0:\n            return 'No'\n\n    # Print the result\n    return 'Yes\\n' + ' '.join(map(str, numbers[1:]))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve and print the result\nprint(can_assign_numbers(n, m, edges))"}
{"task_id": "3550", "code": "def maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    i, j = 0, 0\n    result = 0\n    used_rows = set()\n    used_cols = set()\n    \n    while len(used_rows) < 3 and len(used_cols) < 3:\n        if i not in used_rows and j not in used_cols:\n            result += board[i][j]\n            used_rows.add(i)\n            used_cols.add(j)\n        \n        if i < m - 1:\n            i += 1\n        else:\n            i = 0\n            j += 1\n    \n    return result", "passed": false, "raw_code": "```python\ndef maxSumOfRooks(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    i, j = 0, 0\n    result = 0\n    used_rows = set()\n    used_cols = set()\n    \n    while len(used_rows) < 3 and len(used_cols) < 3:\n        if i not in used_rows and j not in used_cols:\n            result += board[i][j]\n            used_rows.add(i)\n            used_cols.add(j)\n        \n        if i < m - 1:\n            i += 1\n        else:\n            i = 0\n            j += 1\n    \n    return result\n```"}
{"task_id": "abc370_f", "code": "def min_weight_and_unused_cut_lines(N, K, A):\n    # Step 1: Calculate prefix sums\n    prefix = [0]\n    for a in A:\n        prefix.append(prefix[-1] + a)\n    \n    # Step 2: Binary search for the maximum possible minimum weight\n    low, high = min(A), prefix[-1]\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid, N, K, A, prefix):\n            low = mid\n        else:\n            high = mid - 1\n    \n    # Step 3: Count unused cut lines\n    used_cut_lines = set()\n    current_sum = 0\n    for i in range(1, N + 1):\n        current_sum += A[i - 1]\n        if current_sum >= low:\n            used_cut_lines.add(i)\n            current_sum = 0\n    \n    unused_cut_lines = N - len(used_cut_lines)", "passed": false, "raw_code": "def min_weight_and_unused_cut_lines(N, K, A):\n    # Step 1: Calculate prefix sums\n    prefix = [0]\n    for a in A:\n        prefix.append(prefix[-1] + a)\n    \n    # Step 2: Binary search for the maximum possible minimum weight\n    low, high = min(A), prefix[-1]\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_distribute(mid, N, K, A, prefix):\n            low = mid\n        else:\n            high = mid - 1\n    \n    # Step 3: Count unused cut lines\n    used_cut_lines = set()\n    current_sum = 0\n    for i in range(1, N + 1):\n        current_sum += A[i - 1]\n        if current_sum >= low:\n            used_cut_lines.add(i)\n            current_sum = 0\n    \n    unused_cut_lines = N - len(used_cut_lines)"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    n = len(damage)\n    time_to_die = [h / d for h, d in zip(health, damage)]\n    enemies = sorted(range(n), key=lambda i: time_to_die[i], reverse=True)\n    total_damage = 0\n    current_time = 0\n    \n    for enemy in enemies:\n        if health[enemy] > 0:\n            attacks = int(health[enemy] / power)\n            if health[enemy] % power != 0:\n                attacks += 1\n            total_damage += attacks * damage[enemy]\n            health[enemy] = 0\n    \n    return total_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    time_to_die = [h / d for h, d in zip(health, damage)]\n    enemies = sorted(range(n), key=lambda i: time_to_die[i], reverse=True)\n    total_damage = 0\n    current_time = 0\n    \n    for enemy in enemies:\n        if health[enemy] > 0:\n            attacks = int(health[enemy] / power)\n            if health[enemy] % power != 0:\n                attacks += 1\n            total_damage += attacks * damage[enemy]\n            health[enemy] = 0\n    \n    return total_damage\n```"}
{"task_id": "3552", "code": "def largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max(i for i in range(1, 10) if i % k == 0))\n    \n    max_palindrome = 0\n    \n    # Generate half of the palindrome\n    for half in range(10**(n//2), 10**((n+1)//2)):\n        half_str = str(half)\n        if n % 2 == 0:\n            palindrome = int(half_str + half_str[::-1])\n        else:\n            palindrome = int(half_str + half_str[-2::-1])\n        \n        if palindrome % k == 0:\n            max_palindrome = max(max_palindrome, palindrome)\n    \n    return str(max_palindrome)", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max(i for i in range(1, 10) if i % k == 0))\n    \n    max_palindrome = 0\n    \n    # Generate half of the palindrome\n    for half in range(10**(n//2), 10**((n+1)//2)):\n        half_str = str(half)\n        if n % 2 == 0:\n            palindrome = int(half_str + half_str[::-1])\n        else:\n            palindrome = int(half_str + half_str[-2::-1])\n        \n        if palindrome % k == 0:\n            max_palindrome = max(max_palindrome, palindrome)\n    \n    return str(max_palindrome)\n```"}
{"task_id": "arc183_d", "code": "d", "passed": false, "raw_code": "```python\ndef max_score_operations(N, edges):\n    import heapq\n    \n    # Build the adjacency list representation of the tree\n    adj_list = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Function to get all leaves in the tree\n    def get_leaves():\n        leaves = []\n        for i in range(1, N + 1):\n            if len(adj_list[i]) == 1:\n                leaves.append(i)\n        return leaves\n    \n    # Function to calculate the distance between two nodes using BFS\n    def bfs_distance(start, end):\n        queue = [(start, 0)]\n        visited = set([start])\n        while queue:\n            node, dist = queue.pop(0)\n            if node == end:\n                return dist\n            for neighbor in adj_list[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        return float('inf')\n    \n    # Perform the operations\n    operations = []\n    while len(get_leaves()) >= 2:\n        leaves = get_leaves()\n        max_dist = 0\n        best_pair = (None, None)\n        for i in range(len(leaves)):\n            for j in range(i + 1, len(leaves)):\n                dist = bfs_distance(leaves[i], leaves[j])\n                if dist > max_dist:\n                    max_dist = dist\n                    best_pair = (leaves[i], leaves[j])\n        \n        operations.append(best_pair)\n        # Remove the chosen leaves from the tree\n        for leaf in best_pair:\n            for neighbor in adj_list[leaf]:\n                adj_list[neighbor].remove(leaf)\n            adj_list[leaf] = []\n    \n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(N - 1)]\n\n# Get the operations\noperations = max_score_operations(N, edges)\n\n# Print the result\nfor op in operations:\n    print(op[0], op[1])"}
{"task_id": "abc368_g", "code": "d", "passed": false, "raw_code": "```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    queries = data[2*N+2:]\n    \n    # Precompute the maximum possible values for subarrays of A and B\n    max_A = [[0] * N for _ in range(N)]\n    max_B = [[0] * N for _ in range(N)]\n    \n    for i in range(N):\n        max_A[i][i] = A[i]\n        max_B[i][i] = B[i]\n    \n    for length in range(2, N+1):\n        for i in range(N-length+1):\n            j = i + length - 1\n            max_A[i][j] = max(max_A[i][j-1] + A[j], max_A[i+1][j] * A[j])\n            max_B[i][j] = max(max_B[i][j-1] + B[j], max_B[i+1][j] * B[j])\n    \n    # Process each query\n    index = 0\n    results = []\n    for _ in range(Q):\n        query_type = int(queries[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(queries[index]) - 1\n            x = int(queries[index+1])\n            A[i] = x\n            max_A[i][i] = x\n            index += 2\n        elif query_type == 2:\n            i = int(queries[index]) - 1\n            x = int(queries[index+1])\n            B[i] = x\n            max_B[i][i] = x\n            index += 2\n        elif query_type == 3:\n            l = int(queries[index]) - 1\n            r = int(queries[index+1])\n            v = 0\n            for i in range(l, r+1):\n                v = max(v + A[i], v * B[i])\n            results.append(v)\n            index += 2\n    \n    # Print the results for type 3 queries\n    for result in results:\n        print(result)\n\n# Call the function to process the queries\nprocess_queries()"}
{"task_id": "3551", "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_xor = 0\n\n    def insert(self, num):\n        node = self\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n            node.max_xor = max(node.max_xor, num)\n\n    def search(self, num):\n        node = self\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                node = node.children[1 - bit]\n                max_xor |= (1 << i)\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)], key=lambda x: x[1])\n    trie = TrieNode()\n    result = [0] * len(queries)\n    j = 0\n    \n    for l, r, i in queries:\n        while j <= r:\n            trie.insert(prefix_xor[j])\n            j += 1\n        result[i] = trie.search(prefix_xor[r] ^ prefix_xor[l - 1])\n    \n    return result", "passed": false, "raw_code": "```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.max_xor = 0\n\n    def insert(self, num):\n        node = self\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node.children:\n                node.children[bit] = TrieNode()\n            node = node.children[bit]\n            node.max_xor = max(node.max_xor, num)\n\n    def search(self, num):\n        node = self\n        max_xor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node.children:\n                node = node.children[1 - bit]\n                max_xor |= (1 << i)\n            else:\n                node = node.children[bit]\n        return max_xor\n\ndef max_xor_subarray(nums, queries):\n    n = len(nums)\n    prefix_xor = [0] * (n + 1)\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\n    \n    queries = sorted([(l, r, i) for i, (l, r) in enumerate(queries)], key=lambda x: x[1])\n    trie = TrieNode()\n    result = [0] * len(queries)\n    j = 0\n    \n    for l, r, i in queries:\n        while j <= r:\n            trie.insert(prefix_xor[j])\n            j += 1\n        result[i] = trie.search(prefix_xor[r] ^ prefix_xor[l - 1])\n    \n    return result\n```"}
{"task_id": "arc183_c", "code": "def count_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for l, r, x in conditions:\n        new_dp = [0] * (N + 1)\n        for p in range(1, N + 1):\n            if p < x or p > r:\n                new_dp[p] = (new_dp[p] + dp[p]) % MOD\n            elif p == x:\n                for q in range(l - 1, r):\n                    if q != x:\n                        new_dp[q] = (new_dp[q] + dp[p]) % MOD\n        dp = new_dp\n    return sum(dp) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = [(int(data[i * 3 + 2]), int(data[i * 3 + 3]), int(data[i * 3 + 4])) for i in range(M)]\nprint(count_permutations(N, M, conditions))", "passed": false, "raw_code": "def count_permutations(N, M, conditions):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for l, r, x in conditions:\n        new_dp = [0] * (N + 1)\n        for p in range(1, N + 1):\n            if p < x or p > r:\n                new_dp[p] = (new_dp[p] + dp[p]) % MOD\n            elif p == x:\n                for q in range(l - 1, r):\n                    if q != x:\n                        new_dp[q] = (new_dp[q] + dp[p]) % MOD\n        dp = new_dp\n    return sum(dp) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nconditions = [(int(data[i * 3 + 2]), int(data[i * 3 + 3]), int(data[i * 3 + 4])) for i in range(M)]\nprint(count_permutations(N, M, conditions))"}
{"task_id": "arc183_b", "code": "d", "passed": false, "raw_code": "```python\ndef can_make_equal():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        # Create frequency maps for A and B\n        freq_A = {}\n        freq_B = {}\n        \n        for num in A:\n            freq_A[num] = freq_A.get(num, 0) + 1\n        \n        for num in B:\n            freq_B[num] = freq_B.get(num, 0) + 1\n        \n        # Check if frequencies match\n        if freq_A != freq_B:\n            results.append(\"No\")\n            continue\n        \n        # Sliding window to check if elements can be moved within range K\n        for num in set(B):\n            left = 0\n            right = 0\n            count_in_range = 0\n            \n            while right < N:\n                if A[right] == num:\n                    count_in_range += 1\n                \n                if right - left > K:\n                    if A[left] == num:\n                        count_in_range -= 1\n                    left += 1\n                \n                if count_in_range == 0:\n                    break\n                \n                right += 1\n            \n            if count_in_range == 0:\n                results.append(\"No\")\n                break\n            else:\n                freq_A[num] -= 1\n                freq_B[num] -= 1\n        \n        if len(results) == len(set(B)):\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\ncan_make_equal()"}
{"task_id": "abc368_d", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef find_min_vertices(N, K, edges, V):\n    # Build the tree using adjacency list\n    tree = defaultdict(list)\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    # Function to perform DFS and find the subtree with all specified vertices\n    def dfs(node, parent, visited, subtree):\n        visited.add(node)\n        subtree.add(node)\n        for neighbor in tree[node]:\n            if neighbor != parent and neighbor not in visited:\n                dfs(neighbor, node, visited, subtree)\n\n    # Find the subtree with all specified vertices\n    visited = set()\n    subtree = set()\n    for v in V:\n        if v not in visited:\n            dfs(v, -1, visited, subtree)\n\n    # Return the size of the subtree\n    return len(subtree)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N-1):\n    a = int(data[2+2*i])\n    b = int(data[3+2*i])\n    edges.append((a, b))\nV = list(map(int, data[2*N+1:2*N+1+K]))\n\n# Find and print the minimum number of vertices\nprint(find_min_vertices(N, K, edges, V))\n", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict, deque\n\ndef find_min_vertices(N, K, edges, V):\n    # Build the tree using adjacency list\n    tree = defaultdict(list)\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    # Function to perform DFS and find the subtree with all specified vertices\n    def dfs(node, parent, visited, subtree):\n        visited.add(node)\n        subtree.add(node)\n        for neighbor in tree[node]:\n            if neighbor != parent and neighbor not in visited:\n                dfs(neighbor, node, visited, subtree)\n\n    # Find the subtree with all specified vertices\n    visited = set()\n    subtree = set()\n    for v in V:\n        if v not in visited:\n            dfs(v, -1, visited, subtree)\n\n    # Return the size of the subtree\n    return len(subtree)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nedges = []\nfor i in range(N-1):\n    a = int(data[2+2*i])\n    b = int(data[3+2*i])\n    edges.append((a, b))\nV = list(map(int, data[2*N+1:2*N+1+K]))\n\n# Find and print the minimum number of vertices\nprint(find_min_vertices(N, K, edges, V))\n"}
{"task_id": "arc182_e", "code": "def calculate_min_mod_values(N, M, C, K, A):\n    min_mod_values = []\n    for k in range(K):\n        mod_values = [(C * k + A[i]) % M for i in range(N)]\n        min_mod_values.append(min(mod_values))\n    return min_mod_values\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    min_mod_values = calculate_min_mod_values(N, M, C, K, A)\n    result = sum(min_mod_values)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef calculate_min_mod_values(N, M, C, K, A):\n    min_mod_values = []\n    for k in range(K):\n        mod_values = [(C * k + A[i]) % M for i in range(N)]\n        min_mod_values.append(min(mod_values))\n    return min_mod_values\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    min_mod_values = calculate_min_mod_values(N, M, C, K, A)\n    result = sum(min_mod_values)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3575", "code": "def maxSubsequenceValue(nums, k):\n    from itertools import combinations\n    \n    n = len(nums)\n    max_value = 0\n    \n    for subseq in combinations(nums, 2 * k):\n        first_half = subseq[:k]\n        second_half = subseq[k:]\n        \n        or_first_half = 0\n        or_second_half = 0\n        \n        for num in first_half:\n            or_first_half |= num\n        \n        for num in second_half:\n            or_second_half |= num\n        \n        max_value = max(max_value, or_first_half ^ or_second_half)\n    \n    return max_value", "passed": false, "raw_code": "```python\ndef maxSubsequenceValue(nums, k):\n    from itertools import combinations\n    \n    n = len(nums)\n    max_value = 0\n    \n    for subseq in combinations(nums, 2 * k):\n        first_half = subseq[:k]\n        second_half = subseq[k:]\n        \n        or_first_half = 0\n        or_second_half = 0\n        \n        for num in first_half:\n            or_first_half |= num\n        \n        for num in second_half:\n            or_second_half |= num\n        \n        max_value = max(max_value, or_first_half ^ or_second_half)\n    \n    return max_value\n```"}
{"task_id": "abc370_g", "code": "def sum_of_divisors(n):\n    divisors_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors_sum[j] += i\n    return divisors_sum\n\ndef is_good_integer(n, divisors_sum):\n    return divisors_sum[n] % 3 == 0\n\ndef count_sequences(N, M):\n    MOD = 998244353\n    divisors_sum = sum_of_divisors(N)\n    \n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    for i in range(1, N + 1):\n        if is_good_integer(i, divisors_sum):\n            dp[1][i] = 1\n    \n    for i in range(2, M + 1):\n        for j in range(1, N + 1):\n            for k in range(1, j + 1):\n                if is_good_integer(j, divisors_sum):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % MOD\n    \n    result = 0\n    for j in range(1, N + 1):\n        if is_good_integer(j, divisors_sum):\n            result = (result + dp[M][j]) % MOD\n    \n    return result\n\n# Read input\nN, M = map(int, input().split())\n\n# Print the result\nprint(count_sequences(N, M))", "passed": false, "raw_code": "```python\ndef sum_of_divisors(n):\n    divisors_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors_sum[j] += i\n    return divisors_sum\n\ndef is_good_integer(n, divisors_sum):\n    return divisors_sum[n] % 3 == 0\n\ndef count_sequences(N, M):\n    MOD = 998244353\n    divisors_sum = sum_of_divisors(N)\n    \n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    for i in range(1, N + 1):\n        if is_good_integer(i, divisors_sum):\n            dp[1][i] = 1\n    \n    for i in range(2, M + 1):\n        for j in range(1, N + 1):\n            for k in range(1, j + 1):\n                if is_good_integer(j, divisors_sum):\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % MOD\n    \n    result = 0\n    for j in range(1, N + 1):\n        if is_good_integer(j, divisors_sum):\n            result = (result + dp[M][j]) % MOD\n    \n    return result\n\n# Read input\nN, M = map(int, input().split())\n\n# Print the result\nprint(count_sequences(N, M))\n```"}
{"task_id": "3560", "code": "def min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if x == px and y == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(sorted(positions)))\n    if key in memo:\n        return memo[key]\n    \n    max_moves = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        if len(remaining_positions) % 2 == 0:\n            max_moves = max(max_moves, moves + max_moves(px, py, remaining_positions, memo))\n        else:\n            max_moves = max(max_moves, moves + min_moves(px, py, kx, ky) + max_moves(kx, ky, remaining_positions, memo))\n    \n    memo[key] = max_moves\n    return max_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return max_moves(kx, ky, positions, memo)", "passed": false, "raw_code": "```python\ndef min_moves(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if x == px and y == py:\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n    return float('inf')\n\ndef max_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    \n    key = (kx, ky, tuple(sorted(positions)))\n    if key in memo:\n        return memo[key]\n    \n    max_moves = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves(kx, ky, px, py)\n        remaining_positions = positions[:i] + positions[i+1:]\n        if len(remaining_positions) % 2 == 0:\n            max_moves = max(max_moves, moves + max_moves(px, py, remaining_positions, memo))\n        else:\n            max_moves = max(max_moves, moves + min_moves(px, py, kx, ky) + max_moves(kx, ky, remaining_positions, memo))\n    \n    memo[key] = max_moves\n    return max_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return max_moves(kx, ky, positions, memo)\n```"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    coordinates.sort()\n    \n    # Create a dictionary to map coordinates to indices\n    coord_to_index = {tuple(coord): i for i, coord in enumerate(coordinates)}\n    \n    # Initialize memoization table\n    memo = {}\n    \n    def dfs(i):\n        if i in memo:\n            return memo[i]\n        \n        x, y = coordinates[i]\n        max_path_length = 1\n        \n        # Check right neighbor\n        if i + 1 < n and coordinates[i + 1][0] > x and coordinates[i + 1][1] > y:\n            max_path_length = max(max_path_length, 1 + dfs(i + 1))\n        \n        # Check down neighbor\n        if i + n < n * n and coordinates[i + n][0] > x and coordinates[i + n][1] > y:\n            max_path_length = max(max_path_length, 1 + dfs(i + n))\n        \n        memo[i] = max_path_length\n        return max_path_length\n    \n    # Start DFS from the node corresponding to the coordinate at index k\n    start_index = coord_to_index[tuple(coordinates[k])]\n    return dfs(start_index)", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    coordinates.sort()\n    \n    # Create a dictionary to map coordinates to indices\n    coord_to_index = {tuple(coord): i for i, coord in enumerate(coordinates)}\n    \n    # Initialize memoization table\n    memo = {}\n    \n    def dfs(i):\n        if i in memo:\n            return memo[i]\n        \n        x, y = coordinates[i]\n        max_path_length = 1\n        \n        # Check right neighbor\n        if i + 1 < n and coordinates[i + 1][0] > x and coordinates[i + 1][1] > y:\n            max_path_length = max(max_path_length, 1 + dfs(i + 1))\n        \n        # Check down neighbor\n        if i + n < n * n and coordinates[i + n][0] > x and coordinates[i + n][1] > y:\n            max_path_length = max(max_path_length, 1 + dfs(i + n))\n        \n        memo[i] = max_path_length\n        return max_path_length\n    \n    # Start DFS from the node corresponding to the coordinate at index k\n    start_index = coord_to_index[tuple(coordinates[k])]\n    return dfs(start_index)\n```"}
{"task_id": "3583", "code": "def solve(nums, queries):\n    from collections import defaultdict\n    import math\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Compute the frequency of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = math.gcd(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    # Get the unique GCD values and sort them\n    unique_gcds = sorted(gcd_count.keys())\n    \n    # Compute the prefix sum array\n    prefix_sum = [0]\n    for gcd_val in unique_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_count[gcd_val])\n    \n    # Answer the queries\n    answer = []\n    for query in queries:\n        idx = query + 1\n        if idx < prefix_sum[-1]:\n            for i in range(len(unique_gcds)):\n                if prefix_sum[i] < idx <= prefix_sum[i + 1]:\n                    answer.append(unique_gcds[i])\n                    break\n        else:\n            answer.append(unique_gcds[-1])\n    \n    return answer", "passed": false, "raw_code": "```python\ndef solve(nums, queries):\n    from collections import defaultdict\n    import math\n    \n    n = len(nums)\n    gcd_count = defaultdict(int)\n    \n    # Compute the frequency of each GCD value\n    for i in range(n):\n        for j in range(i + 1, n):\n            gcd_val = math.gcd(nums[i], nums[j])\n            gcd_count[gcd_val] += 1\n    \n    # Get the unique GCD values and sort them\n    unique_gcds = sorted(gcd_count.keys())\n    \n    # Compute the prefix sum array\n    prefix_sum = [0]\n    for gcd_val in unique_gcds:\n        prefix_sum.append(prefix_sum[-1] + gcd_count[gcd_val])\n    \n    # Answer the queries\n    answer = []\n    for query in queries:\n        idx = query + 1\n        if idx < prefix_sum[-1]:\n            for i in range(len(unique_gcds)):\n                if prefix_sum[i] < idx <= prefix_sum[i + 1]:\n                    answer.append(unique_gcds[i])\n                    break\n        else:\n            answer.append(unique_gcds[-1])\n    \n    return answer\n```"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    for i in range(n - m + 1):\n        diff_count = sum(1 for j in range(m) if s[i + j] != pattern[j])\n        if diff_count <= 1:\n            return i\n    return -1\n```"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    from itertools import combinations, permutations\n    \n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def is_divisible(num, k):\n        return num % k == 0\n    \n    count = 0\n    \n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    half_length = (n + 1) // 2\n    digits = list(range(1, 10)) + [0] * (n - 1)\n    \n    for comb in combinations(digits, half_length):\n        if sum(comb) % k != 0:\n            continue\n        perm = set(permutations(comb))\n        for p in perm:\n            if p[0] == 0:\n                continue\n            num = int(''.join(map(str, p)))\n            if is_palindrome(num):\n                count += 1\n    \n    return count", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    from itertools import combinations, permutations\n    \n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def is_divisible(num, k):\n        return num % k == 0\n    \n    count = 0\n    \n    if n == 1:\n        return sum(1 for i in range(1, 10) if i % k == 0)\n    \n    half_length = (n + 1) // 2\n    digits = list(range(1, 10)) + [0] * (n - 1)\n    \n    for comb in combinations(digits, half_length):\n        if sum(comb) % k != 0:\n            continue\n        perm = set(permutations(comb))\n        for p in perm:\n            if p[0] == 0:\n                continue\n            num = int(''.join(map(str, p)))\n            if is_palindrome(num):\n                count += 1\n    \n    return count\n```"}
{"task_id": "arc182_a", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize DP array\n    dp = [0] * (Q + 1)\n    dp[0] = 1\n    \n    max_val = [0] * (N + 1)\n    \n    for i in range(1, Q + 1):\n        p = P[i - 1]\n        v = V[i - 1]\n        \n        if p == 1:\n            new_max_val = max(max_val[:p], default=0)\n            if new_max_val <= v:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = 0\n        else:\n            new_max_val = max(max_val[p - 1:], default=0)\n            if new_max_val <= v:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = 0\n        \n        max_val[:p] = [max(v, x) for x in max_val[:p]]\n    \n    print(dp[-1] % MOD)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    P = []\n    V = []\n    for _ in range(Q):\n        P.append(int(data[index]))\n        V.append(int(data[index + 1]))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize DP array\n    dp = [0] * (Q + 1)\n    dp[0] = 1\n    \n    max_val = [0] * (N + 1)\n    \n    for i in range(1, Q + 1):\n        p = P[i - 1]\n        v = V[i - 1]\n        \n        if p == 1:\n            new_max_val = max(max_val[:p], default=0)\n            if new_max_val <= v:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = 0\n        else:\n            new_max_val = max(max_val[p - 1:], default=0)\n            if new_max_val <= v:\n                dp[i] = dp[i - 1]\n            else:\n                dp[i] = 0\n        \n        max_val[:p] = [max(v, x) for x in max_val[:p]]\n    \n    print(dp[-1] % MOD)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_c", "code": "def count_divisors(n):\n    if n == 1:\n        return 1\n    count = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            exp = 0\n            while n % i == 0:\n                n //= i\n                exp += 1\n            count *= (exp + 1)\n        i += 1\n    if n > 1:\n        count *= 2\n    return count\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Precompute the number of divisors for each number up to M\n    divisors = [count_divisors(i) for i in range(1, M + 1)]\n    \n    # Initialize DP array\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    # Fill DP array\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            dp[i] = (dp[i] + dp[i - 1] * divisors[j - 1]) % MOD\n    \n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef count_divisors(n):\n    if n == 1:\n        return 1\n    count = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            exp = 0\n            while n % i == 0:\n                n //= i\n                exp += 1\n            count *= (exp + 1)\n        i += 1\n    if n > 1:\n        count *= 2\n    return count\n\nMOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Precompute the number of divisors for each number up to M\n    divisors = [count_divisors(i) for i in range(1, M + 1)]\n    \n    # Initialize DP array\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    \n    # Fill DP array\n    for i in range(1, N + 1):\n        for j in range(M, 0, -1):\n            dp[i] = (dp[i] + dp[i - 1] * divisors[j - 1]) % MOD\n    \n    print(dp[N])\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"final_accuracy": "0.00%"}
