{"difficulty": "hard", "num_threads": 32, "temperature": 0.9, "n": 1, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_temp09_bug_trace_TPL_CODEEXECUTOR_qwen_7b_hard_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc366_f", "code": "d", "passed": false, "raw_code": "```python\ndef nested_function_max_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    max_values = [B for A, B in functions]  # Initial maximum values for f_i(1)\n    \n    for i in range(K):\n        new_max_values = [0] * N\n        for j in range(N):\n            for k in range(N):\n                if j != k:\n                    A_j, B_j = functions[j]\n                    A_k, B_k = functions[k]\n                    new_value = A_j * (A_k * 1 + B_k) + B_j\n                    new_max_values[j] = max(new_max_values[j], new_value)\n        max_values = new_max_values\n    \n    print(max(max_values))\n\nnested_function_max_value()"}
{"task_id": "abc368_f", "code": "d", "passed": false, "raw_code": "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def is_composite(n):\n        if n < 4:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return True\n        return False\n    \n    for num in A:\n        if is_composite(num):\n            print(\"Anna\")\n            return\n    print(\"Bruno\")\n\ndetermine_winner()"}
{"task_id": "abc368_d", "code": "f", "passed": false, "raw_code": "```python\nfrom collections import defaultdict, deque\n\ndef bfs_min_subtree(n, edges, k, vertices):\n    # Step 1: Build the graph\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Step 2: Perform BFS to find the minimum subtree\n    visited = set()\n    queue = deque([vertices[0]])\n    visited.add(vertices[0])\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    # The number of vertices in the visited set is the answer\n    return len(visited)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    a = int(data[2 + 2 * i]) - 1\n    b = int(data[3 + 2 * i]) - 1\n    edges.append((a, b))\nvertices = list(map(int, data[2 + 2 * (n - 1):])) - 1\n\n# Call the function and print the result\nprint(bfs_min_subtree(n, edges, k, vertices))"}
{"task_id": "abc366_g", "code": "import sys\n\ndef dfs(current, parent, assignments, graph, visited):\n    xor_adj = 0\n    for neighbor in graph[current]:\n        if neighbor != parent:\n            xor_adj ^= assignments[neighbor]\n    if xor_adj == 0:\n        assignments[current] = 1\n    else:\n        for i in range(1, 2**60):\n            if i ^ xor_adj == 0:\n                assignments[current] = i\n                break\n\ndef can_assign_integers(N, M, edges):\n    graph = [[] for _ in range(N)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    assignments = [0] * N\n    visited = [False] * N\n    \n    for i in range(N):\n        if not visited[i]:\n            dfs(i, -1, assignments, graph, visited)\n    \n    for i in range(N):\n        xor_adj = 0\n        for neighbor in graph[i]:\n            xor_adj ^= assignments[neighbor]\n        if xor_adj != 0:\n            return \"No\"\n    \n    return \"Yes\\n\" + \" \".join(map(str, assignments))\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2*i]) - 1, int(data[3 + 2*i]) - 1) for i in range(M)]\n\n# Determine the solution\nresult = can_assign_integers(N, M, edges)\n\n# Output the result\nprint(result)", "passed": false, "raw_code": "```python\nimport sys\n\ndef dfs(current, parent, assignments, graph, visited):\n    xor_adj = 0\n    for neighbor in graph[current]:\n        if neighbor != parent:\n            xor_adj ^= assignments[neighbor]\n    if xor_adj == 0:\n        assignments[current] = 1\n    else:\n        for i in range(1, 2**60):\n            if i ^ xor_adj == 0:\n                assignments[current] = i\n                break\n\ndef can_assign_integers(N, M, edges):\n    graph = [[] for _ in range(N)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    assignments = [0] * N\n    visited = [False] * N\n    \n    for i in range(N):\n        if not visited[i]:\n            dfs(i, -1, assignments, graph, visited)\n    \n    for i in range(N):\n        xor_adj = 0\n        for neighbor in graph[i]:\n            xor_adj ^= assignments[neighbor]\n        if xor_adj != 0:\n            return \"No\"\n    \n    return \"Yes\\n\" + \" \".join(map(str, assignments))\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nedges = [(int(data[2 + 2*i]) - 1, int(data[3 + 2*i]) - 1) for i in range(M)]\n\n# Determine the solution\nresult = can_assign_integers(N, M, edges)\n\n# Output the result\nprint(result)\n```"}
{"task_id": "abc367_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n\n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * M for _ in range(N)]\n    \n    # Base case: dp[0][A[0]] = 1\n    dp[0][A[0]] = 1\n    \n    for i in range(1, N):\n        for j in range(M):\n            dp[i][j] = dp[i-1][j]\n        for j in range(M):\n            dp[i][(j ^ A[i])] += dp[i-1][j]\n            dp[i][(j ^ A[i])] %= MOD\n    \n    # Calculate the total score\n    total_score = 0\n    for i in range(N):\n        if (i + 1) % M == 0:\n            total_score += pow(sum(dp[i]), K, MOD)\n            total_score %= MOD\n    \n    print(total_score)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n\n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * M for _ in range(N)]\n    \n    # Base case: dp[0][A[0]] = 1\n    dp[0][A[0]] = 1\n    \n    for i in range(1, N):\n        for j in range(M):\n            dp[i][j] = dp[i-1][j]\n        for j in range(M):\n            dp[i][(j ^ A[i])] += dp[i-1][j]\n            dp[i][(j ^ A[i])] %= MOD\n    \n    # Calculate the total score\n    total_score = 0\n    for i in range(N):\n        if (i + 1) % M == 0:\n            total_score += pow(sum(dp[i]), K, MOD)\n            total_score %= MOD\n    \n    print(total_score)\n\nmain()\n```"}
{"task_id": "abc370_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    MOD = 998244353\n    \n    # Initialize dp table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(i):\n            prefix_sum += A[j]\n            if prefix_sum <= K:\n                dp[i][prefix_sum] = (dp[i][prefix_sum] + dp[j][0]) % MOD\n            for k in range(1, min(K, prefix_sum) + 1):\n                dp[i][prefix_sum] = (dp[i][prefix_sum] + dp[j][k]) % MOD\n    \n    result = sum(dp[N][j] for j in range(K + 1)) % MOD\n    print(result)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n\n    MOD = 998244353\n    \n    # Initialize dp table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, N + 1):\n        prefix_sum = 0\n        for j in range(i):\n            prefix_sum += A[j]\n            if prefix_sum <= K:\n                dp[i][prefix_sum] = (dp[i][prefix_sum] + dp[j][0]) % MOD\n            for k in range(1, min(K, prefix_sum) + 1):\n                dp[i][prefix_sum] = (dp[i][prefix_sum] + dp[j][k]) % MOD\n    \n    result = sum(dp[N][j] for j in range(K + 1)) % MOD\n    print(result)\n\nmain()\n```"}
{"task_id": "abc369_e", "code": "import sys\nfrom collections import defaultdict\n\ndef dfs(node, visited, graph, bridges, current_time):\n    if node == N:\n        return current_time\n    \n    min_time = float('inf')\n    for neighbor, time in graph[node]:\n        if not visited[neighbor] or neighbor == node - 1 or neighbor == node + 1:\n            visited[neighbor] = True\n            min_time = min(min_time, dfs(neighbor, visited, graph, bridges, current_time + time))\n            visited[neighbor] = False\n    \n    return min_time\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    graph = defaultdict(list)\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        t = int(data[index + 2])\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n        index += 3\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        bridges = set(int(data[index + i]) - 1 for i in range(K))\n        index += K\n        \n        # Generate all possible paths using the specified bridges\n        visited = [False] * N\n        visited[0] = True\n        min_time = dfs(0, visited, graph, bridges, 0)\n        \n        results.append(min_time)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict\n\ndef dfs(node, visited, graph, bridges, current_time):\n    if node == N:\n        return current_time\n    \n    min_time = float('inf')\n    for neighbor, time in graph[node]:\n        if not visited[neighbor] or neighbor == node - 1 or neighbor == node + 1:\n            visited[neighbor] = True\n            min_time = min(min_time, dfs(neighbor, visited, graph, bridges, current_time + time))\n            visited[neighbor] = False\n    \n    return min_time\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    graph = defaultdict(list)\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        t = int(data[index + 2])\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n        index += 3\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        bridges = set(int(data[index + i]) - 1 for i in range(K))\n        index += K\n        \n        # Generate all possible paths using the specified bridges\n        visited = [False] * N\n        visited[0] = True\n        min_time = dfs(0, visited, graph, bridges, 0)\n        \n        results.append(min_time)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc373_e", "code": "d", "passed": false, "raw_code": "```python\ndef min_additional_votes():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    # Total votes already counted\n    total_votes = sum(A)\n    # Remaining votes\n    remaining_votes = K - total_votes\n    \n    # Calculate the max votes any candidate could get from the remaining votes\n    max_possible_votes_for_any_candidate = remaining_votes // N\n    \n    # Sort the votes in descending order to easily compare with others\n    A.sort(reverse=True)\n    \n    results = []\n    for i in range(N):\n        if A[i] > sum(A[:i+1]) - A[i]:\n            results.append(0)\n        elif A[i] + max_possible_votes_for_any_candidate <= sum(A[:i]):\n            results.append(-1)\n        else:\n            # Find the minimum additional votes needed\n            for j in range(max_possible_votes_for_any_candidate, -1, -1):\n                if A[i] + j > sum(A[:i+1]) - A[i] and A[i] + j <= sum(A[:i]) + j * (N-i-1):\n                    results.append(j)\n                    break\n    \n    print(\" \".join(map(str, results)))\n\nmin_additional_votes()"}
{"task_id": "arc182_d", "code": "def min_operations(N, M, A, B):\n    operations = 0\n    for i in range(N):\n        if A[i] != B[i]:\n            diff = abs(A[i] - B[i])\n            mod_diff = M - diff\n            operations += min(diff, mod_diff)\n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print the result\nresult = min_operations(N, M, A, B)\nprint(result)", "passed": false, "raw_code": "```python\ndef min_operations(N, M, A, B):\n    operations = 0\n    for i in range(N):\n        if A[i] != B[i]:\n            diff = abs(A[i] - B[i])\n            mod_diff = M - diff\n            operations += min(diff, mod_diff)\n    return operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Calculate and print the result\nresult = min_operations(N, M, A, B)\nprint(result)\n```"}
{"task_id": "abc372_g", "code": "d", "passed": false, "raw_code": "```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        \n        count = 0\n        \n        for i in range(N):\n            A_i = int(data[index])\n            B_i = int(data[index + 1])\n            C_i = int(data[index + 2])\n            index += 3\n            \n            if A_i >= C_i or B_i >= C_i:\n                continue\n            \n            max_y = (C_i - 1) // B_i\n            if max_y >= 1:\n                count += max_y\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\ncount_valid_pairs()"}
{"task_id": "abc368_g", "code": "d", "passed": false, "raw_code": "```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    a = list(map(int, data[index:index+N]))\n    index += N\n    \n    b = list(map(int, data[index:index+N]))\n    index += N\n    \n    Q = int(data[index])\n    index += 1\n    \n    dp = {}\n    \n    def max_value(l, r):\n        if (l, r) in dp:\n            return dp[(l, r)]\n        \n        if l == r:\n            return max(a[l], b[l])\n        \n        ans = 0\n        for i in range(l, r):\n            ans = max(ans, max(max_value(l, i) + a[i+1], max_value(l, i) * b[i+1]))\n        \n        dp[(l, r)] = ans\n        return ans\n    \n    results = []\n    while Q > 0:\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            a[i] = x\n        elif query_type == 2:\n            i = int(data[index]) - 1\n            index += 1\n            x = int(data[index])\n            index += 1\n            b[i] = x\n        elif query_type == 3:\n            l = int(data[index]) - 1\n            index += 1\n            r = int(data[index]) - 1\n            index += 1\n            results.append(str(max_value(l, r)))\n        \n        Q -= 1\n    \n    for result in results:\n        print(result)\n\n# Call the function to process the queries\nprocess_queries()"}
{"task_id": "3527", "code": "def alternatingGroups(colors, queries):\n    n = len(colors)\n    # Extend colors to simulate circular arrangement\n    extended_colors = colors + colors[:2]\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if (extended_colors[i:i+size] == [0]*(size//2) + [1]*(size//2) or\n                extended_colors[i:i+size] == [1]*(size//2) + [0]*(size//2)):\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            if old_color != new_color:\n                colors[index] = new_color\n                extended_colors[index+n] = new_color\n                for size in range(3, n+1):\n                    if index >= size-1 and index+n-size+1 < 2*n:\n                        left_group = extended_colors[index:index+size-1] == [0]*(size//2-1) + [1]*(size//2-1)\n                        right_group = extended_colors[index+n-size+1:index+n] == [1]*(size//2-1) + [0]*(size//2-1)\n                        middle_group = extended_colors[index+size-1:index+n-size+1] == [0]*(size//2) + [1]*(size//2)\n                        if left_group or right_group or middle_group:\n                            result[-1] += 1 if new_color != old_color else -1\n    \n    return result", "passed": false, "raw_code": "```python\ndef alternatingGroups(colors, queries):\n    n = len(colors)\n    # Extend colors to simulate circular arrangement\n    extended_colors = colors + colors[:2]\n    \n    def count_alternating_groups(size):\n        count = 0\n        for i in range(n):\n            if (extended_colors[i:i+size] == [0]*(size//2) + [1]*(size//2) or\n                extended_colors[i:i+size] == [1]*(size//2) + [0]*(size//2)):\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            result.append(count_alternating_groups(query[1]))\n        elif query[0] == 2:\n            index, new_color = query[1], query[2]\n            old_color = colors[index]\n            if old_color != new_color:\n                colors[index] = new_color\n                extended_colors[index+n] = new_color\n                for size in range(3, n+1):\n                    if index >= size-1 and index+n-size+1 < 2*n:\n                        left_group = extended_colors[index:index+size-1] == [0]*(size//2-1) + [1]*(size//2-1)\n                        right_group = extended_colors[index+n-size+1:index+n] == [1]*(size//2-1) + [0]*(size//2-1)\n                        middle_group = extended_colors[index+size-1:index+n-size+1] == [0]*(size//2) + [1]*(size//2)\n                        if left_group or right_group or middle_group:\n                            result[-1] += 1 if new_color != old_color else -1\n    \n    return result\n```"}
{"task_id": "arc181_b", "code": "d", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    result = []\n    for char in X:\n        if char == '0':\n            result.append(S)\n        else:\n            result.append(T)\n    return ''.join(result)\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        S = data[index]\n        X = data[index + 1]\n        Y = data[index + 2]\n        index += 3\n        \n        len_X = len(X)\n        len_Y = len(Y)\n        \n        if len_X != len_Y:\n            results.append(\"No\")\n            continue\n        \n        for i in range(len_X):\n            if X[i] == '0' and Y[i] == '0':\n                continue\n            elif X[i] == '1' and Y[i] == '1':\n                continue\n            elif X[i] == '0' and Y[i] == '1':\n                if not T:\n                    results.append(\"No\")\n                    break\n            elif X[i] == '1' and Y[i] == '0':\n                if not T:\n                    results.append(\"No\")\n                    break\n        else:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\nsolve()"}
{"task_id": "arc183_c", "code": "f", "passed": false, "raw_code": "```python\nfrom itertools import permutations\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    conditions = []\n    for _ in range(M):\n        L = int(data[index])\n        R = int(data[index + 1])\n        X = int(data[index + 2])\n        index += 3\n        conditions.append((L, R, X))\n    \n    MOD = 998244353\n    count = 0\n    \n    for perm in permutations(range(1, N + 1)):\n        valid = True\n        for L, R, X in conditions:\n            subarray = perm[L-1:R]\n            if max(subarray) == perm[X-1]:\n                valid = False\n                break\n        if valid:\n            count += 1\n    \n    print(count)\n\nsolve()"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [[0] * (n + 1) for _ in range(51)]\n    dp_non_incr = [[0] * (n + 1) for _ in range(51)]\n    \n    # Initialize DP tables\n    for j in range(51):\n        dp_non_decr[j][1] = 1\n        dp_non_incr[j][1] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        current = nums[i]\n        for j in range(current + 1):\n            dp_non_decr[j][i + 1] += dp_non_decr[j][i]\n            dp_non_decr[j][i + 1] %= MOD\n            dp_non_incr[current - j][i + 1] += dp_non_incr[j][i]\n            dp_non_incr[current - j][i + 1] %= MOD\n    \n    # Combine results\n    result = 0\n    for j in range(51):\n        result += dp_non_decr[j][n] * dp_non_incr[j][n]\n        result %= MOD\n    \n    return result", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    dp_non_decr = [[0] * (n + 1) for _ in range(51)]\n    dp_non_incr = [[0] * (n + 1) for _ in range(51)]\n    \n    # Initialize DP tables\n    for j in range(51):\n        dp_non_decr[j][1] = 1\n        dp_non_incr[j][1] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        current = nums[i]\n        for j in range(current + 1):\n            dp_non_decr[j][i + 1] += dp_non_decr[j][i]\n            dp_non_decr[j][i + 1] %= MOD\n            dp_non_incr[current - j][i + 1] += dp_non_incr[j][i]\n            dp_non_incr[current - j][i + 1] %= MOD\n    \n    # Combine results\n    result = 0\n    for j in range(51):\n        result += dp_non_decr[j][n] * dp_non_incr[j][n]\n        result %= MOD\n    \n    return result\n```"}
{"task_id": "abc366_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n\n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n\n    def count_points(D, points):\n        total_count = 0\n        for point in points:\n            x, y = point\n            total_count += max(0, D - abs(x) - abs(y) + 1)\n        return total_count\n\n    result = count_points(D, points)\n    print(result)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n\n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n\n    def count_points(D, points):\n        total_count = 0\n        for point in points:\n            x, y = point\n            total_count += max(0, D - abs(x) - abs(y) + 1)\n        return total_count\n\n    result = count_points(D, points)\n    print(result)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "abc368_e", "code": "def calculate_delays(N, M, X1):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    A = [int(data[index]) for index in range(1, M + 1)]\n    B = [int(data[index]) for index in range(M + 1, 2 * M + 1)]\n    S = [int(data[index]) for index in range(2 * M + 1, 3 * M + 1)]\n    T = [int(data[index]) for index in range(3 * M + 1, 4 * M + 1)]\n    \n    # Initialize delays\n    delays = [X1] * M\n    \n    # Sort trains based on arrival time T\n    sorted_indices = sorted(range(M), key=lambda i: T[i])\n    \n    # Calculate delays\n    for i in range(1, M):\n        current_index = sorted_indices[i]\n        prev_index = sorted_indices[i - 1]\n        \n        if B[prev_index] == A[current_index] and T[prev_index] <= S[current_index]:\n            required_delay = max(0, S[current_index] - T[prev_index] - delays[prev_index] + delays[current_index])\n            delays[current_index] += required_delay\n    \n    # Print delays excluding X1\n    print(' '.join(map(str, delays[1:])))\n    \ncalculate_delays(3, 6, 15)", "passed": false, "raw_code": "```python\ndef calculate_delays(N, M, X1):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse input\n    index = 0\n    A = [int(data[index]) for index in range(1, M + 1)]\n    B = [int(data[index]) for index in range(M + 1, 2 * M + 1)]\n    S = [int(data[index]) for index in range(2 * M + 1, 3 * M + 1)]\n    T = [int(data[index]) for index in range(3 * M + 1, 4 * M + 1)]\n    \n    # Initialize delays\n    delays = [X1] * M\n    \n    # Sort trains based on arrival time T\n    sorted_indices = sorted(range(M), key=lambda i: T[i])\n    \n    # Calculate delays\n    for i in range(1, M):\n        current_index = sorted_indices[i]\n        prev_index = sorted_indices[i - 1]\n        \n        if B[prev_index] == A[current_index] and T[prev_index] <= S[current_index]:\n            required_delay = max(0, S[current_index] - T[prev_index] - delays[prev_index] + delays[current_index])\n            delays[current_index] += required_delay\n    \n    # Print delays excluding X1\n    print(' '.join(map(str, delays[1:])))\n    \ncalculate_delays(3, 6, 15)\n```"}
{"task_id": "abc365_e", "code": "def xor_subarray_sum(N, A):\n    # Step 1: Compute the prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    # Step 2: Initialize the result\n    total_sum = 0\n    \n    # Step 3: Iterate over each bit position\n    for bit_position in range(32):\n        bit_count = 0\n        left_count = 0\n        \n        for i in range(N + 1):\n            # Check if the bit at the current position is set in the prefix XOR\n            if prefix_xor[i] & (1 << bit_position):\n                bit_count += 1\n            \n            # Calculate the number of valid subarrays that contribute to the current bit\n            total_sum += bit_count * left_count\n        \n        # Update the count of left elements\n        left_count += bit_count\n    \n    print(total_sum)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Call the function with the input\nxor_subarray_sum(N, A)", "passed": false, "raw_code": "```python\ndef xor_subarray_sum(N, A):\n    # Step 1: Compute the prefix XOR array\n    prefix_xor = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i - 1]\n    \n    # Step 2: Initialize the result\n    total_sum = 0\n    \n    # Step 3: Iterate over each bit position\n    for bit_position in range(32):\n        bit_count = 0\n        left_count = 0\n        \n        for i in range(N + 1):\n            # Check if the bit at the current position is set in the prefix XOR\n            if prefix_xor[i] & (1 << bit_position):\n                bit_count += 1\n            \n            # Calculate the number of valid subarrays that contribute to the current bit\n            total_sum += bit_count * left_count\n        \n        # Update the count of left elements\n        left_count += bit_count\n    \n    print(total_sum)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Call the function with the input\nxor_subarray_sum(N, A)\n```"}
{"task_id": "abc373_f", "code": "def max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    items = []\n    \n    index = 2\n    for _ in range(N):\n        w_i = int(data[index])\n        v_i = int(data[index + 1])\n        items.append((w_i, v_i))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w_i, v_i in items:\n        for j in range(W, w_i - 1, -1):\n            k = 1\n            while k * v_i - k**2 <= dp[j - w_i]:\n                dp[j] = max(dp[j], dp[j - w_i] + k * v_i - k**2)\n                k += 1\n    \n    print(dp[W])\n\nmax_happiness()", "passed": false, "raw_code": "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    items = []\n    \n    index = 2\n    for _ in range(N):\n        w_i = int(data[index])\n        v_i = int(data[index + 1])\n        items.append((w_i, v_i))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w_i, v_i in items:\n        for j in range(W, w_i - 1, -1):\n            k = 1\n            while k * v_i - k**2 <= dp[j - w_i]:\n                dp[j] = max(dp[j], dp[j - w_i] + k * v_i - k**2)\n                k += 1\n    \n    print(dp[W])\n\nmax_happiness()\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def f(i, j):\n        distinct_values = set()\n        left = i\n        count = 0\n        \n        for right in range(i, j + 1):\n            if A[right] not in distinct_values:\n                distinct_values.add(A[right])\n                count += len(distinct_values)\n            else:\n                while A[left] != A[right]:\n                    distinct_values.remove(A[left])\n                    left += 1\n                left += 1\n        \n        return count\n    \n    total_sum = 0\n    for i in range(N):\n        for j in range(i, N):\n            total_sum += f(i, j)\n    \n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    def f(i, j):\n        distinct_values = set()\n        left = i\n        count = 0\n        \n        for right in range(i, j + 1):\n            if A[right] not in distinct_values:\n                distinct_values.add(A[right])\n                count += len(distinct_values)\n            else:\n                while A[left] != A[right]:\n                    distinct_values.remove(A[left])\n                    left += 1\n                left += 1\n        \n        return count\n    \n    total_sum = 0\n    for i in range(N):\n        for j in range(i, N):\n            total_sum += f(i, j)\n    \n    print(total_sum)\n\nmain()\n```"}
{"task_id": "arc183_b", "code": "d", "passed": false, "raw_code": "```python\ndef can_transform_A_to_B():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        A = list(map(int, data[index:index + N]))\n        B = list(map(int, data[index + N:index + 2 * N]))\n        index += 2 * N\n        \n        # Count occurrences of each value in B\n        count_B = {}\n        for b in B:\n            if b in count_B:\n                count_B[b] += 1\n            else:\n                count_B[b] = 1\n        \n        # Function to check if a subarray of size len(subarr) contains exactly the required counts\n        def has_required_counts(subarr, required_counts):\n            current_counts = {}\n            for num in subarr:\n                if num in current_counts:\n                    current_counts[num] += 1\n                else:\n                    current_counts[num] = 1\n            \n            return current_counts == required_counts\n        \n        # Try to find a valid subarray in A for each value in B\n        found = True\n        for b, count in count_B.items():\n            left = 0\n            right = 0\n            current_count = {}\n            \n            while right < N:\n                if A[right] in current_count:\n                    current_count[A[right]] += 1\n                else:\n                    current_count[A[right]] = 1\n                \n                while right - left + 1 > K:\n                    if current_count[A[left]] > 1:\n                        current_count[A[left]] -= 1\n                    else:\n                        del current_count[A[left]]\n                    left += 1\n                \n                if current_count == {b: count}:\n                    found = True\n                    break\n                \n                right += 1\n            \n            if not found:\n                results.append(\"No\")\n                break\n        \n        if found:\n            results.append(\"Yes\")\n    \n    for result in results:\n        print(result)\n\ncan_transform_A_to_B()"}
{"task_id": "3552", "code": "def largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    def is_divisible_by_k(num_str):\n        return int(num_str) % k == 0\n    \n    half_len = (n + 1) // 2\n    half_max_digit = '9' * half_len\n    half_num = int(half_max_digit)\n    \n    while True:\n        half_num -= 1\n        half_str = str(half_num).zfill(half_len)\n        full_str = half_str[::-1] + half_str[1:] if n % 2 == 0 else half_str[::-1]\n        \n        if is_divisible_by_k(full_str):\n            return full_str", "passed": false, "raw_code": "```python\ndef largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(max(0, k - 1))\n    \n    def is_divisible_by_k(num_str):\n        return int(num_str) % k == 0\n    \n    half_len = (n + 1) // 2\n    half_max_digit = '9' * half_len\n    half_num = int(half_max_digit)\n    \n    while True:\n        half_num -= 1\n        half_str = str(half_num).zfill(half_len)\n        full_str = half_str[::-1] + half_str[1:] if n % 2 == 0 else half_str[::-1]\n        \n        if is_divisible_by_k(full_str):\n            return full_str\n```"}
{"task_id": "3550", "code": "def max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    max_sum = float('-inf')\n    \n    for i in range(m):\n        max_val = float('-inf')\n        col_idx = -1\n        for j in range(n):\n            if board[i][j] > max_val:\n                max_val = board[i][j]\n                col_idx = j\n        if col_idx != -1:\n            for k in range(m):\n                if k != i and board[k][col_idx] != float('-inf'):\n                    temp_sum = sum(board[i][j] for j in range(n) if board[i][j] != float('-inf')) + sum(board[k][j] for j in range(n) if board[k][j] != float('-inf'))\n                    if temp_sum > max_sum:\n                        max_sum = temp_sum\n                    break\n    \n    return max_sum", "passed": false, "raw_code": "```python\ndef max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    max_sum = float('-inf')\n    \n    for i in range(m):\n        max_val = float('-inf')\n        col_idx = -1\n        for j in range(n):\n            if board[i][j] > max_val:\n                max_val = board[i][j]\n                col_idx = j\n        if col_idx != -1:\n            for k in range(m):\n                if k != i and board[k][col_idx] != float('-inf'):\n                    temp_sum = sum(board[i][j] for j in range(n) if board[i][j] != float('-inf')) + sum(board[k][j] for j in range(n) if board[k][j] != float('-inf'))\n                    if temp_sum > max_sum:\n                        max_sum = temp_sum\n                    break\n    \n    return max_sum\n```"}
{"task_id": "arc182_c", "code": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n\n    MOD = 998244353\n    total_score = 0\n\n    def helper(N, M):\n        if N == 0:\n            return 1\n        if M == 1:\n            return 1\n\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\n        for m in range(1, M + 1):\n            dp[1][m] = count_divisors(m)\n\n        for n in range(2, N + 1):\n            for m in range(1, M + 1):\n                dp[n][m] = (dp[n - 1][m] + dp[n][m - 1]) % MOD\n\n        return dp[N][M]\n\n    total_score = helper(N, M)\n    print(total_score)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n\n    MOD = 998244353\n    total_score = 0\n\n    def helper(N, M):\n        if N == 0:\n            return 1\n        if M == 1:\n            return 1\n\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\n        for m in range(1, M + 1):\n            dp[1][m] = count_divisors(m)\n\n        for n in range(2, N + 1):\n            for m in range(1, M + 1):\n                dp[n][m] = (dp[n - 1][m] + dp[n][m - 1]) % MOD\n\n        return dp[N][M]\n\n    total_score = helper(N, M)\n    print(total_score)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "3531", "code": "def min_damage(power, damage, health):\n    # Calculate the total damage each enemy can inflict on Bob\n    total_damage = [(d * h) // p + (1 if (d * h) % p != 0 else 0) for d, h in zip(damage, health)]\n    \n    # Sort the enemies based on the total damage they can inflict\n    sorted_enemies = sorted(zip(total_damage, range(len(total_damage))), reverse=True)\n    \n    # Simulate the attacks and calculate the total damage Bob takes\n    bob_damage = 0\n    for td, idx in sorted_enemies:\n        if health[idx] > 0:\n            attacks = health[idx] // power\n            if health[idx] % power != 0:\n                attacks += 1\n            bob_damage += td - (attacks * power)\n            health[idx] = 0\n    \n    return bob_damage", "passed": false, "raw_code": "```python\ndef min_damage(power, damage, health):\n    # Calculate the total damage each enemy can inflict on Bob\n    total_damage = [(d * h) // p + (1 if (d * h) % p != 0 else 0) for d, h in zip(damage, health)]\n    \n    # Sort the enemies based on the total damage they can inflict\n    sorted_enemies = sorted(zip(total_damage, range(len(total_damage))), reverse=True)\n    \n    # Simulate the attacks and calculate the total damage Bob takes\n    bob_damage = 0\n    for td, idx in sorted_enemies:\n        if health[idx] > 0:\n            attacks = health[idx] // power\n            if health[idx] % power != 0:\n                attacks += 1\n            bob_damage += td - (attacks * power)\n            health[idx] = 0\n    \n    return bob_damage\n```"}
{"task_id": "arc183_d", "code": "d", "passed": false, "raw_code": "```python\ndef find_leaves(tree):\n    leaves = []\n    for node in range(1, len(tree)):\n        if len(tree[node]) == 1:\n            leaves.append(node)\n    return leaves\n\ndef max_score_operations(N, edges):\n    # Build the adjacency list representation of the tree\n    tree = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Find initial leaves\n    leaves = find_leaves(tree)\n    \n    result = []\n    \n    while leaves:\n        # Select the two outermost leaves\n        u = leaves[0]\n        v = leaves[-1]\n        \n        # Remove the leaves\n        tree[u].remove(v)\n        tree[v].remove(u)\n        \n        # Update leaves list\n        leaves.remove(u)\n        leaves.remove(v)\n        if u in leaves:\n            leaves.remove(u)\n        if v in leaves:\n            leaves.remove(v)\n        \n        # Add the pair to the result\n        result.append((u, v))\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nedges = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range((N - 1) // 2)]\n\n# Get the result\nresult = max_score_operations(N, edges)\n\n# Print the result\nfor u, v in result:\n    print(u, v)"}
{"task_id": "3532", "code": "def minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    \n    # Build the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize the marking times\n    times = [-1] * n\n    queue = deque()\n    \n    # Find all leaf nodes and add them to the queue\n    for node in range(n):\n        if len(adj_list[node]) == 1:\n            queue.append(node)\n            times[node] = 0\n    \n    # Perform BFS to propagate the marking times\n    while queue:\n        current_node = queue.popleft()\n        parent_node = adj_list[current_node][0]\n        \n        if times[parent_node] != -1:\n            continue\n        \n        if current_node % 2 == 0:\n            times[parent_node] = times[current_node] + 2\n        else:\n            times[parent_node] = times[current_node] + 1\n        \n        queue.append(parent_node)\n    \n    # Return the result\n    return times", "passed": false, "raw_code": "```python\ndef minTimeToMarkNodes(edges):\n    from collections import defaultdict, deque\n    \n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    \n    # Build the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize the marking times\n    times = [-1] * n\n    queue = deque()\n    \n    # Find all leaf nodes and add them to the queue\n    for node in range(n):\n        if len(adj_list[node]) == 1:\n            queue.append(node)\n            times[node] = 0\n    \n    # Perform BFS to propagate the marking times\n    while queue:\n        current_node = queue.popleft()\n        parent_node = adj_list[current_node][0]\n        \n        if times[parent_node] != -1:\n            continue\n        \n        if current_node % 2 == 0:\n            times[parent_node] = times[current_node] + 2\n        else:\n            times[parent_node] = times[current_node] + 1\n        \n        queue.append(parent_node)\n    \n    # Return the result\n    return times\n```"}
{"task_id": "abc373_g", "code": "d", "passed": false, "raw_code": "```python\ndef find_permutation(N, points):\n    # Function to determine if three points form a counter-clockwise turn\n    def ccw(A, B, C):\n        return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\n    # Function to check if two line segments AB and CD intersect\n    def intersects(A, B, C, D):\n        if ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D):\n            return True\n        return False\n\n    # Sort points by x-coordinate\n    points.sort(key=lambda x: x[0])\n\n    # Try all permutations of Q points\n    from itertools import permutations\n    for R in permutations(range(1, N + 1)):\n        valid = True\n        for i in range(N):\n            for j in range(i + 1, N):\n                if intersects(points[i], points[N + j - 1], points[j], points[N + R[j - 1] - 1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return ' '.join(map(str, R))\n    return '-1'\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\npoints = []\nfor i in range(N):\n    points.append((int(data[2 * i + 1]), int(data[2 * i + 2])))\npoints += [(int(data[2 * N + 1 + 2 * i + 1]), int(data[2 * N + 1 + 2 * i + 2])) for i in range(N)]\n\n# Output result\nprint(find_permutation(N, points))"}
{"task_id": "abc372_f", "code": "def count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    edges = []\n    \n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    # Fill dp table\n    for k in range(1, K + 1):\n        new_dp = [0] * (K + 1)\n        for v in range(1, N + 1):\n            if v == 1:\n                new_dp[v] = (new_dp[v] + dp[v][k - 1]) % MOD\n                new_dp[(v % N) + 1] = (new_dp[(v % N) + 1] + dp[v][k - 1]) % MOD\n            else:\n                new_dp[v] = (new_dp[v] + dp[v][k - 1]) % MOD\n            for u, v in edges:\n                if u == v:\n                    continue\n                new_dp[v] = (new_dp[v] + dp[u][k - 1]) % MOD\n        dp = new_dp\n    \n    # Sum up the ways to reach any vertex after K moves\n    result = sum(dp[v][K] for v in range(1, N + 1)) % MOD\n    print(result)\n\ncount_ways()", "passed": false, "raw_code": "```python\ndef count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    edges = []\n    \n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    MOD = 998244353\n    \n    # Initialize dp table\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    \n    # Fill dp table\n    for k in range(1, K + 1):\n        new_dp = [0] * (K + 1)\n        for v in range(1, N + 1):\n            if v == 1:\n                new_dp[v] = (new_dp[v] + dp[v][k - 1]) % MOD\n                new_dp[(v % N) + 1] = (new_dp[(v % N) + 1] + dp[v][k - 1]) % MOD\n            else:\n                new_dp[v] = (new_dp[v] + dp[v][k - 1]) % MOD\n            for u, v in edges:\n                if u == v:\n                    continue\n                new_dp[v] = (new_dp[v] + dp[u][k - 1]) % MOD\n        dp = new_dp\n    \n    # Sum up the ways to reach any vertex after K moves\n    result = sum(dp[v][K] for v in range(1, N + 1)) % MOD\n    print(result)\n\ncount_ways()\n```"}
{"task_id": "abc367_f", "code": "i", "passed": false, "raw_code": "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Read N and Q\nN = int(data[0])\nQ = int(data[1])\n\n# Read array A\nA = list(map(int, data[2:2+N]))\n\n# Read array B\nB = list(map(int, data[2+N:2+N+N]))\n\n# Read queries\nqueries = []\nindex = 2 + 2 * N\nfor _ in range(Q):\n    l_i = int(data[index]) - 1\n    r_i = int(data[index+1]) - 1\n    L_i = int(data[index+2]) - 1\n    R_i = int(data[index+3]) - 1\n    queries.append((l_i, r_i, L_i, R_i))\n    index += 4\n\n# Process each query\nresults = []\nfor l_i, r_i, L_i, R_i in queries:\n    sub_A = sorted(A[l_i:r_i+1])\n    sub_B = sorted(B[L_i:R_i+1])\n    if sub_A == sub_B:\n        results.append(\"Yes\")\n    else:\n        results.append(\"No\")\n\n# Print results\nfor result in results:\n    print(result)"}
{"task_id": "abc367_e", "code": "def process_sequence(N, K, X, A):\n    def apply_operation(A, X):\n        return [A[X[i] - 1] for i in range(N)]\n    \n    # Apply the operation once to get B\n    B = apply_operation(A, X)\n    \n    # Check if B matches A to find the cycle\n    if B == A:\n        cycle_length = 1\n    else:\n        current = B[:]\n        count = 1\n        while True:\n            current = apply_operation(current, X)\n            count += 1\n            if current == A:\n                break\n        cycle_length = count\n    \n    # Compute the effective number of operations needed\n    effective_K = K % cycle_length\n    \n    # Apply the effective number of operations\n    for _ in range(effective_K):\n        A = apply_operation(A, X)\n    \n    # Print the final result\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)", "passed": false, "raw_code": "```python\ndef process_sequence(N, K, X, A):\n    def apply_operation(A, X):\n        return [A[X[i] - 1] for i in range(N)]\n    \n    # Apply the operation once to get B\n    B = apply_operation(A, X)\n    \n    # Check if B matches A to find the cycle\n    if B == A:\n        cycle_length = 1\n    else:\n        current = B[:]\n        count = 1\n        while True:\n            current = apply_operation(current, X)\n            count += 1\n            if current == A:\n                break\n        cycle_length = count\n    \n    # Compute the effective number of operations needed\n    effective_K = K % cycle_length\n    \n    # Apply the effective number of operations\n    for _ in range(effective_K):\n        A = apply_operation(A, X)\n    \n    # Print the final result\n    print(' '.join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\nprocess_sequence(N, K, X, A)\n```"}
{"task_id": "3583", "code": "def getGCD(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef solve(nums, queries):\n    max_val = max(nums)\n    freq_map = [0] * (max_val + 1)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            freq_map[gcd_val] += 1\n    \n    sorted_gcds = []\n    for gcd_val, count in enumerate(freq_map):\n        sorted_gcds.extend([gcd_val] * count)\n    \n    return [sorted_gcds[q] for q in queries]", "passed": false, "raw_code": "```python\ndef getGCD(x, y):\n    while y != 0:\n        x, y = y, x % y\n    return x\n\ndef solve(nums, queries):\n    max_val = max(nums)\n    freq_map = [0] * (max_val + 1)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            freq_map[gcd_val] += 1\n    \n    sorted_gcds = []\n    for gcd_val, count in enumerate(freq_map):\n        sorted_gcds.extend([gcd_val] * count)\n    \n    return [sorted_gcds[q] for q in queries]\n```"}
{"task_id": "arc182_e", "code": "d", "passed": false, "raw_code": "```python\ndef calculate_answer():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    C = int(data[2])\n    K = int(data[3])\n    A = list(map(int, data[4:]))\n    \n    # Frequency count of A_i mod M\n    freq = [0] * M\n    for a in A:\n        freq[a % M] += 1\n    \n    # Calculate the minimum value for each residue class\n    min_values = [min((C * k + v) % M for k in range(K)) for v in range(M)]\n    \n    # Sum the minimum values weighted by their frequency\n    result = sum(min_values[v] * freq[v] for v in range(M))\n    \n    print(result)\n\ncalculate_answer()"}
{"task_id": "3551", "code": "def xorQueries(nums, queries):\\n    n = len(nums)\\n    prefix_xor = [0] * (n + 1)\\n    for i in range(n):\\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\\n\\n    answers = []\\n    for l, r in queries:\\n        max_xor = 0\\n        current_xor = 0\\n        seen = set()\\n        for i in range(r + 1, n + 1):\\n            current_xor = prefix_xor[i] ^ prefix_xor[l]\\n            max_xor = max(max_xor, current_xor)\\n            seen.add(current_xor)\\n        answers.append(max_xor)\\n\\n    return answers", "passed": false, "raw_code": "def xorQueries(nums, queries):\\n    n = len(nums)\\n    prefix_xor = [0] * (n + 1)\\n    for i in range(n):\\n        prefix_xor[i + 1] = prefix_xor[i] ^ nums[i]\\n\\n    answers = []\\n    for l, r in queries:\\n        max_xor = 0\\n        current_xor = 0\\n        seen = set()\\n        for i in range(r + 1, n + 1):\\n            current_xor = prefix_xor[i] ^ prefix_xor[l]\\n            max_xor = max(max_xor, current_xor)\\n            seen.add(current_xor)\\n        answers.append(max_xor)\\n\\n    return answers"}
{"task_id": "3575", "code": "import heapq\n\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    \n    # Priority queues to store the largest numbers for the left and right halves\n    left_half = []\n    right_half = []\n    \n    # Fill the left half with the largest k numbers\n    for i in range(k):\n        heapq.heappush(left_half, -nums[i])\n    \n    # Fill the right half with the next k largest numbers\n    for i in range(k, 2 * k):\n        heapq.heappush(right_half, -nums[i])\n    \n    max_xor = 0\n    \n    # Calculate the initial XOR value for the first subsequence\n    left_or = 0\n    right_or = 0\n    for _ in range(k):\n        left_or |= heapq.heappop(left_half)\n        right_or |= heapq.heappop(right_half)\n    max_xor = abs(left_or ^ right_or)\n    \n    # Sliding window to find the maximum XOR value for all subsequences\n    for i in range(2 * k, n):\n        left_or &= ~(-heapq.heappop(left_half))\n        left_or |= -heapq.heappushpop(left_half, -nums[i])\n        \n        right_or &= ~(-heapq.heappop(right_half))\n        right_or |= -heapq.heappushpop(right_half, -nums[i])\n        \n        max_xor = max(max_xor, abs(left_or ^ right_or))\n    \n    return max_xor", "passed": false, "raw_code": "```python\nimport heapq\n\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    \n    # Priority queues to store the largest numbers for the left and right halves\n    left_half = []\n    right_half = []\n    \n    # Fill the left half with the largest k numbers\n    for i in range(k):\n        heapq.heappush(left_half, -nums[i])\n    \n    # Fill the right half with the next k largest numbers\n    for i in range(k, 2 * k):\n        heapq.heappush(right_half, -nums[i])\n    \n    max_xor = 0\n    \n    # Calculate the initial XOR value for the first subsequence\n    left_or = 0\n    right_or = 0\n    for _ in range(k):\n        left_or |= heapq.heappop(left_half)\n        right_or |= heapq.heappop(right_half)\n    max_xor = abs(left_or ^ right_or)\n    \n    # Sliding window to find the maximum XOR value for all subsequences\n    for i in range(2 * k, n):\n        left_or &= ~(-heapq.heappop(left_half))\n        left_or |= -heapq.heappushpop(left_half, -nums[i])\n        \n        right_or &= ~(-heapq.heappop(right_half))\n        right_or |= -heapq.heappushpop(right_half, -nums[i])\n        \n        max_xor = max(max_xor, abs(left_or ^ right_or))\n    \n    return max_xor\n```"}
{"task_id": "abc369_g", "code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n\n    def bfs(start, target):\n        queue = deque([(start, 0)])\n        visited = set([start])\n        while queue:\n            node, dist = queue.popleft()\n            if node == target:\n                return dist\n            for neighbor, weight in adj[node].items():\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + weight))\n        return float('inf')\n\n    def get_dists_from_root(root):\n        dists = [float('inf')] * (N + 1)\n        stack = [(root, 0)]\n        while stack:\n            node, dist = stack.pop()\n            dists[node] = dist\n            for neighbor, weight in adj[node].items():\n                stack.append((neighbor, dist + weight))\n        return dists\n\n    adj = defaultdict(dict)\n    for u, v, l in edges:\n        adj[u][v] = l\n        adj[v][u] = l\n\n    root = 1\n    root_dists = get_dists_from_root(root)\n\n    ans = [0] * (N + 1)\n    for K in range(1, N + 1):\n        max_score = 0\n        for comb in combinations(range(1, N + 1), K):\n            total_dist = 0\n            current = root\n            for next_vertex in comb:\n                total_dist += bfs(current, next_vertex)\n                current = next_vertex\n            total_dist += bfs(current, root)\n            max_score = max(max_score, total_dist)\n        ans[K] = max_score\n\n    for score in ans[1:]:\n        print(score)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n\n    def bfs(start, target):\n        queue = deque([(start, 0)])\n        visited = set([start])\n        while queue:\n            node, dist = queue.popleft()\n            if node == target:\n                return dist\n            for neighbor, weight in adj[node].items():\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + weight))\n        return float('inf')\n\n    def get_dists_from_root(root):\n        dists = [float('inf')] * (N + 1)\n        stack = [(root, 0)]\n        while stack:\n            node, dist = stack.pop()\n            dists[node] = dist\n            for neighbor, weight in adj[node].items():\n                stack.append((neighbor, dist + weight))\n        return dists\n\n    adj = defaultdict(dict)\n    for u, v, l in edges:\n        adj[u][v] = l\n        adj[v][u] = l\n\n    root = 1\n    root_dists = get_dists_from_root(root)\n\n    ans = [0] * (N + 1)\n    for K in range(1, N + 1):\n        max_score = 0\n        for comb in combinations(range(1, N + 1), K):\n            total_dist = 0\n            current = root\n            for next_vertex in comb:\n                total_dist += bfs(current, next_vertex)\n                current = next_vertex\n            total_dist += bfs(current, root)\n            max_score = max(max_score, total_dist)\n        ans[K] = max_score\n\n    for score in ans[1:]:\n        print(score)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "arc181_c", "code": "def fill_grid(N, P, Q):\n    # Initialize an N x N grid with all zeros\n    grid = [['0'] * N for _ in range(N)]\n    \n    # Helper function to get the current row and column as binary strings\n    def get_row_col(i, j):\n        return ''.join(grid[i][:j+1]), ''.join(row[j] for row in grid[:i+1])\n    \n    # Fill the grid\n    for i in range(N):\n        for j in range(N):\n            while True:\n                row, col = get_row_col(i, j)\n                next_val = '0' if row < col else '1'\n                grid[i][j] = next_val\n                if i == N - 1 and j == N - 1:\n                    break\n                elif i == N - 1:\n                    j += 1\n                else:\n                    i += 1\n    \n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Call the function\nfill_grid(N, P, Q)", "passed": false, "raw_code": "```python\ndef fill_grid(N, P, Q):\n    # Initialize an N x N grid with all zeros\n    grid = [['0'] * N for _ in range(N)]\n    \n    # Helper function to get the current row and column as binary strings\n    def get_row_col(i, j):\n        return ''.join(grid[i][:j+1]), ''.join(row[j] for row in grid[:i+1])\n    \n    # Fill the grid\n    for i in range(N):\n        for j in range(N):\n            while True:\n                row, col = get_row_col(i, j)\n                next_val = '0' if row < col else '1'\n                grid[i][j] = next_val\n                if i == N - 1 and j == N - 1:\n                    break\n                elif i == N - 1:\n                    j += 1\n                else:\n                    i += 1\n    \n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nQ = list(map(int, data[N+1:]))\n\n# Call the function\nfill_grid(N, P, Q)\n```"}
{"task_id": "3560", "code": "def minKnightMoves(x, y):\n    return (max(abs(x), abs(y)) - 1) * 2 + (abs(x) != abs(y))\n\ndef knightProbability(kx, ky, positions):\n    n = len(positions)\n    dp = [float('-inf')] * (1 << n)\n    dp[0] = 0\n    \n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    \n    for mask in range(1 << n):\n        for i in range(n):\n            if (mask & (1 << i)) > 0:\n                x1, y1 = positions[i]\n                for dx, dy in directions:\n                    nx, ny = kx + dx, ky + dy\n                    if 0 <= nx <= 49 and 0 <= ny <= 49:\n                        steps = minKnightMoves(nx, ny) + minKnightMoves(nx - x1, ny - y1)\n                        dp[mask] = max(dp[mask], dp[mask ^ (1 << i)] + steps)\n    \n    return dp[(1 << n) - 1]", "passed": false, "raw_code": "```python\ndef minKnightMoves(x, y):\n    return (max(abs(x), abs(y)) - 1) * 2 + (abs(x) != abs(y))\n\ndef knightProbability(kx, ky, positions):\n    n = len(positions)\n    dp = [float('-inf')] * (1 << n)\n    dp[0] = 0\n    \n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    \n    for mask in range(1 << n):\n        for i in range(n):\n            if (mask & (1 << i)) > 0:\n                x1, y1 = positions[i]\n                for dx, dy in directions:\n                    nx, ny = kx + dx, ky + dy\n                    if 0 <= nx <= 49 and 0 <= ny <= 49:\n                        steps = minKnightMoves(nx, ny) + minKnightMoves(nx - x1, ny - y1)\n                        dp[mask] = max(dp[mask], dp[mask ^ (1 << i)] + steps)\n    \n    return dp[(1 << n) - 1]\n```"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(Q):\n        p, v = P[i], V[i]\n        new_dp = [0] * (N + 1)\n        for j in range(p - 1, -1, -1):\n            if j == p - 1 or dp[j + 1] == 0:\n                break\n            new_dp[j] += dp[j + 1]\n            new_dp[j] %= MOD\n        for j in range(p - 1, N):\n            if dp[j + 1] == 0:\n                break\n            new_dp[j] += dp[j + 1]\n            new_dp[j] %= MOD\n        dp = new_dp\n    return sum(dp) % MOD\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nP = list(map(int, data[2::2]))\nV = list(map(int, data[3::2]))\n\n# Call the function and print the result\nprint(count_valid_sequences(N, Q, P, V))", "passed": false, "raw_code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for i in range(Q):\n        p, v = P[i], V[i]\n        new_dp = [0] * (N + 1)\n        for j in range(p - 1, -1, -1):\n            if j == p - 1 or dp[j + 1] == 0:\n                break\n            new_dp[j] += dp[j + 1]\n            new_dp[j] %= MOD\n        for j in range(p - 1, N):\n            if dp[j + 1] == 0:\n                break\n            new_dp[j] += dp[j + 1]\n            new_dp[j] %= MOD\n        dp = new_dp\n    return sum(dp) % MOD\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nP = list(map(int, data[2::2]))\nV = list(map(int, data[3::2]))\n\n# Call the function and print the result\nprint(count_valid_sequences(N, Q, P, V))"}
{"task_id": "arc181_d", "code": "def merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef merge_and_count(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n    return inv_count\n\ndef inversion_number_after_operations(N, P, M, A):\n    temp_arr = [0] * N\n    inv_count = 0\n    for a in A:\n        for i in range(a - 1, 0, -1):\n            if P[i] > P[i - 1]:\n                P[i], P[i - 1] = P[i - 1], P[i]\n            else:\n                break\n        inv_count = merge_sort_and_count(P, temp_arr, 0, N - 1)\n        print(inv_count)\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nM = int(input())\nA = list(map(int, input().split()))\n\n# Get inversion number after each operation\ninversion_number_after_operations(N, P, M, A)\n", "passed": false, "raw_code": "def merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef merge_and_count(arr, temp_arr, left, mid, right):\n    i = left\n    j = mid + 1\n    k = left\n    inv_count = 0\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n    return inv_count\n\ndef inversion_number_after_operations(N, P, M, A):\n    temp_arr = [0] * N\n    inv_count = 0\n    for a in A:\n        for i in range(a - 1, 0, -1):\n            if P[i] > P[i - 1]:\n                P[i], P[i - 1] = P[i - 1], P[i]\n            else:\n                break\n        inv_count = merge_sort_and_count(P, temp_arr, 0, N - 1)\n        print(inv_count)\n\n# Read input\nN = int(input())\nP = list(map(int, input().split()))\nM = int(input())\nA = list(map(int, input().split()))\n\n# Get inversion number after each operation\ninversion_number_after_operations(N, P, M, A)\n"}
{"task_id": "abc370_g", "code": "MOD = 998244353\n\ndef sum_of_divisors(n):\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i + (n // i if i != n // i else 0)\n    return total\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef count_good_sequences(N, M):\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            if is_good_integer(j):\n                dp[i][j] = dp[i - 1][j]\n            for k in range(1, j // 2 + 1):\n                if is_good_integer(k) and is_good_integer(j // k):\n                    dp[i][j] += dp[i - 1][j // k]\n                    dp[i][j] %= MOD\n    \n    return dp[M][N]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\nprint(count_good_sequences(N, M))", "passed": false, "raw_code": "```python\nMOD = 998244353\n\ndef sum_of_divisors(n):\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i + (n // i if i != n // i else 0)\n    return total\n\ndef is_good_integer(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef count_good_sequences(N, M):\n    dp = [[0] * (N + 1) for _ in range(M + 1)]\n    dp[0][1] = 1\n    \n    for i in range(1, M + 1):\n        for j in range(1, N + 1):\n            if is_good_integer(j):\n                dp[i][j] = dp[i - 1][j]\n            for k in range(1, j // 2 + 1):\n                if is_good_integer(k) and is_good_integer(j // k):\n                    dp[i][j] += dp[i - 1][j // k]\n                    dp[i][j] %= MOD\n    \n    return dp[M][N]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\nprint(count_good_sequences(N, M))\n```"}
{"task_id": "abc371_g", "code": "def smallest_permutation(N, P, A):\n    # Create a list of indices and sort it based on the permutation P\n    indices = sorted(range(N), key=lambda x: P[x])\n    \n    # Initialize the result array\n    result = [0] * N\n    \n    # Fill the result array based on the sorted indices\n    for i, idx in enumerate(indices):\n        result[idx] = A[i]\n    \n    return ' '.join(map(str, result))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the smallest permutation\nresult = smallest_permutation(N, P, A)\n\n# Print the result\nprint(result)", "passed": false, "raw_code": "```python\ndef smallest_permutation(N, P, A):\n    # Create a list of indices and sort it based on the permutation P\n    indices = sorted(range(N), key=lambda x: P[x])\n    \n    # Initialize the result array\n    result = [0] * N\n    \n    # Fill the result array based on the sorted indices\n    for i, idx in enumerate(indices):\n        result[idx] = A[i]\n    \n    return ' '.join(map(str, result))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the smallest permutation\nresult = smallest_permutation(N, P, A)\n\n# Print the result\nprint(result)\n```"}
{"task_id": "abc372_e", "code": "from collections import defaultdict\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = defaultdict(list)\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            \n            # Add edge\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            \n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            # Get connected vertices and sort them\n            connected_vertices = adj_list[v]\n            if len(connected_vertices) < k:\n                results.append(-1)\n            else:\n                sorted_vertices = sorted(set(connected_vertices), reverse=True)\n                results.append(sorted_vertices[k - 1])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nfrom collections import defaultdict\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    adj_list = defaultdict(list)\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index]) - 1\n            v = int(data[index + 1]) - 1\n            index += 2\n            \n            # Add edge\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n            \n        elif query_type == 2:\n            v = int(data[index]) - 1\n            k = int(data[index + 1])\n            index += 2\n            \n            # Get connected vertices and sort them\n            connected_vertices = adj_list[v]\n            if len(connected_vertices) < k:\n                results.append(-1)\n            else:\n                sorted_vertices = sorted(set(connected_vertices), reverse=True)\n                results.append(sorted_vertices[k - 1])\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc371_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    X = list(map(int, data[1:N+1]))\n    Q = int(data[N+1])\n    tasks = [(int(data[N+2+2*i]), int(data[N+3+2*i])) for i in range(Q)]\n\n    total_movements = 0\n\n    for T, G in tasks:\n        person_pos = X[T-1]\n        total_movements += abs(person_pos - G)\n\n    print(total_movements)\n\nmain()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    N = int(data[0])\n    X = list(map(int, data[1:N+1]))\n    Q = int(data[N+1])\n    tasks = [(int(data[N+2+2*i]), int(data[N+3+2*i])) for i in range(Q)]\n\n    total_movements = 0\n\n    for T, G in tasks:\n        person_pos = X[T-1]\n        total_movements += abs(person_pos - G)\n\n    print(total_movements)\n\nmain()"}
{"task_id": "3563", "code": "def maxScore(grid):\n    def backtrack(row, selected):\n        if row == len(grid):\n            return 0\n        max_score = 0\n        for col in range(len(grid[row])):\n            if grid[row][col] not in selected:\n                selected.add(grid[row][col])\n                score = grid[row][col] + backtrack(row + 1, selected)\n                selected.remove(grid[row][col])\n                max_score = max(max_score, score)\n        return max_score\n\n    for i in range(len(grid)):\n        grid[i].sort(reverse=True)\n    \n    return backtrack(0, set())", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    def backtrack(row, selected):\n        if row == len(grid):\n            return 0\n        max_score = 0\n        for col in range(len(grid[row])):\n            if grid[row][col] not in selected:\n                selected.add(grid[row][col])\n                score = grid[row][col] + backtrack(row + 1, selected)\n                selected.remove(grid[row][col])\n                max_score = max(max_score, score)\n        return max_score\n\n    for i in range(len(grid)):\n        grid[i].sort(reverse=True)\n    \n    return backtrack(0, set())\n```"}
{"task_id": "abc370_f", "code": "import sys\n\ndef can_divide(N, K, max_weight, A):\n    cut_lines_cut = 0\n    current_sum = 0\n    for i in range(N):\n        if current_sum + A[i] <= max_weight:\n            current_sum += A[i]\n        else:\n            if current_sum != 0 and i > 0:\n                cut_lines_cut += 1\n            current_sum = A[i]\n    if current_sum != 0:\n        cut_lines_cut += 1\n    return cut_lines_cut <= K\n\ndef find_min_max_weight(N, K, A):\n    left, right = max(A), sum(A)\n    while left < right:\n        mid = (left + right) // 2\n        if can_divide(N, K, mid, A):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nmin_weight = find_min_max_weight(N, K, A)\ncut_lines_cut = 0\ncurrent_sum = 0\nfor i in range(N):\n    if current_sum + A[i] <= min_weight:\n        current_sum += A[i]\n    else:\n        cut_lines_cut += 1\n        current_sum = A[i]\nif current_sum != 0:\n    cut_lines_cut += 1\n\nprint(min_weight, cut_lines_cut)\n", "passed": false, "raw_code": "import sys\n\ndef can_divide(N, K, max_weight, A):\n    cut_lines_cut = 0\n    current_sum = 0\n    for i in range(N):\n        if current_sum + A[i] <= max_weight:\n            current_sum += A[i]\n        else:\n            if current_sum != 0 and i > 0:\n                cut_lines_cut += 1\n            current_sum = A[i]\n    if current_sum != 0:\n        cut_lines_cut += 1\n    return cut_lines_cut <= K\n\ndef find_min_max_weight(N, K, A):\n    left, right = max(A), sum(A)\n    while left < right:\n        mid = (left + right) // 2\n        if can_divide(N, K, mid, A):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nmin_weight = find_min_max_weight(N, K, A)\ncut_lines_cut = 0\ncurrent_sum = 0\nfor i in range(N):\n    if current_sum + A[i] <= min_weight:\n        current_sum += A[i]\n    else:\n        cut_lines_cut += 1\n        current_sum = A[i]\nif current_sum != 0:\n    cut_lines_cut += 1\n\nprint(min_weight, cut_lines_cut)\n"}
{"task_id": "3580", "code": "def findAlmostEqualSubstring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1", "passed": false, "raw_code": "```python\ndef findAlmostEqualSubstring(s: str, pattern: str) -> int:\n    m, n = len(pattern), len(s)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"}
{"task_id": "3571", "code": "from collections import defaultdict, deque\n\ndef longestIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    \n    # Sort coordinates based on x, and by y if x is the same\n    coordinates.sort()\n    \n    # Step 1: Build the graph\n    graph = defaultdict(list)\n    indegree = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = coordinates[i]\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Step 2: Topological sort\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]", "passed": false, "raw_code": "```python\nfrom collections import defaultdict, deque\n\ndef longestIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    \n    # Sort coordinates based on x, and by y if x is the same\n    coordinates.sort()\n    \n    # Step 1: Build the graph\n    graph = defaultdict(list)\n    indegree = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = coordinates[i]\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Step 2: Topological sort\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]\n\n```"}
{"task_id": "3548", "code": "def countGoodIntegers(n: int, k: int) -> int:\n    if k == 1:\n        return 10 ** (n - 1)\n    \n    from math import comb\n    \n    def isGood(num):\n        num_str = str(num)\n        if num_str != num_str[::-1]:\n            return False\n        return num % k == 0\n    \n    count = 0\n    start = 10 ** (n - 1)\n    end = 10 ** n\n    \n    for num in range(start, end):\n        if isGood(num):\n            count += 1\n    \n    return count", "passed": false, "raw_code": "```python\ndef countGoodIntegers(n: int, k: int) -> int:\n    if k == 1:\n        return 10 ** (n - 1)\n    \n    from math import comb\n    \n    def isGood(num):\n        num_str = str(num)\n        if num_str != num_str[::-1]:\n            return False\n        return num % k == 0\n    \n    count = 0\n    start = 10 ** (n - 1)\n    end = 10 ** n\n    \n    for num in range(start, end):\n        if isGood(num):\n            count += 1\n    \n    return count\n```"}
{"final_accuracy": "0.00%"}
