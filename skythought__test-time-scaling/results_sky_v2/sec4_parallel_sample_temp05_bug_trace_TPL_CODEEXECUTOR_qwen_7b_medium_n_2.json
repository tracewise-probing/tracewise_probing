{"difficulty": "medium", "num_threads": 32, "temperature": 0.5, "n": 2, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp05_bug_trace_TPL_CODEEXECUTOR_qwen_7b_medium_n_2.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3541", "codes": ["def is_spam(message: list[str], bannedWords: list[str]) -> bool:\n    banned_set = set(bannedWords)\n    count = {}\n    for word in message:\n        if word in banned_set:\n            count[word] = count.get(word, 0) + 1\n            if count[word] >= 2:\n                return True\n    return False", "def is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            if word in word_count:\n                word_count[word] += 1\n                if word_count[word] == 2:\n                    return True\n            else:\n                word_count[word] = 1\n    \n    return False"], "passed": [false, false], "raw_code": ["```python\ndef is_spam(message: list[str], bannedWords: list[str]) -> bool:\n    banned_set = set(bannedWords)\n    count = {}\n    for word in message:\n        if word in banned_set:\n            count[word] = count.get(word, 0) + 1\n            if count[word] >= 2:\n                return True\n    return False\n```", "```python\ndef is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            if word in word_count:\n                word_count[word] += 1\n                if word_count[word] == 2:\n                    return True\n            else:\n                word_count[word] = 1\n    \n    return False\n```"]}
{"task_id": "3540", "codes": ["def hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result", "def hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashedChar = char_sum % 26\n        result += chr(ord('a') + hashedChar)\n    return result"], "passed": [true, true], "raw_code": ["```python\ndef hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```", "```python\ndef hash_string(s: str, k: int) -> str:\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashedChar = char_sum % 26\n        result += chr(ord('a') + hashedChar)\n    return result\n```"]}
{"task_id": "abc366_c", "codes": ["def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    results = []\n    \n    index = 0\n    for _ in range(Q):\n        query_type = int(queries[index])\n        if query_type == 1:\n            x = int(queries[index + 1])\n            bag.add(x)\n        elif query_type == 2:\n            x = int(queries[index + 1])\n            bag.remove(x)\n        elif query_type == 3:\n            results.append(str(len(bag)))\n        index += 2\n    \n    for result in results:\n        print(result)\n\nprocess_queries()", "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    results = []\n    \n    index = 0\n    for _ in range(Q):\n        query_type = int(queries[index])\n        index += 1\n        \n        if query_type == 1:\n            x = int(queries[index])\n            index += 1\n            bag.add(x)\n        elif query_type == 2:\n            x = int(queries[index])\n            index += 1\n            bag.remove(x)\n        elif query_type == 3:\n            results.append(len(bag))\n    \n    for result in results:\n        print(result)\n\nprocess_queries()"], "passed": [false, false], "raw_code": ["```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    results = []\n    \n    index = 0\n    for _ in range(Q):\n        query_type = int(queries[index])\n        if query_type == 1:\n            x = int(queries[index + 1])\n            bag.add(x)\n        elif query_type == 2:\n            x = int(queries[index + 1])\n            bag.remove(x)\n        elif query_type == 3:\n            results.append(str(len(bag)))\n        index += 2\n    \n    for result in results:\n        print(result)\n\nprocess_queries()\n```", "```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    results = []\n    \n    index = 0\n    for _ in range(Q):\n        query_type = int(queries[index])\n        index += 1\n        \n        if query_type == 1:\n            x = int(queries[index])\n            index += 1\n            bag.add(x)\n        elif query_type == 2:\n            x = int(queries[index])\n            index += 1\n            bag.remove(x)\n        elif query_type == 3:\n            results.append(len(bag))\n    \n    for result in results:\n        print(result)\n\nprocess_queries()\n```"]}
{"task_id": "3518", "codes": ["def maxScore(a, b):\n    # Sort array b to easily access the smallest and largest elements\n    b_sorted = sorted(b)\n    \n    # Calculate the score using the identified indices\n    return a[0] * b_sorted[0] + a[1] * b_sorted[1] + a[2] * b_sorted[-2] + a[3] * b_sorted[-1]", "def maxScore(a, b):\n    # Sort array b\n    b.sort()\n    \n    # Initialize the score\n    score = 0\n    \n    # Iterate over the sorted array b and calculate the score\n    for i in range(4):\n        score += a[i] * b[len(b) - 1 - i]\n    \n    return score"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(a, b):\n    # Sort array b to easily access the smallest and largest elements\n    b_sorted = sorted(b)\n    \n    # Calculate the score using the identified indices\n    return a[0] * b_sorted[0] + a[1] * b_sorted[1] + a[2] * b_sorted[-2] + a[3] * b_sorted[-1]\n```", "```python\ndef maxScore(a, b):\n    # Sort array b\n    b.sort()\n    \n    # Initialize the score\n    score = 0\n    \n    # Iterate over the sorted array b and calculate the score\n    for i in range(4):\n        score += a[i] * b[len(b) - 1 - i]\n    \n    return score\n```"]}
{"task_id": "3522", "codes": ["def find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if is_consecutive_and_sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n\ndef is_consecutive_and_sorted(arr):\n    return arr == sorted(arr) and all(b - a == 1 for a, b in zip(arr, arr[1:]))\n\n# Example usage:\nprint(find_subarray_powers([1,2,3,4,3,2,5], 3))  # Output: [3, 4, -1, -1, -1]\nprint(find_subarray_powers([2,2,2,2,2], 4))      # Output: [-1, -1]\nprint(find_subarray_powers([3,2,3,2,3,2], 2))    # Output: [-1, 3, -1, 3, -1]", "def find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if subarray == sorted_subarray and all(sorted_subarray[j] - sorted_subarray[j-1] == 1 for j in range(1, k)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results"], "passed": [true, true], "raw_code": ["```python\ndef find_subarray_powers(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        if is_consecutive_and_sorted(subarray):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n\ndef is_consecutive_and_sorted(arr):\n    return arr == sorted(arr) and all(b - a == 1 for a, b in zip(arr, arr[1:]))\n\n# Example usage:\nprint(find_subarray_powers([1,2,3,4,3,2,5], 3))  # Output: [3, 4, -1, -1, -1]\nprint(find_subarray_powers([2,2,2,2,2], 4))      # Output: [-1, -1]\nprint(find_subarray_powers([3,2,3,2,3,2], 2))    # Output: [-1, 3, -1, 3, -1]\n```", "```python\ndef find_power_of_subarrays(nums, k):\n    n = len(nums)\n    results = []\n    \n    for i in range(n - k + 1):\n        subarray = nums[i:i+k]\n        sorted_subarray = sorted(subarray)\n        \n        if subarray == sorted_subarray and all(sorted_subarray[j] - sorted_subarray[j-1] == 1 for j in range(1, k)):\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    \n    return results\n```"]}
{"task_id": "abc369_d", "codes": ["d", "d"], "passed": [false, false], "raw_code": ["```python\ndef max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Sort the monsters by their strength in descending order\n    A.sort(reverse=True)\n    \n    max_points = 0\n    for i in range(N):\n        if (i + 1) % 2 == 0:\n            max_points += 2 * A[i]\n        else:\n            max_points += A[i]\n    \n    print(max_points)\n\nmax_experience_points()", "```python\ndef max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Sort the strengths in descending order\n    A.sort(reverse=True)\n    \n    total_points = 0\n    for i in range(N):\n        if (i + 1) % 2 == 0:\n            total_points += 2 * A[i]\n        else:\n            total_points += A[i]\n    \n    print(total_points)\n\nmax_experience_points()"]}
{"task_id": "3526", "codes": ["def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flips_for_col(col):\n        return sum(1 for i in range((m + 1) // 2) if grid[i][col] != grid[m - 1 - i][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_cols = sum(flips_for_col(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_cols)", "def min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)"], "passed": [true, true], "raw_code": ["```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_for_row(row):\n        return sum(1 for i in range((n + 1) // 2) if row[i] != row[n - 1 - i])\n    \n    def flips_for_col(col):\n        return sum(1 for i in range((m + 1) // 2) if grid[i][col] != grid[m - 1 - i][col])\n    \n    total_flips_rows = sum(flips_for_row(row) for row in grid)\n    total_flips_cols = sum(flips_for_col(col) for col in range(n))\n    \n    return min(total_flips_rows, total_flips_cols)\n```", "```python\ndef min_flips_to_palindrome(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flips_needed(arr):\n        return sum(1 for i in range((len(arr) + 1) // 2) if arr[i] != arr[-i - 1])\n    \n    row_flips = sum(flips_needed(row) for row in grid)\n    col_flips = sum(flips_needed([grid[j][i] for j in range(m)]) for i in range(n))\n    \n    return min(row_flips, col_flips)\n```"]}
{"task_id": "3517", "codes": ["from collections import deque\n\ndef shortest_path_after_queries(n, queries):\n    # Initialize the graph as an adjacency list\n    graph = {i: [] for i in range(n)}\n    \n    # Add initial roads\n    for i in range(n - 1):\n        graph[i].append(i + 1)\n    \n    def bfs(start, end):\n        queue = deque([start])\n        visited = set([start])\n        distance = 0\n        \n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                current = queue.popleft()\n                if current == end:\n                    return distance\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            distance += 1\n    \n    result = []\n    for u, v in queries:\n        graph[u].append(v)\n        result.append(bfs(0, n - 1))\n    \n    return result", "def shortestPath(n, queries):\n    # Initialize the shortest path lengths from city 0 to each city\n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    # Initialize the answer array\n    answer = []\n    \n    # Process each query\n    for u, v in queries:\n        # Update the shortest path lengths\n        for i in range(u, v + 1):\n            dp[i] = min(dp[i], dp[u] + (v - i) + 1)\n        \n        # Store the shortest path length from city 0 to city n-1\n        answer.append(dp[n-1])\n    \n    return answer"], "passed": [true, false], "raw_code": ["```python\nfrom collections import deque\n\ndef shortest_path_after_queries(n, queries):\n    # Initialize the graph as an adjacency list\n    graph = {i: [] for i in range(n)}\n    \n    # Add initial roads\n    for i in range(n - 1):\n        graph[i].append(i + 1)\n    \n    def bfs(start, end):\n        queue = deque([start])\n        visited = set([start])\n        distance = 0\n        \n        while queue:\n            level_size = len(queue)\n            for _ in range(level_size):\n                current = queue.popleft()\n                if current == end:\n                    return distance\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            distance += 1\n    \n    result = []\n    for u, v in queries:\n        graph[u].append(v)\n        result.append(bfs(0, n - 1))\n    \n    return result\n```", "```python\ndef shortestPath(n, queries):\n    # Initialize the shortest path lengths from city 0 to each city\n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    # Initialize the answer array\n    answer = []\n    \n    # Process each query\n    for u, v in queries:\n        # Update the shortest path lengths\n        for i in range(u, v + 1):\n            dp[i] = min(dp[i], dp[u] + (v - i) + 1)\n        \n        # Store the shortest path length from city 0 to city n-1\n        answer.append(dp[n-1])\n    \n    return answer\n```"]}
{"task_id": "3496", "codes": ["def minTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        remainingHeight = height\n        for wt in sorted(workerTimes, reverse=True):\n            if remainingHeight == 0:\n                break\n            x = 1\n            while True:\n                if wt * (x * (x + 1)) // 2 > time:\n                    break\n                if wt * x <= time:\n                    remainingHeight -= 1\n                x += 1\n        return remainingHeight == 0\n    \n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low", "def minTime(mountainHeight, workerTimes):\n    def canReduce(height, targetTime):\n        totalWork = 0\n        for time in workerTimes:\n            x = 1\n            while time * (x * (x + 1)) // 2 <= targetTime:\n                if time * x >= height:\n                    return True\n                totalWork += time * x\n                x += 1\n        return False\n    \n    low = max(workerTimes)\n    high = sum(workerTimes) * mountainHeight\n    \n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    \n    return low"], "passed": [false, false], "raw_code": ["```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, time):\n        remainingHeight = height\n        for wt in sorted(workerTimes, reverse=True):\n            if remainingHeight == 0:\n                break\n            x = 1\n            while True:\n                if wt * (x * (x + 1)) // 2 > time:\n                    break\n                if wt * x <= time:\n                    remainingHeight -= 1\n                x += 1\n        return remainingHeight == 0\n    \n    low, high = max(workerTimes), sum(workerTimes) * mountainHeight\n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low\n```", "```python\ndef minTime(mountainHeight, workerTimes):\n    def canReduce(height, targetTime):\n        totalWork = 0\n        for time in workerTimes:\n            x = 1\n            while time * (x * (x + 1)) // 2 <= targetTime:\n                if time * x >= height:\n                    return True\n                totalWork += time * x\n                x += 1\n        return False\n    \n    low = max(workerTimes)\n    high = sum(workerTimes) * mountainHeight\n    \n    while low < high:\n        mid = (low + high) // 2\n        if canReduce(mountainHeight, mid):\n            high = mid\n        else:\n            low = mid + 1\n    \n    return low\n```"]}
{"task_id": "3558", "codes": ["def canReach(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dx, dy in directions:\n            if dfs(x + dx, y + dy, health - grid[x + dx][y + dy]):\n                return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)", "def hasPath(grid, health):\n    def dfs(i, j, health):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or health <= 0:\n            return False\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return health >= 1\n        temp = grid[i][j]\n        grid[i][j] = -1\n        if dfs(i + 1, j, health - temp) or dfs(i - 1, j, health - temp) or dfs(i, j + 1, health - temp) or dfs(i, j - 1, health - temp):\n            return True\n        grid[i][j] = temp\n        return False\n    \n    return dfs(0, 0, health)"], "passed": [false, false], "raw_code": ["```python\ndef canReach(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dx, dy in directions:\n            if dfs(x + dx, y + dy, health - grid[x + dx][y + dy]):\n                return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)\n```", "```python\ndef hasPath(grid, health):\n    def dfs(i, j, health):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or health <= 0:\n            return False\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\n            return health >= 1\n        temp = grid[i][j]\n        grid[i][j] = -1\n        if dfs(i + 1, j, health - temp) or dfs(i - 1, j, health - temp) or dfs(i, j + 1, health - temp) or dfs(i, j - 1, health - temp):\n            return True\n        grid[i][j] = temp\n        return False\n    \n    return dfs(0, 0, health)\n```"]}
{"task_id": "abc371_d", "codes": ["def update(bit, index, value):\n    while index < len(bit):\n        bit[index] += value\n        index += index & -index\n\ndef query(bit, index):\n    result = 0\n    while index > 0:\n        result += bit[index]\n        index -= index & -index\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    X = [int(data[index + i]) for i in range(N)]\n    P = [int(data[index + N + i]) for i in range(N)]\n    index += 2 * N\n    \n    Q = int(data[index])\n    index += 1\n    \n    queries = [(int(data[index + 2 * i]), int(data[index + 2 * i + 1])) for i in range(Q)]\n    \n    # Create a list of tuples (coordinate, population)\n    villages = [(X[i], P[i]) for i in range(N)]\n    villages.sort()\n    \n    # Create a mapping from coordinate to index in sorted order\n    coord_to_index = {v[0]: i for i, v in enumerate(villages)}\n    \n    # Initialize Fenwick Tree\n    bit = [0] * (N + 1)\n    \n    # Process each query\n    results = []\n    for L, R in queries:\n        L_index = coord_to_index[L]\n        R_index = coord_to_index[R]\n        \n        # Calculate the number of villagers in the range [L, R]\n        result = query(bit, R_index + 1) - query(bit, L_index)\n        results.append(result)\n        \n        # Update the Fenwick Tree for the next query\n        update(bit, R_index + 1, villages[R_index][1])\n    \n    # Print the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "d"], "passed": [false, false], "raw_code": ["```python\ndef update(bit, index, value):\n    while index < len(bit):\n        bit[index] += value\n        index += index & -index\n\ndef query(bit, index):\n    result = 0\n    while index > 0:\n        result += bit[index]\n        index -= index & -index\n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    X = [int(data[index + i]) for i in range(N)]\n    P = [int(data[index + N + i]) for i in range(N)]\n    index += 2 * N\n    \n    Q = int(data[index])\n    index += 1\n    \n    queries = [(int(data[index + 2 * i]), int(data[index + 2 * i + 1])) for i in range(Q)]\n    \n    # Create a list of tuples (coordinate, population)\n    villages = [(X[i], P[i]) for i in range(N)]\n    villages.sort()\n    \n    # Create a mapping from coordinate to index in sorted order\n    coord_to_index = {v[0]: i for i, v in enumerate(villages)}\n    \n    # Initialize Fenwick Tree\n    bit = [0] * (N + 1)\n    \n    # Process each query\n    results = []\n    for L, R in queries:\n        L_index = coord_to_index[L]\n        R_index = coord_to_index[R]\n        \n        # Calculate the number of villagers in the range [L, R]\n        result = query(bit, R_index + 1) - query(bit, L_index)\n        results.append(result)\n        \n        # Update the Fenwick Tree for the next query\n        update(bit, R_index + 1, villages[R_index][1])\n    \n    # Print the results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read input\n    index = 0\n    N = int(data[index])\n    index += 1\n    X = [int(data[index + i]) for i in range(N)]\n    index += N\n    P = [int(data[index + i]) for i in range(N)]\n    index += N\n    Q = int(data[index])\n    index += 1\n    queries = [(int(data[index + 2 * i]), int(data[index + 2 * i + 1])) for i in range(Q)]\n    \n    # Sort villages by position\n    villages = sorted(zip(X, P))\n    X, P = zip(*villages)\n    \n    # Compute prefix sum array\n    prefix_sum = [0]\n    for p in P:\n        prefix_sum.append(prefix_sum[-1] + p)\n    \n    # Process each query\n    for L, R in queries:\n        # Find the indices using binary search\n        left_idx = bisect_left(X, L)\n        right_idx = bisect_right(X, R)\n        \n        # Calculate the total population in the range [L, R]\n        if left_idx == len(X) or X[left_idx] > R:\n            result = 0\n        else:\n            result = prefix_sum[right_idx] - prefix_sum[left_idx]\n        \n        print(result)\n\nimport bisect\nmain()"]}
{"task_id": "arc183_a", "codes": ["import itertools\n\ndef generate_good_sequences(N, K):\n    elements = list(range(1, N + 1))\n    good_sequences = set()\n    \n    # Generate all combinations of size K for each element\n    for combination in itertools.combinations(elements * K, K):\n        # Ensure each element appears exactly K times\n        if all(combination.count(i) == K for i in elements):\n            good_sequences.add(tuple(sorted(combination)))\n    \n    return sorted(good_sequences)\n\ndef get_desired_sequence(N, K):\n    good_sequences = generate_good_sequences(N, K)\n    total_sequences = len(good_sequences)\n    target_index = (total_sequences + 1) // 2 - 1\n    \n    if target_index < 0 or target_index >= total_sequences:\n        raise ValueError(\"Target index out of range\")\n    \n    return good_sequences[target_index]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    \n    result = get_desired_sequence(N, K)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()", "i"], "passed": [false, false], "raw_code": ["```python\nimport itertools\n\ndef generate_good_sequences(N, K):\n    elements = list(range(1, N + 1))\n    good_sequences = set()\n    \n    # Generate all combinations of size K for each element\n    for combination in itertools.combinations(elements * K, K):\n        # Ensure each element appears exactly K times\n        if all(combination.count(i) == K for i in elements):\n            good_sequences.add(tuple(sorted(combination)))\n    \n    return sorted(good_sequences)\n\ndef get_desired_sequence(N, K):\n    good_sequences = generate_good_sequences(N, K)\n    total_sequences = len(good_sequences)\n    target_index = (total_sequences + 1) // 2 - 1\n    \n    if target_index < 0 or target_index >= total_sequences:\n        raise ValueError(\"Target index out of range\")\n    \n    return good_sequences[target_index]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    \n    result = get_desired_sequence(N, K)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nimport itertools\n\ndef find_middle_sequence(N, K):\n    # Generate all numbers from 1 to N repeated K times\n    sequence = [num for num in range(1, N + 1) for _ in range(K)]\n    \n    # Generate all unique permutations of the sequence\n    all_permutations = set(itertools.permutations(sequence))\n    \n    # Sort the permutations lexicographically\n    sorted_permutations = sorted(all_permutations)\n    \n    # Find the middle index\n    middle_index = len(sorted_permutations) // 2\n    \n    # Return the middle permutation\n    return sorted_permutations[middle_index]\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\n\n# Find and print the middle sequence\nmiddle_sequence = find_middle_sequence(N, K)\nprint(' '.join(map(str, middle_sequence)))"]}
{"task_id": "3579", "codes": ["def max_concatenated_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order\n    binary_nums.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)", "def largestNumber(nums):\n    # Convert each number to its binary representation and store it as a tuple (binary string, original number)\n    binary_nums = [(bin(num)[2:], num) for num in nums]\n    \n    # Sort the binary representations in descending order based on the binary string\n    binary_nums.sort(key=lambda x: x[0], reverse=True)\n    \n    # Concatenate the sorted binary strings\n    largest_binary = ''.join(num[0] for num in binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(largest_binary, 2)"], "passed": [false, false], "raw_code": ["```python\ndef max_concatenated_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order\n    binary_nums.sort(reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```", "```python\ndef largestNumber(nums):\n    # Convert each number to its binary representation and store it as a tuple (binary string, original number)\n    binary_nums = [(bin(num)[2:], num) for num in nums]\n    \n    # Sort the binary representations in descending order based on the binary string\n    binary_nums.sort(key=lambda x: x[0], reverse=True)\n    \n    # Concatenate the sorted binary strings\n    largest_binary = ''.join(num[0] for num in binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(largest_binary, 2)\n```"]}
{"task_id": "3573", "codes": ["def countValidSubstrings(word1: str, word2: str) -> int:\n    count = 0\n    word2_len = len(word2)\n    \n    for i in range(len(word1) - word2_len + 1):\n        substring = word1[i:i + word2_len]\n        if is_valid_prefix(substring, word2):\n            count += 1\n    \n    return count\n\ndef is_valid_prefix(substring: str, word2: str) -> bool:\n    word2_index = 0\n    for char in substring:\n        if word2_index < len(word2) and char == word2[word2_index]:\n            word2_index += 1\n    return word2_index == len(word2)", "from collections import Counter\n\ndef countValidSubstrings(word1, word2):\n    n, m = len(word1), len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        prefix = word1[i:i+m]\n        if prefix == word2[:m]:\n            remaining_word1 = word1[i+m:]\n            remaining_word2 = word2[m:]\n            if Counter(remaining_word1) >= Counter(remaining_word2):\n                count += 1\n                \n    return count"], "passed": [false, false], "raw_code": ["```python\ndef countValidSubstrings(word1: str, word2: str) -> int:\n    count = 0\n    word2_len = len(word2)\n    \n    for i in range(len(word1) - word2_len + 1):\n        substring = word1[i:i + word2_len]\n        if is_valid_prefix(substring, word2):\n            count += 1\n    \n    return count\n\ndef is_valid_prefix(substring: str, word2: str) -> bool:\n    word2_index = 0\n    for char in substring:\n        if word2_index < len(word2) and char == word2[word2_index]:\n            word2_index += 1\n    return word2_index == len(word2)\n```", "```python\nfrom collections import Counter\n\ndef countValidSubstrings(word1, word2):\n    n, m = len(word1), len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        prefix = word1[i:i+m]\n        if prefix == word2[:m]:\n            remaining_word1 = word1[i+m:]\n            remaining_word2 = word2[m:]\n            if Counter(remaining_word1) >= Counter(remaining_word2):\n                count += 1\n                \n    return count\n```"]}
{"task_id": "3559", "codes": ["def minValidStrings(words, target):\n    n = len(target)\n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(n):\n        for word in words:\n            if i + 1 >= len(word) and target[i - len(word) + 1:i + 1] == word:\n                dp[i] = min(dp[i], dp[i - len(word)] + 1 if i - len(word) >= 0 else 1)\n    \n    return dp[-1] if dp[-1] != float('inf') else -1", "def minValidStrings(words, target):\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for j in range(n):\n        if dp[j] == float('inf'):\n            continue\n        for word in words:\n            if target.startswith(word, j):\n                dp[j + len(word)] = min(dp[j + len(word)], dp[j] + 1)\n    \n    return dp[n] if dp[n] != float('inf') else -1"], "passed": [false, false], "raw_code": ["```python\ndef minValidStrings(words, target):\n    n = len(target)\n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(n):\n        for word in words:\n            if i + 1 >= len(word) and target[i - len(word) + 1:i + 1] == word:\n                dp[i] = min(dp[i], dp[i - len(word)] + 1 if i - len(word) >= 0 else 1)\n    \n    return dp[-1] if dp[-1] != float('inf') else -1\n```", "```python\ndef minValidStrings(words, target):\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for j in range(n):\n        if dp[j] == float('inf'):\n            continue\n        for word in words:\n            if target.startswith(word, j):\n                dp[j + len(word)] = min(dp[j + len(word)], dp[j] + 1)\n    \n    return dp[n] if dp[n] != float('inf') else -1\n```"]}
{"task_id": "3584", "codes": ["def smallestSequence(word1, word2):\n    m, n = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify mismatched characters\n    for i in range(n):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check validity and construct the sequence\n    valid_sequence = []\n    for idx in diff_indices:\n        temp_word1 = list(word1)\n        temp_word1[idx] = word2[idx]\n        if sum(1 for i in range(n) if temp_word1[i] != word2[i]) <= 1:\n            valid_sequence.append(idx)\n\n    # Sort the valid sequence to ensure lexicographical order\n    valid_sequence.sort()\n\n    return valid_sequence", "def find_lexicographically_smallest_sequence(word1, word2):\n    n, m = len(word1), len(word2)\n    mismatches = []\n\n    # Identify all mismatch positions\n    for i in range(m):\n        if word1[i] != word2[i]:\n            mismatches.append(i)\n\n    # Check if there's a valid sequence\n    if len(mismatches) > 1:\n        return []\n\n    # The lexicographically smallest sequence is the list of mismatches\n    return mismatches\n\n# Example usage:\nprint(find_lexicographically_smallest_sequence(\"vbcca\", \"abc\"))  # Output: [0, 1, 2]\nprint(find_lexicographically_smallest_sequence(\"bacdc\", \"abc\"))  # Output: [1, 2, 4]\nprint(find_lexicographically_smallest_sequence(\"aaaaaa\", \"aaabc\"))  # Output: []\nprint(find_lexicographically_smallest_sequence(\"abc\", \"ab\"))  # Output: [0, 1]"], "passed": [false, false], "raw_code": ["```python\ndef smallestSequence(word1, word2):\n    m, n = len(word1), len(word2)\n    diff_indices = []\n\n    # Identify mismatched characters\n    for i in range(n):\n        if word1[i] != word2[i]:\n            diff_indices.append(i)\n\n    # Check validity and construct the sequence\n    valid_sequence = []\n    for idx in diff_indices:\n        temp_word1 = list(word1)\n        temp_word1[idx] = word2[idx]\n        if sum(1 for i in range(n) if temp_word1[i] != word2[i]) <= 1:\n            valid_sequence.append(idx)\n\n    # Sort the valid sequence to ensure lexicographical order\n    valid_sequence.sort()\n\n    return valid_sequence\n```", "```python\ndef find_lexicographically_smallest_sequence(word1, word2):\n    n, m = len(word1), len(word2)\n    mismatches = []\n\n    # Identify all mismatch positions\n    for i in range(m):\n        if word1[i] != word2[i]:\n            mismatches.append(i)\n\n    # Check if there's a valid sequence\n    if len(mismatches) > 1:\n        return []\n\n    # The lexicographically smallest sequence is the list of mismatches\n    return mismatches\n\n# Example usage:\nprint(find_lexicographically_smallest_sequence(\"vbcca\", \"abc\"))  # Output: [0, 1, 2]\nprint(find_lexicographically_smallest_sequence(\"bacdc\", \"abc\"))  # Output: [1, 2, 4]\nprint(find_lexicographically_smallest_sequence(\"aaaaaa\", \"aaabc\"))  # Output: []\nprint(find_lexicographically_smallest_sequence(\"abc\", \"ab\"))  # Output: [0, 1]\n```"]}
{"task_id": "abc370_c", "codes": ["def min_transformations(S, T):\n    n = len(S)\n    X = [S]\n    for i in range(n):\n        if S[i] != T[i]:\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                if char != S[i]:\n                    new_S = S[:i] + char + S[i+1:]\n                    if new_S == T:\n                        X.append(new_S)\n                        break\n                    elif new_S < S:\n                        X.append(new_S)\n                        S = new_S\n                        break\n    return len(X), X\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\nS, T = input().split()\nM, X = min_transformations(S, T)\nprint(M)\nfor s in X:\n    print(s)", "def min_operations(S, T):\n    n = len(S)\n    X = [S]\n    for i in range(n):\n        if S[i] != T[i]:\n            # Find the next lexicographically smallest character greater than S[i]\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if ord(c) > ord(S[i]) and c <= T[i]:\n                    new_S = S[:i] + c + S[i+1:i+2] * (n - i - 1)\n                    break\n            X.append(new_S)\n            S = new_S\n    return len(X), X\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nS = data[0]\nT = data[1]\n\n# Get the result\nM, X = min_operations(S, T)\n\n# Print the result\nprint(M)\nfor s in X:\n    print(s)"], "passed": [false, false], "raw_code": ["def min_transformations(S, T):\n    n = len(S)\n    X = [S]\n    for i in range(n):\n        if S[i] != T[i]:\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                if char != S[i]:\n                    new_S = S[:i] + char + S[i+1:]\n                    if new_S == T:\n                        X.append(new_S)\n                        break\n                    elif new_S < S:\n                        X.append(new_S)\n                        S = new_S\n                        break\n    return len(X), X\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\nS, T = input().split()\nM, X = min_transformations(S, T)\nprint(M)\nfor s in X:\n    print(s)", "def min_operations(S, T):\n    n = len(S)\n    X = [S]\n    for i in range(n):\n        if S[i] != T[i]:\n            # Find the next lexicographically smallest character greater than S[i]\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if ord(c) > ord(S[i]) and c <= T[i]:\n                    new_S = S[:i] + c + S[i+1:i+2] * (n - i - 1)\n                    break\n            X.append(new_S)\n            S = new_S\n    return len(X), X\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nS = data[0]\nT = data[1]\n\n# Get the result\nM, X = min_operations(S, T)\n\n# Print the result\nprint(M)\nfor s in X:\n    print(s)"]}
{"task_id": "abc369_c", "codes": ["def count_arithmetic_progressions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_count = 0\n    \n    for start in range(N):\n        diff_count = {}\n        \n        for end in range(start, N):\n            if end == start:\n                diff_count[None] = 1\n            else:\n                diff = A[end] - A[end - 1]\n                if diff in diff_count:\n                    total_count += diff_count[diff]\n                diff_count[diff] = diff_count.get(diff, 0) + 1\n    \n    print(total_count)\n\ncount_arithmetic_progressions()", "d"], "passed": [false, false], "raw_code": ["```python\ndef count_arithmetic_progressions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_count = 0\n    \n    for start in range(N):\n        diff_count = {}\n        \n        for end in range(start, N):\n            if end == start:\n                diff_count[None] = 1\n            else:\n                diff = A[end] - A[end - 1]\n                if diff in diff_count:\n                    total_count += diff_count[diff]\n                diff_count[diff] = diff_count.get(diff, 0) + 1\n    \n    print(total_count)\n\ncount_arithmetic_progressions()\n```", "```python\ndef count_arithmetic_progressions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    \n    for i in range(N):\n        diff_count = {}\n        for j in range(i, N):\n            if j > i:\n                diff = A[j] - A[j - 1]\n                if diff in diff_count:\n                    count += diff_count[diff]\n            diff_count[diff] = diff_count.get(diff, 0) + 1\n    \n    print(count)\n\ncount_arithmetic_progressions()"]}
{"task_id": "arc181_a", "codes": ["def min_operations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        P = list(map(int, data[index:index + N]))\n        index += N\n        \n        inversions = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if P[i] > P[j]:\n                    inversions += 1\n        \n        results.append(inversions)\n    \n    for result in results:\n        print(result)\n\nmin_operations()", "def min_operations(permutation):\n    n = len(permutation)\n    visited = [False] * n\n    operations = 0\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle_length = 0\n            x = i\n            \n            while not visited[x]:\n                visited[x] = True\n                x = permutation[x] - 1\n                cycle_length += 1\n            \n            if cycle_length > 0:\n                operations += (cycle_length - 1)\n    \n    return operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        permutation = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = min_operations(permutation)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef min_operations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        P = list(map(int, data[index:index + N]))\n        index += N\n        \n        inversions = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if P[i] > P[j]:\n                    inversions += 1\n        \n        results.append(inversions)\n    \n    for result in results:\n        print(result)\n\nmin_operations()\n```", "```python\ndef min_operations(permutation):\n    n = len(permutation)\n    visited = [False] * n\n    operations = 0\n    \n    for i in range(n):\n        if not visited[i]:\n            cycle_length = 0\n            x = i\n            \n            while not visited[x]:\n                visited[x] = True\n                x = permutation[x] - 1\n                cycle_length += 1\n            \n            if cycle_length > 0:\n                operations += (cycle_length - 1)\n    \n    return operations\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        permutation = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = min_operations(permutation)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc367_c", "codes": ["import sys\nfrom itertools import product\n\ndef find_sequences(N, K, R):\n    def is_valid(seq):\n        return sum(seq) % K == 0\n\n    sequences = list(product(range(1, r + 1) for r in R))\n    valid_sequences = [seq for seq in sequences if is_valid(seq)]\n    valid_sequences.sort()\n    return valid_sequences\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    R = list(map(int, data[2:]))\n    sequences = find_sequences(N, K, R)\n    print(len(sequences))\n    for seq in sequences:\n        print(' '.join(map(str, seq)))", "import sys\nfrom itertools import product\n\ndef find_sequences(N, K, ranges):\n    def is_valid(seq):\n        return sum(seq) % K == 0\n\n    sequences = []\n    for seq in product(*(range(1, r + 1) for r in ranges)):\n        if is_valid(seq):\n            sequences.append(seq)\n\n    return sorted(sequences)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    ranges = list(map(int, data[2:])),\n\n    sequences = find_sequences(N, K, ranges)\n    print(len(sequences))\n    for seq in sequences:\n        print(' '.join(map(str, seq)))\n\nif __name__ == '__main__':\n    main()"], "passed": [false, false], "raw_code": ["import sys\nfrom itertools import product\n\ndef find_sequences(N, K, R):\n    def is_valid(seq):\n        return sum(seq) % K == 0\n\n    sequences = list(product(range(1, r + 1) for r in R))\n    valid_sequences = [seq for seq in sequences if is_valid(seq)]\n    valid_sequences.sort()\n    return valid_sequences\n\nif __name__ == '__main__':\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    R = list(map(int, data[2:]))\n    sequences = find_sequences(N, K, R)\n    print(len(sequences))\n    for seq in sequences:\n        print(' '.join(map(str, seq)))", "import sys\nfrom itertools import product\n\ndef find_sequences(N, K, ranges):\n    def is_valid(seq):\n        return sum(seq) % K == 0\n\n    sequences = []\n    for seq in product(*(range(1, r + 1) for r in ranges)):\n        if is_valid(seq):\n            sequences.append(seq)\n\n    return sorted(sequences)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    ranges = list(map(int, data[2:])),\n\n    sequences = find_sequences(N, K, ranges)\n    print(len(sequences))\n    for seq in sequences:\n        print(' '.join(map(str, seq)))\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "3534", "codes": ["def almost_equal_pairs(nums):\n    def generate_swaps(num):\n        num_str = str(num)\n        n = len(num_str)\n        swaps = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                swapped_str = num_str[:i] + num_str[j] + num_str[i+1:j] + num_str[i] + num_str[j+1:]\n                swaps.add(int(swapped_str))\n        return swaps\n    \n    num_set = set(nums)\n    swap_dict = {num: generate_swaps(num) for num in num_set}\n    \n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] in swap_dict[nums[i]]:\n                count += 1\n                \n    return count", "def almost_equal_pairs(nums):\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            str_i, str_j = str(nums[i]), str(nums[j])\n            if str_i == str_j:\n                count += 1\n                continue\n            for k in range(len(str_i)):\n                for l in range(k + 1, len(str_i)):\n                    swapped_str_i = list(str_i)\n                    swapped_str_i[k], swapped_str_i[l] = swapped_str_i[l], swapped_str_i[k]\n                    if ''.join(swapped_str_i) == str_j or ''.join(swapped_str_i) == str_j[::-1]:\n                        count += 1\n                        break\n                else:\n                    continue\n                break\n    return count"], "passed": [false, false], "raw_code": ["```python\ndef almost_equal_pairs(nums):\n    def generate_swaps(num):\n        num_str = str(num)\n        n = len(num_str)\n        swaps = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                swapped_str = num_str[:i] + num_str[j] + num_str[i+1:j] + num_str[i] + num_str[j+1:]\n                swaps.add(int(swapped_str))\n        return swaps\n    \n    num_set = set(nums)\n    swap_dict = {num: generate_swaps(num) for num in num_set}\n    \n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] in swap_dict[nums[i]]:\n                count += 1\n                \n    return count\n```", "```python\ndef almost_equal_pairs(nums):\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            str_i, str_j = str(nums[i]), str(nums[j])\n            if str_i == str_j:\n                count += 1\n                continue\n            for k in range(len(str_i)):\n                for l in range(k + 1, len(str_i)):\n                    swapped_str_i = list(str_i)\n                    swapped_str_i[k], swapped_str_i[l] = swapped_str_i[l], swapped_str_i[k]\n                    if ''.join(swapped_str_i) == str_j or ''.join(swapped_str_i) == str_j[::-1]:\n                        count += 1\n                        break\n                else:\n                    continue\n                break\n    return count\n```"]}
{"task_id": "abc371_c", "codes": ["i", "i"], "passed": [false, false], "raw_code": ["```python\nimport itertools\n\ndef min_cost_to_isomorphic(N, MG, edges_G, MH, edges_H, costs):\n    # Convert edge lists to adjacency lists\n    adj_G = [[] for _ in range(N)]\n    for u, v in edges_G:\n        adj_G[u-1].append(v-1)\n        adj_G[v-1].append(u-1)\n\n    adj_H = [[] for _ in range(N)]\n    for a, b in edges_H:\n        adj_H[a-1].append(b-1)\n        adj_H[b-1].append", "```python\nimport sys\nfrom itertools import permutations\n\ndef min_cost_to_isomorphic():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    M_G = int(data[index])\n    index += 1\n    edges_G = []\n    for _ in range(M_G):\n        u_G = int(data[index]) - 1\n        v_G = int(data[index + 1]) - 1\n        edges_G.append((u_G, v_G))\n        index += 2\n    \n    M_H = int(data[index])\n    index += 1\n    edges_H = []\n    for _ in range(M_H):\n        a_H = int(data[index]) - 1\n        b_H = int(data[index + 1]) - 1\n        edges_H.append((a_H, b_H))\n        index += 2\n    \n    A = []\n    for i in range(N):\n        row = []\n        for j in range(N):\n            if i < j:\n                row.append(int(data[index]))\n                index += 1\n            else:\n                row.append(0)\n        A.append(row)\n    \n    # Convert edge lists to adjacency matrices\n    adj_G = [[0] * N for _ in range(N)]\n    for u, v in edges_G:\n        adj_G[u][v] = 1\n        adj_G[v][u] = 1\n    \n    adj_H = [[0] * N for _ in range(N)]\n    for a, b in edges_H:\n        adj_H[a][b] = 1\n        adj_H[b][a] = 1\n    \n    # Function to calculate the cost of making adj_H isomorphic to adj_G with a given permutation\n    def calculate_cost(permutation):\n        cost = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if adj_G[i][j] != adj_H[permutation[i]][permutation[j]]:\n                    cost += A[i][j]\n        return cost\n    \n    # Try all permutations and find the minimum cost\n    min_cost = float('inf')\n    for perm in permutations(range(N)):\n        min_cost = min(min_cost, calculate_cost(perm))\n    \n    print(min_cost)\n\nmin_cost_to_isomorphic()"]}
{"task_id": "abc373_c", "codes": ["def max_sum_of_arrays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N\n    N = int(data[0])\n    \n    # Read array A\n    A = list(map(int, data[1:N+1]))\n    \n    # Read array B\n    B = list(map(int, data[N+1:2*N+1]))\n    \n    # Find the maximum element in A\n    max_A = max(A)\n    \n    # Find the maximum element in B\n    max_B = max(B)\n    \n    # Print the sum of the maximum elements\n    print(max_A + max_B)\n\n# Call the function\nmax_sum_of_arrays()", "import sys\nfrom bisect import bisect_right\n\ndef max_sum(A, B):\n    A.sort()\n    max_val = float('-inf')\n    \n    for b in B:\n        idx = bisect_right(A, 10**9 - b)\n        if idx > 0:\n            max_val = max(max_val, A[idx - 1] + b)\n    \n    return max_val\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:]))\n    \n    result = max_sum(A, B)\n    print(result)"], "passed": [true, false], "raw_code": ["```python\ndef max_sum_of_arrays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N\n    N = int(data[0])\n    \n    # Read array A\n    A = list(map(int, data[1:N+1]))\n    \n    # Read array B\n    B = list(map(int, data[N+1:2*N+1]))\n    \n    # Find the maximum element in A\n    max_A = max(A)\n    \n    # Find the maximum element in B\n    max_B = max(B)\n    \n    # Print the sum of the maximum elements\n    print(max_A + max_B)\n\n# Call the function\nmax_sum_of_arrays()\n```", "```python\nimport sys\nfrom bisect import bisect_right\n\ndef max_sum(A, B):\n    A.sort()\n    max_val = float('-inf')\n    \n    for b in B:\n        idx = bisect_right(A, 10**9 - b)\n        if idx > 0:\n            max_val = max(max_val, A[idx - 1] + b)\n    \n    return max_val\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:]))\n    \n    result = max_sum(A, B)\n    print(result)\n```"]}
{"task_id": "abc370_d", "codes": ["d", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    H = int(data[index])\n    W = int(data[index + 1])\n    Q = int(data[index + 2])\n    index += 3\n    \n    grid = [[True] * W for _ in range(H)]\n    \n    for _ in range(Q):\n        R = int(data[index]) - 1\n        C = int(data[index + 1]) - 1\n        index += 2\n        \n        if grid[R][C]:\n            grid[R][C] = False\n        else:\n            # Destroy walls in the four directions\n            for dr in [-1, 1]:\n                r = R + dr\n                while 0 <= r < H and not grid[r][C]:\n                    r += dr\n                if 0 <= r < H:\n                    grid[r][C] = False\n            \n            for dc in [-1, 1]:\n                c = C + dc\n                while 0 <= c < W and not grid[R][c]:\n                    c += dc\n                if 0 <= c < W:\n                    grid[R][c] = False\n    \n    remaining_walls = sum(row.count(True) for row in grid)\n    print(remaining_walls)\n\nmain()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    H = int(data[0])\n    W = int(data[1])\n    Q = int(data[2])\n    \n    grid = [[True] * W for _ in range(H)]\n    \n    index = 3\n    for _ in range(Q):\n        R = int(data[index]) - 1\n        C = int(data[index + 1]) - 1\n        index += 2\n        \n        if grid[R][C]:\n            grid[R][C] = False\n        else:\n            # Destroy walls up\n            for i in range(R - 1, -1, -1):\n                if grid[i][C]:\n                    grid[i][C] = False\n                    break\n            # Destroy walls down\n            for i in range(R + 1, H):\n                if grid[i][C]:\n                    grid[i][C] = False\n                    break\n            # Destroy walls left\n            for j in range(C - 1, -1, -1):\n                if grid[R][j]:\n                    grid[R][j] = False\n                    break\n            # Destroy walls right\n            for j in range(C + 1, W):\n                if grid[R][j]:\n                    grid[R][j] = False\n                    break\n    \n    remaining_walls = sum(row.count(True) for row in grid)\n    print(remaining_walls)\n\nmain()", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    H = int(data[index])\n    W = int(data[index + 1])\n    Q = int(data[index + 2])\n    index += 3\n    \n    grid = [[True] * W for _ in range(H)]\n    \n    for _ in range(Q):\n        R = int(data[index]) - 1\n        C = int(data[index + 1]) - 1\n        index += 2\n        \n        if grid[R][C]:\n            grid[R][C] = False\n        else:\n            # Destroy walls in the four directions\n            for dr in [-1, 1]:\n                r = R + dr\n                while 0 <= r < H and not grid[r][C]:\n                    r += dr\n                if 0 <= r < H:\n                    grid[r][C] = False\n            \n            for dc in [-1, 1]:\n                c = C + dc\n                while 0 <= c < W and not grid[R][c]:\n                    c += dc\n                if 0 <= c < W:\n                    grid[R][c] = False\n    \n    remaining_walls = sum(row.count(True) for row in grid)\n    print(remaining_walls)\n\nmain()\n```"]}
{"task_id": "abc372_c", "codes": ["d", "def count_abc(s):\n    return s.count('ABC')\n\ndef process_queries(n, q, s, queries):\n    abc_count = count_abc(s)\n    results = []\n    \n    for x, c in queries:\n        x -= 1  # Convert to 0-indexed\n        old_char = s[x]\n        \n        if old_char == 'A':\n            if s[x+1] == 'B' and s[x+2] == 'C':\n                abc_count -= 1\n            if c == 'B':\n                if x+1 < n and s[x+1] == 'C':\n                    abc_count += 1\n                if x+2 < n and s[x+2] == 'C':\n                    abc_count += 1\n        elif old_char == 'B':\n            if s[x-1] == 'A' and s[x+1] == 'C':\n                abc_count -= 1\n            if c == 'A':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x+1 < n and s[x+1] == 'C':\n                    abc_count += 1\n            elif c == 'C':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x+1 < n and s[x+1] == 'C':\n                    abc_count += 1\n        elif old_char == 'C':\n            if s[x-1] == 'A' and s[x-2] == 'B':\n                abc_count -= 1\n            if c == 'A':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x-2 >= 0 and s[x-2] == 'B':\n                    abc_count += 1\n            elif c == 'B':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x-2 >= 0 and s[x-2] == 'B':\n                    abc_count += 1\n        \n        s = s[:x] + c + s[x+1:]\n        results.append(abc_count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    s = data[2]\n    queries = [(int(data[2 + 2 * i]) - 1, data[3 + 2 * i]) for i in range(q)]\n    \n    results = process_queries(n, q, s, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef count_abc_substrings(s):\n    n = len(s)\n    count = 0\n    a, b, c = 0, 0, 0\n    \n    # Initial count of \"ABC\"\n    for i in range(n - 2):\n        if s[i] == 'A':\n            a += 1\n        elif s[i] == 'B':\n            b += 1\n        elif s[i] == 'C':\n            c += 1\n            if a > 0 and b > 0:\n                count += min(a, b, c)\n    \n    return count\n\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    s = data[2]\n    \n    results = []\n    a, b, c = 0, 0, 0\n    count = 0\n    \n    index = 3\n    for _ in range(q):\n        x = int(data[index]) - 1\n        c_new = data[index + 1]\n        \n        # Update the counters based on the previous character\n        if s[x] == 'A':\n            a -= 1\n        elif s[x] == 'B':\n            b -= 1\n        elif s[x] == 'C':\n            c -= 1\n        \n        # Add the new character to the counters\n        if c_new == 'A':\n            a += 1\n        elif c_new == 'B':\n            b += 1\n        elif c_new == 'C':\n            c += 1\n        \n        # Adjust the count of \"ABC\" if the window is valid\n        if x >= 2:\n            if s[x - 2] == 'A':\n                a -= 1\n            elif s[x - 2] == 'B':\n                b -= 1\n            elif s[x - 2] == 'C':\n                c -= 1\n            \n            if s[x] == 'A':\n                a += 1\n            elif s[x] == 'B':\n                b += 1\n            elif s[x] == 'C':\n                c += 1\n        \n        if x >= 2 and x < n - 1:\n            if s[x - 2] == 'A' and s[x - 1] == 'B' and s[x] == 'C':\n                count += min(a, b, c)\n        \n        results.append(count)\n        index += 2\n    \n    for result in results:\n        print(result)\n\nprocess_queries()", "```python\ndef count_abc(s):\n    return s.count('ABC')\n\ndef process_queries(n, q, s, queries):\n    abc_count = count_abc(s)\n    results = []\n    \n    for x, c in queries:\n        x -= 1  # Convert to 0-indexed\n        old_char = s[x]\n        \n        if old_char == 'A':\n            if s[x+1] == 'B' and s[x+2] == 'C':\n                abc_count -= 1\n            if c == 'B':\n                if x+1 < n and s[x+1] == 'C':\n                    abc_count += 1\n                if x+2 < n and s[x+2] == 'C':\n                    abc_count += 1\n        elif old_char == 'B':\n            if s[x-1] == 'A' and s[x+1] == 'C':\n                abc_count -= 1\n            if c == 'A':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x+1 < n and s[x+1] == 'C':\n                    abc_count += 1\n            elif c == 'C':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x+1 < n and s[x+1] == 'C':\n                    abc_count += 1\n        elif old_char == 'C':\n            if s[x-1] == 'A' and s[x-2] == 'B':\n                abc_count -= 1\n            if c == 'A':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x-2 >= 0 and s[x-2] == 'B':\n                    abc_count += 1\n            elif c == 'B':\n                if x-1 >= 0 and s[x-1] == 'A':\n                    abc_count += 1\n                if x-2 >= 0 and s[x-2] == 'B':\n                    abc_count += 1\n        \n        s = s[:x] + c + s[x+1:]\n        results.append(abc_count)\n    \n    return results\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    s = data[2]\n    queries = [(int(data[2 + 2 * i]) - 1, data[3 + 2 * i]) for i in range(q)]\n    \n    results = process_queries(n, q, s, queries)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3570", "codes": ["def countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    def has_all_vowels(vowel_count):\n        return all(vowel_count[v] >= 1 for v in vowels)\n    \n    for i in range(n):\n        vowel_count = {v: 0 for v in vowels}\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count[char] += 1\n            else:\n                consonant_count += 1\n            \n            while consonant_count > k or not has_all_vowels(vowel_count):\n                if word[i] in vowels:\n                    vowel_count[word[i]] -= 1\n                else:\n                    consonant_count -= 1\n                i += 1\n            \n            if consonant_count == k and has_all_vowels(vowel_count):\n                count += 1\n    \n    return count", "def countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    # Function to check if a character is a vowel\n    def is_vowel(char):\n        return char in vowels\n    \n    # Function to check if a character is a consonant\n    def is_consonant(char):\n        return char.isalpha() and not is_vowel(char)\n    \n    # Sliding window approach\n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        for j in range(i, n):\n            if is_vowel(word[j]):\n                vowel_count += 1\n            elif is_consonant(word[j]):\n                consonant_count += 1\n            \n            # Check if the current window has all vowels and exactly k consonants\n            if vowel_count == 5 and consonant_count == k:\n                count += (n - j)\n                break\n    \n    return count"], "passed": [false, false], "raw_code": ["```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    def has_all_vowels(vowel_count):\n        return all(vowel_count[v] >= 1 for v in vowels)\n    \n    for i in range(n):\n        vowel_count = {v: 0 for v in vowels}\n        consonant_count = 0\n        \n        for j in range(i, n):\n            char = word[j]\n            if char in vowels:\n                vowel_count[char] += 1\n            else:\n                consonant_count += 1\n            \n            while consonant_count > k or not has_all_vowels(vowel_count):\n                if word[i] in vowels:\n                    vowel_count[word[i]] -= 1\n                else:\n                    consonant_count -= 1\n                i += 1\n            \n            if consonant_count == k and has_all_vowels(vowel_count):\n                count += 1\n    \n    return count\n```", "```python\ndef countSubstrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    \n    # Function to check if a character is a vowel\n    def is_vowel(char):\n        return char in vowels\n    \n    # Function to check if a character is a consonant\n    def is_consonant(char):\n        return char.isalpha() and not is_vowel(char)\n    \n    # Sliding window approach\n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        for j in range(i, n):\n            if is_vowel(word[j]):\n                vowel_count += 1\n            elif is_consonant(word[j]):\n                consonant_count += 1\n            \n            # Check if the current window has all vowels and exactly k consonants\n            if vowel_count == 5 and consonant_count == k:\n                count += (n - j)\n                break\n    \n    return count\n```"]}
{"task_id": "abc365_c", "codes": ["def max_subsidy_limit(N, M, A):\n    A.sort()\n    \n    def can_satisfy(limit):\n        total_subsidy = sum(min(limit, ai) for ai in A)\n        return total_subsidy <= M\n    \n    left, right = 0, max(A)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_satisfy(mid):\n            left = mid\n        else:\n            right = mid - 1\n    \n    return \"infinite\" if left == max(A) and not can_satisfy(max(A)) else str(left)\n\n# Call the function with stdin as input and print the output\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(max_subsidy_limit(N, M, A))", "def max_subsidy_limit(N, M, A):\n    A.sort()\n    \n    def can_subsidize(x):\n        total_subsidy = sum(min(x, a) for a in A)\n        return total_subsidy <= M\n    \n    low, high = 0, A[-1]\n    result = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_subsidize(mid):\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    if result == -1:\n        return \"infinite\"\n    else:\n        return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(max_subsidy_limit(N, M, A))"], "passed": [false, false], "raw_code": ["```python\ndef max_subsidy_limit(N, M, A):\n    A.sort()\n    \n    def can_satisfy(limit):\n        total_subsidy = sum(min(limit, ai) for ai in A)\n        return total_subsidy <= M\n    \n    left, right = 0, max(A)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_satisfy(mid):\n            left = mid\n        else:\n            right = mid - 1\n    \n    return \"infinite\" if left == max(A) and not can_satisfy(max(A)) else str(left)\n\n# Call the function with stdin as input and print the output\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(max_subsidy_limit(N, M, A))\n```", "```python\ndef max_subsidy_limit(N, M, A):\n    A.sort()\n    \n    def can_subsidize(x):\n        total_subsidy = sum(min(x, a) for a in A)\n        return total_subsidy <= M\n    \n    low, high = 0, A[-1]\n    result = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if can_subsidize(mid):\n            result = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    if result == -1:\n        return \"infinite\"\n    else:\n        return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(max_subsidy_limit(N, M, A))\n```"]}
{"task_id": "abc368_c", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        for i in range(N):\n            if H[i] > 0:\n                if T % 3 == 0:\n                    H[i] -= 3\n                else:\n                    H[i] -= 1\n                if H[i] <= 0:\n                    H.pop(i)\n                    N -= 1\n                    break\n    \n    print(T)\n\nmain()", "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        if T % 3 == 0:\n            H[0] -= 3\n        else:\n            H[0] -= 1\n    \n    print(T)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        for i in range(N):\n            if H[i] > 0:\n                if T % 3 == 0:\n                    H[i] -= 3\n                else:\n                    H[i] -= 1\n                if H[i] <= 0:\n                    H.pop(i)\n                    N -= 1\n                    break\n    \n    print(T)\n\nmain()\n```", "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        if T % 3 == 0:\n            H[0] -= 3\n        else:\n            H[0] -= 1\n    \n    print(T)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3485", "codes": ["def maxScore(start, d):\n    choices = []\n    for s in start:\n        choices.append(s + d)\n        choices.append(s)\n    choices.sort()\n    return max(choices[i] - choices[i - 1] for i in range(1, len(choices)))", "def maxScore(start, d):\n    # Select the larger value from each interval\n    choices = [s + d for s in start]\n    \n    # Sort the selected values\n    choices.sort()\n    \n    # Compute the minimum difference between consecutive elements\n    max_diff = 0\n    for i in range(1, len(choices)):\n        diff = choices[i] - choices[i - 1]\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(start, d):\n    choices = []\n    for s in start:\n        choices.append(s + d)\n        choices.append(s)\n    choices.sort()\n    return max(choices[i] - choices[i - 1] for i in range(1, len(choices)))\n```", "```python\ndef maxScore(start, d):\n    # Select the larger value from each interval\n    choices = [s + d for s in start]\n    \n    # Sort the selected values\n    choices.sort()\n    \n    # Compute the minimum difference between consecutive elements\n    max_diff = 0\n    for i in range(1, len(choices)):\n        diff = choices[i] - choices[i - 1]\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff\n```"]}
{"task_id": "3528", "codes": ["def maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if j > i:\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[n - 1]", "def maxJumpScore(nums):\n    n = len(nums)\n    max_score = 0\n    current_score = 0\n    for i in range(n - 2, -1, -1):\n        current_score = (i + 1 - i) * nums[i] + max_score\n        max_score = max(max_score, current_score)\n    return max_score"], "passed": [false, false], "raw_code": ["```python\ndef maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if j > i:\n                dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[n - 1]\n```", "```python\ndef maxJumpScore(nums):\n    n = len(nums)\n    max_score = 0\n    current_score = 0\n    for i in range(n - 2, -1, -1):\n        current_score = (i + 1 - i) * nums[i] + max_score\n        max_score = max(max_score, current_score)\n    return max_score\n```"]}
{"task_id": "abc367_d", "codes": ["def count_pairs(N, M, A):\n    # Calculate prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    # Dictionary to store the frequency of remainders\n    remainder_count = {}\n    for i in range(N + 1):\n        remainder = prefix_sum[i] % M\n        if remainder in remainder_count:\n            remainder_count[remainder] += 1\n        else:\n            remainder_count[remainder] = 1\n    \n    # Count the number of valid pairs\n    count = 0\n    for remainder, freq in remainder_count.items():\n        count += freq * (freq - 1) // 2\n    \n    return count\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_pairs(N, M, A))", "d"], "passed": [false, false], "raw_code": ["```python\ndef count_pairs(N, M, A):\n    # Calculate prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    # Dictionary to store the frequency of remainders\n    remainder_count = {}\n    for i in range(N + 1):\n        remainder = prefix_sum[i] % M\n        if remainder in remainder_count:\n            remainder_count[remainder] += 1\n        else:\n            remainder_count[remainder] = 1\n    \n    # Count the number of valid pairs\n    count = 0\n    for remainder, freq in remainder_count.items():\n        count += freq * (freq - 1) // 2\n    \n    return count\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_pairs(N, M, A))\n```", "```python\ndef count_valid_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    # Calculate prefix sum array\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    # Dictionary to store the count of each modulo value\n    mod_count = {}\n    result = 0\n    \n    for i in range(N):\n        mod_value = prefix_sum[i] % M\n        if mod_value in mod_count:\n            result += mod_count[mod_value]\n        mod_count[mod_value] = mod_count.get(mod_value, 0) + 1\n    \n    print(result)\n\ncount_valid_pairs()"]}
{"task_id": "abc372_d", "codes": ["def count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    result = [0] * N\n    \n    for i in range(N):\n        count = 0\n        for j in range(i + 1, N):\n            if heights[j] <= heights[i]:\n                count += 1\n        result[i] = count\n    \n    print(' '.join(map(str, result)))\n\ncount_valid_buildings()", "d"], "passed": [false, false], "raw_code": ["```python\ndef count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    result = [0] * N\n    \n    for i in range(N):\n        count = 0\n        for j in range(i + 1, N):\n            if heights[j] <= heights[i]:\n                count += 1\n        result[i] = count\n    \n    print(' '.join(map(str, result)))\n\ncount_valid_buildings()\n```", "```python\ndef count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    result = [0] * N\n    max_height = 0\n    \n    for i in range(N-1, -1, -1):\n        if heights[i] > max_height:\n            max_height = heights[i]\n        else:\n            j = i + 1\n            while j < N and heights[j] <= max_height:\n                result[i] += 1\n                j += 1\n    \n    print(' '.join(map(str, result)))\n\ncount_valid_buildings()"]}
{"task_id": "3525", "codes": ["def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_no_switch = max(energyDrinkA[0], energyDrinkB[0])\n    dp_switch = 0\n    \n    for i in range(1, n):\n        new_dp_no_switch = max(dp_no_switch + energyDrinkA[i], dp_switch + energyDrinkA[i])\n        new_dp_switch = max(dp_no_switch + energyDrinkB[i], dp_switch + energyDrinkB[i])\n        \n        dp_no_switch, dp_switch = new_dp_no_switch, new_dp_switch\n    \n    return max(dp_no_switch, dp_switch)", "def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_A = energyDrinkA[0]\n    dp_B = energyDrinkB[0]\n    \n    for i in range(1, n):\n        dp_A, dp_B = max(dp_A + energyDrinkA[i], dp_B + energyDrinkA[i]), max(dp_B + energyDrinkB[i], dp_A + energyDrinkB[i])\n    \n    return max(dp_A, dp_B)"], "passed": [false, false], "raw_code": ["```python\ndef maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_no_switch = max(energyDrinkA[0], energyDrinkB[0])\n    dp_switch = 0\n    \n    for i in range(1, n):\n        new_dp_no_switch = max(dp_no_switch + energyDrinkA[i], dp_switch + energyDrinkA[i])\n        new_dp_switch = max(dp_no_switch + energyDrinkB[i], dp_switch + energyDrinkB[i])\n        \n        dp_no_switch, dp_switch = new_dp_no_switch, new_dp_switch\n    \n    return max(dp_no_switch, dp_switch)\n```", "```python\ndef maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_A = energyDrinkA[0]\n    dp_B = energyDrinkB[0]\n    \n    for i in range(1, n):\n        dp_A, dp_B = max(dp_A + energyDrinkA[i], dp_B + energyDrinkA[i]), max(dp_B + energyDrinkB[i], dp_A + energyDrinkB[i])\n    \n    return max(dp_A, dp_B)\n```"]}
{"task_id": "abc365_d", "codes": ["def max_wins(N, S):\n    wins = 0\n    for move in S:\n        if move == 'R':\n            if wins % 3 != 0:\n                wins += 1\n        elif move == 'P':\n            if wins % 3 != 1:\n                wins += 1\n        elif move == 'S':\n            if wins % 3 != 2:\n                wins += 1\n    return wins\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Calculate and print the result\nprint(max_wins(N, S))", "def max_wins(N, S):\n    # Initialize the count of wins\n    wins = 0\n    \n    # Iterate through Aoki's moves\n    for i in range(N):\n        if S[i] == 'R':\n            # If Aoki plays Rock, Takahashi should play Paper to win\n            wins += 1\n        elif S[i] == 'P':\n            # If Aoki plays Paper, Takahashi should play Scissors to win\n            wins += 1\n        elif S[i] == 'S':\n            # If Aoki plays Scissors, Takahashi should play Rock to win\n            wins += 1\n    \n    # Return the maximum number of wins\n    return wins\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Print the result\nprint(max_wins(N, S))"], "passed": [false, false], "raw_code": ["```python\ndef max_wins(N, S):\n    wins = 0\n    for move in S:\n        if move == 'R':\n            if wins % 3 != 0:\n                wins += 1\n        elif move == 'P':\n            if wins % 3 != 1:\n                wins += 1\n        elif move == 'S':\n            if wins % 3 != 2:\n                wins += 1\n    return wins\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Calculate and print the result\nprint(max_wins(N, S))\n```", "```python\ndef max_wins(N, S):\n    # Initialize the count of wins\n    wins = 0\n    \n    # Iterate through Aoki's moves\n    for i in range(N):\n        if S[i] == 'R':\n            # If Aoki plays Rock, Takahashi should play Paper to win\n            wins += 1\n        elif S[i] == 'P':\n            # If Aoki plays Paper, Takahashi should play Scissors to win\n            wins += 1\n        elif S[i] == 'S':\n            # If Aoki plays Scissors, Takahashi should play Rock to win\n            wins += 1\n    \n    # Return the maximum number of wins\n    return wins\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\n# Print the result\nprint(max_wins(N, S))\n```"]}
{"task_id": "abc366_d", "codes": ["d", "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read input parameters\n    N = int(data[0])\n    index = 1\n    A = [[[int(data[index + z * N * N + y * N + x]) for x in range(N)] for y in range(N)] for z in range(N)]\n    Q = int(data[index + N * N * N])\n    index += N * N * N + 1\n    queries = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, data[index:index + 6])\n        queries.append((Lx - 1, Rx, Ly - 1, Ry, Lz - 1, Rz))\n        index += 6\n\n    # Create 3D prefix sum array\n    P = [[[0 for _ in range(N + 1)] for _ in range(N + 1)] for _ in range(N + 1)]\n    for x in range(1, N + 1):\n        for y in range(1, N + 1):\n            for z in range(1, N + 1):\n                P[x][y][z] = A[x - 1][y - 1][z - 1] + P[x - 1][y][z] + P[x][y - 1][z] + P[x][y][z - 1] - P[x - 1][y - 1][z] - P[x - 1][y][z - 1] - P[x][y - 1][z - 1] + P[x - 1][y - 1][z - 1]\n\n    # Process each query using the prefix sum array\n    results = []\n    for Lx, Rx, Ly, Ry, Lz, Rz in queries:\n        result = P[Rx][Ry][Rz] - P[Lx - 1][Ry][Rz] - P[Rx][Ly - 1][Rz] - P[Rx][Ry][Lz - 1] + P[Lx - 1][Ly - 1][Rz] + P[Lx - 1][Ry][Lz - 1] + P[Rx][Ly - 1][Lz - 1] - P[Lx - 1][Ly - 1][Lz - 1]\n        results.append(result)\n\n    # Print the results\n    for result in results:\n        print(result)\n\n# Call the function to process queries\nprocess_queries()"], "passed": [false, false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    # Create a 3D list to store the input values\n    A = [[[0] * (N + 1) for _ in range(N + 1)] for _ in range(N + 1)]\n    for x in range(1, N + 1):\n        for y in range(1, N + 1):\n            A[x][y][1] = int(data[index])\n            index += 1\n    \n    # Compute the prefix sums for the 3D grid\n    for x in range(1, N + 1):\n        for y in range(1, N + 1):\n            for z in range(2, N + 1):\n                A[x][y][z] += A[x][y][z - 1]\n    \n    for y in range(1, N + 1):\n        for z in range(1, N + 1):\n            for x in range(2, N + 1):\n                A[x][y][z] += A[x - 1][y][z]\n    \n    for z in range(1, N + 1):\n        for x in range(1, N + 1):\n            for y in range(2, N + 1):\n                A[x][y][z] += A[x][y - 1][z]\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, data[index:index + 6])\n        index += 6\n        \n        # Use the prefix sums to compute the range sum\n        result = A[Rx][Ry][Rz]\n        if Lx > 1:\n            result -= A[Lx - 1][Ry][Rz]\n        if Ly > 1:\n            result -= A[Rx][Ly - 1][Rz]\n        if Lz > 1:\n            result -= A[Rx][Ry][Lz - 1]\n        if Lx > 1 and Ly > 1:\n            result += A[Lx - 1][Ly - 1][Rz]\n        if Lx > 1 and Lz > 1:\n            result += A[Lx - 1][Ry][Lz - 1]\n        if Ly > 1 and Lz > 1:\n            result += A[Rx][Ly - 1][Lz - 1]\n        if Lx > 1 and Ly > 1 and Lz > 1:\n            result -= A[Lx - 1][Ly - 1][Lz - 1]\n        \n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nmain()", "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read input parameters\n    N = int(data[0])\n    index = 1\n    A = [[[int(data[index + z * N * N + y * N + x]) for x in range(N)] for y in range(N)] for z in range(N)]\n    Q = int(data[index + N * N * N])\n    index += N * N * N + 1\n    queries = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, data[index:index + 6])\n        queries.append((Lx - 1, Rx, Ly - 1, Ry, Lz - 1, Rz))\n        index += 6\n\n    # Create 3D prefix sum array\n    P = [[[0 for _ in range(N + 1)] for _ in range(N + 1)] for _ in range(N + 1)]\n    for x in range(1, N + 1):\n        for y in range(1, N + 1):\n            for z in range(1, N + 1):\n                P[x][y][z] = A[x - 1][y - 1][z - 1] + P[x - 1][y][z] + P[x][y - 1][z] + P[x][y][z - 1] - P[x - 1][y - 1][z] - P[x - 1][y][z - 1] - P[x][y - 1][z - 1] + P[x - 1][y - 1][z - 1]\n\n    # Process each query using the prefix sum array\n    results = []\n    for Lx, Rx, Ly, Ry, Lz, Rz in queries:\n        result = P[Rx][Ry][Rz] - P[Lx - 1][Ry][Rz] - P[Rx][Ly - 1][Rz] - P[Rx][Ry][Lz - 1] + P[Lx - 1][Ly - 1][Rz] + P[Lx - 1][Ry][Lz - 1] + P[Rx][Ly - 1][Lz - 1] - P[Lx - 1][Ly - 1][Lz - 1]\n        results.append(result)\n\n    # Print the results\n    for result in results:\n        print(result)\n\n# Call the function to process queries\nprocess_queries()"]}
{"task_id": "3495", "codes": ["import heapq\n\ndef kthSmallestObstacleDistance(queries, k):\n    heap = []\n    results = []\n    \n    for x, y in queries:\n        distance = abs(x) + abs(y)\n        heapq.heappush(heap, distance)\n        \n        if len(heap) > k:\n            heapq.heappop(heap)\n        \n        if len(heap) < k:\n            results.append(-1)\n        else:\n            results.append(heap[0])\n    \n    return results", "import heapq\n\ndef kthSmallestObstacle(queries, k):\n    # Min-heap to store distances of obstacles from the origin\n    min_heap = []\n    \n    # List to store results\n    results = []\n    \n    for x, y in queries:\n        # Calculate the distance of the obstacle from the origin\n        distance = abs(x) + abs(y)\n        \n        # Add the distance to the min-heap\n        heapq.heappush(min_heap, distance)\n        \n        # If there are fewer than k obstacles, append -1 to results\n        if len(min_heap) < k:\n            results.append(-1)\n        else:\n            # Pop the smallest k-1 elements to get the k-th smallest element\n            for _ in range(k - 1):\n                heapq.heappop(min_heap)\n            # Append the k-th smallest element to results\n            results.append(min_heap[0])\n    \n    return results"], "passed": [false, false], "raw_code": ["```python\nimport heapq\n\ndef kthSmallestObstacleDistance(queries, k):\n    heap = []\n    results = []\n    \n    for x, y in queries:\n        distance = abs(x) + abs(y)\n        heapq.heappush(heap, distance)\n        \n        if len(heap) > k:\n            heapq.heappop(heap)\n        \n        if len(heap) < k:\n            results.append(-1)\n        else:\n            results.append(heap[0])\n    \n    return results\n```", "```python\nimport heapq\n\ndef kthSmallestObstacle(queries, k):\n    # Min-heap to store distances of obstacles from the origin\n    min_heap = []\n    \n    # List to store results\n    results = []\n    \n    for x, y in queries:\n        # Calculate the distance of the obstacle from the origin\n        distance = abs(x) + abs(y)\n        \n        # Add the distance to the min-heap\n        heapq.heappush(min_heap, distance)\n        \n        # If there are fewer than k obstacles, append -1 to results\n        if len(min_heap) < k:\n            results.append(-1)\n        else:\n            # Pop the smallest k-1 elements to get the k-th smallest element\n            for _ in range(k - 1):\n                heapq.heappop(min_heap)\n            # Append the k-th smallest element to results\n            results.append(min_heap[0])\n    \n    return results\n```"]}
{"task_id": "3510", "codes": ["def maxTowerSum(maximumHeight):\n    n = len(maximumHeight)\n    unique_heights = set(range(1, n + 1))\n    \n    if len(unique_heights) < n:\n        return -1\n    \n    sorted_heights = sorted(maximumHeight, reverse=True)\n    current_sum = 0\n    \n    for i in range(n):\n        if sorted_heights[i] >= next(iter(unique_heights)):\n            current_sum += next(iter(unique_heights))\n            unique_heights.remove(next(iter(unique_heights)))\n        else:\n            return -1\n    \n    return current_sum", "def maxTowerHeight(maximumHeight):\n    maximumHeight.sort(reverse=True)\n    used_heights = set()\n    total_sum = 0\n    \n    for mh in maximumHeight:\n        for height in range(1, mh + 1):\n            if height not in used_heights:\n                used_heights.add(height)\n                total_sum += height\n                break\n        else:\n            return -1\n    \n    return total_sum"], "passed": [false, false], "raw_code": ["```python\ndef maxTowerSum(maximumHeight):\n    n = len(maximumHeight)\n    unique_heights = set(range(1, n + 1))\n    \n    if len(unique_heights) < n:\n        return -1\n    \n    sorted_heights = sorted(maximumHeight, reverse=True)\n    current_sum = 0\n    \n    for i in range(n):\n        if sorted_heights[i] >= next(iter(unique_heights)):\n            current_sum += next(iter(unique_heights))\n            unique_heights.remove(next(iter(unique_heights)))\n        else:\n            return -1\n    \n    return current_sum\n```", "```python\ndef maxTowerHeight(maximumHeight):\n    maximumHeight.sort(reverse=True)\n    used_heights = set()\n    total_sum = 0\n    \n    for mh in maximumHeight:\n        for height in range(1, mh + 1):\n            if height not in used_heights:\n                used_heights.add(height)\n                total_sum += height\n                break\n        else:\n            return -1\n    \n    return total_sum\n```"]}
{"final_accuracy": "8.11%"}
