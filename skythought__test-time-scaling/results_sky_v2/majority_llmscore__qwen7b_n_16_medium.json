{"difficulty": "medium", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majority_llmscore__qwen7b_n_16_medium.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3526", "code": "def min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flip_row(row):\n        return [1 - cell for cell in row]\n    \n    def flip_col(col):\n        return [grid[row][col] for row in range(m)][::-1]\n    \n    def count_flips_to_palindrome(arr):\n        flips = 0\n        for i in range(len(arr) // 2):\n            if arr[i] != arr[-(i + 1)]:\n                flips += 1\n        return flips\n    \n    row_flips = sum(count_flips_to_palindrome(row) for row in grid)\n    col_flips = sum(count_flips_to_palindrome(flip_col(col)) for col in range(n))\n    \n    return min(row_flips, col_flips)\n", "passed": true, "raw_code": "def min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    \n    def flip_row(row):\n        return [1 - cell for cell in row]\n    \n    def flip_col(col):\n        return [grid[row][col] for row in range(m)][::-1]\n    \n    def count_flips_to_palindrome(arr):\n        flips = 0\n        for i in range(len(arr) // 2):\n            if arr[i] != arr[-(i + 1)]:\n                flips += 1\n        return flips\n    \n    row_flips = sum(count_flips_to_palindrome(row) for row in grid)\n    col_flips = sum(count_flips_to_palindrome(flip_col(col)) for col in range(n))\n    \n    return min(row_flips, col_flips)\n"}
{"task_id": "3517", "code": "def shortest_path(n, queries):\n    graph = {i: [] for i in range(n)}\n    for i in range(n-1):\n        graph[i].append(i+1)\n    \n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, dist = queue.pop(0)\n            if node == end:\n                return dist\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, dist + 1))\n        return float('inf')\n    \n    result = []\n    current_min = n - 1\n    for u, v in queries:\n        graph[u].append(v)\n        current_min = min(current_min, bfs(0, n-1))\n        result.append(current_min)\n    \n    return result\n", "passed": true, "raw_code": "def shortest_path(n, queries):\n    graph = {i: [] for i in range(n)}\n    for i in range(n-1):\n        graph[i].append(i+1)\n    \n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, dist = queue.pop(0)\n            if node == end:\n                return dist\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, dist + 1))\n        return float('inf')\n    \n    result = []\n    current_min = n - 1\n    for u, v in queries:\n        graph[u].append(v)\n        current_min = min(current_min, bfs(0, n-1))\n        result.append(current_min)\n    \n    return result\n"}
{"task_id": "abc366_c", "code": "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    index = 1\n    \n    # Dictionary to keep track of the count of each number in the bag\n    bag = {}\n    # Set to keep track of unique numbers in the bag for quick lookup\n    unique_numbers = set()\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            x = int(data[index])\n            index += 1\n            if x not in bag:\n                unique_numbers.add(x)\n            bag[x] = bag.get(x, 0) + 1\n        elif query_type == 2:\n            x = int(data[index])\n            index += 1\n            bag[x] -= 1\n            if bag[x] == 0:\n                unique_numbers.remove(x)\n        elif query_type == 3:\n            results.append(len(unique_numbers))\n    \n    for result in results:\n        print(result)\n\n# Call the function to process the queries\nprocess_queries()\n", "passed": false, "raw_code": "def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    index = 1\n    \n    # Dictionary to keep track of the count of each number in the bag\n    bag = {}\n    # Set to keep track of unique numbers in the bag for quick lookup\n    unique_numbers = set()\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            x = int(data[index])\n            index += 1\n            if x not in bag:\n                unique_numbers.add(x)\n            bag[x] = bag.get(x, 0) + 1\n        elif query_type == 2:\n            x = int(data[index])\n            index += 1\n            bag[x] -= 1\n            if bag[x] == 0:\n                unique_numbers.remove(x)\n        elif query_type == 3:\n            results.append(len(unique_numbers))\n    \n    for result in results:\n        print(result)\n\n# Call the function to process the queries\nprocess_queries()\n"}
{"task_id": "abc365_d", "code": "def max_wins():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    S = data[1]\n    \n    # Initialize win count\n    win_count = 0\n    \n    # Keep track of previous Takahashi move\n    previous_takahashi_move = None\n    \n    for i in range(N):\n        aoki_move = S[i]\n        \n        # Determine the best move for Takahashi to avoid losing\n        if aoki_move == 'R':\n            takahashi_move = 'P'\n        elif aoki_move == 'P':\n            takahashi_move = 'S'\n        else:\n            takahashi_move = 'R'\n        \n        # Ensure the move is different from the previous one\n        while takahashi_move == previous_takahashi_move:\n            if takahashi_move == 'R':\n                takahashi_move = 'P'\n            elif takahashi_move == 'P':\n                takahashi_move = 'S'\n            else:\n                takahashi_move = 'R'\n        \n        # Update the previous Takahashi move\n        previous_takahashi_move = takahashi_move\n        \n        # Check if Takahashi wins this game\n        if (takahashi_move == 'R' and aoki_move == 'S') or \\\n           (takahashi_move == 'S' and aoki_move == 'P') or \\\n           (takahashi_move == 'P' and aoki_move == 'R'):\n            win_count += 1\n    \n    # Print the maximum number of games Takahashi could have won\n    print(win_count)\n\n# Call the function to execute\nmax_wins()\n", "passed": false, "raw_code": "def max_wins():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N = int(data[0])\n    S = data[1]\n    \n    # Initialize win count\n    win_count = 0\n    \n    # Keep track of previous Takahashi move\n    previous_takahashi_move = None\n    \n    for i in range(N):\n        aoki_move = S[i]\n        \n        # Determine the best move for Takahashi to avoid losing\n        if aoki_move == 'R':\n            takahashi_move = 'P'\n        elif aoki_move == 'P':\n            takahashi_move = 'S'\n        else:\n            takahashi_move = 'R'\n        \n        # Ensure the move is different from the previous one\n        while takahashi_move == previous_takahashi_move:\n            if takahashi_move == 'R':\n                takahashi_move = 'P'\n            elif takahashi_move == 'P':\n                takahashi_move = 'S'\n            else:\n                takahashi_move = 'R'\n        \n        # Update the previous Takahashi move\n        previous_takahashi_move = takahashi_move\n        \n        # Check if Takahashi wins this game\n        if (takahashi_move == 'R' and aoki_move == 'S') or \\\n           (takahashi_move == 'S' and aoki_move == 'P') or \\\n           (takahashi_move == 'P' and aoki_move == 'R'):\n            win_count += 1\n    \n    # Print the maximum number of games Takahashi could have won\n    print(win_count)\n\n# Call the function to execute\nmax_wins()\n"}
{"task_id": "abc367_d", "code": "def count_pairs(N, M, A):\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    count = 0\n    remainder_count = [0] * M\n    for i in range(N):\n        if prefix_sum[i + 1] % M == 0:\n            count += i + 1\n        else:\n            count += remainder_count[prefix_sum[i + 1] % M]\n        remainder_count[prefix_sum[i + 1] % M] += 1\n    \n    return count\n\n# Example usage:\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nresult = count_pairs(N, M, A)\nprint(result)\n", "passed": false, "raw_code": "def count_pairs(N, M, A):\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + A[i - 1]\n    \n    count = 0\n    remainder_count = [0] * M\n    for i in range(N):\n        if prefix_sum[i + 1] % M == 0:\n            count += i + 1\n        else:\n            count += remainder_count[prefix_sum[i + 1] % M]\n        remainder_count[prefix_sum[i + 1] % M] += 1\n    \n    return count\n\n# Example usage:\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nresult = count_pairs(N, M, A)\nprint(result)\n"}
{"difficulty": "medium", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majority_llmscore__qwen7b_n_16_medium.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3525", "code": "def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp = [[0, 0, 0, 0] for _ in range(n)]\n    \n    # Initialize the DP array for the first hour\n    dp[0][0] = energyDrinkA[0]  # Start with energy drink A\n    dp[0][1] = energyDrinkB[0]  # Start with energy drink B\n    dp[0][2] = 0  # Switch from A to B after the first hour\n    dp[0][3] = 0  # Switch from B to A after the first hour\n    \n    for i in range(1, n):\n        # Continue with energy drink A\n        dp[i][0] = max(dp[i-1][0] + energyDrinkA[i], dp[i-1][2])\n        # Continue with energy drink B\n        dp[i][1] = max(dp[i-1][1] + energyDrinkB[i], dp[i-1][3])\n        # Switch from A to B after the current hour\n        dp[i][2] = dp[i-1][0]\n        # Switch from B to A after the current hour\n        dp[i][3] = dp[i-1][1]\n    \n    # The maximum energy boost is the maximum value in the last row of the DP table\n    return max(max(dp[n-1][0], dp[n-1][1]), max(dp[n-1][2], dp[n-1][3]))\n", "passed": false, "raw_code": "def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp = [[0, 0, 0, 0] for _ in range(n)]\n    \n    # Initialize the DP array for the first hour\n    dp[0][0] = energyDrinkA[0]  # Start with energy drink A\n    dp[0][1] = energyDrinkB[0]  # Start with energy drink B\n    dp[0][2] = 0  # Switch from A to B after the first hour\n    dp[0][3] = 0  # Switch from B to A after the first hour\n    \n    for i in range(1, n):\n        # Continue with energy drink A\n        dp[i][0] = max(dp[i-1][0] + energyDrinkA[i], dp[i-1][2])\n        # Continue with energy drink B\n        dp[i][1] = max(dp[i-1][1] + energyDrinkB[i], dp[i-1][3])\n        # Switch from A to B after the current hour\n        dp[i][2] = dp[i-1][0]\n        # Switch from B to A after the current hour\n        dp[i][3] = dp[i-1][1]\n    \n    # The maximum energy boost is the maximum value in the last row of the DP table\n    return max(max(dp[n-1][0], dp[n-1][1]), max(dp[n-1][2], dp[n-1][3]))\n"}
{"task_id": "abc373_c", "code": "def max_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    \n    max_a = max(A)\n    max_b = max(B)\n    \n    print(max_a + max_b)\n\n# Call the function to run\nmax_sum()\n", "passed": true, "raw_code": "def max_sum():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    \n    max_a = max(A)\n    max_b = max(B)\n    \n    print(max_a + max_b)\n\n# Call the function to run\nmax_sum()\n"}
{"difficulty": "medium", "num_threads": 16, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/majority_llmscore__qwen7b_n_16_medium.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "gpt-4o-mini", "num_test_suites": 1, "api_name": "Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": false, "no_dspy_gen": true, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "3534", "code": "def count_almost_equal_pairs(nums):\n    def can_be_made_equal(x, y):\n        str_x, str_y = str(x), str(y)\n        if len(str_x) != len(str_y):\n            return False\n        diff_count = sum(1 for a, b in zip(str_x, str_y) if a != b)\n        if diff_count == 0:\n            return True\n        elif diff_count == 2:\n            return sorted(str_x) == sorted(str_y)\n        else:\n            return False\n\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_be_made_equal(nums[i], nums[j]):\n                count += 1\n    return count\n", "passed": false, "raw_code": "def count_almost_equal_pairs(nums):\n    def can_be_made_equal(x, y):\n        str_x, str_y = str(x), str(y)\n        if len(str_x) != len(str_y):\n            return False\n        diff_count = sum(1 for a, b in zip(str_x, str_y) if a != b)\n        if diff_count == 0:\n            return True\n        elif diff_count == 2:\n            return sorted(str_x) == sorted(str_y)\n        else:\n            return False\n\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if can_be_made_equal(nums[i], nums[j]):\n                count += 1\n    return count\n"}
{"task_id": "3495", "code": "import heapq\n\ndef kthObstacleDistance(queries, k):\n    # Priority queue to store distances and coordinates\n    max_heap = []\n    results = []\n    # Set to keep track of unique obstacles\n    obstacles = set()\n    \n    for x, y in queries:\n        # Calculate the Manhattan distance from the origin\n        distance = abs(x) + abs(y)\n        # Create a unique identifier for the obstacle\n        obstacle_key = (x, y)\n        \n        # Add the new obstacle to the heap\n        heapq.heappush(max_heap, (-distance, obstacle_key))\n        \n        # Remove obstacles that are further from the origin than the kth obstacle\n        while len(max_heap) > k:\n            _, farthest = heapq.heappop(max_heap)\n            if farthest in obstacles:\n                obstacles.remove(farthest)\n        \n        # Add the obstacle to the set\n        obstacles.add(obstacle_key)\n        \n        # If there are less than k obstacles, return -1\n        if len(obstacles) < k:\n            results.append(-1)\n        else:\n            # The kth obstacle is the farthest obstacle in the heap\n            farthest_distance, _ = max_heap[0]\n            results.append(-farthest_distance)\n    \n    return results\n", "passed": true, "raw_code": "import heapq\n\ndef kthObstacleDistance(queries, k):\n    # Priority queue to store distances and coordinates\n    max_heap = []\n    results = []\n    # Set to keep track of unique obstacles\n    obstacles = set()\n    \n    for x, y in queries:\n        # Calculate the Manhattan distance from the origin\n        distance = abs(x) + abs(y)\n        # Create a unique identifier for the obstacle\n        obstacle_key = (x, y)\n        \n        # Add the new obstacle to the heap\n        heapq.heappush(max_heap, (-distance, obstacle_key))\n        \n        # Remove obstacles that are further from the origin than the kth obstacle\n        while len(max_heap) > k:\n            _, farthest = heapq.heappop(max_heap)\n            if farthest in obstacles:\n                obstacles.remove(farthest)\n        \n        # Add the obstacle to the set\n        obstacles.add(obstacle_key)\n        \n        # If there are less than k obstacles, return -1\n        if len(obstacles) < k:\n            results.append(-1)\n        else:\n            # The kth obstacle is the farthest obstacle in the heap\n            farthest_distance, _ = max_heap[0]\n            results.append(-farthest_distance)\n    \n    return results\n"}
{"task_id": "abc367_c", "code": "import sys\n\ndef generate_sequences(N, K, R):\n    def backtrack(seq):\n        if len(seq) == N:\n            if sum(seq) % K == 0:\n                print(' '.join(map(str, seq)))\n            return\n        \n        for num in range(1, R[len(seq)] + 1):\n            seq.append(num)\n            backtrack(seq)\n            seq.pop()\n\n    backtrack([])\n\n# Read input from stdin\ninput_data = sys.stdin.read().split()\nN = int(input_data[0])\nK = int(input_data[1])\nR = list(map(int, input_data[2:]))\n\ngenerate_sequences(N, K, R)\n", "passed": true, "raw_code": "import sys\n\ndef generate_sequences(N, K, R):\n    def backtrack(seq):\n        if len(seq) == N:\n            if sum(seq) % K == 0:\n                print(' '.join(map(str, seq)))\n            return\n        \n        for num in range(1, R[len(seq)] + 1):\n            seq.append(num)\n            backtrack(seq)\n            seq.pop()\n\n    backtrack([])\n\n# Read input from stdin\ninput_data = sys.stdin.read().split()\nN = int(input_data[0])\nK = int(input_data[1])\nR = list(map(int, input_data[2:]))\n\ngenerate_sequences(N, K, R)\n"}
{"task_id": "3485", "code": "def maximize_score(start, d):\n    # Sort the start array\n    start.sort()\n    \n    # Initialize the maximum score to a very small number\n    max_score = 0\n    \n    # Calculate the score for each possible chosen integer\n    for i in range(len(start)):\n        # Calculate the two potential integers for the current interval\n        low = start[i] - d\n        high = start[i] + d\n        \n        # Calculate the score for choosing the higher integer\n        score = high - low\n        \n        # Update the maximum score if the current score is higher\n        if score > max_score:\n            max_score = score\n    \n    # Return the maximum possible score\n    return max_score\n", "passed": false, "raw_code": "def maximize_score(start, d):\n    # Sort the start array\n    start.sort()\n    \n    # Initialize the maximum score to a very small number\n    max_score = 0\n    \n    # Calculate the score for each possible chosen integer\n    for i in range(len(start)):\n        # Calculate the two potential integers for the current interval\n        low = start[i] - d\n        high = start[i] + d\n        \n        # Calculate the score for choosing the higher integer\n        score = high - low\n        \n        # Update the maximum score if the current score is higher\n        if score > max_score:\n            max_score = score\n    \n    # Return the maximum possible score\n    return max_score\n"}
