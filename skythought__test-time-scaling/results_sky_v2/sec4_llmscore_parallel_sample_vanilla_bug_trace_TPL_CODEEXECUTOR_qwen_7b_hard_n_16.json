{"difficulty": "hard", "num_threads": 32, "temperature": 0.7, "n": 16, "context": "all", "selection": "generated_tests_majority_llm", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_llmscore_parallel_sample_vanilla_bug_trace_TPL_CODEEXECUTOR_qwen_7b_hard_n_16.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc368_f", "code": "def determine_winner(N, A):\n    # Count the number of elements greater than 1\n    count_greater_than_1 = sum(1 for num in A if num > 1)\n    \n    # If the count is odd, Anna wins; otherwise, Bruno wins\n    if count_greater_than_1 % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Print the result\nprint(determine_winner(N, A))", "passed": false, "raw_code": "```python\ndef determine_winner(N, A):\n    # Count the number of elements greater than 1\n    count_greater_than_1 = sum(1 for num in A if num > 1)\n    \n    # If the count is odd, Anna wins; otherwise, Bruno wins\n    if count_greater_than_1 % 2 == 1:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Print the result\nprint(determine_winner(N, A))\n```"}
{"task_id": "abc366_f", "code": "def max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    functions = []\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    # Apply the functions sequentially to the initial value of 1\n    result = 1\n    for A, B in functions[:K]:\n        result = A * result + B\n    \n    print(result)\n\nmax_nested_function_value()", "passed": false, "raw_code": "```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    K = int(data[index + 1])\n    index += 2\n    \n    functions = []\n    for _ in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by A in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    # Apply the functions sequentially to the initial value of 1\n    result = 1\n    for A, B in functions[:K]:\n        result = A * result + B\n    \n    print(result)\n\nmax_nested_function_value()\n```"}
{"task_id": "abc365_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Compute prefix XOR array\n    prefix_xor = [0] * N\n    prefix_xor[0] = A[0]\n    for i in range(1, N):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i]\n\n    total_sum = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if i == 0:\n                xor_value = prefix_xor[j]\n            else:\n                xor_value = prefix_xor[j] ^ prefix_xor[i - 1]\n            total_sum += xor_value\n\n    print(total_sum)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n\n    # Compute prefix XOR array\n    prefix_xor = [0] * N\n    prefix_xor[0] = A[0]\n    for i in range(1, N):\n        prefix_xor[i] = prefix_xor[i - 1] ^ A[i]\n\n    total_sum = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if i == 0:\n                xor_value = prefix_xor[j]\n            else:\n                xor_value = prefix_xor[j] ^ prefix_xor[i - 1]\n            total_sum += xor_value\n\n    print(total_sum)\n\nmain()\n```"}
{"task_id": "arc181_c", "code": "def can_place(grid, row, col, num):\n    for i in range(row):\n        if grid[i][col] > str(num):\n            return False\n    for j in range(col):\n        if grid[row][j] > str(num):\n            return False\n    return True\n\ndef fill_grid(grid, row, col, P, Q, pos):\n    if row == len(grid):\n        return True\n    \n    if col == len(grid):\n        return fill_grid(grid, row + 1, 0, P, Q, pos)\n    \n    for num in [0, 1]:\n        if can_place(grid, row, col, num):\n            grid[row][col] = str(num)\n            if fill_grid(grid, row, col + 1, P, Q, pos + 1):\n                return True\n            grid[row][col] = ' '\n    \n    return False\n\ndef solve(N, P, Q):\n    grid = [[' ' for _ in range(N)] for _ in range(N)]\n    if fill_grid(grid, 0, 0, P, Q, 0):\n        return '\\n'.join(''.join(row) for row in grid)\n    return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    Q = list(map(int, data[N+1:2*N+1]))\n    \n    result = solve(N, P, Q)\n    if result:\n        print(result)\n    else:\n        print(\"No solution\")\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef can_place(grid, row, col, num):\n    for i in range(row):\n        if grid[i][col] > str(num):\n            return False\n    for j in range(col):\n        if grid[row][j] > str(num):\n            return False\n    return True\n\ndef fill_grid(grid, row, col, P, Q, pos):\n    if row == len(grid):\n        return True\n    \n    if col == len(grid):\n        return fill_grid(grid, row + 1, 0, P, Q, pos)\n    \n    for num in [0, 1]:\n        if can_place(grid, row, col, num):\n            grid[row][col] = str(num)\n            if fill_grid(grid, row, col + 1, P, Q, pos + 1):\n                return True\n            grid[row][col] = ' '\n    \n    return False\n\ndef solve(N, P, Q):\n    grid = [[' ' for _ in range(N)] for _ in range(N)]\n    if fill_grid(grid, 0, 0, P, Q, 0):\n        return '\\n'.join(''.join(row) for row in grid)\n    return None\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    Q = list(map(int, data[N+1:2*N+1]))\n    \n    result = solve(N, P, Q)\n    if result:\n        print(result)\n    else:\n        print(\"No solution\")\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc367_f", "code": "def can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        sub_A = A[l_i:r_i + 1]\n        sub_B = B[L_i:R_i + 1]\n        \n        if sorted(sub_A) == sorted(sub_B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()", "passed": false, "raw_code": "```python\ndef can_rearrange_subsequences():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    A = list(map(int, data[index:index + N]))\n    B = list(map(int, data[index + N:index + 2 * N]))\n    index += 2 * N\n    \n    results = []\n    \n    for _ in range(Q):\n        l_i = int(data[index]) - 1\n        r_i = int(data[index + 1]) - 1\n        L_i = int(data[index + 2]) - 1\n        R_i = int(data[index + 3]) - 1\n        index += 4\n        \n        sub_A = A[l_i:r_i + 1]\n        sub_B = B[L_i:R_i + 1]\n        \n        if sorted(sub_A) == sorted(sub_B):\n            results.append(\"Yes\")\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\ncan_rearrange_subsequences()\n```"}
{"task_id": "3535", "code": "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def countNonDecreasing(num):\n        dp = [0] * (num + 1)\n        dp[0] = 1\n        for i in range(1, num + 1):\n            for j in range(i):\n                dp[i] += dp[j]\n                dp[i] %= MOD\n        return dp[num]\n    \n    def countNonIncreasing(num):\n        dp = [0] * (num + 1)\n        dp[0] = 1\n        for i in range(1, num + 1):\n            for j in range(i):\n                dp[i] += dp[j]\n                dp[i] %= MOD\n        return dp[num]\n    \n    result = 0\n    for num in nums:\n        result += (countNonDecreasing(num) * countNonIncreasing(num)) % MOD\n        result %= MOD\n    \n    return result", "passed": false, "raw_code": "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def countNonDecreasing(num):\n        dp = [0] * (num + 1)\n        dp[0] = 1\n        for i in range(1, num + 1):\n            for j in range(i):\n                dp[i] += dp[j]\n                dp[i] %= MOD\n        return dp[num]\n    \n    def countNonIncreasing(num):\n        dp = [0] * (num + 1)\n        dp[0] = 1\n        for i in range(1, num + 1):\n            for j in range(i):\n                dp[i] += dp[j]\n                dp[i] %= MOD\n        return dp[num]\n    \n    result = 0\n    for num in nums:\n        result += (countNonDecreasing(num) * countNonIncreasing(num)) % MOD\n        result %= MOD\n    \n    return result\n```"}
{"task_id": "abc366_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    # Sort points by x-coordinate, then by y-coordinate\n    points.sort(key=lambda p: (p[0], p[1]))\n    \n    def count_pairs(points, D):\n        ans = 0\n        left = 0\n        right = 0\n        \n        for x, y in points:\n            while right < len(points) and abs(points[right][0] - x) <= D:\n                right += 1\n            \n            while left < right and points[left][0] < x - D:\n                left += 1\n            \n            ans += max(0, min(right, len(points)) - left)\n        \n        return ans\n    \n    # Count pairs for x-axis\n    ans_x = count_pairs(points, D)\n    \n    # Rotate points by 90 degrees and repeat the process\n    rotated_points = [(y, -x) for x, y in points]\n    rotated_points.sort(key=lambda p: (p[0], p[1]))\n    ans_y = count_pairs(rotated_points, D)\n    \n    # Total number of valid pairs\n    print(ans_x + ans_y)\n\nmain()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    D = int(data[index + 1])\n    index += 2\n    \n    points = []\n    for _ in range(N):\n        x = int(data[index])\n        y = int(data[index + 1])\n        points.append((x, y))\n        index += 2\n    \n    # Sort points by x-coordinate, then by y-coordinate\n    points.sort(key=lambda p: (p[0], p[1]))\n    \n    def count_pairs(points, D):\n        ans = 0\n        left = 0\n        right = 0\n        \n        for x, y in points:\n            while right < len(points) and abs(points[right][0] - x) <= D:\n                right += 1\n            \n            while left < right and points[left][0] < x - D:\n                left += 1\n            \n            ans += max(0, min(right, len(points)) - left)\n        \n        return ans\n    \n    # Count pairs for x-axis\n    ans_x = count_pairs(points, D)\n    \n    # Rotate points by 90 degrees and repeat the process\n    rotated_points = [(y, -x) for x, y in points]\n    rotated_points.sort(key=lambda p: (p[0], p[1]))\n    ans_y = count_pairs(rotated_points, D)\n    \n    # Total number of valid pairs\n    print(ans_x + ans_y)\n\nmain()\n```"}
{"task_id": "arc181_b", "code": "def f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    currentIndex = 1\n    for _ in range(t):\n        S = data[currentIndex]\n        X = data[currentIndex + 1]\n        Y = data[currentIndex + 2]\n        currentIndex += 3\n        \n        seen = {}\n        \n        for i in range(len(X)):\n            pattern = X[:i] + Y[i:]\n            if pattern not in seen:\n                seen[pattern] = f(S, \"\", pattern)\n            \n            if seen[pattern] == f(S, \"\", X[:i] + Y[i:]):\n                results.append(\"Yes\")\n                break\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()", "passed": false, "raw_code": "```python\ndef f(S, T, X):\n    result = \"\"\n    for char in X:\n        if char == '0':\n            result += S\n        else:\n            result += T\n    return result\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    currentIndex = 1\n    for _ in range(t):\n        S = data[currentIndex]\n        X = data[currentIndex + 1]\n        Y = data[currentIndex + 2]\n        currentIndex += 3\n        \n        seen = {}\n        \n        for i in range(len(X)):\n            pattern = X[:i] + Y[i:]\n            if pattern not in seen:\n                seen[pattern] = f(S, \"\", pattern)\n            \n            if seen[pattern] == f(S, \"\", X[:i] + Y[i:]):\n                results.append(\"Yes\")\n                break\n        else:\n            results.append(\"No\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n```"}
{"task_id": "abc371_g", "code": "d", "passed": false, "raw_code": "```python\ndef find(parent, i):\n    if parent[i] != i:\n        parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    \n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef min_lexicographical_array(N, P, A):\n    parent = list(range(N))\n    rank = [0] * N\n    \n    # Identify cycles using union-find\n    for i in range(N):\n        union(parent, rank, i, P[i] - 1)\n    \n    # Create a dictionary to store elements in each cycle\n    cycle_dict = {}\n    for i in range(N):\n        root = find(parent, i)\n        if root not in cycle_dict:\n            cycle_dict[root] = []\n        cycle_dict[root].append(A[i])\n    \n    # Sort each cycle\n    for cycle in cycle_dict.values():\n        cycle.sort()\n    \n    # Reconstruct the array with sorted elements\n    result = [0] * N\n    for i in range(N):\n        root = find(parent, i)\n        result[i] = cycle_dict[root].pop(0)\n    \n    return ' '.join(map(str, result))\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nP = list(map(int, data[1:N+1]))\nA = list(map(int, data[N+1:]))\n\n# Get the minimum lexicographical array\nprint(min_lexicographical_array(N, P, A))"}
{"task_id": "abc367_e", "code": "def process_sequence(N, K, X, A):\n    # Determine the effective number of operations\n    effective_operations = K % N\n    \n    # Perform the operation the determined number of times\n    for _ in range(effective_operations):\n        A = [A[X[i] - 1] for i in range(N)]\n    \n    # Print the resulting sequence\n    print(\" \".join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Process the sequence\nprocess_sequence(N, K, X, A)", "passed": false, "raw_code": "```python\ndef process_sequence(N, K, X, A):\n    # Determine the effective number of operations\n    effective_operations = K % N\n    \n    # Perform the operation the determined number of times\n    for _ in range(effective_operations):\n        A = [A[X[i] - 1] for i in range(N)]\n    \n    # Print the resulting sequence\n    print(\" \".join(map(str, A)))\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nK = int(data[1])\nX = list(map(int, data[2:N+2]))\nA = list(map(int, data[N+2:]))\n\n# Process the sequence\nprocess_sequence(N, K, X, A)\n```"}
{"task_id": "abc371_f", "code": "def min_movements(N, X, Q, T, G):\n    # Sort the initial positions of the people\n    X.sort()\n\n    # Initialize variables to store the total movements and the current position index\n    total_moves = 0\n    pos_index = 0\n\n    # Process each task\n    for t, g in zip(T, G):\n        # Find the position of the person who needs to move\n        while pos_index < N and X[pos_index] != X[t - 1]:\n            pos_index += 1\n\n        # Calculate the distance to the target position\n        distance = abs(X[t - 1] - g)\n\n        # Add the distance to the total movements\n        total_moves += distance\n\n        # Move to the next person\n        pos_index += 1\n\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input data\nN = int(data[0])\nX = list(map(int, data[1:N + 1]))\nQ = int(data[N + 1])\nT = [int(data[N + 2 + 2 * i]) for i in range(Q)]\nG = [int(data[N + 3 + 2 * i]) for i in range(Q)]\n\n# Call the function and print the result\nprint(min_movements(N, X, Q, T, G))", "passed": false, "raw_code": "def min_movements(N, X, Q, T, G):\n    # Sort the initial positions of the people\n    X.sort()\n\n    # Initialize variables to store the total movements and the current position index\n    total_moves = 0\n    pos_index = 0\n\n    # Process each task\n    for t, g in zip(T, G):\n        # Find the position of the person who needs to move\n        while pos_index < N and X[pos_index] != X[t - 1]:\n            pos_index += 1\n\n        # Calculate the distance to the target position\n        distance = abs(X[t - 1] - g)\n\n        # Add the distance to the total movements\n        total_moves += distance\n\n        # Move to the next person\n        pos_index += 1\n\n    return total_moves\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input data\nN = int(data[0])\nX = list(map(int, data[1:N + 1]))\nQ = int(data[N + 1])\nT = [int(data[N + 2 + 2 * i]) for i in range(Q)]\nG = [int(data[N + 3 + 2 * i]) for i in range(Q)]\n\n# Call the function and print the result\nprint(min_movements(N, X, Q, T, G))"}
{"task_id": "abc368_e", "code": "def solve_train_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X_1 = int(data[index + 2])\n    index += 3\n    \n    trains = []\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        trains.append((A, B, S, T))\n        index += 4\n    \n    # Sort trains by their arrival time\n    trains.sort(key=lambda x: x[3])\n    \n    # Initialize delays\n    delays = [0] * M\n    delays[0] = X_1\n    \n    for i in range(1, M):\n        A, B, S, T = trains[i]\n        for j in range(i):\n            if trains[j][1] == A and trains[j][3] <= S:\n                delays[i] = max(delays[i], delays[j] + S - T)\n    \n    # Print the result\n    print(' '.join(map(str, delays[1:])))\n\n# Call the function\nsolve_train_delays()", "passed": false, "raw_code": "```python\ndef solve_train_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X_1 = int(data[index + 2])\n    index += 3\n    \n    trains = []\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        trains.append((A, B, S, T))\n        index += 4\n    \n    # Sort trains by their arrival time\n    trains.sort(key=lambda x: x[3])\n    \n    # Initialize delays\n    delays = [0] * M\n    delays[0] = X_1\n    \n    for i in range(1, M):\n        A, B, S, T = trains[i]\n        for j in range(i):\n            if trains[j][1] == A and trains[j][3] <= S:\n                delays[i] = max(delays[i], delays[j] + S - T)\n    \n    # Print the result\n    print(' '.join(map(str, delays[1:])))\n\n# Call the function\nsolve_train_delays()\n```"}
{"task_id": "3532", "code": "def minTimeToMarkNodes(edges):\n    def bfs(start):\n        queue = [(start, 0)]\n        visited = {start}\n        while queue:\n            node, time = queue.pop(0)\n            times[node] = max(times[node], time)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if node % 2 == 0:\n                        queue.append((neighbor, time + 2))\n                    else:\n                        queue.append((neighbor, time + 1))\n\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    times = [0] * n\n    for i in range(n):\n        bfs(i)\n    \n    return times", "passed": false, "raw_code": "```python\ndef minTimeToMarkNodes(edges):\n    def bfs(start):\n        queue = [(start, 0)]\n        visited = {start}\n        while queue:\n            node, time = queue.pop(0)\n            times[node] = max(times[node], time)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if node % 2 == 0:\n                        queue.append((neighbor, time + 2))\n                    else:\n                        queue.append((neighbor, time + 1))\n\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    times = [0] * n\n    for i in range(n):\n        bfs(i)\n    \n    return times\n```"}
{"task_id": "abc372_g", "code": "import sys\n\ndef count_valid_pairs(A, B, C):\n    N = len(A)\n    x_min, x_max, y_min, y_max = 0, 10**9, 0, 10**9\n    \n    for i in range(N):\n        if A[i] != 0:\n            x_max = min(x_max, (C[i] - 1) // A[i])\n        if B[i] != 0:\n            y_max = min(y_max, (C[i] - 1) // B[i])\n    \n    count = 0\n    for x in range(1, x_max + 1):\n        for y in range(1, y_max + 1):\n            if all(A[i] * x + B[i] * y < C[i] for i in range(N)):\n                count += 1\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\n\ndef count_valid_pairs(A, B, C):\n    N = len(A)\n    x_min, x_max, y_min, y_max = 0, 10**9, 0, 10**9\n    \n    for i in range(N):\n        if A[i] != 0:\n            x_max = min(x_max, (C[i] - 1) // A[i])\n        if B[i] != 0:\n            y_max = min(y_max, (C[i] - 1) // B[i])\n    \n    count = 0\n    for x in range(1, x_max + 1):\n        for y in range(1, y_max + 1):\n            if all(A[i] * x + B[i] * y < C[i] for i in range(N)):\n                count += 1\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = []\n        B = []\n        C = []\n        for i in range(N):\n            A.append(int(data[index]))\n            B.append(int(data[index + 1]))\n            C.append(int(data[index + 2]))\n            index += 3\n        \n        result = count_valid_pairs(A, B, C)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "arc182_d", "code": "def min_operations_to_equalize_sequences(N, M, A, B):\n    min_operations = 0\n    for i in range(N):\n        delta = (B[i] - A[i]) % M\n        min_operations += min(delta, M - delta)\n    return min_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Output the result\nprint(min_operations_to_equalize_sequences(N, M, A, B))", "passed": false, "raw_code": "```python\ndef min_operations_to_equalize_sequences(N, M, A, B):\n    min_operations = 0\n    for i in range(N):\n        delta = (B[i] - A[i]) % M\n        min_operations += min(delta, M - delta)\n    return min_operations\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:N+2]))\nB = list(map(int, data[N+2:]))\n\n# Output the result\nprint(min_operations_to_equalize_sequences(N, M, A, B))\n```"}
{"task_id": "abc370_e", "code": "def count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Adjust K to be within the range of dp indices\n    K += N\n    \n    # Initialize dp table\n    dp = [[0] * (K * 2 + 1) for _ in range(N + 1)]\n    dp[0][K] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(K * 2 + 1):\n            if dp[i-1][j]:\n                # Case 1: Include A[i] in the last subsequence\n                if j + A[i-1] >= 0 and j + A[i-1] <= K * 2:\n                    dp[i][j + A[i-1]] += dp[i-1][j]\n                    dp[i][j + A[i-1]] %= MOD\n                \n                # Case 2: Start a new subsequence\n                dp[i][j] += dp[i-1][j]\n                dp[i][j] %= MOD\n    \n    # Sum up all valid partitions where the last subsequence does not sum to K\n    result = 0\n    for j in range(K * 2 + 1):\n        if j != K:\n            result += dp[N][j]\n            result %= MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))", "passed": false, "raw_code": "```python\ndef count_partitions(N, K, A):\n    MOD = 998244353\n    \n    # Adjust K to be within the range of dp indices\n    K += N\n    \n    # Initialize dp table\n    dp = [[0] * (K * 2 + 1) for _ in range(N + 1)]\n    dp[0][K] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(K * 2 + 1):\n            if dp[i-1][j]:\n                # Case 1: Include A[i] in the last subsequence\n                if j + A[i-1] >= 0 and j + A[i-1] <= K * 2:\n                    dp[i][j + A[i-1]] += dp[i-1][j]\n                    dp[i][j + A[i-1]] %= MOD\n                \n                # Case 2: Start a new subsequence\n                dp[i][j] += dp[i-1][j]\n                dp[i][j] %= MOD\n    \n    # Sum up all valid partitions where the last subsequence does not sum to K\n    result = 0\n    for j in range(K * 2 + 1):\n        if j != K:\n            result += dp[N][j]\n            result %= MOD\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\n# Print the result\nprint(count_partitions(N, K, A))\n```"}
{"task_id": "abc373_e", "code": "d", "passed": false, "raw_code": "```python\ndef calculate_additional_votes(N, M, K, A):\n    # Convert A to a list of tuples (votes, candidate_index)\n    votes_with_indices = [(A[i], i + 1) for i in range(N)]\n    \n    # Sort the list of tuples by votes in descending order\n    votes_with_indices.sort(reverse=True)\n    \n    # Calculate the threshold for victory\n    threshold = N - M + 1\n    \n    # Initialize the result list\n    result = []\n    \n    # Iterate through each candidate\n    for i in range(N):\n        votes, candidate = votes_with_indices[i]\n        # Calculate the minimum number of additional votes needed\n        if i < threshold:\n            additional_votes = votes_with_indices[threshold - 1][0] - votes + 1\n        else:\n            additional_votes = -1\n        result.append(additional_votes)\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\nA = list(map(int, data[3:]))\n\n# Call the function with the parsed input\ncalculate_additional_votes(N, M, K, A)"}
{"task_id": "3527", "code": "def count_alternating_groups(colors, queries):\n    n = len(colors)\n    \n    def count(size):\n        count = 0\n        for i in range(n):\n            if (i + size) % n < n and all((colors[(i + j) % n] != colors[(i + j + 1) % n]) for j in range(1, size)):\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count(size))\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            colors[index] = color\n    \n    return result", "passed": false, "raw_code": "```python\ndef count_alternating_groups(colors, queries):\n    n = len(colors)\n    \n    def count(size):\n        count = 0\n        for i in range(n):\n            if (i + size) % n < n and all((colors[(i + j) % n] != colors[(i + j + 1) % n]) for j in range(1, size)):\n                count += 1\n        return count\n    \n    result = []\n    for query in queries:\n        if query[0] == 1:\n            size = query[1]\n            result.append(count(size))\n        elif query[0] == 2:\n            index, color = query[1], query[2]\n            colors[index] = color\n    \n    return result\n```"}
{"task_id": "abc372_e", "code": "import heapq\n\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = {}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            \n            if u not in graph:\n                graph[u] = set()\n            if v not in graph:\n                graph[v] = set()\n            \n            graph[u].add(v)\n            graph[v].add(u)\n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            if v not in graph or len(graph[v]) < k:\n                results.append(-1)\n            else:\n                neighbors = list(graph[v])\n                heapq.heapify(neighbors)\n                \n                for _ in range(k - 1):\n                    heapq.heappop(neighbors)\n                \n                results.append(heapq.heappop(neighbors) + 1)\n    \n    for result in results:\n        print(result)\n\nprocess_queries()", "passed": false, "raw_code": "```python\nimport heapq\n\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    Q = int(data[index + 1])\n    index += 2\n    \n    graph = {}\n    \n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        if query_type == 1:\n            u = int(data[index + 1]) - 1\n            v = int(data[index + 2]) - 1\n            index += 3\n            \n            if u not in graph:\n                graph[u] = set()\n            if v not in graph:\n                graph[v] = set()\n            \n            graph[u].add(v)\n            graph[v].add(u)\n        elif query_type == 2:\n            v = int(data[index + 1]) - 1\n            k = int(data[index + 2])\n            index += 3\n            \n            if v not in graph or len(graph[v]) < k:\n                results.append(-1)\n            else:\n                neighbors = list(graph[v])\n                heapq.heapify(neighbors)\n                \n                for _ in range(k - 1):\n                    heapq.heappop(neighbors)\n                \n                results.append(heapq.heappop(neighbors) + 1)\n    \n    for result in results:\n        print(result)\n\nprocess_queries()\n```"}
{"task_id": "abc372_f", "code": "def count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][1] = 1\n    \n    # Read additional edges\n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    # Update dp array based on edges\n    for i in range(1, K + 1):\n        for j in range(1, N + 1):\n            if dp[i - 1][j] == 0:\n                continue\n            # Move along the cycle\n            dp[i][(j % N) + 1] = (dp[i][(j % N) + 1] + dp[i - 1][j]) % MOD\n            # Move along additional edges\n            for x, y in edges:\n                if j == x:\n                    dp[i][y] = (dp[i][y] + dp[i - 1][j]) % MOD\n    \n    # Sum up all possible positions after K moves\n    result = sum(dp[K]) % MOD\n    print(result)\n\ncount_ways()", "passed": false, "raw_code": "```python\ndef count_ways():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    MOD = 998244353\n    \n    # Initialize dp array\n    dp = [[0] * (N + 1) for _ in range(K + 1)]\n    dp[0][1] = 1\n    \n    # Read additional edges\n    edges = []\n    index = 3\n    for _ in range(M):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        edges.append((X, Y))\n        index += 2\n    \n    # Update dp array based on edges\n    for i in range(1, K + 1):\n        for j in range(1, N + 1):\n            if dp[i - 1][j] == 0:\n                continue\n            # Move along the cycle\n            dp[i][(j % N) + 1] = (dp[i][(j % N) + 1] + dp[i - 1][j]) % MOD\n            # Move along additional edges\n            for x, y in edges:\n                if j == x:\n                    dp[i][y] = (dp[i][y] + dp[i - 1][j]) % MOD\n    \n    # Sum up all possible positions after K moves\n    result = sum(dp[K]) % MOD\n    print(result)\n\ncount_ways()\n```"}
{"task_id": "abc367_g", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP tables\n    dp = [[[0] * 2 for _ in range(2)] for _ in range(N + 1)]\n    dp[0][0][0] = 1\n    \n    for i in range(N):\n        for j in range(2):\n            for k in range(2):\n                dp[i + 1][j ^ (A[i] & 1)][k] += dp[i][j][k]\n                dp[i + 1][j][k] += dp[i][j][k]\n                dp[i + 1][j ^ (A[i] & 1)][k] %= MOD\n                dp[i + 1][j][k] %= MOD\n    \n    total_sum = 0\n    for i in range(1 << N):\n        length = bin(i).count('1')\n        if length % M == 0:\n            current_xor = 0\n            for j in range(N):\n                if i & (1 << j):\n                    current_xor ^= A[j]\n            total_sum += pow(current_xor, K, MOD)\n            total_sum %= MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    A = list(map(int, data[3:]))\n    \n    MOD = 998244353\n    \n    # Initialize DP tables\n    dp = [[[0] * 2 for _ in range(2)] for _ in range(N + 1)]\n    dp[0][0][0] = 1\n    \n    for i in range(N):\n        for j in range(2):\n            for k in range(2):\n                dp[i + 1][j ^ (A[i] & 1)][k] += dp[i][j][k]\n                dp[i + 1][j][k] += dp[i][j][k]\n                dp[i + 1][j ^ (A[i] & 1)][k] %= MOD\n                dp[i + 1][j][k] %= MOD\n    \n    total_sum = 0\n    for i in range(1 << N):\n        length = bin(i).count('1')\n        if length % M == 0:\n            current_xor = 0\n            for j in range(N):\n                if i & (1 << j):\n                    current_xor ^= A[j]\n            total_sum += pow(current_xor, K, MOD)\n            total_sum %= MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc371_e", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        for j in range(i, N):\n            if A[j] not in seen:\n                seen.add(A[j])\n                distinct_count += 1\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    total_sum = 0\n    \n    for i in range(N):\n        distinct_count = 0\n        seen = set()\n        \n        for j in range(i, N):\n            if A[j] not in seen:\n                seen.add(A[j])\n                distinct_count += 1\n            total_sum += distinct_count\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc373_g", "code": "i", "passed": false, "raw_code": "```python\nimport heapq\nfrom sys import stdin\n\ndef read_input():\n    data = stdin.read()\n    lines = data.splitlines()\n    N = int(lines[0])\n    points_P = []\n    points_Q = []\n    \n    for i in range(N):\n        A, B = map(int, lines[i + 1].split())\n        points_P.append((A, B))\n    \n    for i in range(N):\n        C, D = map(int, lines[N + 1 + i].split())\n        points_Q.append((C, D))\n    \n    return N, points_P, points_Q\n\ndef find_non_intersecting_permutation(N, points_P, points_Q):\n    # Sort points P by x-coordinate\n    points_P.sort()\n    \n    # Priority queue to store points Q sorted by y-coordinate\n    pq = []\n    \n    # Initialize the result list\n    result = [-1] * N\n    \n    for i in range(N):\n        # Remove points Q below the current point P_i\n        while pq and pq[0][1] < points_P[i][1]:\n            heapq.heappop(pq)\n        \n        if pq:\n            # Get the closest point Q\n            _, index = heapq.heappop(pq)\n            result[index] = i + 1\n        \n        # Add the next point Q to the priority queue\n        heapq.heappush(pq, (points_Q[i][1], i))\n    \n    # Check if all points were matched\n    if -1 in result:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, result))\n\n# Read input\nN, points_P, points_Q = read_input()\n\n# Find the result\nresult = find_non_intersecting_permutation(N, points_P, points_Q)\n\n# Print the result\nprint(result)"}
{"task_id": "arc181_d", "code": "def FenwickTree(n):\n    tree = [0] * (n + 1)\n    \n    def update(index, value):\n        while index <= n:\n            tree[index] += value\n            index += index & -index\n    \n    def query(index):\n        result = 0\n        while index > 0:\n            result += tree[index]\n            index -= index & -index\n        return result\n    \n    return update, query\n\ndef count_inversions(sequence):\n    n = len(sequence)\n    sorted_seq = sorted((value, index) for index, value in enumerate(sequence))\n    update, query = FenwickTree(n)\n    \n    inversion_count = 0\n    visited = [0] * n\n    for value, index in sorted_seq:\n        inversion_count += index - query(index + 1)\n        update(index + 1, 1)\n        visited[index] = 1\n    \n    return inversion_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    inversions = []\n    for a in A:\n        P[:a] = sorted(P[:a])\n        inversions.append(count_inversions(P))\n    \n    for inversion in inversions:\n        print(inversion)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\ndef FenwickTree(n):\n    tree = [0] * (n + 1)\n    \n    def update(index, value):\n        while index <= n:\n            tree[index] += value\n            index += index & -index\n    \n    def query(index):\n        result = 0\n        while index > 0:\n            result += tree[index]\n            index -= index & -index\n        return result\n    \n    return update, query\n\ndef count_inversions(sequence):\n    n = len(sequence)\n    sorted_seq = sorted((value, index) for index, value in enumerate(sequence))\n    update, query = FenwickTree(n)\n    \n    inversion_count = 0\n    visited = [0] * n\n    for value, index in sorted_seq:\n        inversion_count += index - query(index + 1)\n        update(index + 1, 1)\n        visited[index] = 1\n    \n    return inversion_count\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    P = list(map(int, data[1:N+1]))\n    M = int(data[N+1])\n    A = list(map(int, data[N+2:N+2+M]))\n    \n    inversions = []\n    for a in A:\n        P[:a] = sorted(P[:a])\n        inversions.append(count_inversions(P))\n    \n    for inversion in inversions:\n        print(inversion)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc366_g", "code": "import sys\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    adj_list = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        index += 2\n    \n    return N, adj_list\n\ndef dfs(vertex, assigned, adj_list):\n    if vertex == len(adj_list):\n        return True\n    \n    for num in range(1, 2**60):\n        valid = True\n        for neighbor in adj_list[vertex]:\n            if neighbor != vertex and assigned[neighbor] ^ num != 0:\n                valid = False\n                break\n        \n        if valid:\n            assigned[vertex] = num\n            if dfs(vertex + 1, assigned, adj_list):\n                return True\n            assigned[vertex] = None\n    \n    return False\n\ndef main():\n    N, adj_list = read_input()\n    \n    if not adj_list[1]:  # Graph has no edges\n        print(\"Yes\")\n        print(1)\n        return\n    \n    assigned = [None] * (N + 1)\n    \n    if dfs(1, assigned, adj_list):\n        print(\"Yes\")\n        for i in range(1, N + 1):\n            print(assigned[i], end=\" \")\n        print()\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    \n    adj_list = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u = int(data[index])\n        v = int(data[index + 1])\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        index += 2\n    \n    return N, adj_list\n\ndef dfs(vertex, assigned, adj_list):\n    if vertex == len(adj_list):\n        return True\n    \n    for num in range(1, 2**60):\n        valid = True\n        for neighbor in adj_list[vertex]:\n            if neighbor != vertex and assigned[neighbor] ^ num != 0:\n                valid = False\n                break\n        \n        if valid:\n            assigned[vertex] = num\n            if dfs(vertex + 1, assigned, adj_list):\n                return True\n            assigned[vertex] = None\n    \n    return False\n\ndef main():\n    N, adj_list = read_input()\n    \n    if not adj_list[1]:  # Graph has no edges\n        print(\"Yes\")\n        print(1)\n        return\n    \n    assigned = [None] * (N + 1)\n    \n    if dfs(1, assigned, adj_list):\n        print(\"Yes\")\n        for i in range(1, N + 1):\n            print(assigned[i], end=\" \")\n        print()\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "3563", "code": "def maxScore(grid):\n    def backtrack(row, path, used_values, current_sum):\n        if row == len(grid):\n            return current_sum\n        \n        max_score = 0\n        for col in range(len(grid[row])):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                max_score = max(max_score, backtrack(row + 1, path + [grid[row][col]], used_values, current_sum + grid[row][col]))\n                used_values.remove(grid[row][col])\n        \n        return max_score\n    \n    for row in grid:\n        row.sort()\n    \n    return backtrack(0, [], set(), 0)", "passed": false, "raw_code": "```python\ndef maxScore(grid):\n    def backtrack(row, path, used_values, current_sum):\n        if row == len(grid):\n            return current_sum\n        \n        max_score = 0\n        for col in range(len(grid[row])):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                max_score = max(max_score, backtrack(row + 1, path + [grid[row][col]], used_values, current_sum + grid[row][col]))\n                used_values.remove(grid[row][col])\n        \n        return max_score\n    \n    for row in grid:\n        row.sort()\n    \n    return backtrack(0, [], set(), 0)\n```"}
{"task_id": "abc370_f", "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    A += A[:K-1]\n    prefix_sum = [0] * (2*N)\n    for i in range(2*N-1, 0, -1):\n        prefix_sum[i-1] = prefix_sum[i] + A[i-1]\n    dp = [[0] * (K+1) for _ in range(2*N)]\n    for i in range(2*N):\n        dp[i][1] = prefix_sum[i]\n    for k in range(2, K+1):\n        for i in range(2*N-k+1):\n            dp[i][k] = min(max(dp[j][k-1], prefix_sum[i]-prefix_sum[j]) for j in range(i+1, i+k))\n    min_weight = dp[0][K]\n    never_cut = sum(1 for i in range(N) if A[i] + A[i+N] <= min_weight)\n    print(min_weight, never_cut)\n\nif __name__ == '__main__':\n    main()", "passed": false, "raw_code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    A = list(map(int, data[2:]))\n    A += A[:K-1]\n    prefix_sum = [0] * (2*N)\n    for i in range(2*N-1, 0, -1):\n        prefix_sum[i-1] = prefix_sum[i] + A[i-1]\n    dp = [[0] * (K+1) for _ in range(2*N)]\n    for i in range(2*N):\n        dp[i][1] = prefix_sum[i]\n    for k in range(2, K+1):\n        for i in range(2*N-k+1):\n            dp[i][k] = min(max(dp[j][k-1], prefix_sum[i]-prefix_sum[j]) for j in range(i+1, i+k))\n    min_weight = dp[0][K]\n    never_cut = sum(1 for i in range(N) if A[i] + A[i+N] <= min_weight)\n    print(min_weight, never_cut)\n\nif __name__ == '__main__':\n    main()"}
{"task_id": "arc182_e", "code": "def calculate_min_mod_sum(N, M, C, K, A):\n    # Initialize a dictionary to store the frequency of remainders\n    remainder_count = {}\n    \n    # Function to get the minimum remainder for a given k\n    def min_remainder(k):\n        return min((C * k + ai) % M for ai in A)\n    \n    # Calculate the sum of minimum remainders for each k from 0 to K-1\n    total_sum = 0\n    for k in range(K):\n        current_min = min_remainder(k)\n        if current_min in remainder_count:\n            remainder_count[current_min] += 1\n        else:\n            remainder_count[current_min] = 1\n    \n    # Sum up the minimum values from the dictionary\n    for remainder, count in remainder_count.items():\n        total_sum += remainder * count\n    \n    return total_sum\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nC = int(data[2])\nK = int(data[3])\nA = list(map(int, data[4:]))\n\n# Print the result\nprint(calculate_min_mod_sum(N, M, C, K, A))", "passed": false, "raw_code": "```python\ndef calculate_min_mod_sum(N, M, C, K, A):\n    # Initialize a dictionary to store the frequency of remainders\n    remainder_count = {}\n    \n    # Function to get the minimum remainder for a given k\n    def min_remainder(k):\n        return min((C * k + ai) % M for ai in A)\n    \n    # Calculate the sum of minimum remainders for each k from 0 to K-1\n    total_sum = 0\n    for k in range(K):\n        current_min = min_remainder(k)\n        if current_min in remainder_count:\n            remainder_count[current_min] += 1\n        else:\n            remainder_count[current_min] = 1\n    \n    # Sum up the minimum values from the dictionary\n    for remainder, count in remainder_count.items():\n        total_sum += remainder * count\n    \n    return total_sum\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nC = int(data[2])\nK = int(data[3])\nA = list(map(int, data[4:]))\n\n# Print the result\nprint(calculate_min_mod_sum(N, M, C, K, A))\n```"}
{"task_id": "abc373_f", "code": "def max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    items = []\n    \n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for wj in range(W, w - 1, -1):\n            for ki in range(1, min(wj // w, 3000) + 1):\n                dp[wj] = max(dp[wj], dp[wj - ki * w] + ki * v - ki ** 2)\n    \n    print(max(dp))\n\nmax_happiness()", "passed": false, "raw_code": "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    items = []\n    \n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for wj in range(W, w - 1, -1):\n            for ki in range(1, min(wj // w, 3000) + 1):\n                dp[wj] = max(dp[wj], dp[wj - ki * w] + ki * v - ki ** 2)\n    \n    print(max(dp))\n\nmax_happiness()\n```"}
{"task_id": "abc368_d", "code": "def min_vertices_to_include_all_vertices(N, K, edges, V):\n    from collections import defaultdict\n    import sys\n    sys.setrecursionlimit(10**6)\n    \n    # Build the adjacency list\n    graph = defaultdict(list)\n    for A, B in edges:\n        graph[A].append(B)\n        graph[B].append(A)\n    \n    # Memoization dictionary to store results of subproblems\n    memo = {}\n    \n    # DFS function to calculate the minimum number of vertices\n    def dfs(node, parent, visited):\n        if (node, tuple(visited)) in memo:\n            return memo[(node, tuple(visited))]\n        \n        # Initialize the result for the current node\n        result = 0\n        \n        # Check if the current node is one of the K specified vertices\n        if node in V:\n            visited.add(node)\n            result = 1\n        \n        # Traverse all neighbors of the current node\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                result += dfs(neighbor, node, visited)\n        \n        # Memoize the result\n        memo[(node, tuple(visited))] = result\n        return result\n    \n    # Start DFS from node 1 (assuming the tree is connected and starts from node 1)\n    min_vertices = dfs(1, -1, set())\n    \n    return min_vertices\n\n# Example usage\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    edges = []\n    for i in range(N - 1):\n        A = int(data[2 + 2 * i])\n        B = int(data[3 + 2 * i])\n        edges.append((A, B))\n    \n    V = [int(data[2 * (N - 1) + 2 + i]) for i in range(K)]\n    \n    min_vertices = min_vertices_to_include_all_vertices(N, K, edges, V)\n    print(min_vertices)", "passed": false, "raw_code": "```python\ndef min_vertices_to_include_all_vertices(N, K, edges, V):\n    from collections import defaultdict\n    import sys\n    sys.setrecursionlimit(10**6)\n    \n    # Build the adjacency list\n    graph = defaultdict(list)\n    for A, B in edges:\n        graph[A].append(B)\n        graph[B].append(A)\n    \n    # Memoization dictionary to store results of subproblems\n    memo = {}\n    \n    # DFS function to calculate the minimum number of vertices\n    def dfs(node, parent, visited):\n        if (node, tuple(visited)) in memo:\n            return memo[(node, tuple(visited))]\n        \n        # Initialize the result for the current node\n        result = 0\n        \n        # Check if the current node is one of the K specified vertices\n        if node in V:\n            visited.add(node)\n            result = 1\n        \n        # Traverse all neighbors of the current node\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                result += dfs(neighbor, node, visited)\n        \n        # Memoize the result\n        memo[(node, tuple(visited))] = result\n        return result\n    \n    # Start DFS from node 1 (assuming the tree is connected and starts from node 1)\n    min_vertices = dfs(1, -1, set())\n    \n    return min_vertices\n\n# Example usage\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    edges = []\n    for i in range(N - 1):\n        A = int(data[2 + 2 * i])\n        B = int(data[3 + 2 * i])\n        edges.append((A, B))\n    \n    V = [int(data[2 * (N - 1) + 2 + i]) for i in range(K)]\n    \n    min_vertices = min_vertices_to_include_all_vertices(N, K, edges, V)\n    print(min_vertices)\n```"}
{"task_id": "abc369_g", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(N - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        l = int(data[index + 2])\n        edges.append((u, v, l))\n        index += 3\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for u, v, l in edges:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    # Function to find the shortest path from root to all other vertices\n    def dijkstra(root):\n        dist = [float('inf')] * (N + 1)\n        dist[root] = 0\n        pq = [(0, root)]\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]:\n                continue\n            for neighbor, weight in graph[node]:\n                new_dist = d + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, neighbor))\n        return dist\n    \n    # Find the shortest path from vertex 1 to all other vertices\n    dist = dijkstra(1)\n    \n    # Function to find the minimum distance to visit all specified vertices and return to the starting vertex\n    def min_distance_to_visit_all(start, vertices):\n        n = len(vertices)\n        dp = [[float('inf')] * (1 << n) for _ in range(n + 1)]\n        dp[start][0] = 0\n        \n        for mask in range(1 << n):\n            for i in range(n):\n                if mask & (1 << i):\n                    for j in range(n):\n                        if j != i and mask & (1 << j):\n                            new_mask = mask ^ (1 << i) ^ (1 << j)\n                            dp[j][new_mask] = min(dp[j][new_mask], dp[i][mask] + dist[vertices[i]] + dist[vertices[j]])\n        \n        min_dist = float('inf')\n        for i in range(n):\n            if mask & (1 << i):\n                min_dist = min(min_dist, dp[i][mask] + dist[vertices[i]])\n        \n        return min_dist\n    \n    # Find the answer for each K\n    answers = []\n    for K in range(1, N + 1):\n        vertices = [int(data[index]) for index in range((K - 1) * 3 + 1, K * 3 + 1)]\n        answers.append(min_distance_to_visit_all(0, vertices))\n    \n    # Print the answers\n    for answer in answers:\n        print(answer)\n\n# Call the solve function\nsolve()"}
{"task_id": "3550", "code": "def maxSumOfRooks(board):\n    rows, cols = len(board), len(board[0])\n    col_used = [False] * cols\n    result = 0\n    \n    for i in range(rows):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(cols):\n            if not col_used[j] and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        col_used[max_col] = True\n        result += max_val\n    \n    return result", "passed": false, "raw_code": "```python\ndef maxSumOfRooks(board):\n    rows, cols = len(board), len(board[0])\n    col_used = [False] * cols\n    result = 0\n    \n    for i in range(rows):\n        max_val = float('-inf')\n        max_col = -1\n        for j in range(cols):\n            if not col_used[j] and board[i][j] > max_val:\n                max_val = board[i][j]\n                max_col = j\n        col_used[max_col] = True\n        result += max_val\n    \n    return result\n```"}
{"task_id": "3551", "code": "def maximizeXor(nums, queries):\n    # Helper function to insert a number into the trie\n    def insert(num, idx):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n            node['count'] = node.get('count', 0) + 1\n    \n    # Helper function to delete a number from the trie\n    def delete(num, idx):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            node = node[bit]\n            node['count'] = node['count'] - 1\n    \n    # Helper function to find the maximum XOR value for a given number\n    def maxXor(num):\n        node = root\n        maxXor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node and node[1 - bit]['count'] > 0:\n                maxXor |= (1 << i)\n                node = node[1 - bit]\n            else:\n                node = node[bit]\n        return maxXor\n    \n    # Sort queries by the end index to process them in order\n    queries = sorted(queries, key=lambda x: x[1])\n    result = [0] * len(queries)\n    prefix_xor = [0] * (len(nums) + 1)\n    insert(0, -1)\n    \n    i = 0\n    for j, (l, r) in enumerate(queries):\n        # Add elements to the trie that are within the current range\n        while i <= r:\n            insert(prefix_xor[i + 1], i)\n            i += 1\n        # Find the maximum XOR value for the current range\n        result[j] = maxXor(prefix_xor[r + 1] ^ prefix_xor[l])\n        # Remove the element at the start of the current range from the trie\n        delete(prefix_xor[l + 1], l)\n    \n    return result", "passed": false, "raw_code": "```python\ndef maximizeXor(nums, queries):\n    # Helper function to insert a number into the trie\n    def insert(num, idx):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if bit not in node:\n                node[bit] = {}\n            node = node[bit]\n            node['count'] = node.get('count', 0) + 1\n    \n    # Helper function to delete a number from the trie\n    def delete(num, idx):\n        node = root\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            node = node[bit]\n            node['count'] = node['count'] - 1\n    \n    # Helper function to find the maximum XOR value for a given number\n    def maxXor(num):\n        node = root\n        maxXor = 0\n        for i in range(31, -1, -1):\n            bit = (num >> i) & 1\n            if 1 - bit in node and node[1 - bit]['count'] > 0:\n                maxXor |= (1 << i)\n                node = node[1 - bit]\n            else:\n                node = node[bit]\n        return maxXor\n    \n    # Sort queries by the end index to process them in order\n    queries = sorted(queries, key=lambda x: x[1])\n    result = [0] * len(queries)\n    prefix_xor = [0] * (len(nums) + 1)\n    insert(0, -1)\n    \n    i = 0\n    for j, (l, r) in enumerate(queries):\n        # Add elements to the trie that are within the current range\n        while i <= r:\n            insert(prefix_xor[i + 1], i)\n            i += 1\n        # Find the maximum XOR value for the current range\n        result[j] = maxXor(prefix_xor[r + 1] ^ prefix_xor[l])\n        # Remove the element at the start of the current range from the trie\n        delete(prefix_xor[l + 1], l)\n    \n    return result\n```"}
{"task_id": "arc183_b", "code": "d", "passed": false, "raw_code": "```python\ndef find(parent, x):\n    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent,"}
{"task_id": "3531", "code": "def minDamage(power, damage, health):\n    n = len(damage)\n    total_damage = [d * h for d, h in zip(damage, health)]\n    enemies = sorted(range(n), key=lambda x: -total_damage[x])\n    \n    bob_damage = 0\n    current_health = sum(health)\n    \n    for enemy in enemies:\n        if current_health <= 0:\n            break\n        attacks = current_health // power\n        if current_health % power != 0:\n            attacks += 1\n        bob_damage += attacks * damage[enemy]\n        current_health -= attacks * power\n    \n    return bob_damage", "passed": false, "raw_code": "```python\ndef minDamage(power, damage, health):\n    n = len(damage)\n    total_damage = [d * h for d, h in zip(damage, health)]\n    enemies = sorted(range(n), key=lambda x: -total_damage[x])\n    \n    bob_damage = 0\n    current_health = sum(health)\n    \n    for enemy in enemies:\n        if current_health <= 0:\n            break\n        attacks = current_health // power\n        if current_health % power != 0:\n            attacks += 1\n        bob_damage += attacks * damage[enemy]\n        current_health -= attacks * power\n    \n    return bob_damage\n```"}
{"task_id": "arc183_c", "code": "import sys\nfrom itertools import permutations\n\ndef count_valid_permutations(N, M, conditions):\n    count = 0\n    for perm in permutations(range(1, N + 1)):\n        valid = True\n        for L, R, X in conditions:\n            if max(perm[L-1:R]) == perm[X-1]:\n                valid = False\n                break\n        if valid:\n            count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = [(int(data[3*i + 2]), int(data[3*i + 3]), int(data[3*i + 4])) for i in range(M)]\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom itertools import permutations\n\ndef count_valid_permutations(N, M, conditions):\n    count = 0\n    for perm in permutations(range(1, N + 1)):\n        valid = True\n        for L, R, X in conditions:\n            if max(perm[L-1:R]) == perm[X-1]:\n                valid = False\n                break\n        if valid:\n            count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = [(int(data[3*i + 2]), int(data[3*i + 3]), int(data[3*i + 4])) for i in range(M)]\n    \n    result = count_valid_permutations(N, M, conditions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc368_g", "code": "import sys\nfrom itertools import product\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    queries = data[2*N+2:]\n    \n    def preprocess(A, B):\n        max_values = []\n        for i in range(N):\n            max_values.append([])\n            for j in range(N):\n                if i > j:\n                    max_values[-1].append(0)\n                else:\n                    max_values[-1].append(max(A[i:j+1]))\n        return max_values\n    \n    max_values_A = preprocess(A, B)\n    max_values_B = preprocess(B, A)\n    \n    def process_queries(queries):\n        results = []\n        for i in range(Q):\n            query = queries[i*3:(i+1)*3]\n            if query[0] == '3':\n                l = int(query[1])\n                r = int(query[2])\n                if r - l + 1 % 2 == 1:\n                    results.append(max_values_A[l][r])\n                else:\n                    results.append(max_values_B[l][r])\n        return results\n    \n    results = process_queries(queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()", "passed": false, "raw_code": "```python\nimport sys\nfrom itertools import product\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    Q = int(data[2*N+1])\n    queries = data[2*N+2:]\n    \n    def preprocess(A, B):\n        max_values = []\n        for i in range(N):\n            max_values.append([])\n            for j in range(N):\n                if i > j:\n                    max_values[-1].append(0)\n                else:\n                    max_values[-1].append(max(A[i:j+1]))\n        return max_values\n    \n    max_values_A = preprocess(A, B)\n    max_values_B = preprocess(B, A)\n    \n    def process_queries(queries):\n        results = []\n        for i in range(Q):\n            query = queries[i*3:(i+1)*3]\n            if query[0] == '3':\n                l = int(query[1])\n                r = int(query[2])\n                if r - l + 1 % 2 == 1:\n                    results.append(max_values_A[l][r])\n                else:\n                    results.append(max_values_B[l][r])\n        return results\n    \n    results = process_queries(queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"}
{"task_id": "abc369_e", "code": "import sys\nfrom collections import defaultdict\nimport heapq\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    graph = defaultdict(list)\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        t = int(data[index + 2])\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n        index += 3\n    Q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        bridges = list(map(int, data[index:index + K]))\n        index += K\n        queries.append(bridges)\n    INF = float('inf')\n    dp = [[INF] * N for _ in range(1 << M)]\n    dp[0][0] = 0\n    pq = [(0, 0, 0)]\n    while pq:\n        cost, node, mask = heapq.heappop(pq)\n        if dp[mask][node] < cost:\n            continue\n        for neighbor, time in graph[node]:\n            new_mask = mask | (1 << neighbor)\n            new_cost = cost + time\n            if dp[new_mask][neighbor] > new_cost:\n                dp[new_mask][neighbor] = new_cost\n                heapq.heappush(pq, (new_cost, neighbor, new_mask))\n    results = []\n    for bridges in queries:\n        min_time = INF\n        for mask in range(1 << N):\n            if all(mask & (1 << (bridge - 1)) != 0 for bridge in bridges):\n                min_time = min(min_time, dp[mask][N - 1])\n        results.append(str(min_time))\n    print('\\n'.join(results))\nsolve()", "passed": false, "raw_code": "import sys\nfrom collections import defaultdict\nimport heapq\ninput = sys.stdin.read\n\ndef solve():\n    data = input().split()\n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    index += 2\n    graph = defaultdict(list)\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        t = int(data[index + 2])\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n        index += 3\n    Q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(Q):\n        K = int(data[index])\n        index += 1\n        bridges = list(map(int, data[index:index + K]))\n        index += K\n        queries.append(bridges)\n    INF = float('inf')\n    dp = [[INF] * N for _ in range(1 << M)]\n    dp[0][0] = 0\n    pq = [(0, 0, 0)]\n    while pq:\n        cost, node, mask = heapq.heappop(pq)\n        if dp[mask][node] < cost:\n            continue\n        for neighbor, time in graph[node]:\n            new_mask = mask | (1 << neighbor)\n            new_cost = cost + time\n            if dp[new_mask][neighbor] > new_cost:\n                dp[new_mask][neighbor] = new_cost\n                heapq.heappush(pq, (new_cost, neighbor, new_mask))\n    results = []\n    for bridges in queries:\n        min_time = INF\n        for mask in range(1 << N):\n            if all(mask & (1 << (bridge - 1)) != 0 for bridge in bridges):\n                min_time = min(min_time, dp[mask][N - 1])\n        results.append(str(min_time))\n    print('\\n'.join(results))\nsolve()"}
{"task_id": "arc183_d", "code": "i", "passed": false, "raw_code": "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    N = int(sys.stdin.readline().strip())\n    edges = []\n    for _ in range(N - 1):\n        A, B = map(int, sys.stdin.readline().strip().split())\n        edges.append((A, B))\n    return N, edges\n\ndef find_max_distance_edges(N, edges):\n    graph = defaultdict(list)\n    for A, B in edges:\n        graph[A].append(B)\n        graph[B].append(A)\n    \n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        parent = {start: None}\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    parent[neighbor] = current\n                    queue.append(neighbor)\n        return parent\n    \n    longest_path = []\n    for node in range(1, N + 1):\n        parent = bfs(node)\n        leaf = node\n        while parent[leaf] is not None:\n            longest_path.append(leaf)\n            leaf = parent[leaf]\n        longest_path.append(leaf)\n    \n    return longest_path[0], longest_path[-1]\n\ndef main():\n    N, edges = read_input()\n    scores = []\n    while len(edges) > 0:\n        u, v = find_max_distance_edges(N, edges)\n        scores.append((u, v))\n        edges = [(A, B) for A, B in edges if A != u and A != v and B != u and B != v]\n        N -= 2\n    for u, v in scores:\n        print(u, v)\n\nif __name__ == \"__main__\":\n    main()"}
{"task_id": "arc182_a", "code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(Q):\n        p, v = P[i] - 1, V[i]\n        new_dp = [[0] * (N + 1) for _ in range(N + 1)]\n        for j in range(N + 1):\n            for k in range(N + 1):\n                if dp[j][k] == 0:\n                    continue\n                if j <= p:\n                    new_dp[j][max(k, v)] += dp[j][k]\n                    new_dp[j][max(k, v)] %= MOD\n                if j >= p:\n                    new_dp[j][max(k, v)] += dp[j][k]\n                    new_dp[j][max(k, v)] %= MOD\n        dp = new_dp\n\n    return sum(dp[N]) % MOD\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nP = [int(data[2 + 2 * i]) for i in range(Q)]\nV = [int(data[3 + 2 * i]) for i in range(Q)]\n\n# Call the function and print the result\nprint(count_valid_sequences(N, Q, P, V))", "passed": false, "raw_code": "def count_valid_sequences(N, Q, P, V):\n    MOD = 998244353\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n\n    for i in range(Q):\n        p, v = P[i] - 1, V[i]\n        new_dp = [[0] * (N + 1) for _ in range(N + 1)]\n        for j in range(N + 1):\n            for k in range(N + 1):\n                if dp[j][k] == 0:\n                    continue\n                if j <= p:\n                    new_dp[j][max(k, v)] += dp[j][k]\n                    new_dp[j][max(k, v)] %= MOD\n                if j >= p:\n                    new_dp[j][max(k, v)] += dp[j][k]\n                    new_dp[j][max(k, v)] %= MOD\n        dp = new_dp\n\n    return sum(dp[N]) % MOD\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nQ = int(data[1])\nP = [int(data[2 + 2 * i]) for i in range(Q)]\nV = [int(data[3 + 2 * i]) for i in range(Q)]\n\n# Call the function and print the result\nprint(count_valid_sequences(N, Q, P, V))"}
{"task_id": "3575", "code": "def max_value_of_subsequence(nums, k):\n    from itertools import combinations\n    \n    n = len(nums)\n    max_value = 0\n    \n    for subseq in combinations(nums, 2 * k):\n        part1 = 0\n        part2 = 0\n        for i in range(k):\n            part1 |= subseq[i]\n            part2 |= subseq[k + i]\n        max_value = max(max_value, part1 ^ part2)\n    \n    return max_value", "passed": false, "raw_code": "```python\ndef max_value_of_subsequence(nums, k):\n    from itertools import combinations\n    \n    n = len(nums)\n    max_value = 0\n    \n    for subseq in combinations(nums, 2 * k):\n        part1 = 0\n        part2 = 0\n        for i in range(k):\n            part1 |= subseq[i]\n            part2 |= subseq[k + i]\n        max_value = max(max_value, part1 ^ part2)\n    \n    return max_value\n```"}
{"task_id": "3552", "code": "def largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n        return \"0\"\n    \n    if n % 2 == 1:\n        half_length = (n + 1) // 2\n    else:\n        half_length = n // 2\n    \n    for num in range(10**(half_length) - 1, 10**(half_length - 1) - 1, -1):\n        num_str = str(num)\n        if n % 2 == 1:\n            candidate = num_str + num_str[-2::-1]\n        else:\n            candidate = num_str + num_str[::-1]\n        \n        if int(candidate) % k == 0:\n            return candidate\n    \n    return \"0\"", "passed": false, "raw_code": "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        for i in range(9, 0, -1):\n            if i % k == 0:\n                return str(i)\n        return \"0\"\n    \n    if n % 2 == 1:\n        half_length = (n + 1) // 2\n    else:\n        half_length = n // 2\n    \n    for num in range(10**(half_length) - 1, 10**(half_length - 1) - 1, -1):\n        num_str = str(num)\n        if n % 2 == 1:\n            candidate = num_str + num_str[-2::-1]\n        else:\n            candidate = num_str + num_str[::-1]\n        \n        if int(candidate) % k == 0:\n            return candidate\n    \n    return \"0\"\n```"}
{"task_id": "3560", "code": "def min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n\n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves + 1\n\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\n    return float('inf')\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[float('inf')] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            px, py = positions[i]\n            qx, qy = positions[j]\n            dp[i][j] = min(min_moves_to_capture(px, py, qx, qy), min_moves_to_capture(qx, qy, px, py))\n            dp[j][i] = dp[i][j]\n\n    def dfs(i, mask, memo):\n        if mask == 0:\n            return 0\n        if (i, mask) in memo:\n            return memo[(i, mask)]\n\n        max_moves = 0\n        for j in range(n):\n            if mask & (1 << j):\n                new_mask = mask ^ (1 << j)\n                moves = dp[i][j] + dfs(j, new_mask, memo)\n                max_moves = max(max_moves, moves)\n\n        memo[(i, mask)] = max_moves\n        return max_moves\n\n    return dfs(0, (1 << n) - 1, {})", "passed": false, "raw_code": "def min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n\n    while queue:\n        cx, cy, moves = queue.pop(0)\n        if cx == px and cy == py:\n            return moves + 1\n\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\n    return float('inf')\n\ndef max_total_moves(kx, ky, positions):\n    n = len(positions)\n    dp = [[float('inf')] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            px, py = positions[i]\n            qx, qy = positions[j]\n            dp[i][j] = min(min_moves_to_capture(px, py, qx, qy), min_moves_to_capture(qx, qy, px, py))\n            dp[j][i] = dp[i][j]\n\n    def dfs(i, mask, memo):\n        if mask == 0:\n            return 0\n        if (i, mask) in memo:\n            return memo[(i, mask)]\n\n        max_moves = 0\n        for j in range(n):\n            if mask & (1 << j):\n                new_mask = mask ^ (1 << j)\n                moves = dp[i][j] + dfs(j, new_mask, memo)\n                max_moves = max(max_moves, moves)\n\n        memo[(i, mask)] = max_moves\n        return max_moves\n\n    return dfs(0, (1 << n) - 1, {})"}
{"task_id": "3548", "code": "def count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    count = 0\n    half_n = (n + 1) // 2\n    \n    for digits in itertools.product(range(1, 10), repeat=(half_n - 1)):\n        if sum(digits) % k != 0:\n            continue\n        \n        mid_digit = 0\n        if n % 2 == 1:\n            mid_digit = digits[-1]\n        \n        full_number = int(''.join(map(str, digits)) + str(mid_digit) + ''.join(map(str, digits[::-1])))\n        if full_number % k == 0:\n            count += 1\n    \n    return count", "passed": false, "raw_code": "```python\ndef count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    count = 0\n    half_n = (n + 1) // 2\n    \n    for digits in itertools.product(range(1, 10), repeat=(half_n - 1)):\n        if sum(digits) % k != 0:\n            continue\n        \n        mid_digit = 0\n        if n % 2 == 1:\n            mid_digit = digits[-1]\n        \n        full_number = int(''.join(map(str, digits)) + str(mid_digit) + ''.join(map(str, digits[::-1])))\n        if full_number % k == 0:\n            count += 1\n    \n    return count\n```"}
{"task_id": "abc370_g", "code": "MOD = 998244353\n\ndef sum_of_divisors(n):\n    if n == 1:\n        return 1\n    result = 1 + n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    return result\n\ndef is_good(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef count_good_sequences(N, M):\n    if M == 1:\n        return sum(is_good(i) for i in range(1, N + 1)) % MOD\n    \n    dp = [[0] * M for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        if is_good(i):\n            dp[i][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(1, M):\n            dp[i][j] = sum(dp[k][j - 1] for k in range(1, i + 1) if i % k == 0 and is_good(k)) % MOD\n    \n    return dp[N][M - 1]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Output the result\nprint(count_good_sequences(N, M))", "passed": false, "raw_code": "```python\nMOD = 998244353\n\ndef sum_of_divisors(n):\n    if n == 1:\n        return 1\n    result = 1 + n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            result += i\n            if i != n // i:\n                result += n // i\n    return result\n\ndef is_good(n):\n    return sum_of_divisors(n) % 3 == 0\n\ndef count_good_sequences(N, M):\n    if M == 1:\n        return sum(is_good(i) for i in range(1, N + 1)) % MOD\n    \n    dp = [[0] * M for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        if is_good(i):\n            dp[i][0] = 1\n    \n    for i in range(1, N + 1):\n        for j in range(1, M):\n            dp[i][j] = sum(dp[k][j - 1] for k in range(1, i + 1) if i % k == 0 and is_good(k)) % MOD\n    \n    return dp[N][M - 1]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Output the result\nprint(count_good_sequences(N, M))\n```"}
{"task_id": "3580", "code": "def find_almost_equal_substring(s: str, pattern: str) -> int:\n    n = len(s)\n    m = len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1", "passed": false, "raw_code": "```python\ndef find_almost_equal_substring(s: str, pattern: str) -> int:\n    n = len(s)\n    m = len(pattern)\n    \n    for i in range(n - m + 1):\n        diff_count = 0\n        for j in range(m):\n            if s[i + j] != pattern[j]:\n                diff_count += 1\n                if diff_count > 1:\n                    break\n        if diff_count <= 1:\n            return i\n    \n    return -1\n```"}
{"task_id": "arc182_c", "code": "def count_good_sequences(N, M):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    dp[0][1] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            for k in range(1, M + 1):\n                if j * k <= M:\n                    dp[i][j * k] += dp[i - 1][j]\n                    dp[i][j * k] %= MOD\n    \n    # Calculate total number of good sequences and their scores\n    total_sequences = sum(dp[N]) % MOD\n    total_score = 0\n    \n    for j in range(1, M + 1):\n        total_score += dp[N][j] * len([i for i in range(1, j + 1) if j % i == 0])\n        total_score %= MOD\n    \n    return total_score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(count_good_sequences(N, M))", "passed": false, "raw_code": "```python\ndef count_good_sequences(N, M):\n    MOD = 998244353\n    \n    # Initialize DP table\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    dp[0][1] = 1\n    \n    # Fill DP table\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            for k in range(1, M + 1):\n                if j * k <= M:\n                    dp[i][j * k] += dp[i - 1][j]\n                    dp[i][j * k] %= MOD\n    \n    # Calculate total number of good sequences and their scores\n    total_sequences = sum(dp[N]) % MOD\n    total_score = 0\n    \n    for j in range(1, M + 1):\n        total_score += dp[N][j] * len([i for i in range(1, j + 1) if j % i == 0])\n        total_score %= MOD\n    \n    return total_score\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\n# Print the result\nprint(count_good_sequences(N, M))\n```"}
{"task_id": "3583", "code": "from collections import Counter\nfrom math import gcd\nfrom typing import List\n\ndef solveGCDPairs(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    max_gcd = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_gcd = max(max_gcd, gcd(nums[i], nums[j]))\n    \n    count = Counter()\n    for i in range(n):\n        for j in range(i + 1, n):\n            count[gcd(nums[i], nums[j])] += 1\n    \n    prefix_sum = [0] * (max_gcd + 1)\n    for i in range(1, max_gcd + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + count[i]\n    \n    result = []\n    for query in queries:\n        idx = query + 1\n        for i in range(1, max_gcd + 1):\n            if prefix_sum[i] >= idx:\n                result.append(i)\n                break\n    \n    return result", "passed": false, "raw_code": "```python\nfrom collections import Counter\nfrom math import gcd\nfrom typing import List\n\ndef solveGCDPairs(nums: List[int], queries: List[int]) -> List[int]:\n    n = len(nums)\n    max_gcd = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_gcd = max(max_gcd, gcd(nums[i], nums[j]))\n    \n    count = Counter()\n    for i in range(n):\n        for j in range(i + 1, n):\n            count[gcd(nums[i], nums[j])] += 1\n    \n    prefix_sum = [0] * (max_gcd + 1)\n    for i in range(1, max_gcd + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + count[i]\n    \n    result = []\n    for query in queries:\n        idx = query + 1\n        for i in range(1, max_gcd + 1):\n            if prefix_sum[i] >= idx:\n                result.append(i)\n                break\n    \n    return result\n```"}
{"task_id": "3571", "code": "def maxIncreasingPath(coordinates, k):\n    def dfs(i):\n        if dp[i] != -1:\n            return dp[i]\n        \n        max_path = 1\n        for x, y in [(i[0] + 1, i[1]), (i[0], i[1] + 1)]:\n            if 0 <= x < len(coords) and 0 <= y < len(coords[x]) and coords[x][y] > coords[i[0]][i[1]]:\n                max_path = max(max_path, 1 + dfs((x, y)))\n        \n        dp[i] = max_path\n        return dp[i]\n    \n    coords = sorted([sorted(c) for c in coordinates])\n    dp = [[-1] * len(coords[0]) for _ in range(len(coords))]\n    \n    for i in range(len(coords)):\n        for j in range(len(coords[i])):\n            if (i, j) == (k // len(coords[0]), k % len(coords[0])):\n                return dfs((i, j))", "passed": false, "raw_code": "```python\ndef maxIncreasingPath(coordinates, k):\n    def dfs(i):\n        if dp[i] != -1:\n            return dp[i]\n        \n        max_path = 1\n        for x, y in [(i[0] + 1, i[1]), (i[0], i[1] + 1)]:\n            if 0 <= x < len(coords) and 0 <= y < len(coords[x]) and coords[x][y] > coords[i[0]][i[1]]:\n                max_path = max(max_path, 1 + dfs((x, y)))\n        \n        dp[i] = max_path\n        return dp[i]\n    \n    coords = sorted([sorted(c) for c in coordinates])\n    dp = [[-1] * len(coords[0]) for _ in range(len(coords))]\n    \n    for i in range(len(coords)):\n        for j in range(len(coords[i])):\n            if (i, j) == (k // len(coords[0]), k % len(coords[0])):\n                return dfs((i, j))\n```"}
{"final_accuracy": "0.00%"}
