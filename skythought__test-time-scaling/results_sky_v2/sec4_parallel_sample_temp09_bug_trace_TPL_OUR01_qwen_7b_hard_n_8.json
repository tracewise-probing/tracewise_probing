"{\"difficulty\": \"hard\", \"num_threads\": 32, \"temperature\": 0.9, \"n\": 8, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_temp09_bug_trace_TPL_OUR01_qwen_7b_hard_n_8.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42, \"resume\": true}"
{"task_id": "3531", "codes": ["def min_damage(power: int, damage: list[int], health: list[int]) -> int:\n    # Calculate the initial total damage Bob would take if he attacked each enemy once immediately\n    initial_total_damage = sum(d * h // power for d, h in zip(damage, health))\n    \n    # Sort enemies by remaining health in descending order\n    enemies = sorted(zip(damage, health), key=lambda x: -x[1])\n    \n    # Simulate the process of attacking the enemies\n    total_damage = 0\n    for d, h in enemies:\n        rounds_to_kill = (h - 1) // power + 1\n        total_damage += rounds_to_kill * d\n    \n    return total_damage", "def min_damage(power, damage, health):\n    # Calculate the time to defeat each enemy\n    times = [(h / p) for h, p in zip(health, damage)]\n    \n    # Sort enemies by the time it takes to defeat them\n    sorted_enemies = sorted(zip(times, damage, health))\n    \n    total_damage = 0\n    current_time = 0\n    \n    for t, d, h in sorted_enemies:\n        if t * d > current_time * power:\n            total_damage += int(current_time * power - current_time * power + d)\n            current_time += 1\n        else:\n            total_damage += d\n    \n    return total_damage", "def minDamage(power, damage, health):\n    import heapq\n    \n    n = len(damage)\n    pq = []\n    \n    # Initialize the priority queue with negative health values\n    for i in range(n):\n        heapq.heappush(pq, -health[i])\n    \n    total_damage = 0\n    \n    while pq:\n        # Calculate the damage Bob receives from all enemies\n        for _ in range(n):\n            if pq:\n                enemy_health = -heapq.heappop(pq)\n                if enemy_health > 0:\n                    total_damage += enemy_health\n                    heapq.heappush(pq, -(enemy_health - power))\n                    if power > enemy_health:\n                        heapq.heappush(pq, 0)\n                    break\n    \n    return total_damage", "def minDamage(power, damage, health):\n    n = len(damage)\n    # Calculate effective damage per second for each enemy\n    enemies = [(damage[i], health[i]) for i in range(n)]\n    enemies.sort(key=lambda x: -x[0] / x[1])\n    \n    total_damage = 0\n    for d, h in enemies:\n        if h > power:\n            total_damage += power * ((h - 1) // power + 1)\n        else:\n            total_damage += d\n    \n    return total_damage", "def min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the number of seconds required to defeat each enemy\n    seconds_to_defeat = [(health[i] - 1) // power + 1 for i in range(n)]\n    \n    # Sort enemies based on the number of seconds required to defeat them\n    sorted_enemies = sorted(range(n), key=lambda x: seconds_to_defeat[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for enemy in sorted_enemies:\n        if health[enemy] > 0:\n            # Calculate the damage Bob can deal in the remaining time\n            time_left = (health[enemy] - 1) // power + 1\n            if time_left > 0:\n                total_damage += min(power * time_left, health[enemy])\n                health[enemy] -= min(power * time_left, health[enemy])\n    \n    return total_damage", "def min_damage(power: int, damage: List[int], health: List[int]) -> int:\n    n = len(damage)\n    enemies = sorted(zip(health, damage), key=lambda x: x[0] / x[1])\n    total_damage = 0\n    current_time = 0\n    \n    for h, d in enemies:\n        time_to_die = h / power\n        if current_time < time_to_die:\n            total_damage += int(time_to_die - current_time) * power\n            current_time = time_to_die\n        if current_time >= h:\n            break\n        total_damage += d\n    \n    return total_damage", "def min_damage(power, damage, health):\n    # Calculate the time each enemy takes to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort the enemies by the time they take to die\n    times_to_die_sorted_indices = sorted(range(len(times_to_die)), key=lambda i: times_to_die[i])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for index in times_to_die_sorted_indices:\n        if health[index] > 0:\n            # Determine how many full attacks Bob can make within the remaining time\n            full_attacks = int((times_to_die[index] - current_time) // power)\n            if full_attacks > 0:\n                total_damage += full_attacks * power\n                current_time += full_attacks * power\n            \n            # Add any partial attack if there's enough time left\n            if current_time < times_to_die[index]:\n                partial_attack = times_to_die[index] - current_time\n                total_damage += partial_attack * power\n                current_time = times_to_die[index]\n            \n            # Reduce the health of the enemy\n            health[index] -= power\n    \n    return int(total_damage)", "def minimumDamage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    time_to_die = [h / d for d, h in zip(damage, health)]\n    \n    # Sort enemies by their time to die in descending order\n    sorted_enemies = sorted(zip(time_to_die, damage, health), key=lambda x: x[0], reverse=True)\n    \n    total_damage = 0\n    for t, d, h in sorted_enemies:\n        # Calculate the number of seconds it will take to kill the enemy\n        seconds_to_kill = h // power\n        if h % power != 0:\n            seconds_to_kill += 1\n        \n        # Add the damage dealt in these seconds to the total damage\n        total_damage += seconds_to_kill * d\n    \n    return total_damage"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef min_damage(power: int, damage: list[int], health: list[int]) -> int:\n    # Calculate the initial total damage Bob would take if he attacked each enemy once immediately\n    initial_total_damage = sum(d * h // power for d, h in zip(damage, health))\n    \n    # Sort enemies by remaining health in descending order\n    enemies = sorted(zip(damage, health), key=lambda x: -x[1])\n    \n    # Simulate the process of attacking the enemies\n    total_damage = 0\n    for d, h in enemies:\n        rounds_to_kill = (h - 1) // power + 1\n        total_damage += rounds_to_kill * d\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    # Calculate the time to defeat each enemy\n    times = [(h / p) for h, p in zip(health, damage)]\n    \n    # Sort enemies by the time it takes to defeat them\n    sorted_enemies = sorted(zip(times, damage, health))\n    \n    total_damage = 0\n    current_time = 0\n    \n    for t, d, h in sorted_enemies:\n        if t * d > current_time * power:\n            total_damage += int(current_time * power - current_time * power + d)\n            current_time += 1\n        else:\n            total_damage += d\n    \n    return total_damage\n```", "```python\ndef minDamage(power, damage, health):\n    import heapq\n    \n    n = len(damage)\n    pq = []\n    \n    # Initialize the priority queue with negative health values\n    for i in range(n):\n        heapq.heappush(pq, -health[i])\n    \n    total_damage = 0\n    \n    while pq:\n        # Calculate the damage Bob receives from all enemies\n        for _ in range(n):\n            if pq:\n                enemy_health = -heapq.heappop(pq)\n                if enemy_health > 0:\n                    total_damage += enemy_health\n                    heapq.heappush(pq, -(enemy_health - power))\n                    if power > enemy_health:\n                        heapq.heappush(pq, 0)\n                    break\n    \n    return total_damage\n```", "```python\ndef minDamage(power, damage, health):\n    n = len(damage)\n    # Calculate effective damage per second for each enemy\n    enemies = [(damage[i], health[i]) for i in range(n)]\n    enemies.sort(key=lambda x: -x[0] / x[1])\n    \n    total_damage = 0\n    for d, h in enemies:\n        if h > power:\n            total_damage += power * ((h - 1) // power + 1)\n        else:\n            total_damage += d\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    n = len(damage)\n    # Calculate the number of seconds required to defeat each enemy\n    seconds_to_defeat = [(health[i] - 1) // power + 1 for i in range(n)]\n    \n    # Sort enemies based on the number of seconds required to defeat them\n    sorted_enemies = sorted(range(n), key=lambda x: seconds_to_defeat[x])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for enemy in sorted_enemies:\n        if health[enemy] > 0:\n            # Calculate the damage Bob can deal in the remaining time\n            time_left = (health[enemy] - 1) // power + 1\n            if time_left > 0:\n                total_damage += min(power * time_left, health[enemy])\n                health[enemy] -= min(power * time_left, health[enemy])\n    \n    return total_damage\n```", "```python\ndef min_damage(power: int, damage: List[int], health: List[int]) -> int:\n    n = len(damage)\n    enemies = sorted(zip(health, damage), key=lambda x: x[0] / x[1])\n    total_damage = 0\n    current_time = 0\n    \n    for h, d in enemies:\n        time_to_die = h / power\n        if current_time < time_to_die:\n            total_damage += int(time_to_die - current_time) * power\n            current_time = time_to_die\n        if current_time >= h:\n            break\n        total_damage += d\n    \n    return total_damage\n```", "```python\ndef min_damage(power, damage, health):\n    # Calculate the time each enemy takes to die\n    times_to_die = [(h / d) for h, d in zip(health, damage)]\n    \n    # Sort the enemies by the time they take to die\n    times_to_die_sorted_indices = sorted(range(len(times_to_die)), key=lambda i: times_to_die[i])\n    \n    total_damage = 0\n    current_time = 0\n    \n    for index in times_to_die_sorted_indices:\n        if health[index] > 0:\n            # Determine how many full attacks Bob can make within the remaining time\n            full_attacks = int((times_to_die[index] - current_time) // power)\n            if full_attacks > 0:\n                total_damage += full_attacks * power\n                current_time += full_attacks * power\n            \n            # Add any partial attack if there's enough time left\n            if current_time < times_to_die[index]:\n                partial_attack = times_to_die[index] - current_time\n                total_damage += partial_attack * power\n                current_time = times_to_die[index]\n            \n            # Reduce the health of the enemy\n            health[index] -= power\n    \n    return int(total_damage)\n```", "```python\ndef minimumDamage(power, damage, health):\n    # Calculate the time it takes for each enemy to die\n    time_to_die = [h / d for d, h in zip(damage, health)]\n    \n    # Sort enemies by their time to die in descending order\n    sorted_enemies = sorted(zip(time_to_die, damage, health), key=lambda x: x[0], reverse=True)\n    \n    total_damage = 0\n    for t, d, h in sorted_enemies:\n        # Calculate the number of seconds it will take to kill the enemy\n        seconds_to_kill = h // power\n        if h % power != 0:\n            seconds_to_kill += 1\n        \n        # Add the damage dealt in these seconds to the total damage\n        total_damage += seconds_to_kill * d\n    \n    return total_damage\n```"]}
{"task_id": "3550", "codes": ["def max_rook_sum(board):\n    rows = []\n    cols = []\n    \n    # Find rows with exactly one non-zero element\n    for i in range(len(board)):\n        non_zero_indices = [j for j, val in enumerate(board[i]) if val != 0]\n        if len(non_zero_indices) == 1:\n            rows.append((i, non_zero_indices[0]))\n    \n    # Find columns with exactly one non-zero element\n    for j in range(len(board[0])):\n        non_zero_indices = [i for i, row in enumerate(board) if row[j] != 0]\n        if len(non_zero_indices) == 1:\n            cols.append((non_zero_indices[0], j))\n    \n    max_sum = float('-inf')\n    \n    # Iterate through all combinations of row and column candidates\n    for row in rows:\n        for col in cols:\n            if row[1] != col[1]:\n                max_sum = max(max_sum, board[row[0]][col[1]])\n    \n    return max_sum", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with exactly one non-zero cell\n    valid_rows = [i for i in range(m) if sum(1 for val in board[i] if val != 0) == 1]\n    valid_cols = [j for j in range(n) if sum(1 for row in board for val in row[j] if val != 0) == 1]\n    \n    # If there are fewer than 3 valid rows or columns, return -1 (impossible to place 3 rooks)\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return -1\n    \n    # Calculate the maximum sum by selecting the top 3 valid rows and columns\n    max_sum = 0\n    for r in valid_rows[:3]:\n        for c in valid_cols[:3]:\n            max_sum += board[r][c]\n    \n    return max_sum", "def maxRooksSum(board):\n    m, n = len(board), len(board[0])\n    max_sum = float('-inf')\n\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == 0:\n                continue\n            row_sum, col_sum = 0, 0\n            for k in range(m):\n                if board[k][j] != 0:\n                    row_sum = board[i][j] if row_sum == 0 else row_sum + board[k][j]\n                    break\n            for l in range(n):\n                if board[i][l] != 0:\n                    col_sum = board[i][j] if col_sum == 0 else col_sum + board[i][l]\n                    break\n            max_sum = max(max_sum, row_sum + col_sum - board[i][j])\n    return max_sum", "def maxRooks(board):\n    rows = sorted(range(len(board)), key=lambda r: sum(board[r]), reverse=True)\n    cols = sorted(range(len(board[0])), key=lambda c: sum(board[r][c] for r in range(len(board))), reverse=True)\n    \n    for i in range(3):\n        for j in range(i + 1, 3):\n            if rows[i] != rows[j] and cols[i] != cols[j]:\n                return board[rows[i]][cols[j]] + board[rows[j]][cols[i]] + board[rows[i]][cols[i]]\n    return 0", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate the sum of each row and column\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Get the indices of the top 3 rows and columns by their sums\n    top_rows = sorted(range(m), key=lambda i: row_sums[i], reverse=True)[:3]\n    top_cols = sorted(range(n), key=lambda j: col_sums[j], reverse=True)[:3]\n    \n    # Ensure no two rooks are in the same row or column\n    selected_rows = []\n    selected_cols = []\n    \n    for row in top_rows:\n        if all(row != r for r in selected_rows):\n            selected_rows.append(row)\n    \n    for col in top_cols:\n        if all(col != c for c in selected_cols):\n            selected_cols.append(col)\n    \n    # If we don't have exactly 3 unique rows and columns, return -1\n    if len(selected_rows) != 3 or len(selected_cols) != 3:\n        return -1\n    \n    # Calculate the maximum sum of the selected positions\n    max_sum = sum(board[row][col] for row in selected_rows for col in selected_cols)\n    \n    return max_sum", "def max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    row_counts = [0] * m\n    col_counts = [0] * n\n    \n    # Count non-zero values in each row and column\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] != 0:\n                row_counts[i] += 1\n                col_counts[j] += 1\n    \n    # Find rows and columns with exactly one non-zero value\n    valid_rows = [i for i, count in enumerate(row_counts) if count == 1]\n    valid_cols = [j for j, count in enumerate(col_counts) if count == 1]\n    \n    # If there are less than 3 valid rows or columns, return 0\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return 0\n    \n    # Calculate the sum of the cell values at the intersection of the selected rows and columns\n    max_sum = 0\n    for r in valid_rows:\n        for c in valid_cols:\n            max_sum += board[r][c]\n    \n    return max_sum", "def maxSumOfNonAttackingRooks(board):\n    m, n = len(board), len(board[0])\n    \n    def get_max_indices(row):\n        return [i for i, val in enumerate(row) if val == max(row)]\n    \n    def get_max_indices_col(col):\n        return [i for i in range(m) if board[i][col] == max([board[row][col] for row in range(m)])]\n    \n    max_sum = float('-inf')\n    \n    for r1 in range(m):\n        for c1 in range(n):\n            if board[r1][c1] != max(board[r1]):\n                continue\n            for r2 in range(r1+1, m):\n                if board[r2][c1] != max(board[r2]):\n                    continue\n                for c2 in range(c1+1, n):\n                    if board[r1][c2] != max(get_max_indices_col(c2)):\n                        continue\n                    current_sum = board[r1][c1] + board[r2][c1] + board[r1][c2]\n                    max_sum = max(max_sum, current_sum)\n    \n    return max_sum if max_sum != float('-inf') else 0", "def max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    return row_sums[0] + col_sums[1] + row_sums[2] + col_sums[3]"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef max_rook_sum(board):\n    rows = []\n    cols = []\n    \n    # Find rows with exactly one non-zero element\n    for i in range(len(board)):\n        non_zero_indices = [j for j, val in enumerate(board[i]) if val != 0]\n        if len(non_zero_indices) == 1:\n            rows.append((i, non_zero_indices[0]))\n    \n    # Find columns with exactly one non-zero element\n    for j in range(len(board[0])):\n        non_zero_indices = [i for i, row in enumerate(board) if row[j] != 0]\n        if len(non_zero_indices) == 1:\n            cols.append((non_zero_indices[0], j))\n    \n    max_sum = float('-inf')\n    \n    # Iterate through all combinations of row and column candidates\n    for row in rows:\n        for col in cols:\n            if row[1] != col[1]:\n                max_sum = max(max_sum, board[row[0]][col[1]])\n    \n    return max_sum\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Find rows and columns with exactly one non-zero cell\n    valid_rows = [i for i in range(m) if sum(1 for val in board[i] if val != 0) == 1]\n    valid_cols = [j for j in range(n) if sum(1 for row in board for val in row[j] if val != 0) == 1]\n    \n    # If there are fewer than 3 valid rows or columns, return -1 (impossible to place 3 rooks)\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return -1\n    \n    # Calculate the maximum sum by selecting the top 3 valid rows and columns\n    max_sum = 0\n    for r in valid_rows[:3]:\n        for c in valid_cols[:3]:\n            max_sum += board[r][c]\n    \n    return max_sum\n```", "```python\ndef maxRooksSum(board):\n    m, n = len(board), len(board[0])\n    max_sum = float('-inf')\n\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == 0:\n                continue\n            row_sum, col_sum = 0, 0\n            for k in range(m):\n                if board[k][j] != 0:\n                    row_sum = board[i][j] if row_sum == 0 else row_sum + board[k][j]\n                    break\n            for l in range(n):\n                if board[i][l] != 0:\n                    col_sum = board[i][j] if col_sum == 0 else col_sum + board[i][l]\n                    break\n            max_sum = max(max_sum, row_sum + col_sum - board[i][j])\n    return max_sum\n```", "```python\ndef maxRooks(board):\n    rows = sorted(range(len(board)), key=lambda r: sum(board[r]), reverse=True)\n    cols = sorted(range(len(board[0])), key=lambda c: sum(board[r][c] for r in range(len(board))), reverse=True)\n    \n    for i in range(3):\n        for j in range(i + 1, 3):\n            if rows[i] != rows[j] and cols[i] != cols[j]:\n                return board[rows[i]][cols[j]] + board[rows[j]][cols[i]] + board[rows[i]][cols[i]]\n    return 0\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    \n    # Calculate the sum of each row and column\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    # Get the indices of the top 3 rows and columns by their sums\n    top_rows = sorted(range(m), key=lambda i: row_sums[i], reverse=True)[:3]\n    top_cols = sorted(range(n), key=lambda j: col_sums[j], reverse=True)[:3]\n    \n    # Ensure no two rooks are in the same row or column\n    selected_rows = []\n    selected_cols = []\n    \n    for row in top_rows:\n        if all(row != r for r in selected_rows):\n            selected_rows.append(row)\n    \n    for col in top_cols:\n        if all(col != c for c in selected_cols):\n            selected_cols.append(col)\n    \n    # If we don't have exactly 3 unique rows and columns, return -1\n    if len(selected_rows) != 3 or len(selected_cols) != 3:\n        return -1\n    \n    # Calculate the maximum sum of the selected positions\n    max_sum = sum(board[row][col] for row in selected_rows for col in selected_cols)\n    \n    return max_sum\n```", "```python\ndef max_sum_of_rooks(board):\n    m, n = len(board), len(board[0])\n    row_counts = [0] * m\n    col_counts = [0] * n\n    \n    # Count non-zero values in each row and column\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] != 0:\n                row_counts[i] += 1\n                col_counts[j] += 1\n    \n    # Find rows and columns with exactly one non-zero value\n    valid_rows = [i for i, count in enumerate(row_counts) if count == 1]\n    valid_cols = [j for j, count in enumerate(col_counts) if count == 1]\n    \n    # If there are less than 3 valid rows or columns, return 0\n    if len(valid_rows) < 3 or len(valid_cols) < 3:\n        return 0\n    \n    # Calculate the sum of the cell values at the intersection of the selected rows and columns\n    max_sum = 0\n    for r in valid_rows:\n        for c in valid_cols:\n            max_sum += board[r][c]\n    \n    return max_sum\n```", "```python\ndef maxSumOfNonAttackingRooks(board):\n    m, n = len(board), len(board[0])\n    \n    def get_max_indices(row):\n        return [i for i, val in enumerate(row) if val == max(row)]\n    \n    def get_max_indices_col(col):\n        return [i for i in range(m) if board[i][col] == max([board[row][col] for row in range(m)])]\n    \n    max_sum = float('-inf')\n    \n    for r1 in range(m):\n        for c1 in range(n):\n            if board[r1][c1] != max(board[r1]):\n                continue\n            for r2 in range(r1+1, m):\n                if board[r2][c1] != max(board[r2]):\n                    continue\n                for c2 in range(c1+1, n):\n                    if board[r1][c2] != max(get_max_indices_col(c2)):\n                        continue\n                    current_sum = board[r1][c1] + board[r2][c1] + board[r1][c2]\n                    max_sum = max(max_sum, current_sum)\n    \n    return max_sum if max_sum != float('-inf') else 0\n```", "```python\ndef max_rook_sum(board):\n    m, n = len(board), len(board[0])\n    row_sums = [sum(row) for row in board]\n    col_sums = [sum(col) for col in zip(*board)]\n    \n    row_sums.sort(reverse=True)\n    col_sums.sort(reverse=True)\n    \n    return row_sums[0] + col_sums[1] + row_sums[2] + col_sums[3]\n```"]}
{"task_id": "3563", "codes": ["def maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_sum = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_sum += value\n                break\n    \n    return max_sum", "def maxScore(grid):\n    def backtrack(row, selected_columns, current_sum):\n        nonlocal max_score\n        if row == len(grid):\n            max_score = max(max_score, current_sum)\n            return\n        \n        for col in range(len(grid[row])):\n            if col not in selected_columns and grid[row][col] not in used_values:\n                selected_columns.add(col)\n                used_values.add(grid[row][col])\n                backtrack(row + 1, selected_columns, current_sum + grid[row][col])\n                selected_columns.remove(col)\n                used_values.remove(grid[row][col])\n    \n    max_score = 0\n    used_values = set()\n    backtrack(0, set(), 0)\n    return max_score", "def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    n = len(grid)\n    m = len(grid[0])\n    cols_used = set()\n    max_score = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if j not in cols_used:\n                max_score += grid[j][i]\n                cols_used.add(j)\n                break\n    \n    return max_score", "def maxScore(grid):\n    def backtrack(row, path, used_cols, current_sum):\n        if row == len(grid):\n            return current_sum\n        \n        max_score = 0\n        for col in range(len(grid[row])):\n            if col not in used_cols:\n                new_path = path + [grid[row][col]]\n                new_used_cols = used_cols | {col}\n                new_score = backtrack(row + 1, new_path, new_used_cols, current_sum + grid[row][col])\n                max_score = max(max_score, new_score)\n        \n        return max_score\n    \n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    return backtrack(0, [], set(), 0)", "def maxScore(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row to prioritize smaller values\n    for row in grid:\n        row.sort()\n    \n    def backtrack(row, used_values, current_sum):\n        if row == n:\n            return current_sum\n        \n        max_score = 0\n        for col in range(m):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                max_score = max(max_score, backtrack(row + 1, used_values, current_sum + grid[row][col]))\n                used_values.remove(grid[row][col])\n        \n        return max_score\n    \n    return backtrack(0, set(), 0)", "from itertools import product\n\ndef max_score(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def is_valid_combination(combination):\n        return len(set(combination)) == len(combination)\n    \n    max_sum = 0\n    \n    # Generate all possible combinations of selecting one cell per row\n    for combination in product(range(cols), repeat=rows):\n        if is_valid_combination(combination):\n            current_sum = sum(grid[row][col] for row, col in enumerate(combination))\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "def maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Initialize variables\n    n = len(grid)\n    m = len(grid[0])\n    selected = [False] * n\n    score = 0\n    \n    # Iterate through columns\n    for j in range(m):\n        for i in range(n):\n            if not selected[i]:\n                score += grid[i][j]\n                selected[i] = True\n                break\n    \n    return score", "def maxScore(grid):\n    for row in grid:\n        row.sort()\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    selected = [False] * rows\n    score = 0\n    \n    for j in range(cols - 1, -1, -1):\n        for i in range(rows):\n            if not selected[i] and grid[i][j] not in [grid[k][j] for k in range(rows) if k != i]:\n                selected[i] = True\n                score += grid[i][j]\n                break\n    \n    return score"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort(reverse=True)\n    \n    selected_values = set()\n    max_sum = 0\n    \n    for row in grid:\n        for value in row:\n            if value not in selected_values:\n                selected_values.add(value)\n                max_sum += value\n                break\n    \n    return max_sum\n```", "```python\ndef maxScore(grid):\n    def backtrack(row, selected_columns, current_sum):\n        nonlocal max_score\n        if row == len(grid):\n            max_score = max(max_score, current_sum)\n            return\n        \n        for col in range(len(grid[row])):\n            if col not in selected_columns and grid[row][col] not in used_values:\n                selected_columns.add(col)\n                used_values.add(grid[row][col])\n                backtrack(row + 1, selected_columns, current_sum + grid[row][col])\n                selected_columns.remove(col)\n                used_values.remove(grid[row][col])\n    \n    max_score = 0\n    used_values = set()\n    backtrack(0, set(), 0)\n    return max_score\n```", "```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    n = len(grid)\n    m = len(grid[0])\n    cols_used = set()\n    max_score = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if j not in cols_used:\n                max_score += grid[j][i]\n                cols_used.add(j)\n                break\n    \n    return max_score\n```", "```python\ndef maxScore(grid):\n    def backtrack(row, path, used_cols, current_sum):\n        if row == len(grid):\n            return current_sum\n        \n        max_score = 0\n        for col in range(len(grid[row])):\n            if col not in used_cols:\n                new_path = path + [grid[row][col]]\n                new_used_cols = used_cols | {col}\n                new_score = backtrack(row + 1, new_path, new_used_cols, current_sum + grid[row][col])\n                max_score = max(max_score, new_score)\n        \n        return max_score\n    \n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    return backtrack(0, [], set(), 0)\n```", "```python\ndef maxScore(grid):\n    n, m = len(grid), len(grid[0])\n    \n    # Sort each row to prioritize smaller values\n    for row in grid:\n        row.sort()\n    \n    def backtrack(row, used_values, current_sum):\n        if row == n:\n            return current_sum\n        \n        max_score = 0\n        for col in range(m):\n            if grid[row][col] not in used_values:\n                used_values.add(grid[row][col])\n                max_score = max(max_score, backtrack(row + 1, used_values, current_sum + grid[row][col]))\n                used_values.remove(grid[row][col])\n        \n        return max_score\n    \n    return backtrack(0, set(), 0)\n```", "```python\nfrom itertools import product\n\ndef max_score(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    def is_valid_combination(combination):\n        return len(set(combination)) == len(combination)\n    \n    max_sum = 0\n    \n    # Generate all possible combinations of selecting one cell per row\n    for combination in product(range(cols), repeat=rows):\n        if is_valid_combination(combination):\n            current_sum = sum(grid[row][col] for row, col in enumerate(combination))\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n```", "```python\ndef maxScore(grid):\n    # Sort each row in descending order\n    for row in grid:\n        row.sort(reverse=True)\n    \n    # Initialize variables\n    n = len(grid)\n    m = len(grid[0])\n    selected = [False] * n\n    score = 0\n    \n    # Iterate through columns\n    for j in range(m):\n        for i in range(n):\n            if not selected[i]:\n                score += grid[i][j]\n                selected[i] = True\n                break\n    \n    return score\n```", "```python\ndef maxScore(grid):\n    for row in grid:\n        row.sort()\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    selected = [False] * rows\n    score = 0\n    \n    for j in range(cols - 1, -1, -1):\n        for i in range(rows):\n            if not selected[i] and grid[i][j] not in [grid[k][j] for k in range(rows) if k != i]:\n                selected[i] = True\n                score += grid[i][j]\n                break\n    \n    return score\n```"]}
{"task_id": "3535", "codes": ["def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Function to calculate combinations C(n, k) % MOD\n    def comb(n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        num = den = 1\n        for i in range(k):\n            num = num * (n - i) % MOD\n            den = den * (i + 1) % MOD\n        return num * pow(den, MOD - 2, MOD) % MOD\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_inc[i][j] = sum(dp_inc[i-1][:j+1]) % MOD\n            dp_dec[i][j] = sum(dp_dec[i-1][j:]) % MOD\n    \n    result = 0\n    for i in range(n):\n        x = nums[i]\n        result = (result + dp_inc[i][x] * dp_dec[i][x]) % MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(1, nums[0] + 1):\n        for j in range(nums[-1], 0, -1):\n            if i + j != nums[0]:\n                continue\n            valid = True\n            for k in range(1, n):\n                if i + j != nums[k]:\n                    valid = False\n                    break\n                if i > (i + j - nums[k]):\n                    valid = False\n                    break\n                if j < (j + nums[k] - i):\n                    valid = False\n                    break\n            if valid:\n                count += 1\n    \n    return count % MOD", "def countMonotonicPairs(nums):\n    n = len(nums)\n    mod = 10**9 + 7\n    \n    def countNonDecreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] <= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % mod\n        return sum(dp) % mod\n    \n    def countNonIncreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] >= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % mod\n        return sum(dp) % mod\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            arr1 = [i] * n\n            arr2 = [nums[i] - i + j] * n\n            if arr2[-1] >= arr2[-2]:\n                count = (count + countNonDecreasing(arr1) * countNonIncreasing(arr2)) % mod\n    \n    return count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_inc = [[0] * (n + 1) for _ in range(n + 1)]\n    dp_dec = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: empty sequences\n    dp_inc[0][0] = 1\n    dp_dec[0][0] = 1\n    \n    # Fill DP tables\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            for k in range(nums[i - 1] + 1):\n                if j > 0:\n                    dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i - 1][j - 1]) % MOD\n                if j < i:\n                    dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i - 1][j + 1]) % MOD\n    \n    # Calculate the total number of valid pairs\n    result = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            result = (result + dp_inc[i][j] * dp_dec[i][j]) % MOD\n    \n    return result", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    dp_inc[0][nums[0]] = 1\n    dp_dec[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        current_sum = nums[i]\n        for j in range(current_sum + 1):\n            if j <= nums[i]:\n                dp_inc[i][j] = (dp_inc[i-1][j] + dp_inc[i-1][j+1]) % MOD\n            if j >= nums[i]:\n                dp_dec[i][j] = (dp_dec[i-1][j] + dp_dec[i-1][j-1]) % MOD\n    \n    total_count = 0\n    for j in range(51):\n        total_count = (total_count + dp_inc[-1][j] * dp_dec[-1][j]) % MOD\n    \n    return total_count", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def count_pairs(sum_val, max_val):\n        count = 0\n        left, right = 0, max_val\n        while left <= right:\n            mid = (left + right) // 2\n            if mid + mid <= sum_val:\n                left = mid + 1\n            else:\n                count += right - mid + 1\n                right = mid - 1\n        return count\n    \n    total_count = 0\n    for num in nums:\n        total_count = (total_count + count_pairs(num, num)) % MOD\n    \n    return total_count", "def countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                if nums[0] == 0:\n                    count += 1\n            elif i == 0:\n                if nums[0] == j:\n                    count += 1\n            elif j == 0:\n                if nums[i] % i == 0 and nums[i] // i == j:\n                    count += 1\n            elif nums[i] - i == j:\n                count += 1\n    \n    return count % MOD", "def countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP arrays\n    dp_increasing = [1] * n\n    dp_decreasing = [1] * n\n    total_pairs = 0\n    \n    # Fill dp_increasing array\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] >= nums[j]:\n                dp_increasing[i] = (dp_increasing[i] + dp_increasing[j]) % MOD\n    \n    # Fill dp_decreasing array\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] <= nums[j]:\n                dp_decreasing[i] = (dp_decreasing[i] + dp_decreasing[j]) % MOD\n    \n    # Calculate total valid pairs\n    for i in range(n):\n        total_pairs = (total_pairs + dp_increasing[i] * dp_decreasing[i]) % MOD\n    \n    return total_pairs"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Function to calculate combinations C(n, k) % MOD\n    def comb(n, k):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        num = den = 1\n        for i in range(k):\n            num = num * (n - i) % MOD\n            den = den * (i + 1) % MOD\n        return num * pow(den, MOD - 2, MOD) % MOD\n    \n    # Initialize DP tables\n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    # Base cases\n    for i in range(51):\n        dp_inc[0][i] = 1\n        dp_dec[0][i] = 1\n    \n    # Fill DP tables\n    for i in range(1, n):\n        for j in range(51):\n            dp_inc[i][j] = sum(dp_inc[i-1][:j+1]) % MOD\n            dp_dec[i][j] = sum(dp_dec[i-1][j:]) % MOD\n    \n    result = 0\n    for i in range(n):\n        x = nums[i]\n        result = (result + dp_inc[i][x] * dp_dec[i][x]) % MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(1, nums[0] + 1):\n        for j in range(nums[-1], 0, -1):\n            if i + j != nums[0]:\n                continue\n            valid = True\n            for k in range(1, n):\n                if i + j != nums[k]:\n                    valid = False\n                    break\n                if i > (i + j - nums[k]):\n                    valid = False\n                    break\n                if j < (j + nums[k] - i):\n                    valid = False\n                    break\n            if valid:\n                count += 1\n    \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    mod = 10**9 + 7\n    \n    def countNonDecreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] <= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % mod\n        return sum(dp) % mod\n    \n    def countNonIncreasing(arr):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[j] >= arr[i]:\n                    dp[i] = (dp[i] + dp[j]) % mod\n        return sum(dp) % mod\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            arr1 = [i] * n\n            arr2 = [nums[i] - i + j] * n\n            if arr2[-1] >= arr2[-2]:\n                count = (count + countNonDecreasing(arr1) * countNonIncreasing(arr2)) % mod\n    \n    return count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP tables\n    dp_inc = [[0] * (n + 1) for _ in range(n + 1)]\n    dp_dec = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Base case: empty sequences\n    dp_inc[0][0] = 1\n    dp_dec[0][0] = 1\n    \n    # Fill DP tables\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            for k in range(nums[i - 1] + 1):\n                if j > 0:\n                    dp_inc[i][j] = (dp_inc[i][j] + dp_inc[i - 1][j - 1]) % MOD\n                if j < i:\n                    dp_dec[i][j] = (dp_dec[i][j] + dp_dec[i - 1][j + 1]) % MOD\n    \n    # Calculate the total number of valid pairs\n    result = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            result = (result + dp_inc[i][j] * dp_dec[i][j]) % MOD\n    \n    return result\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    \n    dp_inc = [[0] * 51 for _ in range(n)]\n    dp_dec = [[0] * 51 for _ in range(n)]\n    \n    dp_inc[0][nums[0]] = 1\n    dp_dec[0][nums[0]] = 1\n    \n    for i in range(1, n):\n        current_sum = nums[i]\n        for j in range(current_sum + 1):\n            if j <= nums[i]:\n                dp_inc[i][j] = (dp_inc[i-1][j] + dp_inc[i-1][j+1]) % MOD\n            if j >= nums[i]:\n                dp_dec[i][j] = (dp_dec[i-1][j] + dp_dec[i-1][j-1]) % MOD\n    \n    total_count = 0\n    for j in range(51):\n        total_count = (total_count + dp_inc[-1][j] * dp_dec[-1][j]) % MOD\n    \n    return total_count\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    def count_pairs(sum_val, max_val):\n        count = 0\n        left, right = 0, max_val\n        while left <= right:\n            mid = (left + right) // 2\n            if mid + mid <= sum_val:\n                left = mid + 1\n            else:\n                count += right - mid + 1\n                right = mid - 1\n        return count\n    \n    total_count = 0\n    for num in nums:\n        total_count = (total_count + count_pairs(num, num)) % MOD\n    \n    return total_count\n```", "```python\ndef countMonotonicPairs(nums):\n    n = len(nums)\n    MOD = 10**9 + 7\n    count = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                if nums[0] == 0:\n                    count += 1\n            elif i == 0:\n                if nums[0] == j:\n                    count += 1\n            elif j == 0:\n                if nums[i] % i == 0 and nums[i] // i == j:\n                    count += 1\n            elif nums[i] - i == j:\n                count += 1\n    \n    return count % MOD\n```", "```python\ndef countMonotonicPairs(nums):\n    MOD = 10**9 + 7\n    n = len(nums)\n    \n    # Initialize DP arrays\n    dp_increasing = [1] * n\n    dp_decreasing = [1] * n\n    total_pairs = 0\n    \n    # Fill dp_increasing array\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] >= nums[j]:\n                dp_increasing[i] = (dp_increasing[i] + dp_increasing[j]) % MOD\n    \n    # Fill dp_decreasing array\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] <= nums[j]:\n                dp_decreasing[i] = (dp_decreasing[i] + dp_decreasing[j]) % MOD\n    \n    # Calculate total valid pairs\n    for i in range(n):\n        total_pairs = (total_pairs + dp_increasing[i] * dp_decreasing[i]) % MOD\n    \n    return total_pairs\n```"]}
{"task_id": "3575", "codes": ["def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    nums.sort()\n    \n    max_value = 0\n    \n    for i in range(n - 2*k + 1):\n        first_half = 0\n        second_half = 0\n        \n        for j in range(i, i+k):\n            first_half |= nums[j]\n        \n        for j in range(i+k, i+2*k):\n            second_half |= nums[j]\n        \n        max_value = max(max_value, first_half ^ second_half)\n    \n    return max_value", "def max_value(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    for i in range(n - 2*k + 1):\n        left_or = 0\n        right_or = 0\n        \n        for j in range(i, i + k):\n            left_or |= nums[j]\n        \n        for j in range(i + k, i + 2*k):\n            right_or |= nums[j]\n        \n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val", "def max_value(nums, k):\n    n = len(nums)\n    dp = {}\n    \n    def dfs(start, end, xor):\n        if start > end:\n            return xor\n        if (start, end) in dp:\n            return dp[(start, end)]\n        \n        dp[(start, end)] = max(dfs(start + 1, end, xor ^ nums[start]), dfs(start, end - 1, xor))\n        return dp[(start, end)]\n    \n    return dfs(0, n - 1, 0)", "def max_xor_subsequence(nums, k):\n    n = len(nums)\n    dp = [0] * (1 << n)\n    \n    for mask in range(1 << n):\n        xor_val = 0\n        count = 0\n        for i in range(n):\n            if mask & (1 << i):\n                xor_val ^= nums[i]\n                count += 1\n            if count == 2 * k:\n                break\n        if count == 2 * k:\n            dp[mask] = xor_val\n    \n    return max(dp)", "def maximum_value(nums: list[int], k: int) -> int:\n    nums.sort()\n    max_value = 0\n    for i in range(k):\n        max_value = max(max_value, (nums[-1 - i] | nums[i]) ^ (nums[-2 - i] | nums[1 + i]))\n    return max_value", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    dp = [[0] * n for _ in range(2 * k + 1)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            if i == 0:\n                dp[j - i + 1][j] = nums[j]\n            else:\n                dp[j - i + 1][j] = dp[j - i][i - 1] | nums[j]\n            if j >= i + 2 * k - 1:\n                dp[j - i + 1][j] = max(dp[j - i + 1][j], dp[j - i + 1][j - 2 * k])\n    \n    return dp[2 * k][n - 1]", "def max_subsequence_value(nums, k):\n    nums.sort()\n    max_value = 0\n    for i in range(k):\n        xor_value = nums[i] | nums[len(nums) - 1 - i]\n        if xor_value > max_value:\n            max_value = xor_value\n    return max_value", "def maxSubsequenceValue(nums, k):\n    n = len(nums)\n    max_value = 0\n    \n    # Helper function to compute OR of elements in the range [start, end]\n    def orRange(start, end):\n        result = 0\n        for i in range(start, end + 1):\n            result |= nums[i]\n        return result\n    \n    # Iterate over all possible starting points for the first segment\n    for i in range(n - 2 * k + 1):\n        # Compute the OR of the first k elements\n        left_or = orRange(i, i + k - 1)\n        # Compute the OR of the next k elements\n        right_or = orRange(i + k, i + 2 * k - 1)\n        # Calculate the XOR of the two OR values\n        current_value = left_or ^ right_or\n        # Update the maximum value if the current value is greater\n        max_value = max(max_value, current_value)\n    \n    return max_value"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    nums.sort()\n    \n    max_value = 0\n    \n    for i in range(n - 2*k + 1):\n        first_half = 0\n        second_half = 0\n        \n        for j in range(i, i+k):\n            first_half |= nums[j]\n        \n        for j in range(i+k, i+2*k):\n            second_half |= nums[j]\n        \n        max_value = max(max_value, first_half ^ second_half)\n    \n    return max_value\n```", "```python\ndef max_value(nums, k):\n    n = len(nums)\n    max_val = 0\n    \n    for i in range(n - 2*k + 1):\n        left_or = 0\n        right_or = 0\n        \n        for j in range(i, i + k):\n            left_or |= nums[j]\n        \n        for j in range(i + k, i + 2*k):\n            right_or |= nums[j]\n        \n        max_val = max(max_val, left_or ^ right_or)\n    \n    return max_val\n```", "```python\ndef max_value(nums, k):\n    n = len(nums)\n    dp = {}\n    \n    def dfs(start, end, xor):\n        if start > end:\n            return xor\n        if (start, end) in dp:\n            return dp[(start, end)]\n        \n        dp[(start, end)] = max(dfs(start + 1, end, xor ^ nums[start]), dfs(start, end - 1, xor))\n        return dp[(start, end)]\n    \n    return dfs(0, n - 1, 0)\n```", "```python\ndef max_xor_subsequence(nums, k):\n    n = len(nums)\n    dp = [0] * (1 << n)\n    \n    for mask in range(1 << n):\n        xor_val = 0\n        count = 0\n        for i in range(n):\n            if mask & (1 << i):\n                xor_val ^= nums[i]\n                count += 1\n            if count == 2 * k:\n                break\n        if count == 2 * k:\n            dp[mask] = xor_val\n    \n    return max(dp)\n```", "```python\ndef maximum_value(nums: list[int], k: int) -> int:\n    nums.sort()\n    max_value = 0\n    for i in range(k):\n        max_value = max(max_value, (nums[-1 - i] | nums[i]) ^ (nums[-2 - i] | nums[1 + i]))\n    return max_value\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    dp = [[0] * n for _ in range(2 * k + 1)]\n    \n    for i in range(n):\n        for j in range(i, n):\n            if i == 0:\n                dp[j - i + 1][j] = nums[j]\n            else:\n                dp[j - i + 1][j] = dp[j - i][i - 1] | nums[j]\n            if j >= i + 2 * k - 1:\n                dp[j - i + 1][j] = max(dp[j - i + 1][j], dp[j - i + 1][j - 2 * k])\n    \n    return dp[2 * k][n - 1]\n```", "```python\ndef max_subsequence_value(nums, k):\n    nums.sort()\n    max_value = 0\n    for i in range(k):\n        xor_value = nums[i] | nums[len(nums) - 1 - i]\n        if xor_value > max_value:\n            max_value = xor_value\n    return max_value\n```", "```python\ndef maxSubsequenceValue(nums, k):\n    n = len(nums)\n    max_value = 0\n    \n    # Helper function to compute OR of elements in the range [start, end]\n    def orRange(start, end):\n        result = 0\n        for i in range(start, end + 1):\n            result |= nums[i]\n        return result\n    \n    # Iterate over all possible starting points for the first segment\n    for i in range(n - 2 * k + 1):\n        # Compute the OR of the first k elements\n        left_or = orRange(i, i + k - 1)\n        # Compute the OR of the next k elements\n        right_or = orRange(i + k, i + 2 * k - 1)\n        # Calculate the XOR of the two OR values\n        current_value = left_or ^ right_or\n        # Update the maximum value if the current value is greater\n        max_value = max(max_value, current_value)\n    \n    return max_value\n```"]}
{"task_id": "3552", "codes": ["def largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def generate_palindromes(length):\n        if length == 1:\n            return range(1, 10)\n        half_length = (length + 1) // 2\n        for prefix in range(10**(half_length - 1), 10**half_length):\n            prefix_str = str(prefix)\n            if length % 2 == 0:\n                yield int(prefix_str + prefix_str[::-1])\n            else:\n                for mid_digit in range(10):\n                    yield int(prefix_str + str(mid_digit) + prefix_str[::-1])\n\n    max_palindrome = 0\n    for length in range(n, 0, -1):\n        for candidate in generate_palindromes(length):\n            if candidate % k == 0:\n                max_palindrome = candidate\n                break\n        if max_palindrome > 0:\n            break\n    \n    return str(max_palindrome)\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"", "def largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        for i in range(9, 0, -1):\n            if k % i == 0:\n                return str(i)\n    \n    if n % 2 == 0:\n        half_length = n // 2\n        mid = 0\n    else:\n        half_length = (n // 2) + 1\n        mid = 5\n    \n    for i in range(10**(half_length-1), 10**half_length):\n        first_half = str(i)\n        second_half = first_half[::-1]\n        if n % 2 == 0:\n            candidate = int(first_half + second_half)\n        else:\n            candidate = int(first_half + str(mid) + second_half)\n        if candidate % k == 0:\n            return str(candidate)\n    \n    return \"0\"\n\n# Test cases\nassert largest_k_palindrome(3, 5) == \"595\"\nassert largest_k_palindrome(1, 4) == \"8\"\nassert largest_k_palindrome(5, 6) == \"89898\"", "def largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num_str: str, k: int) -> bool:\n        return int(num_str) % k == 0\n    \n    def construct_palindrome(prefix: str) -> str:\n        return prefix + prefix[::-1]\n    \n    # Start with the largest n-digit number\n    for num in range(10**(n-1), 0, -1):\n        num_str = str(num)\n        full_num_str = construct_palindrome(num_str)\n        if len(full_num_str) > n:\n            continue\n        if is_divisible_by_k(full_num_str, k):\n            return full_num_str\n    return \"\"", "def largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max([i for i in range(1, 10) if i % k == 0]))\n    \n    half_length = (n + 1) // 2\n    max_digit = 9\n    \n    while True:\n        # Construct the first half of the number\n        first_half = ''.join(str(max_digit))\n        \n        # If n is even, add leading zeros to match the length\n        if n % 2 == 0:\n            first_half = '0' * (half_length - len(first_half)) + first_half\n        \n        # Check if the first half forms a valid k-palindrome\n        candidate = int(first_half + first_half[::-1])\n        if candidate % k == 0:\n            return str(candidate)\n        \n        # Decrease the first digit and try again\n        max_digit -= 1", "def largestKPalindromic(n: int, k: int) -> str:\n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def make_palindrome(num):\n        left = str(num)\n        right = left[::-1][1:]\n        return left + right\n    \n    if n == 1:\n        return str((k * (k // 2)) % 10)\n    \n    for i in range(10**(n-1), 10**n):\n        candidate = make_palindrome(i)\n        if int(candidate) % k == 0:\n            return candidate\n    \n    return \"\"", "```python\ndef largest_K_Palindrome(n, k):\n    if n == 1:\n        return str(k * 5) if k % 2 == 0 else str(8)\n    \n    half_length = (n + 1) // 2\n    half_digits = '9' * half_length\n    while int(half_digits) % k != 0:\n        half_digits = str(int(half_digits) - 1)\n        if half_digits == '0':\n            half_digits = '9' * (half_length - 1)\n            if half_length > 2:\n                half_length -= 1\n            else:\n                return \"0\"\n    \n    if n % 2 == 0:\n        return half_digits + half_digits[::-1]\n    else:\n        return half_digits + half_digits[-2::-1]", "def largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    mid = n // 2\n    if n == 1:\n        return str(max(0, k))\n    \n    for num in range(10**(mid) - 1, 10**(mid - 1) - 1, -1):\n        half = str(num)\n        if n % 2 == 0:\n            candidate = int(half + half[::-1])\n        else:\n            candidate = int(half + half[-2::-1])\n        if candidate % k == 0:\n            return str(candidate)\n    return \"0\"", "```python\ndef largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(k * (k % 2 + 1))\n    \n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def make_divisible_by_k(base):\n        while True:\n            candidate = int(base + base[-2::-1])\n            if candidate % k == 0:\n                return str(candidate)\n            base = str(int(base) - 1).lstrip('0')\n    \n    if n % 2 == 1:\n        half_length = (n - 1) // 2\n        half = '9' * half_length\n        while True:\n            candidate = make_divisible_by_k(half)\n            if len(candidate) == n:\n                return candidate\n            half = str(int(half) - 1).lstrip('0')\n    else:\n        half_length = n // 2\n        half = '9' * half_length\n        while True:\n            candidate = make_divisible_by_k(half)\n            if len(candidate) == n:\n                return candidate\n            half = str(int(half) - 1).lstrip('0')"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    def generate_palindromes(length):\n        if length == 1:\n            return range(1, 10)\n        half_length = (length + 1) // 2\n        for prefix in range(10**(half_length - 1), 10**half_length):\n            prefix_str = str(prefix)\n            if length % 2 == 0:\n                yield int(prefix_str + prefix_str[::-1])\n            else:\n                for mid_digit in range(10):\n                    yield int(prefix_str + str(mid_digit) + prefix_str[::-1])\n\n    max_palindrome = 0\n    for length in range(n, 0, -1):\n        for candidate in generate_palindromes(length):\n            if candidate % k == 0:\n                max_palindrome = candidate\n                break\n        if max_palindrome > 0:\n            break\n    \n    return str(max_palindrome)\n\n# Example usage:\nprint(largest_k_palindrome(3, 5))  # Output: \"595\"\nprint(largest_k_palindrome(1, 4))  # Output: \"8\"\nprint(largest_k_palindrome(5, 6))  # Output: \"89898\"\n```", "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    if n == 1:\n        for i in range(9, 0, -1):\n            if k % i == 0:\n                return str(i)\n    \n    if n % 2 == 0:\n        half_length = n // 2\n        mid = 0\n    else:\n        half_length = (n // 2) + 1\n        mid = 5\n    \n    for i in range(10**(half_length-1), 10**half_length):\n        first_half = str(i)\n        second_half = first_half[::-1]\n        if n % 2 == 0:\n            candidate = int(first_half + second_half)\n        else:\n            candidate = int(first_half + str(mid) + second_half)\n        if candidate % k == 0:\n            return str(candidate)\n    \n    return \"0\"\n\n# Test cases\nassert largest_k_palindrome(3, 5) == \"595\"\nassert largest_k_palindrome(1, 4) == \"8\"\nassert largest_k_palindrome(5, 6) == \"89898\"\n```", "```python\ndef largest_k_palindrome(n: int, k: int) -> str:\n    def is_divisible_by_k(num_str: str, k: int) -> bool:\n        return int(num_str) % k == 0\n    \n    def construct_palindrome(prefix: str) -> str:\n        return prefix + prefix[::-1]\n    \n    # Start with the largest n-digit number\n    for num in range(10**(n-1), 0, -1):\n        num_str = str(num)\n        full_num_str = construct_palindrome(num_str)\n        if len(full_num_str) > n:\n            continue\n        if is_divisible_by_k(full_num_str, k):\n            return full_num_str\n    return \"\"\n```", "```python\ndef largest_k_palindrome(n, k):\n    if n == 1:\n        return str(max([i for i in range(1, 10) if i % k == 0]))\n    \n    half_length = (n + 1) // 2\n    max_digit = 9\n    \n    while True:\n        # Construct the first half of the number\n        first_half = ''.join(str(max_digit))\n        \n        # If n is even, add leading zeros to match the length\n        if n % 2 == 0:\n            first_half = '0' * (half_length - len(first_half)) + first_half\n        \n        # Check if the first half forms a valid k-palindrome\n        candidate = int(first_half + first_half[::-1])\n        if candidate % k == 0:\n            return str(candidate)\n        \n        # Decrease the first digit and try again\n        max_digit -= 1\n```", "```python\ndef largestKPalindromic(n: int, k: int) -> str:\n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def make_palindrome(num):\n        left = str(num)\n        right = left[::-1][1:]\n        return left + right\n    \n    if n == 1:\n        return str((k * (k // 2)) % 10)\n    \n    for i in range(10**(n-1), 10**n):\n        candidate = make_palindrome(i)\n        if int(candidate) % k == 0:\n            return candidate\n    \n    return \"\"\n```", "```python\ndef largest_K_Palindrome(n, k):\n    if n == 1:\n        return str(k * 5) if k % 2 == 0 else str(8)\n    \n    half_length = (n + 1) // 2\n    half_digits = '9' * half_length\n    while int(half_digits) % k != 0:\n        half_digits = str(int(half_digits) - 1)\n        if half_digits == '0':\n            half_digits = '9' * (half_length - 1)\n            if half_length > 2:\n                half_length -= 1\n            else:\n                return \"0\"\n    \n    if n % 2 == 0:\n        return half_digits + half_digits[::-1]\n    else:\n        return half_digits + half_digits[-2::-1]", "```python\ndef largest_k_palindrome(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    mid = n // 2\n    if n == 1:\n        return str(max(0, k))\n    \n    for num in range(10**(mid) - 1, 10**(mid - 1) - 1, -1):\n        half = str(num)\n        if n % 2 == 0:\n            candidate = int(half + half[::-1])\n        else:\n            candidate = int(half + half[-2::-1])\n        if candidate % k == 0:\n            return str(candidate)\n    return \"0\"\n```", "```python\ndef largestKPalindromic(n: int, k: int) -> str:\n    if n == 1:\n        return str(k * (k % 2 + 1))\n    \n    def is_palindrome(num):\n        return num == num[::-1]\n    \n    def make_divisible_by_k(base):\n        while True:\n            candidate = int(base + base[-2::-1])\n            if candidate % k == 0:\n                return str(candidate)\n            base = str(int(base) - 1).lstrip('0')\n    \n    if n % 2 == 1:\n        half_length = (n - 1) // 2\n        half = '9' * half_length\n        while True:\n            candidate = make_divisible_by_k(half)\n            if len(candidate) == n:\n                return candidate\n            half = str(int(half) - 1).lstrip('0')\n    else:\n        half_length = n // 2\n        half = '9' * half_length\n        while True:\n            candidate = make_divisible_by_k(half)\n            if len(candidate) == n:\n                return candidate\n            half = str(int(half) - 1).lstrip('0')"]}
{"task_id": "3560", "codes": ["def minKnightMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:\n    def moves_to_capture(kx, ky, px, py):\n        return abs(px - kx) + abs(py - ky)\n\n    def min_moves_for_pawn(positions):\n        min_moves = float('inf')\n        for px, py in positions:\n            p_moves = moves_to_capture(kx, ky, px, py)\n            min_moves = min(min_moves, p_moves)\n        return min_moves\n\n    total_moves = 0\n    while positions:\n        min_moves = min_moves_for_pawn(positions)\n        positions = [pos for pos in positions if moves_to_capture(kx, ky, *pos) != min_moves]\n        total_moves += min_moves\n\n    return total_moves", "def min_moves_to_capture(knight_x, knight_y, pawn_x, pawn_y):\n    # Possible knight moves\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(knight_x, knight_y, 0)]\n    visited = set()\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if (x, y) == (pawn_x, pawn_y):\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_alice_moves(kx, ky, positions):\n    n = len(positions)\n    mask = (1 << n) - 1\n    \n    @lru_cache(None)\n    def dp(state):\n        if state == 0:\n            return 0\n        \n        moves = 0\n        for i in range(n):\n            if state & (1 << i):\n                moves = max(moves, min_moves_to_capture(kx, ky, positions[i][0], positions[i][1]) + dp(state ^ (1 << i)))\n        \n        return moves\n    \n    return dp(mask)\n\nfrom functools import lru_cache\n\n# Example usage\nprint(max_alice_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_alice_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_alice_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3", "def min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(0, kx, ky)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        steps, x, y = queue.pop(0)\n        if (x, y) == (px, py):\n            return steps\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((steps + 1, nx, ny))\n    return float('inf')\n\ndef max_alice_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    key = (kx, ky, tuple(sorted(positions)))\n    if key in memo:\n        return memo[key]\n    \n    max_moves = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        if moves == float('inf'):\n            continue\n        remaining_positions = positions[:i] + positions[i+1:]\n        bob_moves = max_alice_moves(px, py, remaining_positions, memo)\n        total_moves = moves + bob_moves\n        if total_moves > max_moves:\n            max_moves = total_moves\n    \n    memo[key] = max_moves\n    return max_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return max_alice_moves(kx, ky, positions, memo)", "def min_moves(kx, ky, px, py):\n    dx = abs(px - kx)\n    dy = abs(py - ky)\n    if dx % 2 == dy % 2:\n        return max(dx, dy) // 2 + (dx != dy)\n    else:\n        return max(dx, dy) // 2\n\ndef dfs(kx, ky, positions, alice_turn, memo):\n    if not positions:\n        return 0\n    \n    pos_tuple = tuple(positions)\n    if (pos_tuple, alice_turn) in memo:\n        return memo[(pos_tuple, alice_turn)]\n    \n    if alice_turn:\n        max_moves = float('-inf')\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves(kx, ky, px, py)\n            remaining_positions = positions[:i] + positions[i+1:]\n            opponent_moves = dfs(px, py, remaining_positions, False, memo)\n            max_moves = max(max_moves, moves + opponent_moves)\n        memo[(pos_tuple, alice_turn)] = max_moves\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves(kx, ky, px, py)\n            remaining_positions = positions[:i] + positions[i+1:]\n            opponent_moves = dfs(px, py, remaining_positions, True, memo)\n            min_moves = min(min_moves, opponent_moves)\n        memo[(pos_tuple, alice_turn)] = min_moves\n        return min_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return dfs(kx, ky, positions, True, memo)", "def max_total_moves(kx, ky, positions):\n    def min_knight_moves(kx, ky, px, py):\n        directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n        queue = deque([(kx, ky, 0)])\n        visited = set((kx, ky))\n        \n        while queue:\n            cx, cy, steps = queue.popleft()\n            \n            if cx == px and cy ==", "```python\ndef min_moves_to_capture(knight_pos, pawn_pos):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(knight_pos[0], knight_pos[1], 0)]\n    visited = set(queue)\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        \n        if (x, y) == pawn_pos:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [[-1] * (1 << n) for _ in range(n)]\n    \n    def dfs(state, alice_turn):\n        if state == 0:\n            return 0\n        \n        if dp[state][alice_turn] != -1:\n            return dp[state][alice_turn]\n        \n        moves = 0\n        mask = 1\n        \n        for i in range(n):\n            if state & mask:\n                knight_pos = (ky, kx)\n                pawn_pos = (positions[i][0], positions[i][1])\n                \n                if alice_turn:\n                    alice_moves = float('-inf')\n                    \n                    for j in range(n):\n                        if state & (1 << j) and j != i:\n                            knight_pos = (kx, ky)\n                            knight_pos = (knight_pos[0] + 2 * (pawn_pos[0] - knight_pos[0]) // abs(pawn_pos[0] - knight_pos[0]),\n                                          knight_pos[1] + 2 * (pawn_pos[1] - knight_pos[1]) // abs(pawn_pos[1] - knight_pos[1]))\n                            \n                            alice_moves = max(alice_moves, min_moves_to_capture(knight_pos, pawn_pos) + dfs(state ^ (1 << i) ^ (1 << j), False))\n                    \n                    moves = max(moves, alice_moves)\n                else:\n                    bob_moves = float('inf')\n                    \n                    for j in range(n):\n                        if state & (1 << j) and j != i:\n                            knight_pos = (kx, ky)\n                            knight_pos = (knight_pos[0] + 2 * (pawn_pos[0] - knight_pos[0]) // abs(pawn_pos[0] - knight_pos[0]),\n                                          knight_pos[1] + 2 * (pawn_pos[1] - knight_pos[1]) // abs(pawn_pos[1] - knight_pos[1]))\n                            \n                            bob_moves = min(bob_moves, min_moves_to_capture(knight_pos, pawn_pos) + dfs(state ^ (1 << i) ^ (1 << j), True))\n                    \n                    moves = min(moves, bob_moves)\n            \n            mask <<= 1\n        \n        dp[state][alice_turn] = moves", "def min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, steps = queue.pop(0)\n        \n        if (cx, cy) == (px, py):\n            return steps\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n                \n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    memo = {}\n    \n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        \n        key = tuple(sorted(pawns)) + (turn,)\n        if key in memo:\n            return memo[key]\n        \n        if turn == 'A':\n            max_moves = 0\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    remaining_pawns = pawns[:i] + pawns[i+1:]\n                    max_moves = max(max_moves, moves + dfs(remaining_pawns, 'B'))\n            memo[key] = max_moves\n        else:\n            min_moves = float('inf')\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    remaining_pawns = pawns[:i] + pawns[i+1:]\n                    min_moves = min(min_moves, moves + dfs(remaining_pawns, 'A'))\n            memo[key] = min_moves\n            \n        return memo[key]\n    \n    return dfs(positions, 'A')\n\ndef max_total_moves(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)", "def min_moves(knight_x, knight_y, pawn_x, pawn_y):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = [(knight_x, knight_y, 0)]\n    visited = set((knight_x, knight_y))\n    \n    while queue:\n        cx, cy, steps = queue.pop(0)\n        if (cx, cy) == (pawn_x, pawn_y):\n            return steps\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n\n@cache\ndef dfs(kx, ky, positions):\n    if not positions:\n        return 0\n    \n    max_moves = float('-inf')\n    for px, py in positions:\n        moves = min_moves(kx, ky, px, py)\n        new_positions = [pos for pos in positions if pos != (px, py)]\n        opponent_moves = dfs(px, py, new_positions)\n        max_moves = max(max_moves, moves + opponent_moves)\n    \n    return max_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    return dfs(kx, ky, tuple(positions))"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["def minKnightMoves(self, kx: int, ky: int, positions: List[List[int]]) -> int:\n    def moves_to_capture(kx, ky, px, py):\n        return abs(px - kx) + abs(py - ky)\n\n    def min_moves_for_pawn(positions):\n        min_moves = float('inf')\n        for px, py in positions:\n            p_moves = moves_to_capture(kx, ky, px, py)\n            min_moves = min(min_moves, p_moves)\n        return min_moves\n\n    total_moves = 0\n    while positions:\n        min_moves = min_moves_for_pawn(positions)\n        positions = [pos for pos in positions if moves_to_capture(kx, ky, *pos) != min_moves]\n        total_moves += min_moves\n\n    return total_moves", "```python\ndef min_moves_to_capture(knight_x, knight_y, pawn_x, pawn_y):\n    # Possible knight moves\n    directions = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(knight_x, knight_y, 0)]\n    visited = set()\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        if (x, y) == (pawn_x, pawn_y):\n            return moves\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_alice_moves(kx, ky, positions):\n    n = len(positions)\n    mask = (1 << n) - 1\n    \n    @lru_cache(None)\n    def dp(state):\n        if state == 0:\n            return 0\n        \n        moves = 0\n        for i in range(n):\n            if state & (1 << i):\n                moves = max(moves, min_moves_to_capture(kx, ky, positions[i][0], positions[i][1]) + dp(state ^ (1 << i)))\n        \n        return moves\n    \n    return dp(mask)\n\nfrom functools import lru_cache\n\n# Example usage\nprint(max_alice_moves(1, 1, [[0, 0]]))  # Output: 4\nprint(max_alice_moves(0, 2, [[1, 1], [2, 2], [3, 3]]))  # Output: 8\nprint(max_alice_moves(0, 0, [[1, 2], [2, 4]]))  # Output: 3\n```", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    queue = [(0, kx, ky)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        steps, x, y = queue.pop(0)\n        if (x, y) == (px, py):\n            return steps\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((steps + 1, nx, ny))\n    return float('inf')\n\ndef max_alice_moves(kx, ky, positions, memo):\n    if not positions:\n        return 0\n    key = (kx, ky, tuple(sorted(positions)))\n    if key in memo:\n        return memo[key]\n    \n    max_moves = 0\n    for i, (px, py) in enumerate(positions):\n        moves = min_moves_to_capture(kx, ky, px, py)\n        if moves == float('inf'):\n            continue\n        remaining_positions = positions[:i] + positions[i+1:]\n        bob_moves = max_alice_moves(px, py, remaining_positions, memo)\n        total_moves = moves + bob_moves\n        if total_moves > max_moves:\n            max_moves = total_moves\n    \n    memo[key] = max_moves\n    return max_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return max_alice_moves(kx, ky, positions, memo)\n```", "```python\ndef min_moves(kx, ky, px, py):\n    dx = abs(px - kx)\n    dy = abs(py - ky)\n    if dx % 2 == dy % 2:\n        return max(dx, dy) // 2 + (dx != dy)\n    else:\n        return max(dx, dy) // 2\n\ndef dfs(kx, ky, positions, alice_turn, memo):\n    if not positions:\n        return 0\n    \n    pos_tuple = tuple(positions)\n    if (pos_tuple, alice_turn) in memo:\n        return memo[(pos_tuple, alice_turn)]\n    \n    if alice_turn:\n        max_moves = float('-inf')\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves(kx, ky, px, py)\n            remaining_positions = positions[:i] + positions[i+1:]\n            opponent_moves = dfs(px, py, remaining_positions, False, memo)\n            max_moves = max(max_moves, moves + opponent_moves)\n        memo[(pos_tuple, alice_turn)] = max_moves\n        return max_moves\n    else:\n        min_moves = float('inf')\n        for i, (px, py) in enumerate(positions):\n            moves = min_moves(kx, ky, px, py)\n            remaining_positions = positions[:i] + positions[i+1:]\n            opponent_moves = dfs(px, py, remaining_positions, True, memo)\n            min_moves = min(min_moves, opponent_moves)\n        memo[(pos_tuple, alice_turn)] = min_moves\n        return min_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    memo = {}\n    return dfs(kx, ky, positions, True, memo)\n```", "def max_total_moves(kx, ky, positions):\n    def min_knight_moves(kx, ky, px, py):\n        directions = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n        queue = deque([(kx, ky, 0)])\n        visited = set((kx, ky))\n        \n        while queue:\n            cx, cy, steps = queue.popleft()\n            \n            if cx == px and cy ==", "```python\ndef min_moves_to_capture(knight_pos, pawn_pos):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(knight_pos[0], knight_pos[1], 0)]\n    visited = set(queue)\n    \n    while queue:\n        x, y, moves = queue.pop(0)\n        \n        if (x, y) == pawn_pos:\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves + 1))\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    dp = [[-1] * (1 << n) for _ in range(n)]\n    \n    def dfs(state, alice_turn):\n        if state == 0:\n            return 0\n        \n        if dp[state][alice_turn] != -1:\n            return dp[state][alice_turn]\n        \n        moves = 0\n        mask = 1\n        \n        for i in range(n):\n            if state & mask:\n                knight_pos = (ky, kx)\n                pawn_pos = (positions[i][0], positions[i][1])\n                \n                if alice_turn:\n                    alice_moves = float('-inf')\n                    \n                    for j in range(n):\n                        if state & (1 << j) and j != i:\n                            knight_pos = (kx, ky)\n                            knight_pos = (knight_pos[0] + 2 * (pawn_pos[0] - knight_pos[0]) // abs(pawn_pos[0] - knight_pos[0]),\n                                          knight_pos[1] + 2 * (pawn_pos[1] - knight_pos[1]) // abs(pawn_pos[1] - knight_pos[1]))\n                            \n                            alice_moves = max(alice_moves, min_moves_to_capture(knight_pos, pawn_pos) + dfs(state ^ (1 << i) ^ (1 << j), False))\n                    \n                    moves = max(moves, alice_moves)\n                else:\n                    bob_moves = float('inf')\n                    \n                    for j in range(n):\n                        if state & (1 << j) and j != i:\n                            knight_pos = (kx, ky)\n                            knight_pos = (knight_pos[0] + 2 * (pawn_pos[0] - knight_pos[0]) // abs(pawn_pos[0] - knight_pos[0]),\n                                          knight_pos[1] + 2 * (pawn_pos[1] - knight_pos[1]) // abs(pawn_pos[1] - knight_pos[1]))\n                            \n                            bob_moves = min(bob_moves, min_moves_to_capture(knight_pos, pawn_pos) + dfs(state ^ (1 << i) ^ (1 << j), True))\n                    \n                    moves = min(moves, bob_moves)\n            \n            mask <<= 1\n        \n        dp[state][alice_turn] = moves", "```python\ndef min_moves_to_capture(kx, ky, px, py):\n    directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    queue = [(kx, ky, 0)]\n    visited = set()\n    visited.add((kx, ky))\n    \n    while queue:\n        cx, cy, steps = queue.pop(0)\n        \n        if (cx, cy) == (px, py):\n            return steps\n        \n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            \n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n                \n    return float('inf')\n\ndef max_moves_alice(kx, ky, positions):\n    n = len(positions)\n    memo = {}\n    \n    def dfs(pawns, turn):\n        if not pawns:\n            return 0\n        \n        key = tuple(sorted(pawns)) + (turn,)\n        if key in memo:\n            return memo[key]\n        \n        if turn == 'A':\n            max_moves = 0\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    remaining_pawns = pawns[:i] + pawns[i+1:]\n                    max_moves = max(max_moves, moves + dfs(remaining_pawns, 'B'))\n            memo[key] = max_moves\n        else:\n            min_moves = float('inf')\n            for i, (px, py) in enumerate(pawns):\n                moves = min_moves_to_capture(kx, ky, px, py)\n                if moves < float('inf'):\n                    remaining_pawns = pawns[:i] + pawns[i+1:]\n                    min_moves = min(min_moves, moves + dfs(remaining_pawns, 'A'))\n            memo[key] = min_moves\n            \n        return memo[key]\n    \n    return dfs(positions, 'A')\n\ndef max_total_moves(kx, ky, positions):\n    return max_moves_alice(kx, ky, positions)\n```", "```python\ndef min_moves(knight_x, knight_y, pawn_x, pawn_y):\n    directions = [\n        (-2, -1), (-2, 1), (-1, -2), (-1, 2),\n        (1, -2), (1, 2), (2, -1), (2, 1)\n    ]\n    queue = [(knight_x, knight_y, 0)]\n    visited = set((knight_x, knight_y))\n    \n    while queue:\n        cx, cy, steps = queue.pop(0)\n        if (cx, cy) == (pawn_x, pawn_y):\n            return steps\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < 50 and 0 <= ny < 50 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n\n@cache\ndef dfs(kx, ky, positions):\n    if not positions:\n        return 0\n    \n    max_moves = float('-inf')\n    for px, py in positions:\n        moves = min_moves(kx, ky, px, py)\n        new_positions = [pos for pos in positions if pos != (px, py)]\n        opponent_moves = dfs(px, py, new_positions)\n        max_moves = max(max_moves, moves + opponent_moves)\n    \n    return max_moves\n\ndef knight_pawn_game(kx, ky, positions):\n    return dfs(kx, ky, tuple(positions))\n```"]}
{"task_id": "3532", "codes": ["def find_min_time_to_mark_all_nodes(edges):\n    from collections import defaultdict\n    \n    # Step 1: Build the tree as an adjacency list\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def dfs(node, parent, level):\n        max_time = 0\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_time = dfs(neighbor, node, level + 1)\n                if node % 2 == 0:\n                    max_time = max(max_time, child_time - 2)\n                else:\n                    max_time = max(max_time, child_time - 1)\n        return level + max_time\n    \n    # Step 2: Calculate the minimum time to mark all nodes starting from each node\n    n = len(edges) + 1\n    result = [float('inf')] * n\n    for i in range(n):\n        result[i] = dfs(i, -1, 0)\n    \n    return result\n\n# Example usage:\nprint(find_min_time_to_mark_all_nodes([[0,1],[0,2]]))  # Output: [2, 4, 3]\nprint(find_min_time_to_mark_all_nodes([[0,1]]))       # Output: [1, 2]\nprint(find_min_time_to_mark_all_nodes([[2,4],[0,1],[2,3],[0,2]]))  # Output: [4, 6, 3, 5, 5]", "def get_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    \n    # Build the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    def dfs(node, parent, time):\n        times[node] = time\n        \n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 1)\n    \n    times = [-1] * n\n    dfs(0, -1, 0)\n    \n    return times", "def get_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    \n    # Build adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize distances and visited set\n    dist = [-1] * n\n    visited = set()\n    \n    # Function to perform BFS and calculate marking times\n    def bfs(start):\n        queue = [(start, 0)]\n        dist[start] = 0\n        visited.add(start)\n        \n        while queue:\n            node, time = queue.pop(0)\n            \n            for neighbor in adj_list[node]:\n                if neighbor not in visited:\n                    if node % 2 == 0:\n                        new_time = time + 2\n                    else:\n                        new_time = time + 1\n                    \n                    if dist[neighbor] < new_time:\n                        dist[neighbor] = new_time\n                        queue.append((neighbor, new_time))\n                    visited.add(neighbor)\n    \n    # Perform BFS for each node\n    for i in range(n):\n        if i not in visited:\n            bfs(i)\n    \n    return dist", "def find_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    \n    # Build adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize marking times and visited set\n    marking_times = {i: float('inf') for i in range(n)}\n    marking_times[0] = 0\n    \n    # BFS to find marking times\n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in adj_list[current]:\n            if marking_times[neighbor] == float('inf'):\n                if current % 2 == 0:\n                    marking_times[neighbor] = max(marking_times[current], marking_times[current] - 1) + 2\n                else:\n                    marking_times[neighbor] = max(marking_times[current], marking_times[current] - 2) + 2\n                queue.append(neighbor)\n    \n    return [marking_times[i] for i in range(n)]", "def min_time_to_mark_nodes(edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the adjacency list\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Initialize marking status and queue for BFS\n    marked = {i: False for i in range(n)}\n    times = [0] * n\n    queue = deque()\n    \n    # Step 3: Perform BFS to simulate marking process\n    for node in range(n):\n        if not marked[node]:\n            queue.append((node, 0))\n            while queue:\n                current_node, current_time = queue.popleft()\n                marked[current_node] = True\n                times[current_node] = current_time\n                \n                for neighbor in adj_list[current_node]:\n                    if not marked[neighbor]:\n                        if current_node % 2 == 0:\n                            queue.append((neighbor, current_time + 2))\n                        else:\n                            queue.append((neighbor, current_time + 1))\n    \n    return times", "def minTimes(n, edges):\n    def bfs(start):\n        visited = [False] * n\n        queue = [(start, 0)]\n        while queue:\n            node, time = queue.pop(0)\n            if not visited[node]:\n                visited[node] = True\n                times[node] = time\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        queue.append((neighbor, time + 2))\n    \n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    times = [float('inf')] * n\n    for i in range(n):\n        bfs(i)\n    \n    return times", "from collections import defaultdict, deque\n\ndef min_times_to_mark_all_nodes(edges):\n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    # Build the graph\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        marked_time = {start: 0}\n        \n        while queue:\n            node = queue.popleft()\n            current_time = marked_time[node]\n            \n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if node % 2 == 0:\n                        next_time = current_time + 2\n                    else:\n                        next_time = current_time + 1\n                    marked_time[neighbor] = next_time\n                    queue.append(neighbor)\n        \n        return max(marked_time.values())\n    \n    return [bfs(i) for i in range(n)]", "def marking_times(edges):\n    def bfs_mark(node, start_time):\n        from collections import deque\n        queue = deque([(node, start_time)])\n        visited = set()\n        while queue:\n            current_node, current_time = queue.popleft()\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n            times[current_node] = max(times[current_node], current_time)\n            for neighbor in adj_list[current_node]:\n                if neighbor not in visited:\n                    if current_node % 2 == 0:\n                        next_time = current_time + 2\n                    else:\n                        next_time = current_time + 1\n                    queue.append((neighbor, next_time))\n    \n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    times = [0] * n\n    \n    # Simulate marking process for each node\n    for i in range(n):\n        bfs_mark(i, 0)\n    \n    return times"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef find_min_time_to_mark_all_nodes(edges):\n    from collections import defaultdict\n    \n    # Step 1: Build the tree as an adjacency list\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    def dfs(node, parent, level):\n        max_time = 0\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_time = dfs(neighbor, node, level + 1)\n                if node % 2 == 0:\n                    max_time = max(max_time, child_time - 2)\n                else:\n                    max_time = max(max_time, child_time - 1)\n        return level + max_time\n    \n    # Step 2: Calculate the minimum time to mark all nodes starting from each node\n    n = len(edges) + 1\n    result = [float('inf')] * n\n    for i in range(n):\n        result[i] = dfs(i, -1, 0)\n    \n    return result\n\n# Example usage:\nprint(find_min_time_to_mark_all_nodes([[0,1],[0,2]]))  # Output: [2, 4, 3]\nprint(find_min_time_to_mark_all_nodes([[0,1]]))       # Output: [1, 2]\nprint(find_min_time_to_mark_all_nodes([[2,4],[0,1],[2,3],[0,2]]))  # Output: [4, 6, 3, 5, 5]\n```", "```python\ndef get_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    \n    # Build the adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    def dfs(node, parent, time):\n        times[node] = time\n        \n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, time + 1)\n    \n    times = [-1] * n\n    dfs(0, -1, 0)\n    \n    return times\n```", "```python\ndef get_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    \n    # Build adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize distances and visited set\n    dist = [-1] * n\n    visited = set()\n    \n    # Function to perform BFS and calculate marking times\n    def bfs(start):\n        queue = [(start, 0)]\n        dist[start] = 0\n        visited.add(start)\n        \n        while queue:\n            node, time = queue.pop(0)\n            \n            for neighbor in adj_list[node]:\n                if neighbor not in visited:\n                    if node % 2 == 0:\n                        new_time = time + 2\n                    else:\n                        new_time = time + 1\n                    \n                    if dist[neighbor] < new_time:\n                        dist[neighbor] = new_time\n                        queue.append((neighbor, new_time))\n                    visited.add(neighbor)\n    \n    # Perform BFS for each node\n    for i in range(n):\n        if i not in visited:\n            bfs(i)\n    \n    return dist\n```", "```python\ndef find_marking_times(edges):\n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    \n    # Build adjacency list\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Initialize marking times and visited set\n    marking_times = {i: float('inf') for i in range(n)}\n    marking_times[0] = 0\n    \n    # BFS to find marking times\n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in adj_list[current]:\n            if marking_times[neighbor] == float('inf'):\n                if current % 2 == 0:\n                    marking_times[neighbor] = max(marking_times[current], marking_times[current] - 1) + 2\n                else:\n                    marking_times[neighbor] = max(marking_times[current], marking_times[current] - 2) + 2\n                queue.append(neighbor)\n    \n    return [marking_times[i] for i in range(n)]\n```", "```python\ndef min_time_to_mark_nodes(edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the adjacency list\n    n = len(edges) + 1\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Step 2: Initialize marking status and queue for BFS\n    marked = {i: False for i in range(n)}\n    times = [0] * n\n    queue = deque()\n    \n    # Step 3: Perform BFS to simulate marking process\n    for node in range(n):\n        if not marked[node]:\n            queue.append((node, 0))\n            while queue:\n                current_node, current_time = queue.popleft()\n                marked[current_node] = True\n                times[current_node] = current_time\n                \n                for neighbor in adj_list[current_node]:\n                    if not marked[neighbor]:\n                        if current_node % 2 == 0:\n                            queue.append((neighbor, current_time + 2))\n                        else:\n                            queue.append((neighbor, current_time + 1))\n    \n    return times\n```", "```python\ndef minTimes(n, edges):\n    def bfs(start):\n        visited = [False] * n\n        queue = [(start, 0)]\n        while queue:\n            node, time = queue.pop(0)\n            if not visited[node]:\n                visited[node] = True\n                times[node] = time\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        queue.append((neighbor, time + 2))\n    \n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    times = [float('inf')] * n\n    for i in range(n):\n        bfs(i)\n    \n    return times\n```", "```python\nfrom collections import defaultdict, deque\n\ndef min_times_to_mark_all_nodes(edges):\n    n = len(edges) + 1\n    graph = defaultdict(list)\n    \n    # Build the graph\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        marked_time = {start: 0}\n        \n        while queue:\n            node = queue.popleft()\n            current_time = marked_time[node]\n            \n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    if node % 2 == 0:\n                        next_time = current_time + 2\n                    else:\n                        next_time = current_time + 1\n                    marked_time[neighbor] = next_time\n                    queue.append(neighbor)\n        \n        return max(marked_time.values())\n    \n    return [bfs(i) for i in range(n)]\n```", "```python\ndef marking_times(edges):\n    def bfs_mark(node, start_time):\n        from collections import deque\n        queue = deque([(node, start_time)])\n        visited = set()\n        while queue:\n            current_node, current_time = queue.popleft()\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n            times[current_node] = max(times[current_node], current_time)\n            for neighbor in adj_list[current_node]:\n                if neighbor not in visited:\n                    if current_node % 2 == 0:\n                        next_time = current_time + 2\n                    else:\n                        next_time = current_time + 1\n                    queue.append((neighbor, next_time))\n    \n    n = len(edges) + 1\n    adj_list = [[] for _ in range(n)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    times = [0] * n\n    \n    # Simulate marking process for each node\n    for i in range(n):\n        bfs_mark(i, 0)\n    \n    return times\n```"]}
{"task_id": "3548", "codes": ["from math import factorial\n\ndef count_good_integers(n, k):\n    def mod_inv(a, m):\n        return pow(a, m - 2, m)\n    \n    def nCr(n, r, p):\n        num = den = 1\n        for i in range(r):\n            num = (num * (n - i)) % p\n            den = (den * (i + 1)) % p\n        return (num * mod_inv(den, p)) % p\n    \n    def count_divisible_by_k(n, k):\n        if n == 1:\n            return 1 if k in [1, 2, 5] else 0\n        \n        count = 0\n        for i in range(1, 10):\n            if i % k == 0:\n                count += nCr(10, i, 10) * nCr(n - 1, i // 2, 10)\n        \n        return count\n\n    return count_divisible_by_k(n, k)\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468", "```python\nfrom math import factorial as fact\n\ndef count_good_integers(n, k):\n    def count_combinations_with_modulo(target_sum, target_mod, num_digits):\n        if num_digits == 1:\n            return 1 if target_sum % target_mod == 0 else 0\n        \n        total_count = 0\n        for i in range(10):\n            if i > target_sum:\n                break\n            total_count += count_combinations_with_modulo(target_sum - i, target_mod, num_digits - 1)\n        \n        return total_count\n    \n    def count_permutations(digits):\n        numerator = fact(sum(digits))\n        denominator = 1\n        for d in set(digits):\n            denominator *= fact(digits.count(d))\n        return numerator // denominator\n    \n    def is_k_palindromic(arr):\n        freq = [arr[i] for i in range(len(arr)) if arr[i] != 0]\n        mid = len(freq) // 2\n        left = sum(freq[:mid])\n        right = sum(freq[mid:])", "def countGoodIntegers(n, k):\n    def count_ways(digit_count, used_digits):\n        if sum(digit_count.values()) == 0:\n            return 1 if sum(used_digits % i == 0 for i in range(1, k + 1)) > 0 else 0\n        \n        total = 0\n        for d in range(10):\n            if digit_count[d] > 0:\n                digit_count[d] -= 1\n                used_digits += d\n                total += count_ways(digit_count, used_digits)\n                used_digits -= d\n                digit_count[d] += 1\n        return total\n    \n    def count_palindromic_numbers(n):\n        if n == 1:\n            return k * (k // 2 + 1)  # Only half of the numbers between 1 and 9*k are even and thus can be palindromic\n        if n == 2:\n            return k * (k // 2 + 1) * 2  # Both halves of the number can be the same\n        return 0\n    \n    if n == 1:\n        return k * (k // 2 + 1)\n    \n    dp = [[0] * (1 << 10) for _ in range(n)]\n    for mask in range(1 << 10):\n        dp[0][mask] = 1\n    \n    for length in range(1, n):\n        for mask in range(1 << 10):\n            digit_count = {i: 0 for i in range(10)}\n            for i in range(10):\n                if mask & (1 << i):\n                    digit_count[i] += 1\n            \n            dp[length][mask] = sum(dp[length - 1][m] for m in range(1 << 10) if (m & mask == 0) and (m & (1 << 0) == 0))\n    \n    result = 0\n    for mask in range(1 << 10):\n        digit_count = {i: 0 for i in range(10)}\n        for i in range(10):\n            if mask & (1 << i):\n                digit_count[i] += 1\n        \n        if sum(digit_count.values()) == n:\n            result += dp[n - 1][mask]\n    \n    return result", "def count_good_integers(n, k):\n    def can_form_k_palindrome(digits):\n        count = [0] * 10\n        for digit in digits:\n            count[digit] += 1\n        odd_count = sum(1 for c in count if c % 2 != 0)\n        return odd_count <= 1 and sum(int(d) * (count[int(d)] // k) for d in range(10)) >= k\n    \n    count = 0\n    for i in range(10**(n-1), 10**n):\n        if str(i)[::-1] == str(i) and i % k == 0:\n            count += 1\n    return count", "def count_good_integers(n, k):\n    # Initialize dp table\n    dp = [[0] * 10 for _ in range(1 << 10)]\n    \n    # Base case: single digit numbers\n    for d in range(1, 10):\n        dp[1 << d][d] = 1\n    \n    # Fill dp table\n    for mask in range(1, 1 << 10):\n        for i in range(10):\n            if mask & (1 << i):\n                new_mask = mask ^ (1 << i)\n                for j in range(10):\n                    if new_mask & (1 << j):\n                        dp[mask][i] += dp[new_mask][j]\n    \n    # Count valid n-digit numbers\n    count = 0\n    for mask in range(1, 1 << 10):\n        if bin(mask).count('1') == n:\n            num = int(bin(mask)[2:])\n            if num % k == 0:\n                count += dp[mask][num % 10]\n    \n    return count", "def countGoodIntegers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    @lru_cache(None)\n    def dp(mask, i, tight, even):\n        if i == n:\n            return int(is_palindrome(str(mask)) and mask % k == 0)\n        \n        res = 0\n        ub = 9 if tight else mask // (10**(n-i-1))\n        for d in range(ub + 1):\n            if d == 0 and i == 0:\n                continue\n            new_mask = mask * 10 + d\n            new_tight = tight and d == ub\n            new_even = even ^ (d != 0)\n            res += dp(new_mask, i + 1, new_tight, new_even)\n        \n        return res\n    \n    return dp(0, 0, True, False)", "def countGoodIntegers(n, k):\n    def count_palindrome_divisible_by_k(n, k):\n        if n == 1:\n            return sum(1 for i in range(1, k + 1) if i % k == 0)\n        \n        half_n = (n + 1) // 2\n        count = 0\n        \n        # Iterate over all possible digit sums for the first half\n        for dsum in range(half_n, min(k * half_n, 45) + 1):\n            # Calculate the number of ways to choose digits such that their sum is dsum\n            ways = [0] * (dsum + 1)\n            ways[0] = 1\n            for d in range(1, 10):\n                for j in range(dsum, d - 1, -1):\n                    ways[j] += ways[j - d]\n            \n            # If n is odd, we need to ensure the middle digit is used\n            if n % 2 != 0:\n                for mid_digit in range(1, 10):\n                    if dsum - mid_digit >= 0:\n                        count += ways[dsum - mid_digit]\n            else:\n                count += ways[dsum]\n        \n        # Check divisibility by k\n        count = sum(1 for num in range(int('1' + '0' * (n - 1)), int('9' * n) + 1) if num % k == 0 and str(num) == str(num)[::-1])\n        \n        return count\n    \n    return count_palindrome_divisible_by_k(n, k)", "def count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits, target_sum, used_count, current_combination):\n        if target_sum == 0:\n            if is_palindrome(''.join(str(digit) * count for digit, count in used_count.items())):\n                yield ''.join(str(digit) * count for digit, count in used_count.items())\n            return\n        if target_sum < 0:\n            return\n        \n        for digit in range(10):\n            if digit in used_count and used_count[digit] > 0:\n                used_count[digit] -= 1\n                yield from count_combinations(digits, target_sum - digit, used_count, current_combination + [digit])\n                used_count[digit] += 1\n    \n    total_count = 0\n    used_count = {i: 0 for i in range(10)}\n    \n    for length in range(1, n + 1):\n        for combination in count_combinations(range(10), length * k, used_count.copy(), []):\n            if len(combination) == n:\n                total_count += 1\n                \n    return total_count"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nfrom math import factorial\n\ndef count_good_integers(n, k):\n    def mod_inv(a, m):\n        return pow(a, m - 2, m)\n    \n    def nCr(n, r, p):\n        num = den = 1\n        for i in range(r):\n            num = (num * (n - i)) % p\n            den = (den * (i + 1)) % p\n        return (num * mod_inv(den, p)) % p\n    \n    def count_divisible_by_k(n, k):\n        if n == 1:\n            return 1 if k in [1, 2, 5] else 0\n        \n        count = 0\n        for i in range(1, 10):\n            if i % k == 0:\n                count += nCr(10, i, 10) * nCr(n - 1, i // 2, 10)\n        \n        return count\n\n    return count_divisible_by_k(n, k)\n\n# Example usage:\nprint(count_good_integers(3, 5))  # Output: 27\nprint(count_good_integers(1, 4))  # Output: 2\nprint(count_good_integers(5, 6))  # Output: 2468\n```", "```python\nfrom math import factorial as fact\n\ndef count_good_integers(n, k):\n    def count_combinations_with_modulo(target_sum, target_mod, num_digits):\n        if num_digits == 1:\n            return 1 if target_sum % target_mod == 0 else 0\n        \n        total_count = 0\n        for i in range(10):\n            if i > target_sum:\n                break\n            total_count += count_combinations_with_modulo(target_sum - i, target_mod, num_digits - 1)\n        \n        return total_count\n    \n    def count_permutations(digits):\n        numerator = fact(sum(digits))\n        denominator = 1\n        for d in set(digits):\n            denominator *= fact(digits.count(d))\n        return numerator // denominator\n    \n    def is_k_palindromic(arr):\n        freq = [arr[i] for i in range(len(arr)) if arr[i] != 0]\n        mid = len(freq) // 2\n        left = sum(freq[:mid])\n        right = sum(freq[mid:])", "```python\ndef countGoodIntegers(n, k):\n    def count_ways(digit_count, used_digits):\n        if sum(digit_count.values()) == 0:\n            return 1 if sum(used_digits % i == 0 for i in range(1, k + 1)) > 0 else 0\n        \n        total = 0\n        for d in range(10):\n            if digit_count[d] > 0:\n                digit_count[d] -= 1\n                used_digits += d\n                total += count_ways(digit_count, used_digits)\n                used_digits -= d\n                digit_count[d] += 1\n        return total\n    \n    def count_palindromic_numbers(n):\n        if n == 1:\n            return k * (k // 2 + 1)  # Only half of the numbers between 1 and 9*k are even and thus can be palindromic\n        if n == 2:\n            return k * (k // 2 + 1) * 2  # Both halves of the number can be the same\n        return 0\n    \n    if n == 1:\n        return k * (k // 2 + 1)\n    \n    dp = [[0] * (1 << 10) for _ in range(n)]\n    for mask in range(1 << 10):\n        dp[0][mask] = 1\n    \n    for length in range(1, n):\n        for mask in range(1 << 10):\n            digit_count = {i: 0 for i in range(10)}\n            for i in range(10):\n                if mask & (1 << i):\n                    digit_count[i] += 1\n            \n            dp[length][mask] = sum(dp[length - 1][m] for m in range(1 << 10) if (m & mask == 0) and (m & (1 << 0) == 0))\n    \n    result = 0\n    for mask in range(1 << 10):\n        digit_count = {i: 0 for i in range(10)}\n        for i in range(10):\n            if mask & (1 << i):\n                digit_count[i] += 1\n        \n        if sum(digit_count.values()) == n:\n            result += dp[n - 1][mask]\n    \n    return result\n```", "```python\ndef count_good_integers(n, k):\n    def can_form_k_palindrome(digits):\n        count = [0] * 10\n        for digit in digits:\n            count[digit] += 1\n        odd_count = sum(1 for c in count if c % 2 != 0)\n        return odd_count <= 1 and sum(int(d) * (count[int(d)] // k) for d in range(10)) >= k\n    \n    count = 0\n    for i in range(10**(n-1), 10**n):\n        if str(i)[::-1] == str(i) and i % k == 0:\n            count += 1\n    return count\n```", "```python\ndef count_good_integers(n, k):\n    # Initialize dp table\n    dp = [[0] * 10 for _ in range(1 << 10)]\n    \n    # Base case: single digit numbers\n    for d in range(1, 10):\n        dp[1 << d][d] = 1\n    \n    # Fill dp table\n    for mask in range(1, 1 << 10):\n        for i in range(10):\n            if mask & (1 << i):\n                new_mask = mask ^ (1 << i)\n                for j in range(10):\n                    if new_mask & (1 << j):\n                        dp[mask][i] += dp[new_mask][j]\n    \n    # Count valid n-digit numbers\n    count = 0\n    for mask in range(1, 1 << 10):\n        if bin(mask).count('1') == n:\n            num = int(bin(mask)[2:])\n            if num % k == 0:\n                count += dp[mask][num % 10]\n    \n    return count\n```", "```python\ndef countGoodIntegers(n, k):\n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    @lru_cache(None)\n    def dp(mask, i, tight, even):\n        if i == n:\n            return int(is_palindrome(str(mask)) and mask % k == 0)\n        \n        res = 0\n        ub = 9 if tight else mask // (10**(n-i-1))\n        for d in range(ub + 1):\n            if d == 0 and i == 0:\n                continue\n            new_mask = mask * 10 + d\n            new_tight = tight and d == ub\n            new_even = even ^ (d != 0)\n            res += dp(new_mask, i + 1, new_tight, new_even)\n        \n        return res\n    \n    return dp(0, 0, True, False)\n```", "```python\ndef countGoodIntegers(n, k):\n    def count_palindrome_divisible_by_k(n, k):\n        if n == 1:\n            return sum(1 for i in range(1, k + 1) if i % k == 0)\n        \n        half_n = (n + 1) // 2\n        count = 0\n        \n        # Iterate over all possible digit sums for the first half\n        for dsum in range(half_n, min(k * half_n, 45) + 1):\n            # Calculate the number of ways to choose digits such that their sum is dsum\n            ways = [0] * (dsum + 1)\n            ways[0] = 1\n            for d in range(1, 10):\n                for j in range(dsum, d - 1, -1):\n                    ways[j] += ways[j - d]\n            \n            # If n is odd, we need to ensure the middle digit is used\n            if n % 2 != 0:\n                for mid_digit in range(1, 10):\n                    if dsum - mid_digit >= 0:\n                        count += ways[dsum - mid_digit]\n            else:\n                count += ways[dsum]\n        \n        # Check divisibility by k\n        count = sum(1 for num in range(int('1' + '0' * (n - 1)), int('9' * n) + 1) if num % k == 0 and str(num) == str(num)[::-1])\n        \n        return count\n    \n    return count_palindrome_divisible_by_k(n, k)\n```", "```python\ndef count_good_integers(n, k):\n    if n == 1:\n        return len([i for i in range(1, 10) if i % k == 0])\n    \n    def is_palindrome(s):\n        return s == s[::-1]\n    \n    def count_combinations(digits, target_sum, used_count, current_combination):\n        if target_sum == 0:\n            if is_palindrome(''.join(str(digit) * count for digit, count in used_count.items())):\n                yield ''.join(str(digit) * count for digit, count in used_count.items())\n            return\n        if target_sum < 0:\n            return\n        \n        for digit in range(10):\n            if digit in used_count and used_count[digit] > 0:\n                used_count[digit] -= 1\n                yield from count_combinations(digits, target_sum - digit, used_count, current_combination + [digit])\n                used_count[digit] += 1\n    \n    total_count = 0\n    used_count = {i: 0 for i in range(10)}\n    \n    for length in range(1, n + 1):\n        for combination in count_combinations(range(10), length * k, used_count.copy(), []):\n            if len(combination) == n:\n                total_count += 1\n                \n    return total_count\n```"]}
{"task_id": "3583", "codes": ["from collections import defaultdict\nimport math\n\ndef getGCDs(nums):\n    max_num = max(nums)\n    gcd_freq = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_value = math.gcd(nums[i], nums[j])\n            gcd_freq[gcd_value] += 1\n    \n    cum_freq = []\n    current_sum = 0\n    for freq in gcd_freq.values():\n        current_sum += freq\n        cum_freq.append(current_sum)\n    \n    return cum_freq, gcd_freq\n\ndef processQueries(cum_freq, gcd_freq, queries):\n    result = []\n    for query in queries:\n        if query >= cum_freq[-1]:\n            result.append(max(gcd_freq.keys()))\n        else:\n            low, high = 0, len(cum_freq) - 1\n            while low < high:\n                mid = (low + high) // 2\n                if cum_freq[mid] > query:\n                    high = mid\n                else:\n                    low = mid + 1\n            result.append(list(gcd_freq.keys())[low - 1])\n    \n    return result\n\ndef answer_gcd_pairs(nums, queries):\n    cum_freq, gcd_freq = getGCDs(nums)\n    return processQueries(cum_freq, gcd_freq, queries)", "from math import gcd\nfrom collections import defaultdict\nfrom typing import List\n\ndef getGCDArray(nums: List[int]) -> List[int]:\n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    gcd_list = []\n    for g, count in gcd_count.items():\n        gcd_list.extend([g] * count)\n    \n    gcd_list.sort()\n    return gcd_list\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    gcd_array = getGCDArray(nums)\n    result = [gcd_array[q] for q in queries]\n    return result", "def getGCD(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef processQueries(nums, queries):\n    max_val = max(nums)\n    freq = {}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in freq:\n                freq[gcd_val] = []\n            freq[gcd_val].append((i, j))\n    \n    sorted_gcds = sorted(freq.keys())\n    prefix_sums = [0] * len(sorted_gcds)\n    current_sum = 0\n    \n    for i, gcd_val in enumerate(sorted_gcds):\n        prefix_sums[i] = current_sum\n        current_sum += len(freq[gcd_val])\n    \n    result = []\n    \n    for query in queries:\n        target_index = query + 1\n        for i, prefix_sum in enumerate(prefix_sums):\n            if target_index <= prefix_sum:\n                result.append(sorted_gcds[i])\n                break\n    \n    return result", "def getGCDPairs(nums, queries):\n    from collections import defaultdict\n    from math import gcd\n    \n    max_val = max(nums)\n    sieve = [defaultdict(int) for _ in range(max_val + 1)]\n    \n    def update(i, x):\n        while i <= max_val:\n            sieve[i][x] += 1\n            i += i & -i\n    \n    def query(i, x):\n        res = 0\n        while i > 0:\n            res += sieve[i][x]\n            i -= i & -i\n        return res\n    \n    n = len(nums)\n    pairs = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            pairs.append(g)\n            update(g, 1)\n    \n    pairs.sort()\n    \n    result = []\n    for q in queries:\n        result.append(pairs[q])\n    \n    return result", "from collections import defaultdict\nimport math\n\ndef getGCDPairs(nums, queries):\n    max_num = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Iterate over all possible divisors\n    for d in range(1, max_num + 1):\n        count = 0\n        for num in nums:\n            if num % d == 0:\n                count += 1\n        gcd_counts[d] = count\n    \n    gcd_pairs = []\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_value = math.gcd(nums[i], nums[j])\n            gcd_pairs.append(gcd_value)\n    \n    gcd_pairs.sort()\n    \n    result = []\n    for q in queries:\n        result.append(gcd_pairs[q])\n    \n    return result", "def minOperations(nums):\n    from collections import defaultdict\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count occurrences of each gcd value\n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_count[d] += nums.count(d)\n    \n    # Convert to sorted list of unique gcd values and their counts\n    gcd_list = sorted(gcd_count.items())\n    \n    # Create prefix sum array\n    prefix_sum = [0]\n    for _, count in gcd_list:\n        prefix_sum.append(prefix_sum[-1] + count)\n    \n    # Process queries\n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(prefix_sum, q + 1)\n        if idx > 0:\n            result.append(gcd_list[idx - 1][0])\n        else:\n            result.append(0)\n    \n    return result", "def solve_gcd_pairs(nums, queries):\n    max_val = max(nums)\n    gcd_counts = {}\n    \n    # Count the occurrences of each GCD\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = gcd(nums[i], nums[j])\n            if gcd_val not in gcd_counts:\n                gcd_counts[gcd_val] = 0\n            gcd_counts[gcd_val] += 1\n    \n    # Sort the unique GCD keys\n    sorted_gcds = sorted(gcd_counts.keys())\n    \n    # Prepare the result array\n    result = []\n    current_index = 0\n    current_gcd = 0\n    \n    # Answer each query\n    for q in queries:\n        while current_index < q + 1:\n            gcd_counts[sorted_gcds[current_gcd]] -= 1\n            if gcd_counts[sorted_gcds[current_gcd]] == 0:\n                current_gcd += 1\n            current_index += 1\n        result.append(sorted_gcds[current_gcd - 1])\n    \n    return result", "def solve(nums, queries):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    max_num = max(nums)\n    gcd_counts = [0] * (max_num + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_counts[d] += 1\n    \n    gcd_values = []\n    for d in range(1, max_num + 1):\n        gcd_values.extend([d] * gcd_counts[d])\n    \n    gcd_values.sort()\n    \n    result = []\n    for q in queries:\n        result.append(gcd_values[q])\n    \n    return result"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nfrom collections import defaultdict\nimport math\n\ndef getGCDs(nums):\n    max_num = max(nums)\n    gcd_freq = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_value = math.gcd(nums[i], nums[j])\n            gcd_freq[gcd_value] += 1\n    \n    cum_freq = []\n    current_sum = 0\n    for freq in gcd_freq.values():\n        current_sum += freq\n        cum_freq.append(current_sum)\n    \n    return cum_freq, gcd_freq\n\ndef processQueries(cum_freq, gcd_freq, queries):\n    result = []\n    for query in queries:\n        if query >= cum_freq[-1]:\n            result.append(max(gcd_freq.keys()))\n        else:\n            low, high = 0, len(cum_freq) - 1\n            while low < high:\n                mid = (low + high) // 2\n                if cum_freq[mid] > query:\n                    high = mid\n                else:\n                    low = mid + 1\n            result.append(list(gcd_freq.keys())[low - 1])\n    \n    return result\n\ndef answer_gcd_pairs(nums, queries):\n    cum_freq, gcd_freq = getGCDs(nums)\n    return processQueries(cum_freq, gcd_freq, queries)\n```", "```python\nfrom math import gcd\nfrom collections import defaultdict\nfrom typing import List\n\ndef getGCDArray(nums: List[int]) -> List[int]:\n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            g = gcd(nums[i], nums[j])\n            gcd_count[g] += 1\n    \n    gcd_list = []\n    for g, count in gcd_count.items():\n        gcd_list.extend([g] * count)\n    \n    gcd_list.sort()\n    return gcd_list\n\ndef solve(nums: List[int], queries: List[int]) -> List[int]:\n    gcd_array = getGCDArray(nums)\n    result = [gcd_array[q] for q in queries]\n    return result\n```", "```python\ndef getGCD(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef processQueries(nums, queries):\n    max_val = max(nums)\n    freq = {}\n    \n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = getGCD(nums[i], nums[j])\n            if gcd_val not in freq:\n                freq[gcd_val] = []\n            freq[gcd_val].append((i, j))\n    \n    sorted_gcds = sorted(freq.keys())\n    prefix_sums = [0] * len(sorted_gcds)\n    current_sum = 0\n    \n    for i, gcd_val in enumerate(sorted_gcds):\n        prefix_sums[i] = current_sum\n        current_sum += len(freq[gcd_val])\n    \n    result = []\n    \n    for query in queries:\n        target_index = query + 1\n        for i, prefix_sum in enumerate(prefix_sums):\n            if target_index <= prefix_sum:\n                result.append(sorted_gcds[i])\n                break\n    \n    return result\n```", "```python\ndef getGCDPairs(nums, queries):\n    from collections import defaultdict\n    from math import gcd\n    \n    max_val = max(nums)\n    sieve = [defaultdict(int) for _ in range(max_val + 1)]\n    \n    def update(i, x):\n        while i <= max_val:\n            sieve[i][x] += 1\n            i += i & -i\n    \n    def query(i, x):\n        res = 0\n        while i > 0:\n            res += sieve[i][x]\n            i -= i & -i\n        return res\n    \n    n = len(nums)\n    pairs = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            g = gcd(nums[i], nums[j])\n            pairs.append(g)\n            update(g, 1)\n    \n    pairs.sort()\n    \n    result = []\n    for q in queries:\n        result.append(pairs[q])\n    \n    return result\n```", "```python\nfrom collections import defaultdict\nimport math\n\ndef getGCDPairs(nums, queries):\n    max_num = max(nums)\n    gcd_counts = defaultdict(int)\n    \n    # Iterate over all possible divisors\n    for d in range(1, max_num + 1):\n        count = 0\n        for num in nums:\n            if num % d == 0:\n                count += 1\n        gcd_counts[d] = count\n    \n    gcd_pairs = []\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_value = math.gcd(nums[i], nums[j])\n            gcd_pairs.append(gcd_value)\n    \n    gcd_pairs.sort()\n    \n    result = []\n    for q in queries:\n        result.append(gcd_pairs[q])\n    \n    return result\n```", "```python\ndef minOperations(nums):\n    from collections import defaultdict\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    max_val = max(nums)\n    gcd_count = defaultdict(int)\n    \n    # Count occurrences of each gcd value\n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_count[d] += nums.count(d)\n    \n    # Convert to sorted list of unique gcd values and their counts\n    gcd_list = sorted(gcd_count.items())\n    \n    # Create prefix sum array\n    prefix_sum = [0]\n    for _, count in gcd_list:\n        prefix_sum.append(prefix_sum[-1] + count)\n    \n    # Process queries\n    result = []\n    for q in queries:\n        idx = bisect.bisect_left(prefix_sum, q + 1)\n        if idx > 0:\n            result.append(gcd_list[idx - 1][0])\n        else:\n            result.append(0)\n    \n    return result\n```", "```python\ndef solve_gcd_pairs(nums, queries):\n    max_val = max(nums)\n    gcd_counts = {}\n    \n    # Count the occurrences of each GCD\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            gcd_val = gcd(nums[i], nums[j])\n            if gcd_val not in gcd_counts:\n                gcd_counts[gcd_val] = 0\n            gcd_counts[gcd_val] += 1\n    \n    # Sort the unique GCD keys\n    sorted_gcds = sorted(gcd_counts.keys())\n    \n    # Prepare the result array\n    result = []\n    current_index = 0\n    current_gcd = 0\n    \n    # Answer each query\n    for q in queries:\n        while current_index < q + 1:\n            gcd_counts[sorted_gcds[current_gcd]] -= 1\n            if gcd_counts[sorted_gcds[current_gcd]] == 0:\n                current_gcd += 1\n            current_index += 1\n        result.append(sorted_gcds[current_gcd - 1])\n    \n    return result\n```", "```python\ndef solve(nums, queries):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    max_num = max(nums)\n    gcd_counts = [0] * (max_num + 1)\n    \n    for num in nums:\n        for d in range(1, num + 1):\n            if num % d == 0:\n                gcd_counts[d] += 1\n    \n    gcd_values = []\n    for d in range(1, max_num + 1):\n        gcd_values.extend([d] * gcd_counts[d])\n    \n    gcd_values.sort()\n    \n    result = []\n    for q in queries:\n        result.append(gcd_values[q])\n    \n    return result\n```"]}
{"task_id": "3571", "codes": ["def maxIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Sort coordinates based on x and then y\n    coordinates.sort()\n    \n    n = len(coordinates)\n    dp = [1] * n\n    graph = defaultdict(list)\n    indegree = [0] * n\n    \n    # Build the graph and compute in-degrees\n    for i in range(n):\n        x1, y1 = coordinates[i]\n        for j in range(i + 1, n):\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sorting using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    \n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            dp[v] = max(dp[v], dp[u] + 1)\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    return dp[k]", "def longestIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    def dfs(x, y):\n        if (x, y) in memo:\n            return memo[(x, y)]\n        max_length = 1\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid and grid[(nx, ny)][0] > grid[(x, y)][0] and grid[(nx, ny)][1] > grid[(x, y)][1]:\n                max_length = max(max_length, 1 + dfs(nx, ny))\n        memo[(x, y)] = max_length\n        return max_length\n    \n    coordinates.sort()\n    grid = {(x, y): (x, y) for x, y in coordinates}\n    memo = {}\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    max_path_length = 0\n    for i in range(len(coordinates)):\n        if i == k:\n            max_path_length = max(max_path_length, dfs(coordinates[i][0], coordinates[i][1]))\n    \n    return max_path_length", "def longestIncreasingPath(coordinates, k):\n    from collections import defaultdict\n    import heapq\n\n    # Sort coordinates based on x and then y\n    coordinates.sort()\n\n    # Create a dictionary to store the neighbors of each coordinate\n    neighbors = defaultdict(list)\n    for i in range(len(coordinates)):\n        for j in range(i + 1, len(coordinates)):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                neighbors[coordinates[i]].append(coordinates[j])\n\n    # Memoization dictionary to store the longest increasing path length\n    memo = {}\n\n    # Depth-first search to find the longest increasing path from a given coordinate\n    def dfs(coord):\n        if coord not in memo:\n            memo[coord] = 1\n            for neighbor in neighbors[coord]:\n                memo[coord] = max(memo[coord], 1 + dfs(neighbor))\n        return memo[coord]\n\n    # Find the longest increasing path containing the k-th point\n    result = dfs(coordinates[k])\n    return result", "def longestIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    from collections import defaultdict, deque\n    \n    # Sort coordinates based on x, then y\n    coordinates.sort()\n    \n    n = len(coordinates)\n    dp = [1] * n\n    indegree = [0] * n\n    graph = defaultdict(list)\n    \n    # Build the graph and compute indegrees\n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sorting using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]", "def longestIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Build the graph\n    n = len(coordinates)\n    graph = defaultdict(list)\n    indegree = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = coordinates[i]\n            x2, y2 = coordinates[j]\n            if x1 < x2 and y1 < y2:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Step 3: Topological sort using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]", "def maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    if n == 0:\n        return 0\n    \n    # Sort coordinates based on x and y values\n    coordinates.sort()\n    \n    # Initialize DP array\n    dp = [1] * n\n    \n    # Dictionary to store indices for binary search\n    index_map = {tuple(coord): i for i, coord in enumerate(coordinates)}\n    \n    # Function to perform binary search\n    def binary_search(left, right, target):\n        while left < right:\n            mid = (left + right) // 2\n            if coordinates[mid][0] < target[0] and coordinates[mid][1] < target[1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n    \n    # Update DP array\n    for i, (x, y) in enumerate(coordinates):\n        if i > 0:\n            j = binary_search(0, i, coordinates[i-1])\n            if coordinates[j][0] < x and coordinates[j][1] < y:\n                dp[i] = dp[j] + 1\n    \n    # Return the length of the longest increasing path containing coordinates[k]\n    return dp[index_map[tuple(coordinates[k])]]", "def maxIncreasingPath(coordinates, k):\n    import collections\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Initialize DP table and graph\n    n = len(coordinates)\n    dp = [1] * n\n    graph = collections.defaultdict(list)\n    indegree = [0] * n\n    \n    # Step 3: Build graph and count indegrees\n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[coordinates[i]].append(coordinates[j])\n                indegree[j] += 1\n    \n    # Step 4: Topological sort\n    queue = [i for i in range(n) if indegree[i] == 0]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in graph[coordinates[current]]:\n            dp[neighbor] = max(dp[neighbor], dp[current] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]", "def longestIncreasingPath(coordinates, k):\n    def dfs(x, y):\n        if (x, y) not in memo:\n            max_path = 1\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(coords) and 0 <= ny < len(coords[0]) and coords[nx][ny] > coords[x][y]:\n                    max_path = max(max_path, 1 + dfs(nx, ny))\n            memo[(x, y)] = max_path\n        return memo[(x, y)]\n    \n    # Sort coordinates based on their x and y values\n    coords = sorted(coordinates)\n    \n    # Create a 2D grid to represent the coordinates\n    grid = [[0] * len(set(coord[1] for coord in coords)) for _ in range(len(set(coord[0] for coord in coords)))]\n    for x, y in coords:\n        grid[x][y] = 1\n    \n    # Initialize memoization dictionary\n    memo = {}\n    \n    # Start DFS from the given coordinate k\n    result = dfs(k // len(grid[0]), k % len(grid[0]))\n    \n    return result"], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef maxIncreasingPath(coordinates, k):\n    from collections import defaultdict, deque\n    \n    # Sort coordinates based on x and then y\n    coordinates.sort()\n    \n    n = len(coordinates)\n    dp = [1] * n\n    graph = defaultdict(list)\n    indegree = [0] * n\n    \n    # Build the graph and compute in-degrees\n    for i in range(n):\n        x1, y1 = coordinates[i]\n        for j in range(i + 1, n):\n            x2, y2 = coordinates[j]\n            if x2 > x1 and y2 > y1:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sorting using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    \n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            dp[v] = max(dp[v], dp[u] + 1)\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                queue.append(v)\n    \n    return dp[k]\n```", "```python\ndef longestIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    def dfs(x, y):\n        if (x, y) in memo:\n            return memo[(x, y)]\n        max_length = 1\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in grid and grid[(nx, ny)][0] > grid[(x, y)][0] and grid[(nx, ny)][1] > grid[(x, y)][1]:\n                max_length = max(max_length, 1 + dfs(nx, ny))\n        memo[(x, y)] = max_length\n        return max_length\n    \n    coordinates.sort()\n    grid = {(x, y): (x, y) for x, y in coordinates}\n    memo = {}\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    max_path_length = 0\n    for i in range(len(coordinates)):\n        if i == k:\n            max_path_length = max(max_path_length, dfs(coordinates[i][0], coordinates[i][1]))\n    \n    return max_path_length\n```", "```python\ndef longestIncreasingPath(coordinates, k):\n    from collections import defaultdict\n    import heapq\n\n    # Sort coordinates based on x and then y\n    coordinates.sort()\n\n    # Create a dictionary to store the neighbors of each coordinate\n    neighbors = defaultdict(list)\n    for i in range(len(coordinates)):\n        for j in range(i + 1, len(coordinates)):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                neighbors[coordinates[i]].append(coordinates[j])\n\n    # Memoization dictionary to store the longest increasing path length\n    memo = {}\n\n    # Depth-first search to find the longest increasing path from a given coordinate\n    def dfs(coord):\n        if coord not in memo:\n            memo[coord] = 1\n            for neighbor in neighbors[coord]:\n                memo[coord] = max(memo[coord], 1 + dfs(neighbor))\n        return memo[coord]\n\n    # Find the longest increasing path containing the k-th point\n    result = dfs(coordinates[k])\n    return result\n```", "```python\ndef longestIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    from collections import defaultdict, deque\n    \n    # Sort coordinates based on x, then y\n    coordinates.sort()\n    \n    n = len(coordinates)\n    dp = [1] * n\n    indegree = [0] * n\n    graph = defaultdict(list)\n    \n    # Build the graph and compute indegrees\n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Topological sorting using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]\n```", "```python\ndef longestIncreasingPath(coordinates: List[List[int]], k: int) -> int:\n    from collections import defaultdict, deque\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Build the graph\n    n = len(coordinates)\n    graph = defaultdict(list)\n    indegree = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = coordinates[i]\n            x2, y2 = coordinates[j]\n            if x1 < x2 and y1 < y2:\n                graph[i].append(j)\n                indegree[j] += 1\n    \n    # Step 3: Topological sort using Kahn's algorithm\n    queue = deque([i for i in range(n) if indegree[i] == 0])\n    dp = [1] * n\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            dp[neighbor] = max(dp[neighbor], dp[node] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]\n```", "```python\ndef maxIncreasingPath(coordinates, k):\n    n = len(coordinates)\n    if n == 0:\n        return 0\n    \n    # Sort coordinates based on x and y values\n    coordinates.sort()\n    \n    # Initialize DP array\n    dp = [1] * n\n    \n    # Dictionary to store indices for binary search\n    index_map = {tuple(coord): i for i, coord in enumerate(coordinates)}\n    \n    # Function to perform binary search\n    def binary_search(left, right, target):\n        while left < right:\n            mid = (left + right) // 2\n            if coordinates[mid][0] < target[0] and coordinates[mid][1] < target[1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n    \n    # Update DP array\n    for i, (x, y) in enumerate(coordinates):\n        if i > 0:\n            j = binary_search(0, i, coordinates[i-1])\n            if coordinates[j][0] < x and coordinates[j][1] < y:\n                dp[i] = dp[j] + 1\n    \n    # Return the length of the longest increasing path containing coordinates[k]\n    return dp[index_map[tuple(coordinates[k])]]\n```", "```python\ndef maxIncreasingPath(coordinates, k):\n    import collections\n    \n    # Step 1: Sort coordinates\n    coordinates.sort()\n    \n    # Step 2: Initialize DP table and graph\n    n = len(coordinates)\n    dp = [1] * n\n    graph = collections.defaultdict(list)\n    indegree = [0] * n\n    \n    # Step 3: Build graph and count indegrees\n    for i in range(n):\n        for j in range(i + 1, n):\n            if coordinates[j][0] > coordinates[i][0] and coordinates[j][1] > coordinates[i][1]:\n                graph[coordinates[i]].append(coordinates[j])\n                indegree[j] += 1\n    \n    # Step 4: Topological sort\n    queue = [i for i in range(n) if indegree[i] == 0]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in graph[coordinates[current]]:\n            dp[neighbor] = max(dp[neighbor], dp[current] + 1)\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return dp[k]\n```", "```python\ndef longestIncreasingPath(coordinates, k):\n    def dfs(x, y):\n        if (x, y) not in memo:\n            max_path = 1\n            for dx, dy in [(1, 0), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(coords) and 0 <= ny < len(coords[0]) and coords[nx][ny] > coords[x][y]:\n                    max_path = max(max_path, 1 + dfs(nx, ny))\n            memo[(x, y)] = max_path\n        return memo[(x, y)]\n    \n    # Sort coordinates based on their x and y values\n    coords = sorted(coordinates)\n    \n    # Create a 2D grid to represent the coordinates\n    grid = [[0] * len(set(coord[1] for coord in coords)) for _ in range(len(set(coord[0] for coord in coords)))]\n    for x, y in coords:\n        grid[x][y] = 1\n    \n    # Initialize memoization dictionary\n    memo = {}\n    \n    # Start DFS from the given coordinate k\n    result = dfs(k // len(grid[0]), k % len(grid[0]))\n    \n    return result\n```"]}
{"difficulty": "hard", "num_threads": 32, "temperature": 0.9, "n": 8, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_temp09_bug_trace_TPL_OUR01_qwen_7b_hard_n_8.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"task_id": "abc370_g", "codes": ["", "", "", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["", "", "", "", "", "", "", ""]}
{"task_id": "abc372_e", "codes": ["import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    graph = [[] for _ in range(N + 1)]\n    heap_sizes = [0] * (N + 1)\n    heap_positions = [-1] * (N + 1)\n    \n    index = 2\n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            \n            if v not in graph[u]:\n                graph[u].append(v)\n                graph[v].append(u)\n                \n                if heap_positions[u] >= 0:\n                    heapq.heapreplace(graph[u], v)\n                else:\n                    heapq.heappush(graph[u], v)\n                    \n                if heap_positions[v] >= 0:\n                    heapq.heapreplace(graph[v], u)\n                else:\n                    heapq.heappush(graph[v], u)\n                    \n                heap_positions[u] += 1\n                heap_positions[v] += 1\n                \n                if heap_sizes[u] < 2:\n                    heap_sizes[u] += 1\n                if heap_sizes[v] < 2:\n                    heap_sizes[v] += 1\n        else:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            \n            if k > heap_sizes[v]:\n                results.append(-1)\n            else:\n                results.append(heapq.heappop(graph[v]))\n                heapq.heappush(graph[v], v)\n                heap_positions[v] -= 1\n    \n    for result in results:\n        print(result)\n\n# solve()", "", "", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nimport sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    graph = [[] for _ in range(N + 1)]\n    heap_sizes = [0] * (N + 1)\n    heap_positions = [-1] * (N + 1)\n    \n    index = 2\n    results = []\n    \n    for _ in range(Q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            \n            if v not in graph[u]:\n                graph[u].append(v)\n                graph[v].append(u)\n                \n                if heap_positions[u] >= 0:\n                    heapq.heapreplace(graph[u], v)\n                else:\n                    heapq.heappush(graph[u], v)\n                    \n                if heap_positions[v] >= 0:\n                    heapq.heapreplace(graph[v], u)\n                else:\n                    heapq.heappush(graph[v], u)\n                    \n                heap_positions[u] += 1\n                heap_positions[v] += 1\n                \n                if heap_sizes[u] < 2:\n                    heap_sizes[u] += 1\n                if heap_sizes[v] < 2:\n                    heap_sizes[v] += 1\n        else:\n            v = int(data[index])\n            k = int(data[index + 1])\n            index += 2\n            \n            if k > heap_sizes[v]:\n                results.append(-1)\n            else:\n                results.append(heapq.heappop(graph[v]))\n                heapq.heappush(graph[v], v)\n                heap_positions[v] -= 1\n    \n    for result in results:\n        print(result)\n\n# solve()\n```", "", "", "", "", "", "", ""]}
{"task_id": "abc373_f", "codes": ["i", "d", "", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nimport sys\nimport heapq\n\ndef dp_happiness():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    W = int(data[index + 1])\n    index += 2\n    \n    items = []\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        items.append((w, v))\n    \n    items.sort()\n    \n    dp = [[-float('inf')] * (W + 1) for _ in range(N + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, N + 1):\n        w, v = items[i - 1]\n        for j in range(W + 1):\n            if dp[i - 1][j] != -float('inf'):\n                dp[i][j] = dp[i - 1][j]\n                if j + w <= W:\n                    dp[i][j + w] = max(dp[i][j + w], dp[i - 1][j] + v - w)\n    \n    print(dp[N][W])\n\ndp_happiness()", "```python\ndef max_happiness():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    W = int(data[1])\n    items = []\n    \n    index = 2\n    for _ in range(N):\n        w = int(data[index])\n        v = int(data[index + 1])\n        items.append((w, v))\n        index += 2\n    \n    dp = [0] * (W + 1)\n    \n    for w, v in items:\n        for weight in range(W, w - 1, -1):\n            k = (v + weight - 1) // w\n            dp[weight] = max(dp[weight], dp[weight - w * k] + k * v - k * k)\n    \n    print(dp[W])\n\nmax_happiness()", "", "", "", "", "", ""]}
{"task_id": "abc373_e", "codes": ["", "", "", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["", "", "", "", "", "", "", ""]}
{"task_id": "abc369_g", "codes": ["def optimal_walk_score(N, edges):\n    from collections import defaultdict, deque\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    i = 0\n    i += 1  # Skip N\n    tree = defaultdict(list)\n    for _ in range(N - 1):\n        u = int(data[i]) - 1\n        v = int(data[i + 1]) - 1\n        l = int(data[i + 2])\n        tree[u].append((v, l))\n        tree[v].append((u, l))\n        i += 3\n    \n    def bfs(start, end):\n        queue = deque([(start, 0)])\n        visited = [False] * N\n        visited[start] = True\n        while queue:\n            node, dist = queue.popleft()\n            if node == end:\n                return dist\n            for neighbor, length in tree[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + length))\n        return float('inf')\n    \n    def find_median_path(vertices):\n        total_edges = 0\n        for u, v, l in edges:\n            if u in vertices and v in vertices:\n                total_edges += l\n        return total_edges\n    \n    def play_optimal(N, edges):\n        scores = []\n        for K in range(1, N + 1):\n            min_score = float('inf')\n            for i in range(N):\n                for j in range(i + 1, N):\n                    for k in range(j + 1, N):\n                        if len({i, j, k}) == K:\n                            score = find_median_path({i, j, k})\n                            if score < min_score:\n                                min_score = score\n            scores.append(min_score)\n        return scores\n    \n    scores = play_optimal(N, edges)\n    for score in scores:\n        print(score)\n\n# Call the function with stdin\nN = int(input())\nedges = []\nfor _ in range(N - 1):\n    u, v, l = map(int, input().split())\n    edges.append((u - 1, v - 1, l))\noptimal_walk_score(N, edges)", "", "", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef optimal_walk_score(N, edges):\n    from collections import defaultdict, deque\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Parse the input\n    i = 0\n    i += 1  # Skip N\n    tree = defaultdict(list)\n    for _ in range(N - 1):\n        u = int(data[i]) - 1\n        v = int(data[i + 1]) - 1\n        l = int(data[i + 2])\n        tree[u].append((v, l))\n        tree[v].append((u, l))\n        i += 3\n    \n    def bfs(start, end):\n        queue = deque([(start, 0)])\n        visited = [False] * N\n        visited[start] = True\n        while queue:\n            node, dist = queue.popleft()\n            if node == end:\n                return dist\n            for neighbor, length in tree[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + length))\n        return float('inf')\n    \n    def find_median_path(vertices):\n        total_edges = 0\n        for u, v, l in edges:\n            if u in vertices and v in vertices:\n                total_edges += l\n        return total_edges\n    \n    def play_optimal(N, edges):\n        scores = []\n        for K in range(1, N + 1):\n            min_score = float('inf')\n            for i in range(N):\n                for j in range(i + 1, N):\n                    for k in range(j + 1, N):\n                        if len({i, j, k}) == K:\n                            score = find_median_path({i, j, k})\n                            if score < min_score:\n                                min_score = score\n            scores.append(min_score)\n        return scores\n    \n    scores = play_optimal(N, edges)\n    for score in scores:\n        print(score)\n\n# Call the function with stdin\nN = int(input())\nedges = []\nfor _ in range(N - 1):\n    u, v, l = map(int, input().split())\n    edges.append((u - 1, v - 1, l))\noptimal_walk_score(N, edges)\n```", "", "", "", "", "", "", ""]}
{"task_id": "abc368_e", "codes": ["d", "d", "d", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef calculate_delays(N, M, X1, trains):\n    # Sort trains by their departure times\n    trains.sort(key=lambda x: x[2])\n    \n    # Initialize the total delay\n    total_delay = 0\n    \n    # Iterate through the trains starting from the second train\n    for i in range(1, M):\n        ai, bi, si, ti = trains[i]\n        \n        # Initialize the delay for the current train\n        current_delay = 0\n        \n        # Check if the current train can transfer to any subsequent train\n        for j in range(i + 1, M):\n            aj, bj, sj, tj = trains[j]\n            if bj == ai and ti <= sj:\n                # Calculate the delay needed to allow transfer\n                needed_delay = max(0, sj + total_delay - ti - X1)\n                # Apply the delay to the current train\n                current_delay = max(current_delay, needed_delay)\n                # Update the total delay for the subsequent train\n                total_delay += needed_delay\n        \n        # Add the delay for the current train to the total delay\n        total_delay += current_delay\n    \n    # Return the total delay for the second to last train\n    return [total_delay]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X1 = int(data[index + 2])\n    trains = []\n    for i in range(M):\n        ai = int(data[index + 3 + 4 * i])\n        bi = int(data[index + 4 + 4 * i])\n        si = int(data[index + 5 + 4 * i])\n        ti = int(data[index + 6 + 4 * i])\n        trains.append([ai, bi, si, ti])\n        index += 4\n    \n    result = calculate_delays(N, M, X1, trains)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()", "```python\ndef find_min_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    X1 = int(data[2])\n    \n    trains = []\n    index = 3\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        S = int(data[index + 2])\n        T = int(data[index + 3])\n        trains.append((A, B, S, T))\n        index += 4\n    \n    # Initialize delays with X1 value\n    delays = [X1] + [0] * (M - 1)\n    \n    for i in range(M):\n        for j in range(i + 1, M):\n            A_i, B_i, S_i, T_i = trains[i]\n            A_j, B_j, S_j, T_j = trains[j]\n            \n            if B_i == A_j and T_i <= S_j:\n                required_delay = max(0, S_j - T_i + delays[j] - delays[i])\n                delays[i] += required_delay\n    \n    # Print the delays for trains except the first one\n    print(' '.join(map(str, delays[1:])))\n\nfind_min_delays()", "```python\ndef min_transit_delays():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    X1 = int(data[index + 2])\n    \n    trains = []\n    for i in range(M):\n        A = int(data[index + 3 + i * 4])\n        B = int(data[index + 4 + i * 4])\n        S = int(data[index + 5 + i * 4])\n        T = int(data[index + 6 + i * 4])\n        trains.append((A, B, S, T))\n    \n    # Sort trains by their arrival times\n    trains.sort(key=lambda x: x[3])\n    \n    # Initialize delays\n    delays = [0] * M\n    \n    # Propagate delays\n    for i in range(1, M):\n        A_i, B_i, S_i, T_i = trains[i]\n        for j in range(i - 1, -1, -1):\n            A_j, B_j, S_j, T_j = trains[j]\n            if B_i == A_j and T_i <= S_j:\n                needed_delay = max(0, S_j - T_i)\n                if needed_delay > delays[j]:\n                    delays[j] = needed_delay\n                    if j > 0:\n                        prev_A, _, prev_S, _ = trains[j - 1]\n                        if prev_A == A_j:\n                            delays[j - 1] += needed_delay\n                    if j < M - 1:\n                        next_B, _, next_S, _ = trains[j + 1]\n                        if next_B == A_j:\n                            delays[j + 1] += needed_delay\n    \n    # Print the delays except the first one\n    for i in range(1, M):\n        print(delays[i], end=\" \")\n    print()\n\nmin_transit_delays()", "", "", "", "", ""]}
{"task_id": "arc181_d", "codes": ["def update(bit, index, value, n):\n    while index <= n:\n        bit[index] += value\n        index += index & -index\n\ndef query(bit, index):\n    result = 0\n    while index > 0:\n        result += bit[index]\n        index -= index & -index\n    return result\n\ndef count_inversions(arr, n):\n    bit = [0] * (n + 1)\n    inversions = 0\n    for num in arr:\n        inversions += query(bit, num - 1)\n        update(bit, num, 1, n)\n    return inversions\n\nN = int(input())\nP = list(map(int, input().split()))\nM = int(input())\nA = list(map(int, input().split()))\n\n# Initialize the Fenwick Tree\nbit = [0] * (N + 1)\n\n# Initial inversion count\ninversions = count_inversions(P, N)\nprint(inversions)\n\n# Perform operations and update inversion count\nfor a in A:\n    # Find the index of the element to swap\n    for i in range(a - 1):\n        if P[i] > P[i + 1]:\n            P[i], P[i + 1] = P[i + 1], P[i]\n            # Update the Fenwick Tree\n            update(bit, P[i], -1, N)\n            update(bit, P[i + 1], 1, N)\n            inversions -= query(bit, P[i] - 2)\n            inversions += query(bit, P[i + 1] - 2)\n    # Print the current inversion count\n    print(inversions)", "", "", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef update(bit, index, value, n):\n    while index <= n:\n        bit[index] += value\n        index += index & -index\n\ndef query(bit, index):\n    result = 0\n    while index > 0:\n        result += bit[index]\n        index -= index & -index\n    return result\n\ndef count_inversions(arr, n):\n    bit = [0] * (n + 1)\n    inversions = 0\n    for num in arr:\n        inversions += query(bit, num - 1)\n        update(bit, num, 1, n)\n    return inversions\n\nN = int(input())\nP = list(map(int, input().split()))\nM = int(input())\nA = list(map(int, input().split()))\n\n# Initialize the Fenwick Tree\nbit = [0] * (N + 1)\n\n# Initial inversion count\ninversions = count_inversions(P, N)\nprint(inversions)\n\n# Perform operations and update inversion count\nfor a in A:\n    # Find the index of the element to swap\n    for i in range(a - 1):\n        if P[i] > P[i + 1]:\n            P[i], P[i + 1] = P[i + 1], P[i]\n            # Update the Fenwick Tree\n            update(bit, P[i], -1, N)\n            update(bit, P[i + 1], 1, N)\n            inversions -= query(bit, P[i] - 2)\n            inversions += query(bit, P[i + 1] - 2)\n    # Print the current inversion count\n    print(inversions)\n```", "", "", "", "", "", "", ""]}
{"task_id": "abc366_f", "codes": ["f", "d", "i", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nfrom itertools import permutations\n\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    A = [0] * (N + 1)\n    B = [0] * (N + 1)\n    \n    for i in range(N):\n        A[i + 1] = int(data[2 + 2 * i])\n        B[i + 1] = int(data[3 + 2 * i])\n    \n    max_value = float('-inf')\n    \n    for p in permutations(range(1, N + 1), K):\n        x = 1\n        for i in range(K):\n            x = A[p[i]] * x + B[p[i]]\n        if x > max_value:\n            max_value = x\n    \n    print(max_value)\n\nmax_nested_function_value()", "```python\ndef max_nested_function_value():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for i in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    functions.sort(reverse=True)\n    \n    result = 1\n    for i in range(K):\n        A, B = functions[i]\n        result = A * result + B\n    \n    print(result)\n\nmax_nested_function_value()", "```python\nimport sys\ndef find_max_value():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    functions = []\n    index = 2\n    for i in range(N):\n        A = int(data[index])\n        B = int(data[index + 1])\n        functions.append((A, B))\n        index += 2\n    \n    # Sort functions by their slopes in descending order\n    functions.sort(key=lambda x: x[0], reverse=True)\n    \n    x = 1\n    for i in range(K):\n        A, B = functions[i]\n        x = A * x + B\n    \n    print(x)\n\n# Call the function to execute\nfind_max_value()", "", "", "", "", ""]}
{"task_id": "abc368_f", "codes": ["i", "d", "def determine_winner(N, A):\n    count_squares = sum(1 for a in A if int(a**0.5)**2 == a)\n    if count_squares % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\ndetermine_winner(N, A)", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\nimport sys\nfrom collections import defaultdict\n\ndef count_prime_factors(n):\n    factors = defaultdict(int)\n    # Count number of 2s\n    while n % 2 == 0:\n        factors[2] += 1\n        n = n // 2\n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors[i] += 1\n            n = n // i\n    # If n is a prime number greater than 2\n    if n > 2:\n        factors[n] += 1\n    return sum(factors.values())\n\ndef determine_winner(N, A):\n    total_moves = 0\n    for a in A:\n        total_moves += count_prime_factors(a)\n    if total_moves % 2 == 0:\n        return \"Anna\"\n    else:\n        return \"Bruno\"\n\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(determine_winner(N, A))\n\nif __name__ == \"__main__\":\n    main()", "```python\ndef determine_winner():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = [int(data[i+1]) for i in range(N)]\n    \n    # Calculate the number of non-trivial divisors for each number\n    operations = 0\n    for num in A:\n        while num % 2 == 0:\n            operations += 1\n            num //= 2\n        for i in range(3, int(num**0.5) + 1, 2):\n            while num % i == 0:\n                operations += 1\n                num //= i\n        if num > 2:\n            operations += 1\n    \n    # Determine the winner based on the number of operations\n    if operations % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\ndetermine_winner()", "```python\ndef determine_winner(N, A):\n    count_squares = sum(1 for a in A if int(a**0.5)**2 == a)\n    if count_squares % 2 == 1:\n        print(\"Anna\")\n    else:\n        print(\"Bruno\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nA = list(map(int, data[1:]))\n\n# Determine and print the winner\ndetermine_winner(N, A)\n```", "", "", "", "", ""]}
{"task_id": "abc366_g", "codes": ["d", "def can_assign_integers(n, m, edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 2: Check bipartiteness\n    colors = [-1] * (n + 1)\n    queue = deque()\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            colors[i] = 0\n            queue.append(i)\n        \n        while queue:\n            node = queue.popleft()\n            color = colors[node]\n            next_color = 1 - color\n            \n            for neighbor in graph[node]:\n                if colors[neighbor] == -1:\n                    colors[neighbor] = next_color\n                    queue.append(neighbor)\n                elif colors[neighbor] != next_color:\n                    return False\n    \n    # Step 3: Assign integers\n    if not all(colors):\n        return \"No\"\n    \n    assigned_values = {}\n    for i in range(1, n + 1):\n        if colors[i] == 0:\n            assigned_values[i] = 1\n        else:\n            assigned_values[i] = 2\n    \n    return f\"Yes\\n{' '.join(map(str, assigned_values.values()))}\"\n\n# Example usage\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    \n    result = can_assign_integers(n, m, edges)\n    print(result)", "", "", "", "", "", ""], "passed": [false, false, false, false, false, false, false, false], "raw_code": ["```python\ndef is_bipartite(graph, N, M):\n    colors = [-1] * (N + 1)\n    for i in range(1, N + 1):\n        if colors[i] == -1:\n            queue = [i]\n            colors[i] = 0\n            while queue:\n                node = queue.pop(0)\n                for neighbor in graph[node]:\n                    if colors[neighbor] == -1:\n                        colors[neighbor] = 1 - colors[node]\n                        queue.append(neighbor)\n                    elif colors[neighbor] == colors[node]:\n                        return False\n    return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    graph = [[] for _ in range(N + 1)]\n    \n    index = 2\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        graph[u].append(v)\n        graph[v].append(u)\n        index += 2\n    \n    if is_bipartite(graph, N, M):\n        color_class = [[] for _ in range(2)]\n        for i in range(1, N + 1):\n            color_class[colors[i]].append(i)\n        \n        for i in range(2):\n            for j in range(len(color_class[i])):\n                color_class[i][j] = 2 ** j + 1\n        \n        print(\"Yes\")\n        for i in range(1, N + 1):\n            print(color_class[colors[i]][color_class[colors[i]].index(i)]), \n    else:\n        print(\"No\")\n\nsolve()", "```python\ndef can_assign_integers(n, m, edges):\n    from collections import defaultdict, deque\n    \n    # Step 1: Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Step 2: Check bipartiteness\n    colors = [-1] * (n + 1)\n    queue = deque()\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            colors[i] = 0\n            queue.append(i)\n        \n        while queue:\n            node = queue.popleft()\n            color = colors[node]\n            next_color = 1 - color\n            \n            for neighbor in graph[node]:\n                if colors[neighbor] == -1:\n                    colors[neighbor] = next_color\n                    queue.append(neighbor)\n                elif colors[neighbor] != next_color:\n                    return False\n    \n    # Step 3: Assign integers\n    if not all(colors):\n        return \"No\"\n    \n    assigned_values = {}\n    for i in range(1, n + 1):\n        if colors[i] == 0:\n            assigned_values[i] = 1\n        else:\n            assigned_values[i] = 2\n    \n    return f\"Yes\\n{' '.join(map(str, assigned_values.values()))}\"\n\n# Example usage\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    \n    result = can_assign_integers(n, m, edges)\n    print(result)\n```", "", "", "", "", "", ""]}
