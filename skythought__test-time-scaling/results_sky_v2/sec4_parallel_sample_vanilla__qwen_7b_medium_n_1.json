"{\"difficulty\": \"medium\", \"num_threads\": 32, \"temperature\": 0.7, \"n\": 1, \"context\": \"all\", \"selection\": \"oracle\", \"num_round\": 1, \"selfdebug_decision\": \"exit\", \"judge\": \"openai/gpt-4o-mini\", \"generator\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"start_date\": \"2024-08-01T00:00:00\", \"end_date\": \"2024-12-01T00:00:00\", \"result_json_path\": \"results_sky_v2/sec4_parallel_sample_vanilla__qwen_7b_medium_n_1.json\", \"ablation_judge_api_name\": null, \"ablation_judge_api_base\": \"openai/gpt-4o-mini\", \"method\": \"selfdebug\", \"test_generator\": \"openai/gpt-4o-mini\", \"num_test_suites\": 1, \"api_name\": \"openai/Qwen/Qwen2.5-Coder-7B-Instruct\", \"api_base\": \"http://127.0.0.1:8001/8001/v1\", \"no_refine\": true, \"no_dspy_gen\": false, \"lcb_version\": \"release_v4\", \"num_icl_examples\": 0, \"enable_llm_reflection_with_tool\": false, \"enable_vanilla_reflection\": false, \"ablation_qwq_vanilla_without_reasoning\": false, \"ablation_qwq_debug_with_4o_mini\": false, \"load_cached_preds\": false, \"cached_preds_path\": null, \"seed\": 42, \"resume\": true}"
{"task_id": "abc366_c", "codes": ["def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    result = []\n    \n    index = 0\n    for _ in range(Q):\n        if queries[index] == '1':\n            x = int(queries[index + 1])\n            bag.add(x)\n            index += 2\n        elif queries[index] == '2':\n            x = int(queries[index + 1])\n            bag.remove(x)\n            index += 2\n        elif queries[index] == '3':\n            result.append(str(len(bag)))\n            index += 1\n    \n    for r in result:\n        print(r)\n\nprocess_queries()"], "passed": [false], "raw_code": ["```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    Q = int(data[0])\n    queries = data[1:]\n    \n    bag = set()\n    result = []\n    \n    index = 0\n    for _ in range(Q):\n        if queries[index] == '1':\n            x = int(queries[index + 1])\n            bag.add(x)\n            index += 2\n        elif queries[index] == '2':\n            x = int(queries[index + 1])\n            bag.remove(x)\n            index += 2\n        elif queries[index] == '3':\n            result.append(str(len(bag)))\n            index += 1\n    \n    for r in result:\n        print(r)\n\nprocess_queries()\n```"]}
{"task_id": "abc365_c", "codes": ["def max_subsidy_limit(N, M, A):\n    def is_feasible(x):\n        total_subsidy = sum(min(x, a) for a in A)\n        return total_subsidy <= M\n    \n    low, high = 0, max(A)\n    while low <= high:\n        mid = (low + high) // 2\n        if is_feasible(mid):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    if high == 0:\n        return \"infinite\"\n    return high\n\n# Call the function with stdin as input and print the output\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(max_subsidy_limit(N, M, A))"], "passed": [false], "raw_code": ["```python\ndef max_subsidy_limit(N, M, A):\n    def is_feasible(x):\n        total_subsidy = sum(min(x, a) for a in A)\n        return total_subsidy <= M\n    \n    low, high = 0, max(A)\n    while low <= high:\n        mid = (low + high) // 2\n        if is_feasible(mid):\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    if high == 0:\n        return \"infinite\"\n    return high\n\n# Call the function with stdin as input and print the output\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(max_subsidy_limit(N, M, A))\n```"]}
{"task_id": "3526", "codes": ["def min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    row_flips = [sum(1 for i in range(n) if grid[j][i] != grid[j][n-1-i]) for j in range(m)]\n    col_flips = [sum(1 for j in range(m) if grid[j][i] != grid[m-1-j][i]) for i in range(n)]\n    return min(sum(row_flips), sum(col_flips))"], "passed": [false], "raw_code": ["def min_flips(grid):\n    m, n = len(grid), len(grid[0])\n    row_flips = [sum(1 for i in range(n) if grid[j][i] != grid[j][n-1-i]) for j in range(m)]\n    col_flips = [sum(1 for j in range(m) if grid[j][i] != grid[m-1-j][i]) for i in range(n)]\n    return min(sum(row_flips), sum(col_flips))"]}
{"task_id": "abc372_d", "codes": ["def count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    result = [0] * N\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            if heights[j] <= heights[i]:\n                result[i] += 1\n            else:\n                break\n    \n    print(' '.join(map(str, result)))\n\ncount_valid_buildings()"], "passed": [false], "raw_code": ["```python\ndef count_valid_buildings():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    heights = list(map(int, data[1:]))\n    \n    result = [0] * N\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            if heights[j] <= heights[i]:\n                result[i] += 1\n            else:\n                break\n    \n    print(' '.join(map(str, result)))\n\ncount_valid_buildings()\n```"]}
{"task_id": "abc369_c", "codes": ["```python\ndef count_arithmetic_progressions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    dp = [{} for _ in range(N)]\n    \n    for i in range(N):\n        dp[i][A[i]] = 1\n        for j in range(i):\n            diff = A[i] - A[j]\n            if diff in dp[j]:\n                count += dp[j][diff]\n                dp[i][diff] = dp[i].get(diff, 0) + dp[j][diff] + 1\n            else:\n                dp[i][diff] = dp[i].get(diff, 0) + 1\n    \n    print(count)\n\ncount_arithmetic_progressions()"], "passed": [false], "raw_code": ["```python\ndef count_arithmetic_progressions():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    count = 0\n    dp = [{} for _ in range(N)]\n    \n    for i in range(N):\n        dp[i][A[i]] = 1\n        for j in range(i):\n            diff = A[i] - A[j]\n            if diff in dp[j]:\n                count += dp[j][diff]\n                dp[i][diff] = dp[i].get(diff, 0) + dp[j][diff] + 1\n            else:\n                dp[i][diff] = dp[i].get(diff, 0) + 1\n    \n    print(count)\n\ncount_arithmetic_progressions()"]}
{"task_id": "3485", "codes": ["def maxScore(start, d):\n    # Select the largest number in each interval\n    selected_numbers = [s + d for s in start]\n    # Sort the selected numbers\n    selected_numbers.sort()\n    # Calculate the differences between consecutive numbers\n    differences = [selected_numbers[i] - selected_numbers[i-1] for i in range(1, len(selected_numbers))]\n    # Return the maximum difference\n    return max(differences)"], "passed": [false], "raw_code": ["```python\ndef maxScore(start, d):\n    # Select the largest number in each interval\n    selected_numbers = [s + d for s in start]\n    # Sort the selected numbers\n    selected_numbers.sort()\n    # Calculate the differences between consecutive numbers\n    differences = [selected_numbers[i] - selected_numbers[i-1] for i in range(1, len(selected_numbers))]\n    # Return the maximum difference\n    return max(differences)\n```"]}
{"task_id": "3496", "codes": ["def min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def can_reduce_in_time(time):\n        total_reduction = 0\n        for workerTime in workerTimes:\n            x = 1\n            while workerTime * x * (x + 1) // 2 <= time:\n                total_reduction += x\n                x += 1\n        return total_reduction >= mountainHeight\n    \n    left, right = 1, max(workerTimes) * mountainHeight * (mountainHeight + 1) // 2\n    while left < right:\n        mid = (left + right) // 2\n        if can_reduce_in_time(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left"], "passed": [false], "raw_code": ["```python\ndef min_time_to_reduce_mountain(mountainHeight, workerTimes):\n    def can_reduce_in_time(time):\n        total_reduction = 0\n        for workerTime in workerTimes:\n            x = 1\n            while workerTime * x * (x + 1) // 2 <= time:\n                total_reduction += x\n                x += 1\n        return total_reduction >= mountainHeight\n    \n    left, right = 1, max(workerTimes) * mountainHeight * (mountainHeight + 1) // 2\n    while left < right:\n        mid = (left + right) // 2\n        if can_reduce_in_time(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```"]}
{"task_id": "3579", "codes": ["def max_possible_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their numeric value\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)"], "passed": [false], "raw_code": ["```python\ndef max_possible_number(nums):\n    # Convert each number to its binary representation and remove the '0b' prefix\n    binary_nums = [bin(num)[2:] for num in nums]\n    \n    # Sort the binary strings in descending order based on their numeric value\n    binary_nums.sort(key=int, reverse=True)\n    \n    # Concatenate the sorted binary strings\n    concatenated_binary = ''.join(binary_nums)\n    \n    # Convert the concatenated binary string back to an integer\n    return int(concatenated_binary, 2)\n```"]}
{"task_id": "3522", "codes": ["def find_subarray_powers(nums, k):\n    results = []\n    for i in range(len(nums) - k + 1):\n        subarray = nums[i:i+k]\n        if all(subarray[j] < subarray[j+1] for j in range(k-1)) and len(set(subarray)) == k:\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    return results"], "passed": [false], "raw_code": ["```python\ndef find_subarray_powers(nums, k):\n    results = []\n    for i in range(len(nums) - k + 1):\n        subarray = nums[i:i+k]\n        if all(subarray[j] < subarray[j+1] for j in range(k-1)) and len(set(subarray)) == k:\n            results.append(max(subarray))\n        else:\n            results.append(-1)\n    return results\n```"]}
{"task_id": "abc370_c", "codes": ["def transform_and_print(S, T):\n    X = [S]\n    for i in range(len(S)):\n        if S[i] != T[i]:\n            S = S[:i] + T[i] + S[i+1:]\n            X.append(S)\n    print(len(X))\n    for s in X:\n        print(s)\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nS = data[0]\nT = data[1]\n\ntransform_and_print(S, T)"], "passed": [false], "raw_code": ["```python\ndef transform_and_print(S, T):\n    X = [S]\n    for i in range(len(S)):\n        if S[i] != T[i]:\n            S = S[:i] + T[i] + S[i+1:]\n            X.append(S)\n    print(len(X))\n    for s in X:\n        print(s)\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nS = data[0]\nT = data[1]\n\ntransform_and_print(S, T)\n```"]}
{"task_id": "3540", "codes": ["def hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result"], "passed": [true], "raw_code": ["```python\ndef hash_string(s, k):\n    result = \"\"\n    for i in range(0, len(s), k):\n        substring = s[i:i+k]\n        char_sum = sum(ord(char) - ord('a') for char in substring)\n        hashed_char = char_sum % 26\n        result += chr(hashed_char + ord('a'))\n    return result\n```"]}
{"task_id": "3541", "codes": ["def is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            word_count[word] = word_count.get(word, 0) + 1\n            if word_count[word] >= 2:\n                return True\n    \n    return False"], "passed": [false], "raw_code": ["```python\ndef is_spam(message, bannedWords):\n    banned_set = set(bannedWords)\n    word_count = {}\n    \n    for word in message:\n        if word in banned_set:\n            word_count[word] = word_count.get(word, 0) + 1\n            if word_count[word] >= 2:\n                return True\n    \n    return False\n```"]}
{"task_id": "3518", "codes": ["def maxScore(a, b):\n    # Sort the array b\n    b.sort()\n    \n    # Calculate the scores by pairing elements of a with the largest elements of b\n    score = sum(a[i] * b[-i-1] for i in range(4))\n    \n    return score"], "passed": [false], "raw_code": ["```python\ndef maxScore(a, b):\n    # Sort the array b\n    b.sort()\n    \n    # Calculate the scores by pairing elements of a with the largest elements of b\n    score = sum(a[i] * b[-i-1] for i in range(4))\n    \n    return score\n```"]}
{"task_id": "3534", "codes": ["def count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            # Generate all unique permutations of digits for num1\n            perms1 = {int(''.join(p)) for p in itertools.permutations(num1)}\n            # Generate all unique permutations of digits for num2\n            perms2 = {int(''.join(p)) for p in itertools.permutations(num2)}\n            \n            # Check if there is any common permutation between num1 and num2\n            if perms1 & perms2:\n                count += 1\n                \n    return count"], "passed": [false], "raw_code": ["```python\ndef count_almost_equal_pairs(nums):\n    n = len(nums)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            num1 = str(nums[i])\n            num2 = str(nums[j])\n            \n            # Generate all unique permutations of digits for num1\n            perms1 = {int(''.join(p)) for p in itertools.permutations(num1)}\n            # Generate all unique permutations of digits for num2\n            perms2 = {int(''.join(p)) for p in itertools.permutations(num2)}\n            \n            # Check if there is any common permutation between num1 and num2\n            if perms1 & perms2:\n                count += 1\n                \n    return count\n```"]}
{"task_id": "abc369_d", "codes": ["```python\ndef max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Sort the monsters by their strength in descending order\n    A.sort(reverse=True)\n    \n    max_points = 0\n    even_count = 0\n    \n    for i in range(N):\n        if i % 2 == 0:\n            even_count += 1\n        max_points += A[i] * (1 + even_count // 2)\n    \n    print(max_points)\n\n# Call the function to execute\nmax_experience_points()"], "passed": [false], "raw_code": ["```python\ndef max_experience_points():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    \n    # Sort the monsters by their strength in descending order\n    A.sort(reverse=True)\n    \n    max_points = 0\n    even_count = 0\n    \n    for i in range(N):\n        if i % 2 == 0:\n            even_count += 1\n        max_points += A[i] * (1 + even_count // 2)\n    \n    print(max_points)\n\n# Call the function to execute\nmax_experience_points()"]}
{"task_id": "3517", "codes": ["def shortest_path_after_queries(n, queries):\n    # Initialize the graph with the initial roads\n    graph = {i: [i + 1] for i in range(n - 1)}\n    \n    # Function to perform BFS and find the shortest path from 0 to n-1\n    def bfs():\n        queue = [0]\n        visited = set([0])\n        distance = 0\n        \n        while queue:\n            next_level = []\n            for node in queue:\n                if node == n - 1:\n                    return distance\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        next_level.append(neighbor)\n            queue = next_level\n            distance += 1\n    \n    # List to store the results\n    result = []\n    \n    # Process each query\n    for u, v in queries:\n        # Add the new road to the graph\n        graph[u].append(v)\n        graph[v].append(u)\n        \n        # Find the shortest path after adding the new road\n        result.append(bfs())\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef shortest_path_after_queries(n, queries):\n    # Initialize the graph with the initial roads\n    graph = {i: [i + 1] for i in range(n - 1)}\n    \n    # Function to perform BFS and find the shortest path from 0 to n-1\n    def bfs():\n        queue = [0]\n        visited = set([0])\n        distance = 0\n        \n        while queue:\n            next_level = []\n            for node in queue:\n                if node == n - 1:\n                    return distance\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        next_level.append(neighbor)\n            queue = next_level\n            distance += 1\n    \n    # List to store the results\n    result = []\n    \n    # Process each query\n    for u, v in queries:\n        # Add the new road to the graph\n        graph[u].append(v)\n        graph[v].append(u)\n        \n        # Find the shortest path after adding the new road\n        result.append(bfs())\n    \n    return result\n```"]}
{"task_id": "3495", "codes": ["import heapq\n\ndef kthSmallestObstacleDistance(queries, k):\n    def manhattan_distance(x, y):\n        return abs(x) + abs(y)\n    \n    heap = []\n    results = []\n    \n    for x, y in queries:\n        dist = manhattan_distance(x, y)\n        heapq.heappush(heap, dist)\n        \n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    if len(heap) < k:\n        results.append(-1)\n    else:\n        results.append(heap[0])\n    \n    return results"], "passed": [false], "raw_code": ["```python\nimport heapq\n\ndef kthSmallestObstacleDistance(queries, k):\n    def manhattan_distance(x, y):\n        return abs(x) + abs(y)\n    \n    heap = []\n    results = []\n    \n    for x, y in queries:\n        dist = manhattan_distance(x, y)\n        heapq.heappush(heap, dist)\n        \n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    if len(heap) < k:\n        results.append(-1)\n    else:\n        results.append(heap[0])\n    \n    return results\n```"]}
{"task_id": "3584", "codes": ["def smallestSequenceOfIndices(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    result = []\n    \n    while i < n and j < m:\n        if word1[i] != word2[j]:\n            # Check if changing word1[i] to word2[j] makes them almost equal\n            if i + 1 < n and word1[i + 1] == word2[j]:\n                result.append(i + 1)\n                i += 2\n            elif i < n and word1[i] == word2[j]:\n                result.append(i)\n                i += 1\n            else:\n                return []\n        else:\n            result.append(i)\n            i += 1\n        j += 1\n    \n    # Add remaining indices if needed\n    while i < n:\n        result.append(i)\n        i += 1\n    \n    return result"], "passed": [false], "raw_code": ["```python\ndef smallestSequenceOfIndices(word1, word2):\n    n, m = len(word1), len(word2)\n    i, j = 0, 0\n    result = []\n    \n    while i < n and j < m:\n        if word1[i] != word2[j]:\n            # Check if changing word1[i] to word2[j] makes them almost equal\n            if i + 1 < n and word1[i + 1] == word2[j]:\n                result.append(i + 1)\n                i += 2\n            elif i < n and word1[i] == word2[j]:\n                result.append(i)\n                i += 1\n            else:\n                return []\n        else:\n            result.append(i)\n            i += 1\n        j += 1\n    \n    # Add remaining indices if needed\n    while i < n:\n        result.append(i)\n        i += 1\n    \n    return result\n```"]}
{"task_id": "3559", "codes": ["def minValidStrings(words, target):\n    words.sort(key=len)\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(n):\n        for word in words:\n            if i + 1 >= len(word) and target[i - len(word) + 1:i + 1] == word:\n                dp[i + 1] = min(dp[i + 1], dp[i - len(word) + 1] + 1)\n    \n    return dp[n] if dp[n] != float('inf') else -1"], "passed": [false], "raw_code": ["```python\ndef minValidStrings(words, target):\n    words.sort(key=len)\n    n = len(target)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(n):\n        for word in words:\n            if i + 1 >= len(word) and target[i - len(word) + 1:i + 1] == word:\n                dp[i + 1] = min(dp[i + 1], dp[i - len(word) + 1] + 1)\n    \n    return dp[n] if dp[n] != float('inf') else -1\n```"]}
{"task_id": "abc367_d", "codes": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    # Calculate prefix sums\n    prefix_sums = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + A[i - 1]\n    \n    # Dictionary to store counts of prefix sums modulo M\n    mod_count = {}\n    for i in range(N + 1):\n        mod = prefix_sums[i] % M\n        if mod in mod_count:\n            mod_count[mod] += 1\n        else:\n            mod_count[mod] = 1\n    \n    # Count valid pairs\n    result = 0\n    for count in mod_count.values():\n        result += count * (count - 1) // 2\n    \n    print(result)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:]))\n    \n    # Calculate prefix sums\n    prefix_sums = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + A[i - 1]\n    \n    # Dictionary to store counts of prefix sums modulo M\n    mod_count = {}\n    for i in range(N + 1):\n        mod = prefix_sums[i] % M\n        if mod in mod_count:\n            mod_count[mod] += 1\n        else:\n            mod_count[mod] = 1\n    \n    # Count valid pairs\n    result = 0\n    for count in mod_count.values():\n        result += count * (count - 1) // 2\n    \n    print(result)\n\nmain()"]}
{"task_id": "abc373_c", "codes": ["```python\ndef max_sum_of_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:]))\n    \n    A.sort()\n    \n    max_sum = float('-inf')\n    \n    for b in B:\n        target = -b\n        left, right = 0, N - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if A[mid] == target:\n                max_sum = max(max_sum, A[mid] + b)\n                break\n            elif A[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    print(max_sum)\n\nmax_sum_of_pairs()"], "passed": [false], "raw_code": ["```python\ndef max_sum_of_pairs():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:]))\n    \n    A.sort()\n    \n    max_sum = float('-inf')\n    \n    for b in B:\n        target = -b\n        left, right = 0, N - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if A[mid] == target:\n                max_sum = max(max_sum, A[mid] + b)\n                break\n            elif A[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    print(max_sum)\n\nmax_sum_of_pairs()"]}
{"task_id": "3558", "codes": ["def can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if dfs(x + dx, y + dy, health - grid[x + dx][y + dy]):\n                return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)"], "passed": [false], "raw_code": ["```python\ndef can_reach_final_cell(grid, health):\n    m, n = len(grid), len(grid[0])\n    \n    def dfs(x, y, health):\n        if x < 0 or x >= m or y < 0 or y >= n or health <= 0:\n            return False\n        if x == m - 1 and y == n - 1:\n            return health >= 1\n        grid[x][y] = -1  # Mark the cell as visited\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if dfs(x + dx, y + dy, health - grid[x + dx][y + dy]):\n                return True\n        grid[x][y] = 0  # Unmark the cell\n        return False\n    \n    return dfs(0, 0, health)\n```"]}
{"task_id": "3573", "codes": ["def count_valid_substrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    target_count = Counter(word2)\n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        current_count = Counter(word1[i:i+m])\n        if current_count == target_count:\n            count += 1\n            \n    return count"], "passed": [false], "raw_code": ["```python\ndef count_valid_substrings(word1: str, word2: str) -> int:\n    from collections import Counter\n    \n    target_count = Counter(word2)\n    n = len(word1)\n    m = len(word2)\n    count = 0\n    \n    for i in range(n - m + 1):\n        current_count = Counter(word1[i:i+m])\n        if current_count == target_count:\n            count += 1\n            \n    return count\n```"]}
{"task_id": "abc365_d", "codes": ["def max_wins(N, S):\n    # Define the winning moves\n    beats = {'R': 'P', 'P': 'S', 'S': 'R'}\n    # Initialize the count of wins and the last move Takahashi made\n    wins = 0\n    last_move = ''\n    # Iterate through each move in Aoki's sequence\n    for move in S:\n        # Find a move that beats Aoki's current move and is different from the last move\n        for takahashi_move in 'RPS':\n            if takahashi_move != last_move and beats[takahashi_move] == move:\n                wins += 1\n                last_move = takahashi_move\n                break\n    return wins\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\nN, S = input().split()\nN = int(N)\nprint(max_wins(N, S))"], "passed": [false], "raw_code": ["def max_wins(N, S):\n    # Define the winning moves\n    beats = {'R': 'P', 'P': 'S', 'S': 'R'}\n    # Initialize the count of wins and the last move Takahashi made\n    wins = 0\n    last_move = ''\n    # Iterate through each move in Aoki's sequence\n    for move in S:\n        # Find a move that beats Aoki's current move and is different from the last move\n        for takahashi_move in 'RPS':\n            if takahashi_move != last_move and beats[takahashi_move] == move:\n                wins += 1\n                last_move = takahashi_move\n                break\n    return wins\n\n# Read input from standard input\nimport sys\ninput = sys.stdin.read\nN, S = input().split()\nN = int(N)\nprint(max_wins(N, S))"]}
{"task_id": "arc181_a", "codes": ["```python\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_inv = merge_sort_and_count(arr[:mid])\n    right, right_inv = merge_sort_and_count(arr[mid:])\n    \n    merged, split_inv = merge_and_count(left, right)\n    \n    return merged, left_inv + right_inv + split_inv\n\ndef merge_and_count(left, right):\n    result = []\n    i = j = inv_count = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result, inv_count\n\ndef min_operations_to_identity():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        P = list(map(int, data[index:index + N]))\n        index += N\n        \n        _, inv_count = merge_sort_and_count(P)\n        results.append(inv_count)\n    \n    for result in results:\n        print(result)\n\nmin_operations_to_identity()"], "passed": [false], "raw_code": ["```python\ndef merge_sort_and_count(arr):\n    if len(arr) <= 1:\n        return arr, 0\n    \n    mid = len(arr) // 2\n    left, left_inv = merge_sort_and_count(arr[:mid])\n    right, right_inv = merge_sort_and_count(arr[mid:])\n    \n    merged, split_inv = merge_and_count(left, right)\n    \n    return merged, left_inv + right_inv + split_inv\n\ndef merge_and_count(left, right):\n    result = []\n    i = j = inv_count = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n            inv_count += len(left) - i\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result, inv_count\n\ndef min_operations_to_identity():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        P = list(map(int, data[index:index + N]))\n        index += N\n        \n        _, inv_count = merge_sort_and_count(P)\n        results.append(inv_count)\n    \n    for result in results:\n        print(result)\n\nmin_operations_to_identity()"]}
{"task_id": "abc371_d", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    X = [int(data[index + i]) for i in range(N)]\n    index += N\n    P = [int(data[index + i]) for i in range(N)]\n    index += N\n    Q = int(data[index])\n    index += 1\n    queries = [(int(data[index + 2 * i]), int(data[index + 2 * i + 1])) for i in range(Q)]\n\n    # Compute cumulative population\n    cumulative_population = [0] * (N + 1)\n    for i in range(N):\n        cumulative_population[i + 1] = cumulative_population[i] + P[i]\n\n    # Process each query\n    results = []\n    for L, R in queries:\n        left_index = bisect.bisect_left(X, L)\n        right_index = bisect.bisect_right(X, R)\n        if left_index == N or X[left_index] > R:\n            left_index -= 1\n        if right_index == 0 or X[right_index - 1] < L:\n            right_index += 1\n        results.append(cumulative_population[right_index] - cumulative_population[left_index])\n\n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Parse input\n    index = 0\n    N = int(data[index])\n    index += 1\n    X = [int(data[index + i]) for i in range(N)]\n    index += N\n    P = [int(data[index + i]) for i in range(N)]\n    index += N\n    Q = int(data[index])\n    index += 1\n    queries = [(int(data[index + 2 * i]), int(data[index + 2 * i + 1])) for i in range(Q)]\n\n    # Compute cumulative population\n    cumulative_population = [0] * (N + 1)\n    for i in range(N):\n        cumulative_population[i + 1] = cumulative_population[i] + P[i]\n\n    # Process each query\n    results = []\n    for L, R in queries:\n        left_index = bisect.bisect_left(X, L)\n        right_index = bisect.bisect_right(X, R)\n        if left_index == N or X[left_index] > R:\n            left_index -= 1\n        if right_index == 0 or X[right_index - 1] < L:\n            right_index += 1\n        results.append(cumulative_population[right_index] - cumulative_population[left_index])\n\n    # Print results\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "3525", "codes": ["def maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_A = [0] * n\n    dp_B = [0] * n\n    \n    dp_A[0] = energyDrinkA[0]\n    dp_B[0] = energyDrinkB[0]\n    \n    if n > 1:\n        dp_A[1] = max(dp_A[0] + energyDrinkA[1], dp_B[0])\n        dp_B[1] = max(dp_B[0] + energyDrinkB[1], dp_A[0])\n    \n    for i in range(2, n):\n        dp_A[i] = max(dp_A[i-1] + energyDrinkA[i], dp_B[i-2] + energyDrinkA[i])\n        dp_B[i] = max(dp_B[i-1] + energyDrinkB[i], dp_A[i-2] + energyDrinkB[i])\n    \n    return max(dp_A[-1], dp_B[-1])"], "passed": [true], "raw_code": ["```python\ndef maxEnergyBoost(energyDrinkA, energyDrinkB):\n    n = len(energyDrinkA)\n    dp_A = [0] * n\n    dp_B = [0] * n\n    \n    dp_A[0] = energyDrinkA[0]\n    dp_B[0] = energyDrinkB[0]\n    \n    if n > 1:\n        dp_A[1] = max(dp_A[0] + energyDrinkA[1], dp_B[0])\n        dp_B[1] = max(dp_B[0] + energyDrinkB[1], dp_A[0])\n    \n    for i in range(2, n):\n        dp_A[i] = max(dp_A[i-1] + energyDrinkA[i], dp_B[i-2] + energyDrinkA[i])\n        dp_B[i] = max(dp_B[i-1] + energyDrinkB[i], dp_A[i-2] + energyDrinkB[i])\n    \n    return max(dp_A[-1], dp_B[-1])\n```"]}
{"task_id": "abc372_c", "codes": ["```python\ndef count_abc_substrings(s):\n    n = len(s)\n    count = 0\n    for i in range(n - 2):\n        if s[i:i+3] == 'ABC':\n            count += 1\n    return count\n\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    s = data[2]\n    queries = [(int(data[2 + 2 * i]) - 1, data[2 + 2 * i + 1]) for i in range(q)]\n    \n    current_count = count_abc_substrings(s)\n    prefix_counts = [current_count]\n    \n    for x, c in queries:\n        original_char = s[x]\n        s = s[:x] + c + s[x+1:]\n        \n        # Update the count of \"ABC\" using prefix sums\n        new_count = current_count\n        if original_char == 'A' and c == 'B':\n            new_count -= 1\n        elif original_char == 'B' and c == 'C':\n            new_count -= 1\n        elif original_char == 'A' and c == 'A':\n            new_count += 1\n        elif original_char == 'B' and c == 'B':\n            new_count += 1\n        elif original_char == 'C' and c == 'C':\n            new_count += 1\n        \n        current_count = new_count\n        prefix_counts.append(current_count)\n    \n    for i in range(1, len(prefix_counts)):\n        print(prefix_counts[i])\n\nprocess_queries()"], "passed": [false], "raw_code": ["```python\ndef count_abc_substrings(s):\n    n = len(s)\n    count = 0\n    for i in range(n - 2):\n        if s[i:i+3] == 'ABC':\n            count += 1\n    return count\n\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    s = data[2]\n    queries = [(int(data[2 + 2 * i]) - 1, data[2 + 2 * i + 1]) for i in range(q)]\n    \n    current_count = count_abc_substrings(s)\n    prefix_counts = [current_count]\n    \n    for x, c in queries:\n        original_char = s[x]\n        s = s[:x] + c + s[x+1:]\n        \n        # Update the count of \"ABC\" using prefix sums\n        new_count = current_count\n        if original_char == 'A' and c == 'B':\n            new_count -= 1\n        elif original_char == 'B' and c == 'C':\n            new_count -= 1\n        elif original_char == 'A' and c == 'A':\n            new_count += 1\n        elif original_char == 'B' and c == 'B':\n            new_count += 1\n        elif original_char == 'C' and c == 'C':\n            new_count += 1\n        \n        current_count = new_count\n        prefix_counts.append(current_count)\n    \n    for i in range(1, len(prefix_counts)):\n        print(prefix_counts[i])\n\nprocess_queries()"]}
{"task_id": "arc183_a", "codes": ["from math import factorial\n\ndef get_multinomial_coefficient(n, k_list):\n    numerator = factorial(n)\n    denominator = 1\n    for k in k_list:\n        denominator *= factorial(k)\n    return numerator // denominator\n\ndef find_sequence(N, K, target_rank):\n    def backtrack(index, current_sequence, remaining_counts):\n        if len(current_sequence) == N * K:\n            return current_sequence\n        \n        for num in range(1, N + 1):\n            if remaining_counts[num - 1] > 0:\n                new_remaining_counts = remaining_counts[:]\n                new_remaining_counts[num - 1] -= 1\n                \n                subsequence_rank = get_multinomial_coefficient(N * K - index - 1, new_remaining_counts)\n                \n                if target_rank <= subsequence_rank:\n                    current_sequence.append(num)\n                    result = backtrack(index + 1, current_sequence, new_remaining_counts)\n                    if result:\n                        return result\n                    current_sequence.pop()\n                else:\n                    target_rank -= subsequence_rank\n    \n    remaining_counts = [K] * N\n    return backtrack(0, [], remaining_counts)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    target_rank = (get_multinomial_coefficient(N * K, [K] * N) + 1) // 2\n    \n    sequence = find_sequence(N, K, target_rank)\n    print(' '.join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\nfrom math import factorial\n\ndef get_multinomial_coefficient(n, k_list):\n    numerator = factorial(n)\n    denominator = 1\n    for k in k_list:\n        denominator *= factorial(k)\n    return numerator // denominator\n\ndef find_sequence(N, K, target_rank):\n    def backtrack(index, current_sequence, remaining_counts):\n        if len(current_sequence) == N * K:\n            return current_sequence\n        \n        for num in range(1, N + 1):\n            if remaining_counts[num - 1] > 0:\n                new_remaining_counts = remaining_counts[:]\n                new_remaining_counts[num - 1] -= 1\n                \n                subsequence_rank = get_multinomial_coefficient(N * K - index - 1, new_remaining_counts)\n                \n                if target_rank <= subsequence_rank:\n                    current_sequence.append(num)\n                    result = backtrack(index + 1, current_sequence, new_remaining_counts)\n                    if result:\n                        return result\n                    current_sequence.pop()\n                else:\n                    target_rank -= subsequence_rank\n    \n    remaining_counts = [K] * N\n    return backtrack(0, [], remaining_counts)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    target_rank = (get_multinomial_coefficient(N * K, [K] * N) + 1) // 2\n    \n    sequence = find_sequence(N, K, target_rank)\n    print(' '.join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"task_id": "abc367_c", "codes": ["import sys\nfrom itertools import product\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    R = list(map(int, data[2:]))\n\n    # Generate all possible sequences of length N\n    all_sequences = product(range(1, r + 1) for r in R)\n\n    # Filter sequences where the sum is a multiple of K\n    valid_sequences = [seq for seq in all_sequences if sum(seq) % K == 0]\n\n    # Sort the valid sequences in ascending lexicographical order\n    valid_sequences.sort()\n\n    # Print the result\n    print(len(valid_sequences))\n    for seq in valid_sequences:\n        print(' '.join(map(str, seq)))\n\nif __name__ == '__main__':\n    main()"], "passed": [false], "raw_code": ["import sys\nfrom itertools import product\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    K = int(data[1])\n    R = list(map(int, data[2:]))\n\n    # Generate all possible sequences of length N\n    all_sequences = product(range(1, r + 1) for r in R)\n\n    # Filter sequences where the sum is a multiple of K\n    valid_sequences = [seq for seq in all_sequences if sum(seq) % K == 0]\n\n    # Sort the valid sequences in ascending lexicographical order\n    valid_sequences.sort()\n\n    # Print the result\n    print(len(valid_sequences))\n    for seq in valid_sequences:\n        print(' '.join(map(str, seq)))\n\nif __name__ == '__main__':\n    main()"]}
{"task_id": "abc366_d", "codes": ["def process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read N\n    N = int(data[0])\n\n    # Read the 3D array A\n    index = 1\n    A = [[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    for x in range(1, N+1):\n        for y in range(1, N+1):\n            for z in range(1, N+1):\n                A[x][y][z] = int(data[index])\n                index += 1\n\n    # Precompute the 4D prefix sum array\n    prefix_sum = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    for x in range(1, N+1):\n        for y in range(1, N+1):\n            for z in range(1, N+1):\n                prefix_sum[x][y][z][0] = prefix_sum[x-1][y][z][0] + prefix_sum[x][y-1][z][0] - prefix_sum[x-1][y-1][z][0] + prefix_sum[x-1][y-1][z-1][0] + A[x][y][z]\n                prefix_sum[x][y][z][1] = prefix_sum[x][y][z-1][1] + prefix_sum[x][y][z][0]\n\n    # Read Q\n    Q = int(data[index])\n    index += 1\n\n    # Process each query\n    results = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, data[index:index+6])\n        index += 6\n\n        # Compute the sum using the prefix sum array\n        result = prefix_sum[Rx][Ry][Rz][1] - prefix_sum[Lx-1][Ry][Rz][1] - prefix_sum[Rx][Ly-1][Rz][1] + prefix_sum[Lx-1][Ly-1][Rz][1] - prefix_sum[Rx][Ly-1][Lz-1][1] + prefix_sum[Lx-1][Ly-1][Lz-1][1] - prefix_sum[Lx-1][Ry][Lz-1][1] + prefix_sum[Rx][Ly-1][Lz-1][1]\n        results.append(result)\n\n    # Print the results\n    for result in results:\n        print(result)\n\n# Call the function to process the queries\nprocess_queries()"], "passed": [false], "raw_code": ["```python\ndef process_queries():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    # Read N\n    N = int(data[0])\n\n    # Read the 3D array A\n    index = 1\n    A = [[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    for x in range(1, N+1):\n        for y in range(1, N+1):\n            for z in range(1, N+1):\n                A[x][y][z] = int(data[index])\n                index += 1\n\n    # Precompute the 4D prefix sum array\n    prefix_sum = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    for x in range(1, N+1):\n        for y in range(1, N+1):\n            for z in range(1, N+1):\n                prefix_sum[x][y][z][0] = prefix_sum[x-1][y][z][0] + prefix_sum[x][y-1][z][0] - prefix_sum[x-1][y-1][z][0] + prefix_sum[x-1][y-1][z-1][0] + A[x][y][z]\n                prefix_sum[x][y][z][1] = prefix_sum[x][y][z-1][1] + prefix_sum[x][y][z][0]\n\n    # Read Q\n    Q = int(data[index])\n    index += 1\n\n    # Process each query\n    results = []\n    for _ in range(Q):\n        Lx, Rx, Ly, Ry, Lz, Rz = map(int, data[index:index+6])\n        index += 6\n\n        # Compute the sum using the prefix sum array\n        result = prefix_sum[Rx][Ry][Rz][1] - prefix_sum[Lx-1][Ry][Rz][1] - prefix_sum[Rx][Ly-1][Rz][1] + prefix_sum[Lx-1][Ly-1][Rz][1] - prefix_sum[Rx][Ly-1][Lz-1][1] + prefix_sum[Lx-1][Ly-1][Lz-1][1] - prefix_sum[Lx-1][Ry][Lz-1][1] + prefix_sum[Rx][Ly-1][Lz-1][1]\n        results.append(result)\n\n    # Print the results\n    for result in results:\n        print(result)\n\n# Call the function to process the queries\nprocess_queries()\n```"]}
{"task_id": "abc371_c", "codes": ["import sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nN = int(data[index])\nindex += 1\nM_G = int(data[index])\nindex += 1\nedges_G = []\nfor _ in range(M_G):\n    u = int(data[index]) - 1\n    index += 1\n    v = int(data[index]) - 1\n    index += 1\n    edges_G.append((u, v))\nindex += 1\nM_H = int(data[index])\nindex += 1\nedges_H = []\nfor _ in range(M_H):\n    a = int(data[index]) - 1\n    index += 1\n    b = int(data[index]) - 1\n    index += 1\n    edges_H.append((a, b))\nindex += 1\nA = [[int(data[index + j * N + i]) for i in range(N)] for j in range(N)]\n\n# Initialize DP table\ndp = [float('inf')] * (1 << N)\ndp[0] = 0\n\n# Function to get the bitmask of a set of edges\ndef get_mask(edges):\n    mask = 0\n    for u, v in edges:\n        if u < v:\n            mask |= 1 << ((u * (u + 1)) // 2 + v - u - 1)\n        else:\n            mask |= 1 << ((v * (v + 1)) // 2 + u - v - 1)\n    return mask\n\n# Get the initial mask of edges in H\ninitial_mask = get_mask(edges_H)\n\n# Iterate over all possible masks\nfor mask in range(1 << N):\n    # Check if the current mask is valid\n    valid = True\n    for u in range(N):\n        for v in range(u + 1, N):\n            if (mask & (1 << ((u * (u + 1)) // 2 + v - u - 1))) != 0:\n                if not (initial_mask & (1 << ((u * (u + 1)) // 2 + v - u - 1))):\n                    valid = False\n                    break\n            else:\n                if initial_mask & (1 << ((u * (u + 1)) // 2 + v - u - 1)):\n                    valid = False\n                    break\n        if not valid:\n            break\n    \n    if not valid:\n        continue\n    \n    # Transition to the next state\n    for u in range(N):\n        for v in range(u + 1, N):\n            new_mask = mask ^ (1 << ((u * (u + 1)) // 2 + v - u - 1))\n            dp[new_mask] = min(dp[new_mask], dp[mask] + A[u][v])\n\n# Find the minimum cost to make H isomorphic to G\nmin_cost = float('inf')\ntarget_mask = get_mask(edges_G)\nfor mask in range(1 << N):\n    if mask == target_mask:\n        min_cost = min(min_cost, dp[mask])\n\nprint(min_cost)"], "passed": [false], "raw_code": ["```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nN = int(data[index])\nindex += 1\nM_G = int(data[index])\nindex += 1\nedges_G = []\nfor _ in range(M_G):\n    u = int(data[index]) - 1\n    index += 1\n    v = int(data[index]) - 1\n    index += 1\n    edges_G.append((u, v))\nindex += 1\nM_H = int(data[index])\nindex += 1\nedges_H = []\nfor _ in range(M_H):\n    a = int(data[index]) - 1\n    index += 1\n    b = int(data[index]) - 1\n    index += 1\n    edges_H.append((a, b))\nindex += 1\nA = [[int(data[index + j * N + i]) for i in range(N)] for j in range(N)]\n\n# Initialize DP table\ndp = [float('inf')] * (1 << N)\ndp[0] = 0\n\n# Function to get the bitmask of a set of edges\ndef get_mask(edges):\n    mask = 0\n    for u, v in edges:\n        if u < v:\n            mask |= 1 << ((u * (u + 1)) // 2 + v - u - 1)\n        else:\n            mask |= 1 << ((v * (v + 1)) // 2 + u - v - 1)\n    return mask\n\n# Get the initial mask of edges in H\ninitial_mask = get_mask(edges_H)\n\n# Iterate over all possible masks\nfor mask in range(1 << N):\n    # Check if the current mask is valid\n    valid = True\n    for u in range(N):\n        for v in range(u + 1, N):\n            if (mask & (1 << ((u * (u + 1)) // 2 + v - u - 1))) != 0:\n                if not (initial_mask & (1 << ((u * (u + 1)) // 2 + v - u - 1))):\n                    valid = False\n                    break\n            else:\n                if initial_mask & (1 << ((u * (u + 1)) // 2 + v - u - 1)):\n                    valid = False\n                    break\n        if not valid:\n            break\n    \n    if not valid:\n        continue\n    \n    # Transition to the next state\n    for u in range(N):\n        for v in range(u + 1, N):\n            new_mask = mask ^ (1 << ((u * (u + 1)) // 2 + v - u - 1))\n            dp[new_mask] = min(dp[new_mask], dp[mask] + A[u][v])\n\n# Find the minimum cost to make H isomorphic to G\nmin_cost = float('inf')\ntarget_mask = get_mask(edges_G)\nfor mask in range(1 << N):\n    if mask == target_mask:\n        min_cost = min(min_cost, dp[mask])\n\nprint(min_cost)\n```\n\n[[ ##"]}
{"task_id": "3570", "codes": ["def count_substrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    left = 0\n    vowel_count = 0\n    consonant_count = 0\n    vowel_map = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}\n\n    for right in range(n):\n        if word[right] in vowels:\n            vowel_count += 1\n            vowel_map[word[right]] += 1\n        else:\n            consonant_count += 1\n\n        # Ensure there are exactly k consonants in the window\n        while consonant_count > k:\n            if word[left] in vowels:\n                vowel_count -= 1\n                vowel_map[word[left]] -= 1\n            else:\n                consonant_count -= 1\n            left += 1\n\n        # Check if the current window has at least one of each vowel\n        if vowel_count == 5:\n            count += left + 1\n\n    return count"], "passed": [false], "raw_code": ["def count_substrings(word: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(word)\n    count = 0\n    left = 0\n    vowel_count = 0\n    consonant_count = 0\n    vowel_map = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}\n\n    for right in range(n):\n        if word[right] in vowels:\n            vowel_count += 1\n            vowel_map[word[right]] += 1\n        else:\n            consonant_count += 1\n\n        # Ensure there are exactly k consonants in the window\n        while consonant_count > k:\n            if word[left] in vowels:\n                vowel_count -= 1\n                vowel_map[word[left]] -= 1\n            else:\n                consonant_count -= 1\n            left += 1\n\n        # Check if the current window has at least one of each vowel\n        if vowel_count == 5:\n            count += left + 1\n\n    return count"]}
{"task_id": "3510", "codes": ["def maxTowerHeight(maximumHeight):\n    maximumHeight.sort(reverse=True)\n    used_heights = set()\n    total_sum = 0\n    \n    for height in maximumHeight:\n        for h in range(1, height + 1):\n            if h not in used_heights:\n                used_heights.add(h)\n                total_sum += h\n                break\n        else:\n            return -1\n    \n    return total_sum"], "passed": [false], "raw_code": ["```python\ndef maxTowerHeight(maximumHeight):\n    maximumHeight.sort(reverse=True)\n    used_heights = set()\n    total_sum = 0\n    \n    for height in maximumHeight:\n        for h in range(1, height + 1):\n            if h not in used_heights:\n                used_heights.add(h)\n                total_sum += h\n                break\n        else:\n            return -1\n    \n    return total_sum\n```"]}
{"task_id": "3528", "codes": ["def maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for j in range(1, n):\n        for i in range(j):\n            dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[-1]"], "passed": [false], "raw_code": ["```python\ndef maxScore(nums):\n    n = len(nums)\n    dp = [0] * n\n    \n    for j in range(1, n):\n        for i in range(j):\n            dp[j] = max(dp[j], dp[i] + (j - i) * nums[i])\n    \n    return dp[-1]\n```"]}
{"task_id": "abc370_d", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    H = int(data[index])\n    W = int(data[index + 1])\n    Q = int(data[index + 2])\n    index += 3\n    \n    grid = [[True] * W for _ in range(H)]\n    \n    for _ in range(Q):\n        R_q = int(data[index]) - 1\n        C_q = int(data[index + 1]) - 1\n        index += 2\n        \n        if grid[R_q][C_q]:\n            grid[R_q][C_q] = False\n        else:\n            # Check up\n            for i in range(R_q - 1, -1, -1):\n                if grid[i][C_q]:\n                    grid[i][C_q] = False\n                    break\n            \n            # Check down\n            for i in range(R_q + 1, H):\n                if grid[i][C_q]:\n                    grid[i][C_q] = False\n                    break\n            \n            # Check left\n            for j in range(C_q - 1, -1, -1):\n                if grid[R_q][j]:\n                    grid[R_q][j] = False\n                    break\n            \n            # Check right\n            for j in range(C_q + 1, W):\n                if grid[R_q][j]:\n                    grid[R_q][j] = False\n                    break\n    \n    remaining_walls = sum(row.count(True) for row in grid)\n    print(remaining_walls)\n\nmain()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    H = int(data[index])\n    W = int(data[index + 1])\n    Q = int(data[index + 2])\n    index += 3\n    \n    grid = [[True] * W for _ in range(H)]\n    \n    for _ in range(Q):\n        R_q = int(data[index]) - 1\n        C_q = int(data[index + 1]) - 1\n        index += 2\n        \n        if grid[R_q][C_q]:\n            grid[R_q][C_q] = False\n        else:\n            # Check up\n            for i in range(R_q - 1, -1, -1):\n                if grid[i][C_q]:\n                    grid[i][C_q] = False\n                    break\n            \n            # Check down\n            for i in range(R_q + 1, H):\n                if grid[i][C_q]:\n                    grid[i][C_q] = False\n                    break\n            \n            # Check left\n            for j in range(C_q - 1, -1, -1):\n                if grid[R_q][j]:\n                    grid[R_q][j] = False\n                    break\n            \n            # Check right\n            for j in range(C_q + 1, W):\n                if grid[R_q][j]:\n                    grid[R_q][j] = False\n                    break\n    \n    remaining_walls = sum(row.count(True) for row in grid)\n    print(remaining_walls)\n\nmain()\n```"]}
{"task_id": "abc368_c", "codes": ["def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        for i in range(N):\n            if H[i] > 0:\n                if T % 3 == 0:\n                    H[i] -= 3\n                else:\n                    H[i] -= 1\n                break\n    \n    print(T)\n\nif __name__ == \"__main__\":\n    main()"], "passed": [false], "raw_code": ["```python\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    H = list(map(int, data[1:]))\n    \n    T = 0\n    while any(h > 0 for h in H):\n        T += 1\n        for i in range(N):\n            if H[i] > 0:\n                if T % 3 == 0:\n                    H[i] -= 3\n                else:\n                    H[i] -= 1\n                break\n    \n    print(T)\n\nif __name__ == \"__main__\":\n    main()\n```"]}
{"final_accuracy": "5.41%"}
{"difficulty": "medium", "num_threads": 32, "temperature": 0.7, "n": 1, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_vanilla__qwen_7b_medium_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"final_accuracy": "5.41%"}
{"difficulty": "medium", "num_threads": 32, "temperature": 0.7, "n": 1, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_vanilla__qwen_7b_medium_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"final_accuracy": "5.41%"}
{"difficulty": "medium", "num_threads": 32, "temperature": 0.7, "n": 1, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_vanilla__qwen_7b_medium_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"final_accuracy": "5.41%"}
{"difficulty": "medium", "num_threads": 32, "temperature": 0.7, "n": 1, "context": "all", "selection": "oracle", "num_round": 1, "selfdebug_decision": "exit", "judge": "openai/gpt-4o-mini", "generator": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "start_date": "2024-08-01", "end_date": "2024-12-01", "result_json_path": "results_sky_v2/sec4_parallel_sample_vanilla__qwen_7b_medium_n_1.json", "ablation_judge_api_name": null, "ablation_judge_api_base": "openai/gpt-4o-mini", "method": "selfdebug", "test_generator": "openai/gpt-4o-mini", "num_test_suites": 1, "api_name": "openai/Qwen/Qwen2.5-Coder-7B-Instruct", "api_base": "http://127.0.0.1:8001/8001/v1", "no_refine": true, "no_dspy_gen": false, "lcb_version": "release_v4", "num_icl_examples": 0, "enable_llm_reflection_with_tool": false, "enable_vanilla_reflection": false, "ablation_qwq_vanilla_without_reasoning": false, "ablation_qwq_debug_with_4o_mini": false, "load_cached_preds": false, "cached_preds_path": null, "seed": 42, "resume": true}
{"final_accuracy": "5.41%"}
